{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"pypowervm/","text":"Pypowervm Pypowervm Index / Pypowervm Auto-generated documentation for pypowervm module. Pypowervm Modules Modules Adapter Const Entities Exceptions Hacking Helpers I18n Log Tasks Tests Traits Util Utils Wrappers","title":"Pypowervm"},{"location":"pypowervm/#pypowervm","text":"Pypowervm Index / Pypowervm Auto-generated documentation for pypowervm module. Pypowervm Modules","title":"Pypowervm"},{"location":"pypowervm/#modules","text":"Adapter Const Entities Exceptions Hacking Helpers I18n Log Tasks Tests Traits Util Utils Wrappers","title":"Modules"},{"location":"pypowervm/adapter/","text":"Adapter Pypowervm Index / Pypowervm / Adapter Auto-generated documentation for pypowervm.adapter module. Attributes LOG - Setup logging: logging.getLogger(__name__) Adapter Adapter Adapter().build_href Adapter.build_path Adapter().create Adapter().create_by_path Adapter().create_job Adapter().delete Adapter().delete_by_href Adapter().delete_by_path Adapter().download_file Adapter.extend_path Adapter().helpers Adapter().read Adapter().read_by_href Adapter().read_by_path Adapter().read_job Adapter().read_jobs Adapter().sys_uuid Adapter().traits Adapter().update Adapter().update_by_path Adapter().upload_file EventHandler EventHandler().process EventListener EventListener().shutdown EventListener().subscribe EventListener().unsubscribe RawEventHandler RawEventHandler().process Response Response(). deepcopy Response().atom Response().etag Session Session().get_event_listener Session().has_event_listener Session().request WrapperEventHandler WrapperEventHandler().process Adapter Show source in adapter.py:580 REST API Adapter for PowerVM remote management. Signature class Adapter(object): def __init__(self, session=None, use_cache=False, helpers=None): ... Adapter().build_href Show source in adapter.py:940 Signature def build_href( self, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, suffix_parm=None, detail=None, xag=None, service=\"uom\", ): ... Adapter.build_path Show source in adapter.py:949 Signature @classmethod def build_path( cls, service, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, suffix_parm=None, detail=None, xag=None, add_qp=None, ): ... Adapter().create Show source in adapter.py:651 Create a new resource. Will build the URI path using the provided arguments. Signature def create( self, element, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, suffix_parm=None, detail=None, service=\"uom\", content_service=None, timeout=-1, auditmemento=None, sensitive=False, helpers=None, ): ... Adapter().create_by_path Show source in adapter.py:684 Create a new resource where the URI path is already known. Signature def create_by_path( self, element, path, content_service=None, timeout=-1, auditmemento=None, sensitive=False, helpers=None, ): ... Adapter().create_job Show source in adapter.py:668 Signature def create_job( self, job, root_type, root_id=None, child_type=None, child_id=None, timeout=-1, auditmemento=None, sensitive=False, helpers=None, ): ... Adapter().delete Show source in adapter.py:867 Delete an existing resource. Will build the URI path using the provided arguments. Signature def delete( self, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, suffix_parm=None, service=\"uom\", etag=None, timeout=-1, auditmemento=None, helpers=None, ): ... Adapter().delete_by_href Show source in adapter.py:881 Delete an existing resource based on a link's href. Signature def delete_by_href(self, href, etag=None, timeout=-1, auditmemento=None, helpers=None): ... Adapter().delete_by_path Show source in adapter.py:892 Delete an existing resource where the URI path is already known. Signature def delete_by_path(self, path, etag=None, timeout=-1, auditmemento=None, helpers=None): ... Adapter().download_file Show source in adapter.py:925 Signature def download_file( self, filedescr, filehandle, chunksize=65536, timeout=-1, auditmemento=None, helpers=None, ): ... Adapter.extend_path Show source in adapter.py:964 Extend a base path with zero or more of suffix, detail, and xag. Arguments basepath - The path string to be extended. suffix_type - Suffix key (string) to be appended. suffix_parm - Suffix parameter value to be appended. Ignored if suffix_type is not specified. detail - Value for the 'detail' query parameter. xag - List of extended attribute group enum values. If unspecified or None, 'None' will be appended. If the empty list (xag=[]), no extended attribute query parameter will be added, resulting in the server's default extended attribute group behavior. add_qp - Optional list of (key, value) tuples to add to the query string of the request. Returns String base path (without protocol://server:port part). Signature @staticmethod def extend_path( basepath, suffix_type=None, suffix_parm=None, detail=None, xag=None, add_qp=None ): ... Adapter().helpers Show source in adapter.py:607 Returns a copy of the list of helpers for the adapter. Signature @property def helpers(self): ... Adapter().read Show source in adapter.py:711 Retrieve an existing resource. Will build the URI path using the provided arguments. Arguments root_type - String ROOT REST element type. root_id - String ROOT REST element UUID. If unspecified, the feed of root_type is fetched. Required if child_type is specified. child_type - String CHILD REST element type. child_id - String CHILD REST element UUID. If unspecified, the feed of child_type is fetched. suffix_type - Suffix type added to the path (with '/'). For special URIs, like Job requests (e.g. 'do' in .../do/Something). suffix_parm - Suffix parameter added to the path (with '/'). For special URIs, like Job requests (e.g. 'Something' in .../do/Something). detail - Requested detail level of the response. Obsolete. service - REST service type, one of pypowervm.const.SERVICE_BY_NS etag - Not used (caching disabled). timeout - Timeout in seconds for the HTTP request. auditmemento - X-Audit-Memento header registered in the REST server logs for debug purposes, allowing this request to be identified therein. age - Not used (caching disabled). xag - List of extended attribute group enum values. If unspecified or None, 'None' will be appended. If the empty list (xag=[]), no extended attribute query parameter will be added, resulting in the server's default extended attribute group behavior. sensitive - If True, headers and payloads will be hidden in log entries. Adapter().helpers - A list of decorator methods in which to wrap the HTTP request call. See the pypowervm.helpers package for examples. add_qp - Optional list of (key, value) tuples to add to the query string of the request. Returns Response object representing the result of the query. Signature def read( self, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, suffix_parm=None, detail=None, service=\"uom\", etag=None, timeout=-1, auditmemento=None, age=-1, xag=None, sensitive=False, helpers=None, add_qp=None, ): ... Adapter().read_by_href Show source in adapter.py:777 Retrieve an existing resource based on a link's href. Signature def read_by_href( self, href, suffix_type=None, suffix_parm=None, detail=None, etag=None, timeout=-1, auditmemento=None, age=-1, sensitive=False, helpers=None, xag=None, ): ... Adapter().read_by_path Show source in adapter.py:792 Retrieve an existing resource where URI path is already known. Signature def read_by_path( self, path, etag=None, timeout=-1, auditmemento=None, age=-1, sensitive=False, helpers=None, ): ... Adapter().read_job Show source in adapter.py:763 Signature def read_job( self, job_id, etag=None, timeout=-1, auditmemento=None, sensitive=False, helpers=None ): ... Adapter().read_jobs Show source in adapter.py:769 Signature def read_jobs( self, root_type=None, root_id=None, child_type=None, child_id=None, detail=None, etag=None, timeout=-1, auditmemento=None, sensitive=False, helpers=None, ): ... Adapter().sys_uuid Show source in adapter.py:612 Signature @property def sys_uuid(self): ... Adapter().traits Show source in adapter.py:620 Signature @property def traits(self): ... Adapter().update Show source in adapter.py:825 Update an existing resource. Will build the URI path using the provided arguments. Signature def update( self, data, etag, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, service=\"uom\", timeout=-1, auditmemento=None, xag=None, sensitive=False, helpers=None, ): ... Adapter().update_by_path Show source in adapter.py:840 Update an existing resource where the URI path is already known. Signature def update_by_path( self, data, etag, path, timeout=-1, auditmemento=None, sensitive=False, helpers=None ): ... Adapter().upload_file Show source in adapter.py:907 Signature def upload_file( self, filedescr, filehandle, chunksize=65536, timeout=-1, auditmemento=None, replacing=False, helpers=None, ): ... EventHandler Show source in adapter.py:1390 Used to handle events from the API. The session can poll for events back from the API. An event will give a small indication of something that has occurred within the system. An example may be a ClientNetworkAdapter being created against an LPAR. Implement this class and add it to the Session's event listener to process events back from the API. Signature class EventHandler(_EventHandler): ... EventHandler().process Show source in adapter.py:1400 Process the event that comes back from the API. Arguments events - A dictionary of events that has come back from the system. Format: - Key -> URI of event - Value -> Action of event. May be one of the following: add, delete or invalidate A special key of 'general' may exist. The value for this is init or invalidate. init indicates that the whole system is being initialized. An invalidate indicates that the API event system has been refreshed and the user should do a clean get of the data it needs. Signature @abc.abstractmethod def process(self, events): ... EventListener Show source in adapter.py:1183 Signature class EventListener(object): ... EventListener().shutdown Show source in adapter.py:1199 Shutdown this EventListener. Signature @abc.abstractmethod def shutdown(self): ... EventListener().subscribe Show source in adapter.py:1185 Subscribe an EvenHandler to receive events. Arguments handler - EventHandler Signature @abc.abstractmethod def subscribe(self, handler): ... EventListener().unsubscribe Show source in adapter.py:1192 Unubscribe an EvenHandler from receiving events. Arguments handler - EventHandler Signature @abc.abstractmethod def unsubscribe(self, handler): ... RawEventHandler Show source in adapter.py:1422 Used to handle raw events from the API. With this handler, no processing is done on the events. The events will be passed as a sequence of dicts. Implement this class and add it to the Session's event listener to process events back from the API. Signature class RawEventHandler(_EventHandler): ... RawEventHandler().process Show source in adapter.py:1431 Process the event that comes back from the API. Arguments events - A sequence of event dicts that has come back from the system. Format: [ { 'EventType': , 'EventID': , 'EventData': , 'EventDetail': }, ] Signature @abc.abstractmethod def process(self, events): ... Response Show source in adapter.py:1067 Response to PowerVM API Adapter method invocation. Signature class Response(object): def __init__( self, reqmethod, reqpath, status, reason, headers, reqheaders=None, reqbody=\"\", body=\"\", orig_reqpath=\"\", ): ... Response(). deepcopy Show source in adapter.py:1098 Produce a deep (except for adapter) copy of this Response. Signature def __deepcopy__(self, memo=None): ... Response().atom Show source in adapter.py:1117 Signature @property def atom(self): ... Response().etag Show source in adapter.py:1113 Signature @property def etag(self): ... Session Show source in adapter.py:64 Responsible for PowerVM API session management. Signature class Session(object): def __init__( self, host=\"localhost\", username=None, password=None, auditmemento=None, protocol=None, port=None, timeout=1200, certpath=\"/etc/ssl/certs/\", certext=\".crt\", conn_tries=1, ): ... Session().get_event_listener Show source in adapter.py:199 Signature def get_event_listener(self): ... Session().has_event_listener Show source in adapter.py:205 Signature @property def has_event_listener(self): ... Session().request Show source in adapter.py:221 Send an HTTP/HTTPS request to a PowerVM interface. Arguments filehandle - For downloads (with method == 'GET'), a writable file-like (anything with a write() method) to which the download content should be written. For uploads (with method == 'PUT' or 'POST'), this may be a readable file-like (anything with a read() method) or an iterable from which the upload content should be retrieved. When None (the default), response text goes to the body of the returned Response. chunksize - For downloads, the content is written to filehandle in increments of (at most) chunksize bytes. For uploads when filehandle is a file-like, the content is sent through the request in increments of (at most) chunksize bytes. For uploads when filehandle is an iterable, this arg is ignored - content chunks are sent through the request in whatever size the iterable yields them. For other request types, this arg is ignored. Signature def request( self, method, path, headers=None, body=\"\", sensitive=False, verify=False, timeout=-1, auditmemento=None, relogin=True, login=False, filehandle=None, chunksize=65536, ): ... WrapperEventHandler Show source in adapter.py:1452 Used to handle wrapped events from the API. With this handler, no processing is done on the events. The events will be passed as a list of pypowervm.wrappers.event.Event. Implement this class and add it to the Session's event listener to process events back from the API. Signature class WrapperEventHandler(_EventHandler): ... WrapperEventHandler().process Show source in adapter.py:1461 Process the event that comes back from the API. Arguments events - A list of pypowervm.wrappers.event.Event that has come back from the system. See that wrapper class for details. Signature @abc.abstractmethod def process(self, events): ...","title":"Adapter"},{"location":"pypowervm/adapter/#adapter","text":"Pypowervm Index / Pypowervm / Adapter Auto-generated documentation for pypowervm.adapter module.","title":"Adapter"},{"location":"pypowervm/adapter/#attributes","text":"LOG - Setup logging: logging.getLogger(__name__) Adapter Adapter Adapter().build_href Adapter.build_path Adapter().create Adapter().create_by_path Adapter().create_job Adapter().delete Adapter().delete_by_href Adapter().delete_by_path Adapter().download_file Adapter.extend_path Adapter().helpers Adapter().read Adapter().read_by_href Adapter().read_by_path Adapter().read_job Adapter().read_jobs Adapter().sys_uuid Adapter().traits Adapter().update Adapter().update_by_path Adapter().upload_file EventHandler EventHandler().process EventListener EventListener().shutdown EventListener().subscribe EventListener().unsubscribe RawEventHandler RawEventHandler().process Response Response(). deepcopy Response().atom Response().etag Session Session().get_event_listener Session().has_event_listener Session().request WrapperEventHandler WrapperEventHandler().process","title":"Attributes"},{"location":"pypowervm/adapter/#adapter_1","text":"Show source in adapter.py:580 REST API Adapter for PowerVM remote management.","title":"Adapter"},{"location":"pypowervm/adapter/#signature","text":"class Adapter(object): def __init__(self, session=None, use_cache=False, helpers=None): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterbuild_href","text":"Show source in adapter.py:940","title":"Adapter().build_href"},{"location":"pypowervm/adapter/#signature_1","text":"def build_href( self, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, suffix_parm=None, detail=None, xag=None, service=\"uom\", ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterbuild_path","text":"Show source in adapter.py:949","title":"Adapter.build_path"},{"location":"pypowervm/adapter/#signature_2","text":"@classmethod def build_path( cls, service, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, suffix_parm=None, detail=None, xag=None, add_qp=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adaptercreate","text":"Show source in adapter.py:651 Create a new resource. Will build the URI path using the provided arguments.","title":"Adapter().create"},{"location":"pypowervm/adapter/#signature_3","text":"def create( self, element, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, suffix_parm=None, detail=None, service=\"uom\", content_service=None, timeout=-1, auditmemento=None, sensitive=False, helpers=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adaptercreate_by_path","text":"Show source in adapter.py:684 Create a new resource where the URI path is already known.","title":"Adapter().create_by_path"},{"location":"pypowervm/adapter/#signature_4","text":"def create_by_path( self, element, path, content_service=None, timeout=-1, auditmemento=None, sensitive=False, helpers=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adaptercreate_job","text":"Show source in adapter.py:668","title":"Adapter().create_job"},{"location":"pypowervm/adapter/#signature_5","text":"def create_job( self, job, root_type, root_id=None, child_type=None, child_id=None, timeout=-1, auditmemento=None, sensitive=False, helpers=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterdelete","text":"Show source in adapter.py:867 Delete an existing resource. Will build the URI path using the provided arguments.","title":"Adapter().delete"},{"location":"pypowervm/adapter/#signature_6","text":"def delete( self, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, suffix_parm=None, service=\"uom\", etag=None, timeout=-1, auditmemento=None, helpers=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterdelete_by_href","text":"Show source in adapter.py:881 Delete an existing resource based on a link's href.","title":"Adapter().delete_by_href"},{"location":"pypowervm/adapter/#signature_7","text":"def delete_by_href(self, href, etag=None, timeout=-1, auditmemento=None, helpers=None): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterdelete_by_path","text":"Show source in adapter.py:892 Delete an existing resource where the URI path is already known.","title":"Adapter().delete_by_path"},{"location":"pypowervm/adapter/#signature_8","text":"def delete_by_path(self, path, etag=None, timeout=-1, auditmemento=None, helpers=None): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterdownload_file","text":"Show source in adapter.py:925","title":"Adapter().download_file"},{"location":"pypowervm/adapter/#signature_9","text":"def download_file( self, filedescr, filehandle, chunksize=65536, timeout=-1, auditmemento=None, helpers=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterextend_path","text":"Show source in adapter.py:964 Extend a base path with zero or more of suffix, detail, and xag.","title":"Adapter.extend_path"},{"location":"pypowervm/adapter/#arguments","text":"basepath - The path string to be extended. suffix_type - Suffix key (string) to be appended. suffix_parm - Suffix parameter value to be appended. Ignored if suffix_type is not specified. detail - Value for the 'detail' query parameter. xag - List of extended attribute group enum values. If unspecified or None, 'None' will be appended. If the empty list (xag=[]), no extended attribute query parameter will be added, resulting in the server's default extended attribute group behavior. add_qp - Optional list of (key, value) tuples to add to the query string of the request.","title":"Arguments"},{"location":"pypowervm/adapter/#returns","text":"String base path (without protocol://server:port part).","title":"Returns"},{"location":"pypowervm/adapter/#signature_10","text":"@staticmethod def extend_path( basepath, suffix_type=None, suffix_parm=None, detail=None, xag=None, add_qp=None ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterhelpers","text":"Show source in adapter.py:607 Returns a copy of the list of helpers for the adapter.","title":"Adapter().helpers"},{"location":"pypowervm/adapter/#signature_11","text":"@property def helpers(self): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterread","text":"Show source in adapter.py:711 Retrieve an existing resource. Will build the URI path using the provided arguments.","title":"Adapter().read"},{"location":"pypowervm/adapter/#arguments_1","text":"root_type - String ROOT REST element type. root_id - String ROOT REST element UUID. If unspecified, the feed of root_type is fetched. Required if child_type is specified. child_type - String CHILD REST element type. child_id - String CHILD REST element UUID. If unspecified, the feed of child_type is fetched. suffix_type - Suffix type added to the path (with '/'). For special URIs, like Job requests (e.g. 'do' in .../do/Something). suffix_parm - Suffix parameter added to the path (with '/'). For special URIs, like Job requests (e.g. 'Something' in .../do/Something). detail - Requested detail level of the response. Obsolete. service - REST service type, one of pypowervm.const.SERVICE_BY_NS etag - Not used (caching disabled). timeout - Timeout in seconds for the HTTP request. auditmemento - X-Audit-Memento header registered in the REST server logs for debug purposes, allowing this request to be identified therein. age - Not used (caching disabled). xag - List of extended attribute group enum values. If unspecified or None, 'None' will be appended. If the empty list (xag=[]), no extended attribute query parameter will be added, resulting in the server's default extended attribute group behavior. sensitive - If True, headers and payloads will be hidden in log entries. Adapter().helpers - A list of decorator methods in which to wrap the HTTP request call. See the pypowervm.helpers package for examples. add_qp - Optional list of (key, value) tuples to add to the query string of the request.","title":"Arguments"},{"location":"pypowervm/adapter/#returns_1","text":"Response object representing the result of the query.","title":"Returns"},{"location":"pypowervm/adapter/#signature_12","text":"def read( self, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, suffix_parm=None, detail=None, service=\"uom\", etag=None, timeout=-1, auditmemento=None, age=-1, xag=None, sensitive=False, helpers=None, add_qp=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterread_by_href","text":"Show source in adapter.py:777 Retrieve an existing resource based on a link's href.","title":"Adapter().read_by_href"},{"location":"pypowervm/adapter/#signature_13","text":"def read_by_href( self, href, suffix_type=None, suffix_parm=None, detail=None, etag=None, timeout=-1, auditmemento=None, age=-1, sensitive=False, helpers=None, xag=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterread_by_path","text":"Show source in adapter.py:792 Retrieve an existing resource where URI path is already known.","title":"Adapter().read_by_path"},{"location":"pypowervm/adapter/#signature_14","text":"def read_by_path( self, path, etag=None, timeout=-1, auditmemento=None, age=-1, sensitive=False, helpers=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterread_job","text":"Show source in adapter.py:763","title":"Adapter().read_job"},{"location":"pypowervm/adapter/#signature_15","text":"def read_job( self, job_id, etag=None, timeout=-1, auditmemento=None, sensitive=False, helpers=None ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterread_jobs","text":"Show source in adapter.py:769","title":"Adapter().read_jobs"},{"location":"pypowervm/adapter/#signature_16","text":"def read_jobs( self, root_type=None, root_id=None, child_type=None, child_id=None, detail=None, etag=None, timeout=-1, auditmemento=None, sensitive=False, helpers=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adaptersys_uuid","text":"Show source in adapter.py:612","title":"Adapter().sys_uuid"},{"location":"pypowervm/adapter/#signature_17","text":"@property def sys_uuid(self): ...","title":"Signature"},{"location":"pypowervm/adapter/#adaptertraits","text":"Show source in adapter.py:620","title":"Adapter().traits"},{"location":"pypowervm/adapter/#signature_18","text":"@property def traits(self): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterupdate","text":"Show source in adapter.py:825 Update an existing resource. Will build the URI path using the provided arguments.","title":"Adapter().update"},{"location":"pypowervm/adapter/#signature_19","text":"def update( self, data, etag, root_type, root_id=None, child_type=None, child_id=None, suffix_type=None, service=\"uom\", timeout=-1, auditmemento=None, xag=None, sensitive=False, helpers=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterupdate_by_path","text":"Show source in adapter.py:840 Update an existing resource where the URI path is already known.","title":"Adapter().update_by_path"},{"location":"pypowervm/adapter/#signature_20","text":"def update_by_path( self, data, etag, path, timeout=-1, auditmemento=None, sensitive=False, helpers=None ): ...","title":"Signature"},{"location":"pypowervm/adapter/#adapterupload_file","text":"Show source in adapter.py:907","title":"Adapter().upload_file"},{"location":"pypowervm/adapter/#signature_21","text":"def upload_file( self, filedescr, filehandle, chunksize=65536, timeout=-1, auditmemento=None, replacing=False, helpers=None, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#eventhandler","text":"Show source in adapter.py:1390 Used to handle events from the API. The session can poll for events back from the API. An event will give a small indication of something that has occurred within the system. An example may be a ClientNetworkAdapter being created against an LPAR. Implement this class and add it to the Session's event listener to process events back from the API.","title":"EventHandler"},{"location":"pypowervm/adapter/#signature_22","text":"class EventHandler(_EventHandler): ...","title":"Signature"},{"location":"pypowervm/adapter/#eventhandlerprocess","text":"Show source in adapter.py:1400 Process the event that comes back from the API.","title":"EventHandler().process"},{"location":"pypowervm/adapter/#arguments_2","text":"events - A dictionary of events that has come back from the system. Format: - Key -> URI of event - Value -> Action of event. May be one of the following: add, delete or invalidate A special key of 'general' may exist. The value for this is init or invalidate. init indicates that the whole system is being initialized. An invalidate indicates that the API event system has been refreshed and the user should do a clean get of the data it needs.","title":"Arguments"},{"location":"pypowervm/adapter/#signature_23","text":"@abc.abstractmethod def process(self, events): ...","title":"Signature"},{"location":"pypowervm/adapter/#eventlistener","text":"Show source in adapter.py:1183","title":"EventListener"},{"location":"pypowervm/adapter/#signature_24","text":"class EventListener(object): ...","title":"Signature"},{"location":"pypowervm/adapter/#eventlistenershutdown","text":"Show source in adapter.py:1199 Shutdown this EventListener.","title":"EventListener().shutdown"},{"location":"pypowervm/adapter/#signature_25","text":"@abc.abstractmethod def shutdown(self): ...","title":"Signature"},{"location":"pypowervm/adapter/#eventlistenersubscribe","text":"Show source in adapter.py:1185 Subscribe an EvenHandler to receive events.","title":"EventListener().subscribe"},{"location":"pypowervm/adapter/#arguments_3","text":"handler - EventHandler","title":"Arguments"},{"location":"pypowervm/adapter/#signature_26","text":"@abc.abstractmethod def subscribe(self, handler): ...","title":"Signature"},{"location":"pypowervm/adapter/#eventlistenerunsubscribe","text":"Show source in adapter.py:1192 Unubscribe an EvenHandler from receiving events.","title":"EventListener().unsubscribe"},{"location":"pypowervm/adapter/#arguments_4","text":"handler - EventHandler","title":"Arguments"},{"location":"pypowervm/adapter/#signature_27","text":"@abc.abstractmethod def unsubscribe(self, handler): ...","title":"Signature"},{"location":"pypowervm/adapter/#raweventhandler","text":"Show source in adapter.py:1422 Used to handle raw events from the API. With this handler, no processing is done on the events. The events will be passed as a sequence of dicts. Implement this class and add it to the Session's event listener to process events back from the API.","title":"RawEventHandler"},{"location":"pypowervm/adapter/#signature_28","text":"class RawEventHandler(_EventHandler): ...","title":"Signature"},{"location":"pypowervm/adapter/#raweventhandlerprocess","text":"Show source in adapter.py:1431 Process the event that comes back from the API.","title":"RawEventHandler().process"},{"location":"pypowervm/adapter/#arguments_5","text":"events - A sequence of event dicts that has come back from the system. Format: [ { 'EventType': , 'EventID': , 'EventData': , 'EventDetail': }, ]","title":"Arguments"},{"location":"pypowervm/adapter/#signature_29","text":"@abc.abstractmethod def process(self, events): ...","title":"Signature"},{"location":"pypowervm/adapter/#response","text":"Show source in adapter.py:1067 Response to PowerVM API Adapter method invocation.","title":"Response"},{"location":"pypowervm/adapter/#signature_30","text":"class Response(object): def __init__( self, reqmethod, reqpath, status, reason, headers, reqheaders=None, reqbody=\"\", body=\"\", orig_reqpath=\"\", ): ...","title":"Signature"},{"location":"pypowervm/adapter/#responsedeepcopy","text":"Show source in adapter.py:1098 Produce a deep (except for adapter) copy of this Response.","title":"Response().deepcopy"},{"location":"pypowervm/adapter/#signature_31","text":"def __deepcopy__(self, memo=None): ...","title":"Signature"},{"location":"pypowervm/adapter/#responseatom","text":"Show source in adapter.py:1117","title":"Response().atom"},{"location":"pypowervm/adapter/#signature_32","text":"@property def atom(self): ...","title":"Signature"},{"location":"pypowervm/adapter/#responseetag","text":"Show source in adapter.py:1113","title":"Response().etag"},{"location":"pypowervm/adapter/#signature_33","text":"@property def etag(self): ...","title":"Signature"},{"location":"pypowervm/adapter/#session","text":"Show source in adapter.py:64 Responsible for PowerVM API session management.","title":"Session"},{"location":"pypowervm/adapter/#signature_34","text":"class Session(object): def __init__( self, host=\"localhost\", username=None, password=None, auditmemento=None, protocol=None, port=None, timeout=1200, certpath=\"/etc/ssl/certs/\", certext=\".crt\", conn_tries=1, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#sessionget_event_listener","text":"Show source in adapter.py:199","title":"Session().get_event_listener"},{"location":"pypowervm/adapter/#signature_35","text":"def get_event_listener(self): ...","title":"Signature"},{"location":"pypowervm/adapter/#sessionhas_event_listener","text":"Show source in adapter.py:205","title":"Session().has_event_listener"},{"location":"pypowervm/adapter/#signature_36","text":"@property def has_event_listener(self): ...","title":"Signature"},{"location":"pypowervm/adapter/#sessionrequest","text":"Show source in adapter.py:221 Send an HTTP/HTTPS request to a PowerVM interface.","title":"Session().request"},{"location":"pypowervm/adapter/#arguments_6","text":"filehandle - For downloads (with method == 'GET'), a writable file-like (anything with a write() method) to which the download content should be written. For uploads (with method == 'PUT' or 'POST'), this may be a readable file-like (anything with a read() method) or an iterable from which the upload content should be retrieved. When None (the default), response text goes to the body of the returned Response. chunksize - For downloads, the content is written to filehandle in increments of (at most) chunksize bytes. For uploads when filehandle is a file-like, the content is sent through the request in increments of (at most) chunksize bytes. For uploads when filehandle is an iterable, this arg is ignored - content chunks are sent through the request in whatever size the iterable yields them. For other request types, this arg is ignored.","title":"Arguments"},{"location":"pypowervm/adapter/#signature_37","text":"def request( self, method, path, headers=None, body=\"\", sensitive=False, verify=False, timeout=-1, auditmemento=None, relogin=True, login=False, filehandle=None, chunksize=65536, ): ...","title":"Signature"},{"location":"pypowervm/adapter/#wrappereventhandler","text":"Show source in adapter.py:1452 Used to handle wrapped events from the API. With this handler, no processing is done on the events. The events will be passed as a list of pypowervm.wrappers.event.Event. Implement this class and add it to the Session's event listener to process events back from the API.","title":"WrapperEventHandler"},{"location":"pypowervm/adapter/#signature_38","text":"class WrapperEventHandler(_EventHandler): ...","title":"Signature"},{"location":"pypowervm/adapter/#wrappereventhandlerprocess","text":"Show source in adapter.py:1461 Process the event that comes back from the API.","title":"WrapperEventHandler().process"},{"location":"pypowervm/adapter/#arguments_7","text":"events - A list of pypowervm.wrappers.event.Event that has come back from the system. See that wrapper class for details.","title":"Arguments"},{"location":"pypowervm/adapter/#signature_39","text":"@abc.abstractmethod def process(self, events): ...","title":"Signature"},{"location":"pypowervm/const/","text":"Const Pypowervm Index / Pypowervm / Const Auto-generated documentation for pypowervm.const module. Attributes LOGONREQUEST_TEMPLATE_PASS - LogonRequest template to be used for password-based authentication: _LOGONREQUEST_TEMPLATE_TEMPLATE % dict(pass_or_file=_PASS_TEMPLATE) LOGONREQUEST_TEMPLATE_FILE - LogonRequest template to be used for file-based authentication: _LOGONREQUEST_TEMPLATE_TEMPLATE % dict(pass_or_file=_SESS_FILE) UUID_REGEX - Match a UUID anywhere in the search string: '%(x)s{8}-%(x)s{4}-%(x)s{4}-%(x)s{4}-%(x)s{12}' % {'x': '[A-Fa-f0-9]'} UUID_REGEX_WORD - Entire search string must be a UUID and nothing more: '^%s$' % UUID_REGEX UUID_XPATH - XPath to the UUID of a metadata-having XML object: 'Metadata/Atom/AtomID' Const HTTPStatus MaxLen XAG HTTPStatus Show source in const.py:99 Small subset of HTTP status codes as used by PowerVM. Signature class HTTPStatus(object): ... MaxLen Show source in const.py:110 Attributes FILENAME_DEFAULT - FileName.Pattern: 79 Maximum lengths for various PowerVM entities. Signature class MaxLen(object): ... XAG Show source in const.py:118 Enumeration of all extended attribute group strings. Signature class XAG(object): ...","title":"Const"},{"location":"pypowervm/const/#const","text":"Pypowervm Index / Pypowervm / Const Auto-generated documentation for pypowervm.const module.","title":"Const"},{"location":"pypowervm/const/#attributes","text":"LOGONREQUEST_TEMPLATE_PASS - LogonRequest template to be used for password-based authentication: _LOGONREQUEST_TEMPLATE_TEMPLATE % dict(pass_or_file=_PASS_TEMPLATE) LOGONREQUEST_TEMPLATE_FILE - LogonRequest template to be used for file-based authentication: _LOGONREQUEST_TEMPLATE_TEMPLATE % dict(pass_or_file=_SESS_FILE) UUID_REGEX - Match a UUID anywhere in the search string: '%(x)s{8}-%(x)s{4}-%(x)s{4}-%(x)s{4}-%(x)s{12}' % {'x': '[A-Fa-f0-9]'} UUID_REGEX_WORD - Entire search string must be a UUID and nothing more: '^%s$' % UUID_REGEX UUID_XPATH - XPath to the UUID of a metadata-having XML object: 'Metadata/Atom/AtomID' Const HTTPStatus MaxLen XAG","title":"Attributes"},{"location":"pypowervm/const/#httpstatus","text":"Show source in const.py:99 Small subset of HTTP status codes as used by PowerVM.","title":"HTTPStatus"},{"location":"pypowervm/const/#signature","text":"class HTTPStatus(object): ...","title":"Signature"},{"location":"pypowervm/const/#maxlen","text":"Show source in const.py:110","title":"MaxLen"},{"location":"pypowervm/const/#attributes_1","text":"FILENAME_DEFAULT - FileName.Pattern: 79 Maximum lengths for various PowerVM entities.","title":"Attributes"},{"location":"pypowervm/const/#signature_1","text":"class MaxLen(object): ...","title":"Signature"},{"location":"pypowervm/const/#xag","text":"Show source in const.py:118 Enumeration of all extended attribute group strings.","title":"XAG"},{"location":"pypowervm/const/#signature_2","text":"class XAG(object): ...","title":"Signature"},{"location":"pypowervm/entities/","text":"Entities Pypowervm Index / Pypowervm / Entities Auto-generated documentation for pypowervm.entities module. Entities Atom Atom().links Atom().self_link Atom().uuid Element Element(). deepcopy Element(). iter Element().append Element().attrib Element().attrib Element().find Element().findall Element().findtext Element().get Element().inject Element().insert Element().items Element().iter Element().keys Element().namespace Element().namespace Element().remove Element().replace Element().set Element().tag Element().tag Element().text Element().text Element().toxmlstring Element.wrapelement ElementList ElementList().__create_elem ElementList().__find_elems ElementList().__get_values ElementList().append ElementList().clear ElementList().extend ElementList().index ElementList().remove Entry Entry(). deepcopy Entry().adapter Entry().etag Entry.unmarshal_atom_entry Feed Feed().findentries Feed.unmarshal_atom_feed Atom Show source in entities.py:29 Signature class Atom(object): def __init__(self, properties): ... Atom().links Show source in entities.py:40 Get the rel-keyed dict of s for this Atom, or {} if none. Signature @property def links(self): ... Atom().self_link Show source in entities.py:45 Get the first SELF link, or None if none exists. Signature @property def self_link(self): ... Atom().uuid Show source in entities.py:33 Signature @property def uuid(self): ... Element Show source in entities.py:161 Represents an XML element - a utility wrapper around etree.Element. Signature class Element(object): def __init__( self, tag, adapter, ns=const.UOM_NS, attrib=None, text=\"\", children=(), cdata=False, ): ... Element(). deepcopy Show source in entities.py:202 Produce a deep (except for adapter) copy of this Element. Signature def __deepcopy__(self, memo=None): ... Element(). iter Show source in entities.py:244 Returns the children as a list of Elements. Signature def __iter__(self): ... Element().append Show source in entities.py:331 Adds subelement to the end of this element's list of subelements. Note: if subelement is a reference to an element within another XML hierarchy, it will be removed from that hierarchy. If you intend to reuse the parent object, you should pass a copy.deepcopy of the subelement to this method. Signature def append(self, subelement): ... Element().attrib Show source in entities.py:298 Signature @property def attrib(self): ... Element().attrib Show source in entities.py:302 Signature @attrib.setter def attrib(self, attrib): ... Element().find Show source in entities.py:404 Finds the first subelement matching match. Arguments match - May be a tag name or path. Returns an element instance or None. Signature def find(self, match): ... Element().findall Show source in entities.py:418 Finds all matching subelements. Arguments match - May be a tag name or path. Returns a list containing all matching elements in document order. Signature def findall(self, match): ... Element().findtext Show source in entities.py:431 Finds text for the first subelement matching match. Arguments match - May be a tag name or path. Returns the text content of the first matching element, or default if no element was found. Note that if the matching element has no text content an empty string is returned. Signature def findtext(self, match, default=None): ... Element().get Show source in entities.py:306 Gets the element attribute named key. Returns the attribute value, or default if the attribute was not found. Signature def get(self, key, default=None): ... Element().inject Show source in entities.py:345 Inserts subelement at the correct position in self's children. Uses ordering_list to determine the proper spot at which to insert the specified subelement. Arguments subelement - The element to inject as a child of this element. ordering_list - Iterable of string tag names representing the desired ordering of children for this element. If subelement's tag is not included in this list, the behavior is self.append(subelement). Element().replace - If True, and an existing child with subelement's tag is found, it is replaced. If False, subelement is added after the existing child(ren). Note: You probably want to use True only/always when subelement is maxOccurs=1. Conversely, you probably want to use False only/always when subelement is unbounded. If you use True and more than one matching child is found, the last one is replaced. Signature def inject(self, subelement, ordering_list=(), replace=True): ... Element().insert Show source in entities.py:443 Inserts subelement at the given position in this element. Raises TypeError - if subelement is not an etree.Element. Signature def insert(self, index, subelement): ... Element().items Show source in entities.py:313 Returns the element attributes as a sequence of (name, value) pairs. The attributes are returned in an arbitrary order. Signature def items(self): ... Element().iter Show source in entities.py:450 Creates a tree iterator with the current element as the root. The iterator iterates over this element and all elements below it, in document (depth first) order. If tag is not None or '*', only elements whose tag equals tag are returned from the iterator. If the tree structure is modified during iteration, the result is undefined. Signature def iter(self, tag=None): ... Element().keys Show source in entities.py:320 Returns the element attribute names as a list. The names are returned in an arbitrary order. Signature def keys(self): ... Element().namespace Show source in entities.py:281 Signature @property def namespace(self): ... Element().namespace Show source in entities.py:286 Signature @namespace.setter def namespace(self, ns): ... Element().remove Show source in entities.py:482 Removes subelement from the element. Unlike the find* methods this method compares elements based on the instance identity, not on tag value or contents. Signature def remove(self, subelement): ... Element().replace Show source in entities.py:477 Replaces the existing child Element with the new one. Signature def replace(self, existing, new_element): ... Element().set Show source in entities.py:327 Set the attribute key on the element to value. Signature def set(self, key, value): ... Element().tag Show source in entities.py:269 Signature @property def tag(self): ... Element().tag Show source in entities.py:273 Signature @tag.setter def tag(self, tag): ... Element().text Show source in entities.py:290 Signature @property def text(self): ... Element().text Show source in entities.py:294 Signature @text.setter def text(self, text): ... Element().toxmlstring Show source in entities.py:259 Produce an XML dump of this Element. Arguments pretty - If True, format the XML in a visually-pleasing manner. Returns An XML string representing this Element. Signature def toxmlstring(self, pretty=False): ... Element.wrapelement Show source in entities.py:249 Signature @classmethod def wrapelement(cls, element, adapter): ... ElementList Show source in entities.py:501 Useful list ops on a list of Element. In a schema where a simpleType element has a multiplicity allowing more than one instance within the containing element, this class provides a way to treat those instances as a list, to a limited extent. For example, given XML like: ...(stuff that isn't )... one two three ...(stuff that isn't )... fooList = ElementList(parent_element, 'foo') len(fooList) 3 repr(fooList) \"['one', 'two', 'three']\" 'two' in fooList True 'four' in fooList False fooList.append('four') repr(fooList) \"['one', 'two', 'three', 'four']\" print root.toxmlstring() ...(stuff that isn't )... one two three four ...(stuff that isn't )... Signature class ElementList(object): def __init__(self, root_elem, tag, ordering_list=()): ... ElementList().__create_elem Show source in entities.py:568 Create a new entities.Element suitable for this list. Arguments val - The raw string value for the text content of the new element. E.g. self.__create_elem('foo') will yield an entities.Element representing foo (where tag is whatever this ElementList was initialized with). Returns A new entities.Element containing the specified string val. Signature def __create_elem(self, val): ... ElementList().__find_elems Show source in entities.py:560 List of entities.Element under self.root_elem with tag self.tag. Signature def __find_elems(self): ... ElementList().__get_values Show source in entities.py:564 List of the string values within the entities.Element instances. Signature def __get_values(self): ... ElementList().append Show source in entities.py:598 Signature def append(self, val): ... ElementList().clear Show source in entities.py:617 Signature def clear(self): ... ElementList().extend Show source in entities.py:585 Signature def extend(self, val_list): ... ElementList().index Show source in entities.py:579 Signature def index(self, val): ... ElementList().remove Show source in entities.py:611 Signature def remove(self, val): ... Entry Show source in entities.py:113 Represents an Atom Entry returned by the PowerVM API. Signature class Entry(Atom): def __init__(self, properties, element, adapter): ... See also Atom Entry(). deepcopy Show source in entities.py:128 Produce a deep (except for adapter) copy of this Entry. Signature def __deepcopy__(self, memo=None): ... Entry().adapter Show source in entities.py:138 Signature @property def adapter(self): ... Entry().etag Show source in entities.py:134 Signature @property def etag(self): ... Entry.unmarshal_atom_entry Show source in entities.py:142 Factory method producing an Entry object from a parsed ElementTree Arguments entryelem - Parsed ElementTree object representing an atom entry. resp - The Response containing (the feed containing) the entry. Returns a new Entry object representing the entryelem parameter. Signature @classmethod def unmarshal_atom_entry(cls, entryelem, resp): ... Feed Show source in entities.py:78 Represents an Atom Feed returned from PowerVM. Signature class Feed(Atom): def __init__(self, properties, entries): ... See also Atom Feed().findentries Show source in entities.py:84 Signature def findentries(self, subelem, text): ... Feed.unmarshal_atom_feed Show source in entities.py:94 Factory method producing a Feed object from a parsed ElementTree Arguments feedelem - Parsed ElementTree object representing an atom feed. resp - The Response from which this Feed was parsed. Returns a new Feed object representing the feedelem parameter. Signature @classmethod def unmarshal_atom_feed(cls, feedelem, resp): ...","title":"Entities"},{"location":"pypowervm/entities/#entities","text":"Pypowervm Index / Pypowervm / Entities Auto-generated documentation for pypowervm.entities module. Entities Atom Atom().links Atom().self_link Atom().uuid Element Element(). deepcopy Element(). iter Element().append Element().attrib Element().attrib Element().find Element().findall Element().findtext Element().get Element().inject Element().insert Element().items Element().iter Element().keys Element().namespace Element().namespace Element().remove Element().replace Element().set Element().tag Element().tag Element().text Element().text Element().toxmlstring Element.wrapelement ElementList ElementList().__create_elem ElementList().__find_elems ElementList().__get_values ElementList().append ElementList().clear ElementList().extend ElementList().index ElementList().remove Entry Entry(). deepcopy Entry().adapter Entry().etag Entry.unmarshal_atom_entry Feed Feed().findentries Feed.unmarshal_atom_feed","title":"Entities"},{"location":"pypowervm/entities/#atom","text":"Show source in entities.py:29","title":"Atom"},{"location":"pypowervm/entities/#signature","text":"class Atom(object): def __init__(self, properties): ...","title":"Signature"},{"location":"pypowervm/entities/#atomlinks","text":"Show source in entities.py:40 Get the rel-keyed dict of s for this Atom, or {} if none.","title":"Atom().links"},{"location":"pypowervm/entities/#signature_1","text":"@property def links(self): ...","title":"Signature"},{"location":"pypowervm/entities/#atomself_link","text":"Show source in entities.py:45 Get the first SELF link, or None if none exists.","title":"Atom().self_link"},{"location":"pypowervm/entities/#signature_2","text":"@property def self_link(self): ...","title":"Signature"},{"location":"pypowervm/entities/#atomuuid","text":"Show source in entities.py:33","title":"Atom().uuid"},{"location":"pypowervm/entities/#signature_3","text":"@property def uuid(self): ...","title":"Signature"},{"location":"pypowervm/entities/#element","text":"Show source in entities.py:161 Represents an XML element - a utility wrapper around etree.Element.","title":"Element"},{"location":"pypowervm/entities/#signature_4","text":"class Element(object): def __init__( self, tag, adapter, ns=const.UOM_NS, attrib=None, text=\"\", children=(), cdata=False, ): ...","title":"Signature"},{"location":"pypowervm/entities/#elementdeepcopy","text":"Show source in entities.py:202 Produce a deep (except for adapter) copy of this Element.","title":"Element().deepcopy"},{"location":"pypowervm/entities/#signature_5","text":"def __deepcopy__(self, memo=None): ...","title":"Signature"},{"location":"pypowervm/entities/#elementiter","text":"Show source in entities.py:244 Returns the children as a list of Elements.","title":"Element().iter"},{"location":"pypowervm/entities/#signature_6","text":"def __iter__(self): ...","title":"Signature"},{"location":"pypowervm/entities/#elementappend","text":"Show source in entities.py:331 Adds subelement to the end of this element's list of subelements. Note: if subelement is a reference to an element within another XML hierarchy, it will be removed from that hierarchy. If you intend to reuse the parent object, you should pass a copy.deepcopy of the subelement to this method.","title":"Element().append"},{"location":"pypowervm/entities/#signature_7","text":"def append(self, subelement): ...","title":"Signature"},{"location":"pypowervm/entities/#elementattrib","text":"Show source in entities.py:298","title":"Element().attrib"},{"location":"pypowervm/entities/#signature_8","text":"@property def attrib(self): ...","title":"Signature"},{"location":"pypowervm/entities/#elementattrib_1","text":"Show source in entities.py:302","title":"Element().attrib"},{"location":"pypowervm/entities/#signature_9","text":"@attrib.setter def attrib(self, attrib): ...","title":"Signature"},{"location":"pypowervm/entities/#elementfind","text":"Show source in entities.py:404 Finds the first subelement matching match.","title":"Element().find"},{"location":"pypowervm/entities/#arguments","text":"match - May be a tag name or path.","title":"Arguments"},{"location":"pypowervm/entities/#returns","text":"an element instance or None.","title":"Returns"},{"location":"pypowervm/entities/#signature_10","text":"def find(self, match): ...","title":"Signature"},{"location":"pypowervm/entities/#elementfindall","text":"Show source in entities.py:418 Finds all matching subelements.","title":"Element().findall"},{"location":"pypowervm/entities/#arguments_1","text":"match - May be a tag name or path.","title":"Arguments"},{"location":"pypowervm/entities/#returns_1","text":"a list containing all matching elements in document order.","title":"Returns"},{"location":"pypowervm/entities/#signature_11","text":"def findall(self, match): ...","title":"Signature"},{"location":"pypowervm/entities/#elementfindtext","text":"Show source in entities.py:431 Finds text for the first subelement matching match.","title":"Element().findtext"},{"location":"pypowervm/entities/#arguments_2","text":"match - May be a tag name or path.","title":"Arguments"},{"location":"pypowervm/entities/#returns_2","text":"the text content of the first matching element, or default if no element was found. Note that if the matching element has no text content an empty string is returned.","title":"Returns"},{"location":"pypowervm/entities/#signature_12","text":"def findtext(self, match, default=None): ...","title":"Signature"},{"location":"pypowervm/entities/#elementget","text":"Show source in entities.py:306 Gets the element attribute named key. Returns the attribute value, or default if the attribute was not found.","title":"Element().get"},{"location":"pypowervm/entities/#signature_13","text":"def get(self, key, default=None): ...","title":"Signature"},{"location":"pypowervm/entities/#elementinject","text":"Show source in entities.py:345 Inserts subelement at the correct position in self's children. Uses ordering_list to determine the proper spot at which to insert the specified subelement.","title":"Element().inject"},{"location":"pypowervm/entities/#arguments_3","text":"subelement - The element to inject as a child of this element. ordering_list - Iterable of string tag names representing the desired ordering of children for this element. If subelement's tag is not included in this list, the behavior is self.append(subelement). Element().replace - If True, and an existing child with subelement's tag is found, it is replaced. If False, subelement is added after the existing child(ren). Note: You probably want to use True only/always when subelement is maxOccurs=1. Conversely, you probably want to use False only/always when subelement is unbounded. If you use True and more than one matching child is found, the last one is replaced.","title":"Arguments"},{"location":"pypowervm/entities/#signature_14","text":"def inject(self, subelement, ordering_list=(), replace=True): ...","title":"Signature"},{"location":"pypowervm/entities/#elementinsert","text":"Show source in entities.py:443 Inserts subelement at the given position in this element.","title":"Element().insert"},{"location":"pypowervm/entities/#raises","text":"TypeError - if subelement is not an etree.Element.","title":"Raises"},{"location":"pypowervm/entities/#signature_15","text":"def insert(self, index, subelement): ...","title":"Signature"},{"location":"pypowervm/entities/#elementitems","text":"Show source in entities.py:313 Returns the element attributes as a sequence of (name, value) pairs. The attributes are returned in an arbitrary order.","title":"Element().items"},{"location":"pypowervm/entities/#signature_16","text":"def items(self): ...","title":"Signature"},{"location":"pypowervm/entities/#elementiter_1","text":"Show source in entities.py:450 Creates a tree iterator with the current element as the root. The iterator iterates over this element and all elements below it, in document (depth first) order. If tag is not None or '*', only elements whose tag equals tag are returned from the iterator. If the tree structure is modified during iteration, the result is undefined.","title":"Element().iter"},{"location":"pypowervm/entities/#signature_17","text":"def iter(self, tag=None): ...","title":"Signature"},{"location":"pypowervm/entities/#elementkeys","text":"Show source in entities.py:320 Returns the element attribute names as a list. The names are returned in an arbitrary order.","title":"Element().keys"},{"location":"pypowervm/entities/#signature_18","text":"def keys(self): ...","title":"Signature"},{"location":"pypowervm/entities/#elementnamespace","text":"Show source in entities.py:281","title":"Element().namespace"},{"location":"pypowervm/entities/#signature_19","text":"@property def namespace(self): ...","title":"Signature"},{"location":"pypowervm/entities/#elementnamespace_1","text":"Show source in entities.py:286","title":"Element().namespace"},{"location":"pypowervm/entities/#signature_20","text":"@namespace.setter def namespace(self, ns): ...","title":"Signature"},{"location":"pypowervm/entities/#elementremove","text":"Show source in entities.py:482 Removes subelement from the element. Unlike the find* methods this method compares elements based on the instance identity, not on tag value or contents.","title":"Element().remove"},{"location":"pypowervm/entities/#signature_21","text":"def remove(self, subelement): ...","title":"Signature"},{"location":"pypowervm/entities/#elementreplace","text":"Show source in entities.py:477 Replaces the existing child Element with the new one.","title":"Element().replace"},{"location":"pypowervm/entities/#signature_22","text":"def replace(self, existing, new_element): ...","title":"Signature"},{"location":"pypowervm/entities/#elementset","text":"Show source in entities.py:327 Set the attribute key on the element to value.","title":"Element().set"},{"location":"pypowervm/entities/#signature_23","text":"def set(self, key, value): ...","title":"Signature"},{"location":"pypowervm/entities/#elementtag","text":"Show source in entities.py:269","title":"Element().tag"},{"location":"pypowervm/entities/#signature_24","text":"@property def tag(self): ...","title":"Signature"},{"location":"pypowervm/entities/#elementtag_1","text":"Show source in entities.py:273","title":"Element().tag"},{"location":"pypowervm/entities/#signature_25","text":"@tag.setter def tag(self, tag): ...","title":"Signature"},{"location":"pypowervm/entities/#elementtext","text":"Show source in entities.py:290","title":"Element().text"},{"location":"pypowervm/entities/#signature_26","text":"@property def text(self): ...","title":"Signature"},{"location":"pypowervm/entities/#elementtext_1","text":"Show source in entities.py:294","title":"Element().text"},{"location":"pypowervm/entities/#signature_27","text":"@text.setter def text(self, text): ...","title":"Signature"},{"location":"pypowervm/entities/#elementtoxmlstring","text":"Show source in entities.py:259 Produce an XML dump of this Element.","title":"Element().toxmlstring"},{"location":"pypowervm/entities/#arguments_4","text":"pretty - If True, format the XML in a visually-pleasing manner.","title":"Arguments"},{"location":"pypowervm/entities/#returns_3","text":"An XML string representing this Element.","title":"Returns"},{"location":"pypowervm/entities/#signature_28","text":"def toxmlstring(self, pretty=False): ...","title":"Signature"},{"location":"pypowervm/entities/#elementwrapelement","text":"Show source in entities.py:249","title":"Element.wrapelement"},{"location":"pypowervm/entities/#signature_29","text":"@classmethod def wrapelement(cls, element, adapter): ...","title":"Signature"},{"location":"pypowervm/entities/#elementlist","text":"Show source in entities.py:501 Useful list ops on a list of Element. In a schema where a simpleType element has a multiplicity allowing more than one instance within the containing element, this class provides a way to treat those instances as a list, to a limited extent. For example, given XML like: ...(stuff that isn't )... one two three ...(stuff that isn't )... fooList = ElementList(parent_element, 'foo') len(fooList) 3 repr(fooList) \"['one', 'two', 'three']\" 'two' in fooList True 'four' in fooList False fooList.append('four') repr(fooList) \"['one', 'two', 'three', 'four']\" print root.toxmlstring() ...(stuff that isn't )... one two three four ...(stuff that isn't )...","title":"ElementList"},{"location":"pypowervm/entities/#signature_30","text":"class ElementList(object): def __init__(self, root_elem, tag, ordering_list=()): ...","title":"Signature"},{"location":"pypowervm/entities/#elementlist__create_elem","text":"Show source in entities.py:568 Create a new entities.Element suitable for this list.","title":"ElementList().__create_elem"},{"location":"pypowervm/entities/#arguments_5","text":"val - The raw string value for the text content of the new element. E.g. self.__create_elem('foo') will yield an entities.Element representing foo (where tag is whatever this ElementList was initialized with).","title":"Arguments"},{"location":"pypowervm/entities/#returns_4","text":"A new entities.Element containing the specified string val.","title":"Returns"},{"location":"pypowervm/entities/#signature_31","text":"def __create_elem(self, val): ...","title":"Signature"},{"location":"pypowervm/entities/#elementlist__find_elems","text":"Show source in entities.py:560 List of entities.Element under self.root_elem with tag self.tag.","title":"ElementList().__find_elems"},{"location":"pypowervm/entities/#signature_32","text":"def __find_elems(self): ...","title":"Signature"},{"location":"pypowervm/entities/#elementlist__get_values","text":"Show source in entities.py:564 List of the string values within the entities.Element instances.","title":"ElementList().__get_values"},{"location":"pypowervm/entities/#signature_33","text":"def __get_values(self): ...","title":"Signature"},{"location":"pypowervm/entities/#elementlistappend","text":"Show source in entities.py:598","title":"ElementList().append"},{"location":"pypowervm/entities/#signature_34","text":"def append(self, val): ...","title":"Signature"},{"location":"pypowervm/entities/#elementlistclear","text":"Show source in entities.py:617","title":"ElementList().clear"},{"location":"pypowervm/entities/#signature_35","text":"def clear(self): ...","title":"Signature"},{"location":"pypowervm/entities/#elementlistextend","text":"Show source in entities.py:585","title":"ElementList().extend"},{"location":"pypowervm/entities/#signature_36","text":"def extend(self, val_list): ...","title":"Signature"},{"location":"pypowervm/entities/#elementlistindex","text":"Show source in entities.py:579","title":"ElementList().index"},{"location":"pypowervm/entities/#signature_37","text":"def index(self, val): ...","title":"Signature"},{"location":"pypowervm/entities/#elementlistremove","text":"Show source in entities.py:611","title":"ElementList().remove"},{"location":"pypowervm/entities/#signature_38","text":"def remove(self, val): ...","title":"Signature"},{"location":"pypowervm/entities/#entry","text":"Show source in entities.py:113 Represents an Atom Entry returned by the PowerVM API.","title":"Entry"},{"location":"pypowervm/entities/#signature_39","text":"class Entry(Atom): def __init__(self, properties, element, adapter): ...","title":"Signature"},{"location":"pypowervm/entities/#see-also","text":"Atom","title":"See also"},{"location":"pypowervm/entities/#entrydeepcopy","text":"Show source in entities.py:128 Produce a deep (except for adapter) copy of this Entry.","title":"Entry().deepcopy"},{"location":"pypowervm/entities/#signature_40","text":"def __deepcopy__(self, memo=None): ...","title":"Signature"},{"location":"pypowervm/entities/#entryadapter","text":"Show source in entities.py:138","title":"Entry().adapter"},{"location":"pypowervm/entities/#signature_41","text":"@property def adapter(self): ...","title":"Signature"},{"location":"pypowervm/entities/#entryetag","text":"Show source in entities.py:134","title":"Entry().etag"},{"location":"pypowervm/entities/#signature_42","text":"@property def etag(self): ...","title":"Signature"},{"location":"pypowervm/entities/#entryunmarshal_atom_entry","text":"Show source in entities.py:142 Factory method producing an Entry object from a parsed ElementTree","title":"Entry.unmarshal_atom_entry"},{"location":"pypowervm/entities/#arguments_6","text":"entryelem - Parsed ElementTree object representing an atom entry. resp - The Response containing (the feed containing) the entry.","title":"Arguments"},{"location":"pypowervm/entities/#returns_5","text":"a new Entry object representing the entryelem parameter.","title":"Returns"},{"location":"pypowervm/entities/#signature_43","text":"@classmethod def unmarshal_atom_entry(cls, entryelem, resp): ...","title":"Signature"},{"location":"pypowervm/entities/#feed","text":"Show source in entities.py:78 Represents an Atom Feed returned from PowerVM.","title":"Feed"},{"location":"pypowervm/entities/#signature_44","text":"class Feed(Atom): def __init__(self, properties, entries): ...","title":"Signature"},{"location":"pypowervm/entities/#see-also_1","text":"Atom","title":"See also"},{"location":"pypowervm/entities/#feedfindentries","text":"Show source in entities.py:84","title":"Feed().findentries"},{"location":"pypowervm/entities/#signature_45","text":"def findentries(self, subelem, text): ...","title":"Signature"},{"location":"pypowervm/entities/#feedunmarshal_atom_feed","text":"Show source in entities.py:94 Factory method producing a Feed object from a parsed ElementTree","title":"Feed.unmarshal_atom_feed"},{"location":"pypowervm/entities/#arguments_7","text":"feedelem - Parsed ElementTree object representing an atom feed. resp - The Response from which this Feed was parsed.","title":"Arguments"},{"location":"pypowervm/entities/#returns_6","text":"a new Feed object representing the feedelem parameter.","title":"Returns"},{"location":"pypowervm/entities/#signature_46","text":"@classmethod def unmarshal_atom_feed(cls, feedelem, resp): ...","title":"Signature"},{"location":"pypowervm/exceptions/","text":"Exceptions Pypowervm Index / Pypowervm / Exceptions Auto-generated documentation for pypowervm.exceptions module. Exceptions AbstractMsgFmtError AdapterNotFound AtomError AuthFileAccessError AuthFileReadError CacheNotSupportedException CantUpdatePPortsInUse ConnectionError ConsoleNotLocal DuplicateLUNameError Error FeedTaskEmptyFeed FoundDevMultipleTimes HttpError HttpNotFound HttpUnauth IBMiLoadSourceNotFound ISCSIDiscoveryFailed ISCSILogoutFailed ISCSIRemoveFailed InsufficientSRIOVCapacity InvalidEnumValue InvalidHostForRebuild InvalidHostForRebuildFabricsNotFound InvalidHostForRebuildInvalidIOType InvalidHostForRebuildNoVIOSForUDID InvalidHostForRebuildNotEnoughVIOS InvalidHostForRebuildSlotMismatch InvalidIBMiPanelFunctionOperation InvalidVirtualNetworkDeviceType JobRequestFailed JobRequestTimedOut LPARNotFound ManagementPartitionNotFoundException MigrationFailed MultipleExceptionsInFeedTask NoDefaultTierFoundOnSSP NoMediaRepoVolumeGroupFound NoRunningSharedSriovAdapters NoVNICCapableVIOSes NotEnoughActiveVioses NotFound OSShutdownNoRMC OrphanVLANFoundOnProvision PanelFunctionRequiresPartition PartitionIsNotIBMi PvidOfNetworkBridgeError SSLError SingleMappingNotFoundRemapError StorageMapExistsRemapError SystemNotVNICCapable ThisPartitionNotFoundException TimeoutError UnableToBuildPG83EncodingMissingParent UnableToDerivePhysicalPortForNPIV UnableToFindFCPortMap VGNotFound VIOSNotFound VMPowerOffFailure VMPowerOffTimeout VMPowerOnFailure VMPowerOnTimeout VNCBasedTerminalFailedToOpen VNICFailoverNotSupportedSys VNICFailoverNotSupportedVIOS ViosNotAvailable VstorNotFound WrapperTaskNoSubtasks AbstractMsgFmtError Show source in exceptions.py:115 Used to raise an exception with a formattable/parameterized message. The subclass must set the msg_fmt class variable. The consumer should instantiate the subclass with **kwargs appropriate to its msg_fmt. Signature class AbstractMsgFmtError(Error): def __init__(self, response=None, **kwa): ... See also Error AdapterNotFound Show source in exceptions.py:140 Signature class AdapterNotFound(AbstractMsgFmtError): ... See also AbstractMsgFmtError AtomError Show source in exceptions.py:106 Atom Error on PowerVM API Adapter method invocation. Signature class AtomError(Error): def __init__(self, msg, response): ... See also Error AuthFileAccessError Show source in exceptions.py:221 Signature class AuthFileAccessError(AbstractMsgFmtError): ... See also AbstractMsgFmtError AuthFileReadError Show source in exceptions.py:217 Signature class AuthFileReadError(AbstractMsgFmtError): ... See also AbstractMsgFmtError CacheNotSupportedException Show source in exceptions.py:392 Signature class CacheNotSupportedException(AbstractMsgFmtError): ... See also AbstractMsgFmtError CantUpdatePPortsInUse Show source in exceptions.py:382 Signature class CantUpdatePPortsInUse(AbstractMsgFmtError): ... See also AbstractMsgFmtError ConnectionError Show source in exceptions.py:38 Connection Error on PowerVM API Adapter method invocation. Signature class ConnectionError(Error): ... See also Error ConsoleNotLocal Show source in exceptions.py:202 Signature class ConsoleNotLocal(AbstractMsgFmtError): ... See also AbstractMsgFmtError DuplicateLUNameError Show source in exceptions.py:190 Signature class DuplicateLUNameError(AbstractMsgFmtError): ... See also AbstractMsgFmtError Error Show source in exceptions.py:28 Error on PowerVM API Adapter method invocation. Signature class Error(Exception): def __init__(self, msg, response=None): ... FeedTaskEmptyFeed Show source in exceptions.py:213 Signature class FeedTaskEmptyFeed(AbstractMsgFmtError): ... See also AbstractMsgFmtError FoundDevMultipleTimes Show source in exceptions.py:254 Signature class FoundDevMultipleTimes(AbstractMsgFmtError): ... See also AbstractMsgFmtError HttpError Show source in exceptions.py:50 HTTP Error on PowerVM API Adapter method invocation. Signature class HttpError(Error): def __init__(self, resp): ... See also Error HttpNotFound Show source in exceptions.py:96 HttpError subclass where response.status == c.HTTPStatus.NOT_FOUND. Signature class HttpNotFound(HttpError): ... See also HttpError HttpUnauth Show source in exceptions.py:101 HttpError where response.status == c.HTTPStatus.UNAUTHORIZED. Signature class HttpUnauth(HttpError): ... See also HttpError IBMiLoadSourceNotFound Show source in exceptions.py:230 Signature class IBMiLoadSourceNotFound(AbstractMsgFmtError): ... See also AbstractMsgFmtError ISCSIDiscoveryFailed Show source in exceptions.py:422 Signature class ISCSIDiscoveryFailed(AbstractMsgFmtError): ... See also AbstractMsgFmtError ISCSILogoutFailed Show source in exceptions.py:427 Exception currently unused Signature class ISCSILogoutFailed(AbstractMsgFmtError): ... See also AbstractMsgFmtError ISCSIRemoveFailed Show source in exceptions.py:433 Signature class ISCSIRemoveFailed(AbstractMsgFmtError): ... See also AbstractMsgFmtError InsufficientSRIOVCapacity Show source in exceptions.py:353 Signature class InsufficientSRIOVCapacity(AbstractMsgFmtError): ... See also AbstractMsgFmtError InvalidEnumValue Show source in exceptions.py:396 Signature class InvalidEnumValue(AbstractMsgFmtError): ... See also AbstractMsgFmtError InvalidHostForRebuild Show source in exceptions.py:296 Signature class InvalidHostForRebuild(AbstractMsgFmtError): ... See also AbstractMsgFmtError InvalidHostForRebuildFabricsNotFound Show source in exceptions.py:310 Signature class InvalidHostForRebuildFabricsNotFound(InvalidHostForRebuild): ... See also InvalidHostForRebuild InvalidHostForRebuildInvalidIOType Show source in exceptions.py:315 Signature class InvalidHostForRebuildInvalidIOType(InvalidHostForRebuild): ... See also InvalidHostForRebuild InvalidHostForRebuildNoVIOSForUDID Show source in exceptions.py:300 Signature class InvalidHostForRebuildNoVIOSForUDID(InvalidHostForRebuild): ... See also InvalidHostForRebuild InvalidHostForRebuildNotEnoughVIOS Show source in exceptions.py:305 Signature class InvalidHostForRebuildNotEnoughVIOS(InvalidHostForRebuild): ... See also InvalidHostForRebuild InvalidHostForRebuildSlotMismatch Show source in exceptions.py:320 Signature class InvalidHostForRebuildSlotMismatch(InvalidHostForRebuild): ... See also InvalidHostForRebuild InvalidIBMiPanelFunctionOperation Show source in exceptions.py:417 Signature class InvalidIBMiPanelFunctionOperation(AbstractMsgFmtError): ... See also AbstractMsgFmtError InvalidVirtualNetworkDeviceType Show source in exceptions.py:327 Signature class InvalidVirtualNetworkDeviceType(AbstractMsgFmtError): ... See also AbstractMsgFmtError JobRequestFailed Show source in exceptions.py:144 Signature class JobRequestFailed(AbstractMsgFmtError): ... See also AbstractMsgFmtError JobRequestTimedOut Show source in exceptions.py:148 Signature class JobRequestTimedOut(JobRequestFailed): ... See also JobRequestFailed LPARNotFound Show source in exceptions.py:136 Signature class LPARNotFound(AbstractMsgFmtError): ... See also AbstractMsgFmtError ManagementPartitionNotFoundException Show source in exceptions.py:278 Couldn't find exactly one management partition on the system. Signature class ManagementPartitionNotFoundException(AbstractMsgFmtError): ... See also AbstractMsgFmtError MigrationFailed Show source in exceptions.py:226 Signature class MigrationFailed(AbstractMsgFmtError): ... See also AbstractMsgFmtError MultipleExceptionsInFeedTask Show source in exceptions.py:259 Exception concatenating messages in WrappedFailure exceptions. Exception raised when a pypowervm.utils.transaction.FeedTask run raises a tasflow.exceptions.WrappedFailure containing more than one exception. The message string is a concatenation of the message strings of the wrapped exceptions. Signature class MultipleExceptionsInFeedTask(AbstractMsgFmtError): def __init__(self, ft_name, wrapped_failure): ... See also AbstractMsgFmtError NoDefaultTierFoundOnSSP Show source in exceptions.py:290 Looked for a default Tier on the SSP, but didn't find it. Signature class NoDefaultTierFoundOnSSP(AbstractMsgFmtError): ... See also AbstractMsgFmtError NoMediaRepoVolumeGroupFound Show source in exceptions.py:376 Signature class NoMediaRepoVolumeGroupFound(AbstractMsgFmtError): ... See also AbstractMsgFmtError NoRunningSharedSriovAdapters Show source in exceptions.py:345 Attributes msg_fmt - sriov_loc_mode_state should be a string comprising one SRIOV adapter per line, each line comprising the physical location code, the mode, and the state, separated by ' | '.: _('Could not find any SR-IOV adapters in Sriov mode and Running state.\\nLocation | Mode | State\\n%(sriov_loc_mode_state)s') Signature class NoRunningSharedSriovAdapters(AbstractMsgFmtError): ... See also AbstractMsgFmtError NoVNICCapableVIOSes Show source in exceptions.py:362 Signature class NoVNICCapableVIOSes(AbstractMsgFmtError): ... See also AbstractMsgFmtError NotEnoughActiveVioses Show source in exceptions.py:333 Signature class NotEnoughActiveVioses(AbstractMsgFmtError): ... See also AbstractMsgFmtError NotFound Show source in exceptions.py:132 Signature class NotFound(AbstractMsgFmtError): ... See also AbstractMsgFmtError OSShutdownNoRMC Show source in exceptions.py:153 Signature class OSShutdownNoRMC(AbstractMsgFmtError): ... See also AbstractMsgFmtError OrphanVLANFoundOnProvision Show source in exceptions.py:181 Signature class OrphanVLANFoundOnProvision(AbstractMsgFmtError): ... See also AbstractMsgFmtError PanelFunctionRequiresPartition Show source in exceptions.py:413 Signature class PanelFunctionRequiresPartition(AbstractMsgFmtError): ... See also AbstractMsgFmtError PartitionIsNotIBMi Show source in exceptions.py:409 Signature class PartitionIsNotIBMi(AbstractMsgFmtError): ... See also AbstractMsgFmtError PvidOfNetworkBridgeError Show source in exceptions.py:176 Signature class PvidOfNetworkBridgeError(AbstractMsgFmtError): ... See also AbstractMsgFmtError SSLError Show source in exceptions.py:42 SSL Error on PowerVM API Adapter method invocation. Signature class SSLError(Error): ... See also Error SingleMappingNotFoundRemapError Show source in exceptions.py:242 Signature class SingleMappingNotFoundRemapError(AbstractMsgFmtError): ... See also AbstractMsgFmtError StorageMapExistsRemapError Show source in exceptions.py:248 Signature class StorageMapExistsRemapError(AbstractMsgFmtError): ... See also AbstractMsgFmtError SystemNotVNICCapable Show source in exceptions.py:358 Signature class SystemNotVNICCapable(AbstractMsgFmtError): ... See also AbstractMsgFmtError ThisPartitionNotFoundException Show source in exceptions.py:284 Couldn't find exactly one partition with the local VM's short ID. Signature class ThisPartitionNotFoundException(AbstractMsgFmtError): ... See also AbstractMsgFmtError TimeoutError Show source in exceptions.py:46 Timeout Error on PowerVM API Adapter method invocation. Signature class TimeoutError(Error): ... See also Error UnableToBuildPG83EncodingMissingParent Show source in exceptions.py:234 Signature class UnableToBuildPG83EncodingMissingParent(AbstractMsgFmtError): ... See also AbstractMsgFmtError UnableToDerivePhysicalPortForNPIV Show source in exceptions.py:126 Signature class UnableToDerivePhysicalPortForNPIV(AbstractMsgFmtError): ... See also AbstractMsgFmtError UnableToFindFCPortMap Show source in exceptions.py:195 Signature class UnableToFindFCPortMap(AbstractMsgFmtError): ... See also AbstractMsgFmtError VGNotFound Show source in exceptions.py:405 Signature class VGNotFound(AbstractMsgFmtError): ... See also AbstractMsgFmtError VIOSNotFound Show source in exceptions.py:401 Signature class VIOSNotFound(AbstractMsgFmtError): ... See also AbstractMsgFmtError VMPowerOffFailure Show source in exceptions.py:158 Signature class VMPowerOffFailure(AbstractMsgFmtError): ... See also AbstractMsgFmtError VMPowerOffTimeout Show source in exceptions.py:162 Signature class VMPowerOffTimeout(VMPowerOffFailure): ... See also VMPowerOffFailure VMPowerOnFailure Show source in exceptions.py:167 Signature class VMPowerOnFailure(AbstractMsgFmtError): ... See also AbstractMsgFmtError VMPowerOnTimeout Show source in exceptions.py:171 Signature class VMPowerOnTimeout(VMPowerOnFailure): ... See also VMPowerOnFailure VNCBasedTerminalFailedToOpen Show source in exceptions.py:388 Signature class VNCBasedTerminalFailedToOpen(AbstractMsgFmtError): ... See also AbstractMsgFmtError VNICFailoverNotSupportedSys Show source in exceptions.py:366 Signature class VNICFailoverNotSupportedSys(AbstractMsgFmtError): ... See also AbstractMsgFmtError VNICFailoverNotSupportedVIOS Show source in exceptions.py:371 Signature class VNICFailoverNotSupportedVIOS(AbstractMsgFmtError): ... See also AbstractMsgFmtError ViosNotAvailable Show source in exceptions.py:338 Signature class ViosNotAvailable(AbstractMsgFmtError): ... See also AbstractMsgFmtError VstorNotFound Show source in exceptions.py:438 Signature class VstorNotFound(AbstractMsgFmtError): ... See also AbstractMsgFmtError WrapperTaskNoSubtasks Show source in exceptions.py:209 Signature class WrapperTaskNoSubtasks(AbstractMsgFmtError): ... See also AbstractMsgFmtError","title":"Exceptions"},{"location":"pypowervm/exceptions/#exceptions","text":"Pypowervm Index / Pypowervm / Exceptions Auto-generated documentation for pypowervm.exceptions module. Exceptions AbstractMsgFmtError AdapterNotFound AtomError AuthFileAccessError AuthFileReadError CacheNotSupportedException CantUpdatePPortsInUse ConnectionError ConsoleNotLocal DuplicateLUNameError Error FeedTaskEmptyFeed FoundDevMultipleTimes HttpError HttpNotFound HttpUnauth IBMiLoadSourceNotFound ISCSIDiscoveryFailed ISCSILogoutFailed ISCSIRemoveFailed InsufficientSRIOVCapacity InvalidEnumValue InvalidHostForRebuild InvalidHostForRebuildFabricsNotFound InvalidHostForRebuildInvalidIOType InvalidHostForRebuildNoVIOSForUDID InvalidHostForRebuildNotEnoughVIOS InvalidHostForRebuildSlotMismatch InvalidIBMiPanelFunctionOperation InvalidVirtualNetworkDeviceType JobRequestFailed JobRequestTimedOut LPARNotFound ManagementPartitionNotFoundException MigrationFailed MultipleExceptionsInFeedTask NoDefaultTierFoundOnSSP NoMediaRepoVolumeGroupFound NoRunningSharedSriovAdapters NoVNICCapableVIOSes NotEnoughActiveVioses NotFound OSShutdownNoRMC OrphanVLANFoundOnProvision PanelFunctionRequiresPartition PartitionIsNotIBMi PvidOfNetworkBridgeError SSLError SingleMappingNotFoundRemapError StorageMapExistsRemapError SystemNotVNICCapable ThisPartitionNotFoundException TimeoutError UnableToBuildPG83EncodingMissingParent UnableToDerivePhysicalPortForNPIV UnableToFindFCPortMap VGNotFound VIOSNotFound VMPowerOffFailure VMPowerOffTimeout VMPowerOnFailure VMPowerOnTimeout VNCBasedTerminalFailedToOpen VNICFailoverNotSupportedSys VNICFailoverNotSupportedVIOS ViosNotAvailable VstorNotFound WrapperTaskNoSubtasks","title":"Exceptions"},{"location":"pypowervm/exceptions/#abstractmsgfmterror","text":"Show source in exceptions.py:115 Used to raise an exception with a formattable/parameterized message. The subclass must set the msg_fmt class variable. The consumer should instantiate the subclass with **kwargs appropriate to its msg_fmt.","title":"AbstractMsgFmtError"},{"location":"pypowervm/exceptions/#signature","text":"class AbstractMsgFmtError(Error): def __init__(self, response=None, **kwa): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also","text":"Error","title":"See also"},{"location":"pypowervm/exceptions/#adapternotfound","text":"Show source in exceptions.py:140","title":"AdapterNotFound"},{"location":"pypowervm/exceptions/#signature_1","text":"class AdapterNotFound(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_1","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#atomerror","text":"Show source in exceptions.py:106 Atom Error on PowerVM API Adapter method invocation.","title":"AtomError"},{"location":"pypowervm/exceptions/#signature_2","text":"class AtomError(Error): def __init__(self, msg, response): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_2","text":"Error","title":"See also"},{"location":"pypowervm/exceptions/#authfileaccesserror","text":"Show source in exceptions.py:221","title":"AuthFileAccessError"},{"location":"pypowervm/exceptions/#signature_3","text":"class AuthFileAccessError(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_3","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#authfilereaderror","text":"Show source in exceptions.py:217","title":"AuthFileReadError"},{"location":"pypowervm/exceptions/#signature_4","text":"class AuthFileReadError(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_4","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#cachenotsupportedexception","text":"Show source in exceptions.py:392","title":"CacheNotSupportedException"},{"location":"pypowervm/exceptions/#signature_5","text":"class CacheNotSupportedException(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_5","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#cantupdatepportsinuse","text":"Show source in exceptions.py:382","title":"CantUpdatePPortsInUse"},{"location":"pypowervm/exceptions/#signature_6","text":"class CantUpdatePPortsInUse(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_6","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#connectionerror","text":"Show source in exceptions.py:38 Connection Error on PowerVM API Adapter method invocation.","title":"ConnectionError"},{"location":"pypowervm/exceptions/#signature_7","text":"class ConnectionError(Error): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_7","text":"Error","title":"See also"},{"location":"pypowervm/exceptions/#consolenotlocal","text":"Show source in exceptions.py:202","title":"ConsoleNotLocal"},{"location":"pypowervm/exceptions/#signature_8","text":"class ConsoleNotLocal(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_8","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#duplicatelunameerror","text":"Show source in exceptions.py:190","title":"DuplicateLUNameError"},{"location":"pypowervm/exceptions/#signature_9","text":"class DuplicateLUNameError(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_9","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#error","text":"Show source in exceptions.py:28 Error on PowerVM API Adapter method invocation.","title":"Error"},{"location":"pypowervm/exceptions/#signature_10","text":"class Error(Exception): def __init__(self, msg, response=None): ...","title":"Signature"},{"location":"pypowervm/exceptions/#feedtaskemptyfeed","text":"Show source in exceptions.py:213","title":"FeedTaskEmptyFeed"},{"location":"pypowervm/exceptions/#signature_11","text":"class FeedTaskEmptyFeed(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_10","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#founddevmultipletimes","text":"Show source in exceptions.py:254","title":"FoundDevMultipleTimes"},{"location":"pypowervm/exceptions/#signature_12","text":"class FoundDevMultipleTimes(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_11","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#httperror","text":"Show source in exceptions.py:50 HTTP Error on PowerVM API Adapter method invocation.","title":"HttpError"},{"location":"pypowervm/exceptions/#signature_13","text":"class HttpError(Error): def __init__(self, resp): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_12","text":"Error","title":"See also"},{"location":"pypowervm/exceptions/#httpnotfound","text":"Show source in exceptions.py:96 HttpError subclass where response.status == c.HTTPStatus.NOT_FOUND.","title":"HttpNotFound"},{"location":"pypowervm/exceptions/#signature_14","text":"class HttpNotFound(HttpError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_13","text":"HttpError","title":"See also"},{"location":"pypowervm/exceptions/#httpunauth","text":"Show source in exceptions.py:101 HttpError where response.status == c.HTTPStatus.UNAUTHORIZED.","title":"HttpUnauth"},{"location":"pypowervm/exceptions/#signature_15","text":"class HttpUnauth(HttpError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_14","text":"HttpError","title":"See also"},{"location":"pypowervm/exceptions/#ibmiloadsourcenotfound","text":"Show source in exceptions.py:230","title":"IBMiLoadSourceNotFound"},{"location":"pypowervm/exceptions/#signature_16","text":"class IBMiLoadSourceNotFound(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_15","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#iscsidiscoveryfailed","text":"Show source in exceptions.py:422","title":"ISCSIDiscoveryFailed"},{"location":"pypowervm/exceptions/#signature_17","text":"class ISCSIDiscoveryFailed(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_16","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#iscsilogoutfailed","text":"Show source in exceptions.py:427 Exception currently unused","title":"ISCSILogoutFailed"},{"location":"pypowervm/exceptions/#signature_18","text":"class ISCSILogoutFailed(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_17","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#iscsiremovefailed","text":"Show source in exceptions.py:433","title":"ISCSIRemoveFailed"},{"location":"pypowervm/exceptions/#signature_19","text":"class ISCSIRemoveFailed(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_18","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#insufficientsriovcapacity","text":"Show source in exceptions.py:353","title":"InsufficientSRIOVCapacity"},{"location":"pypowervm/exceptions/#signature_20","text":"class InsufficientSRIOVCapacity(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_19","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#invalidenumvalue","text":"Show source in exceptions.py:396","title":"InvalidEnumValue"},{"location":"pypowervm/exceptions/#signature_21","text":"class InvalidEnumValue(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_20","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#invalidhostforrebuild","text":"Show source in exceptions.py:296","title":"InvalidHostForRebuild"},{"location":"pypowervm/exceptions/#signature_22","text":"class InvalidHostForRebuild(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_21","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#invalidhostforrebuildfabricsnotfound","text":"Show source in exceptions.py:310","title":"InvalidHostForRebuildFabricsNotFound"},{"location":"pypowervm/exceptions/#signature_23","text":"class InvalidHostForRebuildFabricsNotFound(InvalidHostForRebuild): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_22","text":"InvalidHostForRebuild","title":"See also"},{"location":"pypowervm/exceptions/#invalidhostforrebuildinvalidiotype","text":"Show source in exceptions.py:315","title":"InvalidHostForRebuildInvalidIOType"},{"location":"pypowervm/exceptions/#signature_24","text":"class InvalidHostForRebuildInvalidIOType(InvalidHostForRebuild): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_23","text":"InvalidHostForRebuild","title":"See also"},{"location":"pypowervm/exceptions/#invalidhostforrebuildnoviosforudid","text":"Show source in exceptions.py:300","title":"InvalidHostForRebuildNoVIOSForUDID"},{"location":"pypowervm/exceptions/#signature_25","text":"class InvalidHostForRebuildNoVIOSForUDID(InvalidHostForRebuild): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_24","text":"InvalidHostForRebuild","title":"See also"},{"location":"pypowervm/exceptions/#invalidhostforrebuildnotenoughvios","text":"Show source in exceptions.py:305","title":"InvalidHostForRebuildNotEnoughVIOS"},{"location":"pypowervm/exceptions/#signature_26","text":"class InvalidHostForRebuildNotEnoughVIOS(InvalidHostForRebuild): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_25","text":"InvalidHostForRebuild","title":"See also"},{"location":"pypowervm/exceptions/#invalidhostforrebuildslotmismatch","text":"Show source in exceptions.py:320","title":"InvalidHostForRebuildSlotMismatch"},{"location":"pypowervm/exceptions/#signature_27","text":"class InvalidHostForRebuildSlotMismatch(InvalidHostForRebuild): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_26","text":"InvalidHostForRebuild","title":"See also"},{"location":"pypowervm/exceptions/#invalidibmipanelfunctionoperation","text":"Show source in exceptions.py:417","title":"InvalidIBMiPanelFunctionOperation"},{"location":"pypowervm/exceptions/#signature_28","text":"class InvalidIBMiPanelFunctionOperation(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_27","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#invalidvirtualnetworkdevicetype","text":"Show source in exceptions.py:327","title":"InvalidVirtualNetworkDeviceType"},{"location":"pypowervm/exceptions/#signature_29","text":"class InvalidVirtualNetworkDeviceType(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_28","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#jobrequestfailed","text":"Show source in exceptions.py:144","title":"JobRequestFailed"},{"location":"pypowervm/exceptions/#signature_30","text":"class JobRequestFailed(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_29","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#jobrequesttimedout","text":"Show source in exceptions.py:148","title":"JobRequestTimedOut"},{"location":"pypowervm/exceptions/#signature_31","text":"class JobRequestTimedOut(JobRequestFailed): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_30","text":"JobRequestFailed","title":"See also"},{"location":"pypowervm/exceptions/#lparnotfound","text":"Show source in exceptions.py:136","title":"LPARNotFound"},{"location":"pypowervm/exceptions/#signature_32","text":"class LPARNotFound(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_31","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#managementpartitionnotfoundexception","text":"Show source in exceptions.py:278 Couldn't find exactly one management partition on the system.","title":"ManagementPartitionNotFoundException"},{"location":"pypowervm/exceptions/#signature_33","text":"class ManagementPartitionNotFoundException(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_32","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#migrationfailed","text":"Show source in exceptions.py:226","title":"MigrationFailed"},{"location":"pypowervm/exceptions/#signature_34","text":"class MigrationFailed(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_33","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#multipleexceptionsinfeedtask","text":"Show source in exceptions.py:259 Exception concatenating messages in WrappedFailure exceptions. Exception raised when a pypowervm.utils.transaction.FeedTask run raises a tasflow.exceptions.WrappedFailure containing more than one exception. The message string is a concatenation of the message strings of the wrapped exceptions.","title":"MultipleExceptionsInFeedTask"},{"location":"pypowervm/exceptions/#signature_35","text":"class MultipleExceptionsInFeedTask(AbstractMsgFmtError): def __init__(self, ft_name, wrapped_failure): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_34","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#nodefaulttierfoundonssp","text":"Show source in exceptions.py:290 Looked for a default Tier on the SSP, but didn't find it.","title":"NoDefaultTierFoundOnSSP"},{"location":"pypowervm/exceptions/#signature_36","text":"class NoDefaultTierFoundOnSSP(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_35","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#nomediarepovolumegroupfound","text":"Show source in exceptions.py:376","title":"NoMediaRepoVolumeGroupFound"},{"location":"pypowervm/exceptions/#signature_37","text":"class NoMediaRepoVolumeGroupFound(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_36","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#norunningsharedsriovadapters","text":"Show source in exceptions.py:345","title":"NoRunningSharedSriovAdapters"},{"location":"pypowervm/exceptions/#attributes","text":"msg_fmt - sriov_loc_mode_state should be a string comprising one SRIOV adapter per line, each line comprising the physical location code, the mode, and the state, separated by ' | '.: _('Could not find any SR-IOV adapters in Sriov mode and Running state.\\nLocation | Mode | State\\n%(sriov_loc_mode_state)s')","title":"Attributes"},{"location":"pypowervm/exceptions/#signature_38","text":"class NoRunningSharedSriovAdapters(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_37","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#novniccapablevioses","text":"Show source in exceptions.py:362","title":"NoVNICCapableVIOSes"},{"location":"pypowervm/exceptions/#signature_39","text":"class NoVNICCapableVIOSes(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_38","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#notenoughactivevioses","text":"Show source in exceptions.py:333","title":"NotEnoughActiveVioses"},{"location":"pypowervm/exceptions/#signature_40","text":"class NotEnoughActiveVioses(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_39","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#notfound","text":"Show source in exceptions.py:132","title":"NotFound"},{"location":"pypowervm/exceptions/#signature_41","text":"class NotFound(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_40","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#osshutdownnormc","text":"Show source in exceptions.py:153","title":"OSShutdownNoRMC"},{"location":"pypowervm/exceptions/#signature_42","text":"class OSShutdownNoRMC(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_41","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#orphanvlanfoundonprovision","text":"Show source in exceptions.py:181","title":"OrphanVLANFoundOnProvision"},{"location":"pypowervm/exceptions/#signature_43","text":"class OrphanVLANFoundOnProvision(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_42","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#panelfunctionrequirespartition","text":"Show source in exceptions.py:413","title":"PanelFunctionRequiresPartition"},{"location":"pypowervm/exceptions/#signature_44","text":"class PanelFunctionRequiresPartition(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_43","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#partitionisnotibmi","text":"Show source in exceptions.py:409","title":"PartitionIsNotIBMi"},{"location":"pypowervm/exceptions/#signature_45","text":"class PartitionIsNotIBMi(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_44","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#pvidofnetworkbridgeerror","text":"Show source in exceptions.py:176","title":"PvidOfNetworkBridgeError"},{"location":"pypowervm/exceptions/#signature_46","text":"class PvidOfNetworkBridgeError(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_45","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#sslerror","text":"Show source in exceptions.py:42 SSL Error on PowerVM API Adapter method invocation.","title":"SSLError"},{"location":"pypowervm/exceptions/#signature_47","text":"class SSLError(Error): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_46","text":"Error","title":"See also"},{"location":"pypowervm/exceptions/#singlemappingnotfoundremaperror","text":"Show source in exceptions.py:242","title":"SingleMappingNotFoundRemapError"},{"location":"pypowervm/exceptions/#signature_48","text":"class SingleMappingNotFoundRemapError(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_47","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#storagemapexistsremaperror","text":"Show source in exceptions.py:248","title":"StorageMapExistsRemapError"},{"location":"pypowervm/exceptions/#signature_49","text":"class StorageMapExistsRemapError(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_48","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#systemnotvniccapable","text":"Show source in exceptions.py:358","title":"SystemNotVNICCapable"},{"location":"pypowervm/exceptions/#signature_50","text":"class SystemNotVNICCapable(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_49","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#thispartitionnotfoundexception","text":"Show source in exceptions.py:284 Couldn't find exactly one partition with the local VM's short ID.","title":"ThisPartitionNotFoundException"},{"location":"pypowervm/exceptions/#signature_51","text":"class ThisPartitionNotFoundException(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_50","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#timeouterror","text":"Show source in exceptions.py:46 Timeout Error on PowerVM API Adapter method invocation.","title":"TimeoutError"},{"location":"pypowervm/exceptions/#signature_52","text":"class TimeoutError(Error): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_51","text":"Error","title":"See also"},{"location":"pypowervm/exceptions/#unabletobuildpg83encodingmissingparent","text":"Show source in exceptions.py:234","title":"UnableToBuildPG83EncodingMissingParent"},{"location":"pypowervm/exceptions/#signature_53","text":"class UnableToBuildPG83EncodingMissingParent(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_52","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#unabletoderivephysicalportfornpiv","text":"Show source in exceptions.py:126","title":"UnableToDerivePhysicalPortForNPIV"},{"location":"pypowervm/exceptions/#signature_54","text":"class UnableToDerivePhysicalPortForNPIV(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_53","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#unabletofindfcportmap","text":"Show source in exceptions.py:195","title":"UnableToFindFCPortMap"},{"location":"pypowervm/exceptions/#signature_55","text":"class UnableToFindFCPortMap(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_54","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#vgnotfound","text":"Show source in exceptions.py:405","title":"VGNotFound"},{"location":"pypowervm/exceptions/#signature_56","text":"class VGNotFound(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_55","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#viosnotfound","text":"Show source in exceptions.py:401","title":"VIOSNotFound"},{"location":"pypowervm/exceptions/#signature_57","text":"class VIOSNotFound(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_56","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#vmpowerofffailure","text":"Show source in exceptions.py:158","title":"VMPowerOffFailure"},{"location":"pypowervm/exceptions/#signature_58","text":"class VMPowerOffFailure(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_57","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#vmpowerofftimeout","text":"Show source in exceptions.py:162","title":"VMPowerOffTimeout"},{"location":"pypowervm/exceptions/#signature_59","text":"class VMPowerOffTimeout(VMPowerOffFailure): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_58","text":"VMPowerOffFailure","title":"See also"},{"location":"pypowervm/exceptions/#vmpoweronfailure","text":"Show source in exceptions.py:167","title":"VMPowerOnFailure"},{"location":"pypowervm/exceptions/#signature_60","text":"class VMPowerOnFailure(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_59","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#vmpowerontimeout","text":"Show source in exceptions.py:171","title":"VMPowerOnTimeout"},{"location":"pypowervm/exceptions/#signature_61","text":"class VMPowerOnTimeout(VMPowerOnFailure): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_60","text":"VMPowerOnFailure","title":"See also"},{"location":"pypowervm/exceptions/#vncbasedterminalfailedtoopen","text":"Show source in exceptions.py:388","title":"VNCBasedTerminalFailedToOpen"},{"location":"pypowervm/exceptions/#signature_62","text":"class VNCBasedTerminalFailedToOpen(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_61","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#vnicfailovernotsupportedsys","text":"Show source in exceptions.py:366","title":"VNICFailoverNotSupportedSys"},{"location":"pypowervm/exceptions/#signature_63","text":"class VNICFailoverNotSupportedSys(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_62","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#vnicfailovernotsupportedvios","text":"Show source in exceptions.py:371","title":"VNICFailoverNotSupportedVIOS"},{"location":"pypowervm/exceptions/#signature_64","text":"class VNICFailoverNotSupportedVIOS(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_63","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#viosnotavailable","text":"Show source in exceptions.py:338","title":"ViosNotAvailable"},{"location":"pypowervm/exceptions/#signature_65","text":"class ViosNotAvailable(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_64","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#vstornotfound","text":"Show source in exceptions.py:438","title":"VstorNotFound"},{"location":"pypowervm/exceptions/#signature_66","text":"class VstorNotFound(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_65","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/exceptions/#wrappertasknosubtasks","text":"Show source in exceptions.py:209","title":"WrapperTaskNoSubtasks"},{"location":"pypowervm/exceptions/#signature_67","text":"class WrapperTaskNoSubtasks(AbstractMsgFmtError): ...","title":"Signature"},{"location":"pypowervm/exceptions/#see-also_66","text":"AbstractMsgFmtError","title":"See also"},{"location":"pypowervm/i18n/","text":"I18n Pypowervm Index / Pypowervm / I18n Auto-generated documentation for pypowervm.i18n module. - I18n","title":"I18n"},{"location":"pypowervm/i18n/#i18n","text":"Pypowervm Index / Pypowervm / I18n Auto-generated documentation for pypowervm.i18n module. - I18n","title":"I18n"},{"location":"pypowervm/log/","text":"Log Pypowervm Index / Pypowervm / Log Auto-generated documentation for pypowervm.log module. - Log","title":"Log"},{"location":"pypowervm/log/#log","text":"Pypowervm Index / Pypowervm / Log Auto-generated documentation for pypowervm.log module. - Log","title":"Log"},{"location":"pypowervm/traits/","text":"Traits Pypowervm Index / Pypowervm / Traits Auto-generated documentation for pypowervm.traits module. Traits APITraits APITraits().dynamic_pvid APITraits().has_high_slot APITraits().has_lpar_profiles APITraits().local_api APITraits().rmdev_job_available APITraits().session APITraits().vea_as_ibmi_console APITraits().vnet_aware APITraits Show source in traits.py:22 Represents capabilities inherent to the backing API server. For instance, depending on a schema version, or the backing REST server, there may be different code paths that the user needs to go through. A key example of this would be the VirtualNetworks. The HMC requires that Virtual Networks be the driver of code paths for various code paths. However, in other API servers, the Virtual Networks are simply realized based off the VLANs/virtual switches that adapters are currently tied to. This class encapsulates the various traits so that tasks and users do not have to inspect the header data directly to determine how the API should behave. Signature class APITraits(object): def __init__(self, session): ... APITraits().dynamic_pvid Show source in traits.py:89 Indicates whether a CNA can dynamically modify its PVID. Signature @property def dynamic_pvid(self): ... APITraits().has_high_slot Show source in traits.py:99 Does the API support UseNextAvailableHighSlotID? Signature @property def has_high_slot(self): ... APITraits().has_lpar_profiles Show source in traits.py:65 Indicates whether the platform manager supports LPAR profiles. This trait will return True if LPAR profiles are supported. Signature @property def has_lpar_profiles(self): ... APITraits().local_api Show source in traits.py:73 Indicates whether or not the PowerVM API Server is running locally. The PowerVM API server in some deployments may be running co-located with the pypowervm API. In those cases, certain optimizations may be available (like uploading from a file instead of a pipe). This trait is a coarse check to determine, for certain, if the API is co-located on the same server. Signature @property def local_api(self): ... APITraits().rmdev_job_available Show source in traits.py:94 Indicates whether or not the Job API supports RMDev. Signature @property def rmdev_job_available(self): ... APITraits().session Show source in traits.py:45 Signature @property def session(self): ... APITraits().vea_as_ibmi_console Show source in traits.py:104 Indicates whether the console type of IBMi VM is vea. IBMi depends on the trait to determine the console type. If the host is not managed by HMC, the console type of an IBMi VM deployed on the host shall be the slot number of its first virtual ethernet adapter. Otherwise, the Console type shall be \"HMC\". Signature @property def vea_as_ibmi_console(self): ... APITraits().vnet_aware Show source in traits.py:50 Indicates whether Virtual Networks are pre-reqs to Network changes. Some APIs (such as modifying the SEA or creating a Client Network Adapter) require that the VirtualNetwork (or VNet wrapper) be pre-created for the operation. This is typically done when working against an HMC. This trait will return True if the Virtual Networks need to be passed in on NetworkBridge or Client Network Adapter creation, or False if the API should directly work with VLANs and Virtual Switches. Signature @property def vnet_aware(self): ...","title":"Traits"},{"location":"pypowervm/traits/#traits","text":"Pypowervm Index / Pypowervm / Traits Auto-generated documentation for pypowervm.traits module. Traits APITraits APITraits().dynamic_pvid APITraits().has_high_slot APITraits().has_lpar_profiles APITraits().local_api APITraits().rmdev_job_available APITraits().session APITraits().vea_as_ibmi_console APITraits().vnet_aware","title":"Traits"},{"location":"pypowervm/traits/#apitraits","text":"Show source in traits.py:22 Represents capabilities inherent to the backing API server. For instance, depending on a schema version, or the backing REST server, there may be different code paths that the user needs to go through. A key example of this would be the VirtualNetworks. The HMC requires that Virtual Networks be the driver of code paths for various code paths. However, in other API servers, the Virtual Networks are simply realized based off the VLANs/virtual switches that adapters are currently tied to. This class encapsulates the various traits so that tasks and users do not have to inspect the header data directly to determine how the API should behave.","title":"APITraits"},{"location":"pypowervm/traits/#signature","text":"class APITraits(object): def __init__(self, session): ...","title":"Signature"},{"location":"pypowervm/traits/#apitraitsdynamic_pvid","text":"Show source in traits.py:89 Indicates whether a CNA can dynamically modify its PVID.","title":"APITraits().dynamic_pvid"},{"location":"pypowervm/traits/#signature_1","text":"@property def dynamic_pvid(self): ...","title":"Signature"},{"location":"pypowervm/traits/#apitraitshas_high_slot","text":"Show source in traits.py:99 Does the API support UseNextAvailableHighSlotID?","title":"APITraits().has_high_slot"},{"location":"pypowervm/traits/#signature_2","text":"@property def has_high_slot(self): ...","title":"Signature"},{"location":"pypowervm/traits/#apitraitshas_lpar_profiles","text":"Show source in traits.py:65 Indicates whether the platform manager supports LPAR profiles. This trait will return True if LPAR profiles are supported.","title":"APITraits().has_lpar_profiles"},{"location":"pypowervm/traits/#signature_3","text":"@property def has_lpar_profiles(self): ...","title":"Signature"},{"location":"pypowervm/traits/#apitraitslocal_api","text":"Show source in traits.py:73 Indicates whether or not the PowerVM API Server is running locally. The PowerVM API server in some deployments may be running co-located with the pypowervm API. In those cases, certain optimizations may be available (like uploading from a file instead of a pipe). This trait is a coarse check to determine, for certain, if the API is co-located on the same server.","title":"APITraits().local_api"},{"location":"pypowervm/traits/#signature_4","text":"@property def local_api(self): ...","title":"Signature"},{"location":"pypowervm/traits/#apitraitsrmdev_job_available","text":"Show source in traits.py:94 Indicates whether or not the Job API supports RMDev.","title":"APITraits().rmdev_job_available"},{"location":"pypowervm/traits/#signature_5","text":"@property def rmdev_job_available(self): ...","title":"Signature"},{"location":"pypowervm/traits/#apitraitssession","text":"Show source in traits.py:45","title":"APITraits().session"},{"location":"pypowervm/traits/#signature_6","text":"@property def session(self): ...","title":"Signature"},{"location":"pypowervm/traits/#apitraitsvea_as_ibmi_console","text":"Show source in traits.py:104 Indicates whether the console type of IBMi VM is vea. IBMi depends on the trait to determine the console type. If the host is not managed by HMC, the console type of an IBMi VM deployed on the host shall be the slot number of its first virtual ethernet adapter. Otherwise, the Console type shall be \"HMC\".","title":"APITraits().vea_as_ibmi_console"},{"location":"pypowervm/traits/#signature_7","text":"@property def vea_as_ibmi_console(self): ...","title":"Signature"},{"location":"pypowervm/traits/#apitraitsvnet_aware","text":"Show source in traits.py:50 Indicates whether Virtual Networks are pre-reqs to Network changes. Some APIs (such as modifying the SEA or creating a Client Network Adapter) require that the VirtualNetwork (or VNet wrapper) be pre-created for the operation. This is typically done when working against an HMC. This trait will return True if the Virtual Networks need to be passed in on NetworkBridge or Client Network Adapter creation, or False if the API should directly work with VLANs and Virtual Switches.","title":"APITraits().vnet_aware"},{"location":"pypowervm/traits/#signature_8","text":"@property def vnet_aware(self): ...","title":"Signature"},{"location":"pypowervm/util/","text":"Util Pypowervm Index / Pypowervm / Util Auto-generated documentation for pypowervm.util module. Attributes LOG - Set up logging: logging.getLogger(__name__) Util MACList MACList.sanitize_for_api VLANList VLANList.parse_val VLANList.sanitize_for_api check_and_apply_xag convert_bytes_to_gb dice_href extend_basepath find_equivalent find_wrapper get_req_path_uuid get_uuid_xag_from_path is_instance_path my_partition_id parent_spec part_id_by_loc_code retry_io_command round_gb_size_up sanitize_bool_for_api sanitize_file_name_for_api sanitize_float_for_api sanitize_mac_for_api sanitize_partition_name_for_api sanitize_percent_for_api sanitize_wwpn_for_api validate_certificate xag_attrs xpath MACList Show source in util.py:630 For REST fields of type AllowedMACAddresses.Union. Signature class MACList(_AllowedList): ... MACList.sanitize_for_api Show source in util.py:634 Signature @staticmethod def sanitize_for_api(val): ... VLANList Show source in util.py:614 For REST fields of type AllowedVLANIDs.Union. Signature class VLANList(_AllowedList): ... VLANList.parse_val Show source in util.py:616 Signature @staticmethod def parse_val(val): ... VLANList.sanitize_for_api Show source in util.py:620 Signature @staticmethod def sanitize_for_api(val): ... check_and_apply_xag Show source in util.py:79 Validate extended attribute groups and produce the correct path. If the existing path already has a group=* other than None, we use it. However, if there is a proposed xag - including [] - it must match the existing xag, or ValueError is raised. Otherwise, we construct the group=* query param according to the proposed xag list, as follows: If xag is None, use group=None. If xag is [] (the empty list), omit the group= query param entirely. Otherwise the group= value is a sorted, comma-separated string of the xag list. E.g. for xag=['b', 'c', 'a'], produce 'group=a,b,c'. Arguments path - Input path or href, which may or may not contain a query string, which may or may not contain a group= . (Multiple group= not handled.) Values in the group=* must be alpha sorted. xag - Iterable of proposed extended attribute values to be included in the query string of the resulting path. Returns path, with at most one group=* in the query string. That group= query param's value will be alpha sorted. Signature def check_and_apply_xag(path, xag): ... convert_bytes_to_gb Show source in util.py:261 Converts an integer of bytes to a decimal representation of gigabytes. If the value is too low, will return the 'low_value'. This is useful for converting a small number of bytes (ex. 50) into gigabytes. Rounding may be required. Arguments bytes_ - The integer number of bytes. low_value - The minimum value that should be returned. (Note: if dp is also specified, the value returned may be rounded up and thus be higher than low_value.) dp - If specified, the value is rounded up to the specified number of decimal places by round_gb_size_up. (Note: None and zero are very different.) Returns The decimal value. Signature def convert_bytes_to_gb(bytes_, low_value=0.0001, dp=None): ... dice_href Show source in util.py:47 Parse, sanitize, and reassemble an href. Arguments href - A full link string of the form ' :// / ; ? # '. This method also works if the :// is omitted, (but obviously include_scheme_netloc has no effect). include_scheme_netloc - If True, the :// portion is included in the returned string. If False, it is stripped. include_query - If True, any ? portion of the link will be included in the return value. include_fragment - If True, any # portion of the link will be included in the return value. Returns A string representing the specified portion of the input link. Signature def dice_href( href, include_scheme_netloc=False, include_query=True, include_fragment=True ): ... extend_basepath Show source in util.py:145 Extends the base path of an href, accounting for querystring/fragment. For example, extend_basepath('http://server:1234/foo?a=b&c=d#frag', '/bar') => 'http://server:1234/foo/bar?a=b&c=d#frag' Arguments href - Path or href to augment. Scheme, netloc, query string, and fragment are allowed but not required. add - String to add onto the base path of the href. Must not contain unescaped special characters such as '?', '&', '#'. Returns The augmented href. Signature def extend_basepath(href, add): ... find_equivalent Show source in util.py:407 Returns the element from the list that is equal to the one passed in. For remove operations and what not, the exact object may need to be provided. This method will find the functionally equivalent element from the list. Arguments elem - The original element. find_list - The list to search through. Returns An element from the that is functionally equivalent (based on eq ). If it does not exist, None is returned. Signature def find_equivalent(elem, find_list): ... find_wrapper Show source in util.py:425 Finds the corresponding wrapper from a list given the UUID. Arguments haystack - A list of wrappers. Usually generated from a 'feed' that has been loaded via the wrapper's wrap(response) method. needle_uuid - The UUID of the object to find in the list. Returns The corresponding wrapper for that UUID. If not found, None. Signature def find_wrapper(haystack, needle_uuid): ... get_req_path_uuid Show source in util.py:229 Extract request target uuid of sanitized path. Arguments path - Path or URI from which to extract the UUID. preserve_case - If False, the returned UUID will be lowercased. If True, it will be returned as it exists in the path. root - If True, and path represents a CHILD entry, the UUID of the ROOT is returned. Otherwise, the UUID of the target is returned. Signature def get_req_path_uuid(path, preserve_case=False, root=False): ... get_uuid_xag_from_path Show source in util.py:253 Signature def get_uuid_xag_from_path(path): ... is_instance_path Show source in util.py:163 Does the path or href represent an instance (end with UUID)? Arguments href - Path or href to check. Scheme, netloc, query string, and fragment are allowed but not required. Returns True if href's path ends with a UUID, indicating that it represents an instance (as opposed to a Feed or some special URI such as quick or search). Signature def is_instance_path(href): ... my_partition_id Show source in util.py:469 Return the short ID (not UUID) of the current partition, as an int. Signature def my_partition_id(): ... parent_spec Show source in util.py:477 Produce a canonical parent type and UUID suitable for read(). Arguments parent - EntryWrapper representing the parent. If specified, parent_type and parent_uuid are ignored. parent_type - EntryWrapper class or schema_type string representing the schema type of the parent. parent_uuid - String UUID of the parent. Returns Type: parent_type String schema type of the parent. The parent_type and parent_uuid returns are both None or both valid strings. Type: parent_uuid String UUID of the parent. The parent_type and parent_uuid returns are both None or both valid strings. Raises ValueError - If parent is None and parent_type xor parent_uuid is specified. Signature def parent_spec(parent, parent_type, parent_uuid): ... part_id_by_loc_code Show source in util.py:444 Get a partition short ID for a provided virtual device location code. All location codes on a virtual device are of the form: . . -V -C Returns An int of the associated partition short ID. Signature def part_id_by_loc_code(loc_code): ... retry_io_command Show source in util.py:510 PEP475: Retry syscalls if EINTR signal received. https://www.python.org/dev/peps/pep-0475/ Certain system calls can be interrupted by signal 4 (EINTR) for no good reason. Per PEP475, these signals should be ignored. This is implemented by default at the lowest level in py3, but we have to account for it in py2. Arguments base_cmd - The syscall to wrap. argv - Arguments to the syscall. Returns The return value from invoking the syscall. Signature def retry_io_command(base_cmd, *argv): ... round_gb_size_up Show source in util.py:285 Rounds a GB disk size (as a decimal float) up to suit the platform. Use this method to ensure that new vdisks, LUs, etc. are big enough, as the platform generally rounds inputs to the nearest [whatever]. For example, a disk of size 4.321GB may wind up at 4.32GB after rounding, possibly leaving insufficient space for the image. Arguments gb_size - A decimal float representing the GB size to be rounded. dp - The number of decimal places to round (up) to. May be zero (round to next highest integer) or negative, (e.g. -1 will round to the next highest ten). Returns A new decimal float which is greater than or equal to the input. Signature def round_gb_size_up(gb_size, dp=2): ... sanitize_bool_for_api Show source in util.py:314 Sanitizes a boolean value for use in the API. Signature def sanitize_bool_for_api(bool_val): ... sanitize_file_name_for_api Show source in util.py:349 Generate a sanitized file name based on PowerVM's FileName.Pattern. Arguments name - The base name to sanitize. prefix - (Optional) A prefix to prepend to the 'name'. No delimiter is added. suffix - (Optional) A suffix to append to the 'name'. No delimiter is added. max_len - (Optional) The maximum allowable length of the final sanitized string. Defaults to the API's defined length for FileName.Pattern. Returns A string scrubbed of all forbidden characters and trimmed for length as necessary. Signature def sanitize_file_name_for_api( name, prefix=\"\", suffix=\"\", max_len=const.MaxLen.FILENAME_DEFAULT ): ... sanitize_float_for_api Show source in util.py:319 Sanitizes a float value for use in the API. Signature def sanitize_float_for_api(float_val, precision=2): ... sanitize_mac_for_api Show source in util.py:302 Converts a generalized mac address to one for the API. Takes any standard mac (case-insensitive, with or without colons) and formats it to uppercase and removes colons. This is the format for the API. Arguments mac - The input mac. Returns The sanitized mac. Signature def sanitize_mac_for_api(mac): ... sanitize_partition_name_for_api Show source in util.py:380 Sanitize a string to be suitable for use as a partition name. PowerVM's partition name restrictions are: - Between 1 and 31 characters, inclusive; - Containing ASCII characters between 0x20 (space) and 0x7E (~), inclusive, except r()\\<>*$&?|[]'\"` Arguments name - The name to scrub. Invalid characters will be replaced with '_'. trunc_ok - If True, and name exceeds 31 characters, it is truncated. If False, and name exceeds 31 characters, ValueError is raised. Returns The scrubbed string. Raises ValueError - If name is None or zero length; or if it exceeds length 31 and trunk_ok=False. Signature def sanitize_partition_name_for_api(name, trunc_ok=True): ... sanitize_percent_for_api Show source in util.py:325 Sanitizes a percent value for use in the API. Arguments float_val - A float where valid values are 0.0 <= x <= 1.0. For example the input 0.02 will produce output '2%'. Returns A string representation of the passed percentage. Signature def sanitize_percent_for_api(float_val, precision=2): ... sanitize_wwpn_for_api Show source in util.py:340 Updates the format of the WWPN to match the expected PowerVM format. Arguments wwpn - The original WWPN. Returns A WWPN of the format expected by the API. Signature def sanitize_wwpn_for_api(wwpn): ... validate_certificate Show source in util.py:179 Signature def validate_certificate(host, port, certpath, certext): ... xag_attrs Show source in util.py:456 Produce XML attributes for a property using extended attribute groups. Arguments xagstr - Extended attribute group name (from pypowervm.const.XAG). base - The dict of attributes to which to add the extended attribute group. Usually one of the pypowervm.const values near DEFAULT_SCHEMA_ATTR (the default). Returns Dict of XML attributes suitable for the 'attrib' kwarg of a (pypowervm.entities or etree) Element constructor. Signature def xag_attrs(xagstr, base=const.DEFAULT_SCHEMA_ATTR): ... xpath Show source in util.py:439 Constructs an XPath out of the passed-in string components. Signature def xpath(*toks): ...","title":"Util"},{"location":"pypowervm/util/#util","text":"Pypowervm Index / Pypowervm / Util Auto-generated documentation for pypowervm.util module.","title":"Util"},{"location":"pypowervm/util/#attributes","text":"LOG - Set up logging: logging.getLogger(__name__) Util MACList MACList.sanitize_for_api VLANList VLANList.parse_val VLANList.sanitize_for_api check_and_apply_xag convert_bytes_to_gb dice_href extend_basepath find_equivalent find_wrapper get_req_path_uuid get_uuid_xag_from_path is_instance_path my_partition_id parent_spec part_id_by_loc_code retry_io_command round_gb_size_up sanitize_bool_for_api sanitize_file_name_for_api sanitize_float_for_api sanitize_mac_for_api sanitize_partition_name_for_api sanitize_percent_for_api sanitize_wwpn_for_api validate_certificate xag_attrs xpath","title":"Attributes"},{"location":"pypowervm/util/#maclist","text":"Show source in util.py:630 For REST fields of type AllowedMACAddresses.Union.","title":"MACList"},{"location":"pypowervm/util/#signature","text":"class MACList(_AllowedList): ...","title":"Signature"},{"location":"pypowervm/util/#maclistsanitize_for_api","text":"Show source in util.py:634","title":"MACList.sanitize_for_api"},{"location":"pypowervm/util/#signature_1","text":"@staticmethod def sanitize_for_api(val): ...","title":"Signature"},{"location":"pypowervm/util/#vlanlist","text":"Show source in util.py:614 For REST fields of type AllowedVLANIDs.Union.","title":"VLANList"},{"location":"pypowervm/util/#signature_2","text":"class VLANList(_AllowedList): ...","title":"Signature"},{"location":"pypowervm/util/#vlanlistparse_val","text":"Show source in util.py:616","title":"VLANList.parse_val"},{"location":"pypowervm/util/#signature_3","text":"@staticmethod def parse_val(val): ...","title":"Signature"},{"location":"pypowervm/util/#vlanlistsanitize_for_api","text":"Show source in util.py:620","title":"VLANList.sanitize_for_api"},{"location":"pypowervm/util/#signature_4","text":"@staticmethod def sanitize_for_api(val): ...","title":"Signature"},{"location":"pypowervm/util/#check_and_apply_xag","text":"Show source in util.py:79 Validate extended attribute groups and produce the correct path. If the existing path already has a group=* other than None, we use it. However, if there is a proposed xag - including [] - it must match the existing xag, or ValueError is raised. Otherwise, we construct the group=* query param according to the proposed xag list, as follows: If xag is None, use group=None. If xag is [] (the empty list), omit the group= query param entirely. Otherwise the group= value is a sorted, comma-separated string of the xag list. E.g. for xag=['b', 'c', 'a'], produce 'group=a,b,c'.","title":"check_and_apply_xag"},{"location":"pypowervm/util/#arguments","text":"path - Input path or href, which may or may not contain a query string, which may or may not contain a group= . (Multiple group= not handled.) Values in the group=* must be alpha sorted. xag - Iterable of proposed extended attribute values to be included in the query string of the resulting path.","title":"Arguments"},{"location":"pypowervm/util/#returns","text":"path, with at most one group=* in the query string. That group= query param's value will be alpha sorted.","title":"Returns"},{"location":"pypowervm/util/#signature_5","text":"def check_and_apply_xag(path, xag): ...","title":"Signature"},{"location":"pypowervm/util/#convert_bytes_to_gb","text":"Show source in util.py:261 Converts an integer of bytes to a decimal representation of gigabytes. If the value is too low, will return the 'low_value'. This is useful for converting a small number of bytes (ex. 50) into gigabytes. Rounding may be required.","title":"convert_bytes_to_gb"},{"location":"pypowervm/util/#arguments_1","text":"bytes_ - The integer number of bytes. low_value - The minimum value that should be returned. (Note: if dp is also specified, the value returned may be rounded up and thus be higher than low_value.) dp - If specified, the value is rounded up to the specified number of decimal places by round_gb_size_up. (Note: None and zero are very different.)","title":"Arguments"},{"location":"pypowervm/util/#returns_1","text":"The decimal value.","title":"Returns"},{"location":"pypowervm/util/#signature_6","text":"def convert_bytes_to_gb(bytes_, low_value=0.0001, dp=None): ...","title":"Signature"},{"location":"pypowervm/util/#dice_href","text":"Show source in util.py:47 Parse, sanitize, and reassemble an href.","title":"dice_href"},{"location":"pypowervm/util/#arguments_2","text":"href - A full link string of the form ' :// / ; ? # '. This method also works if the :// is omitted, (but obviously include_scheme_netloc has no effect). include_scheme_netloc - If True, the :// portion is included in the returned string. If False, it is stripped. include_query - If True, any ? portion of the link will be included in the return value. include_fragment - If True, any # portion of the link will be included in the return value.","title":"Arguments"},{"location":"pypowervm/util/#returns_2","text":"A string representing the specified portion of the input link.","title":"Returns"},{"location":"pypowervm/util/#signature_7","text":"def dice_href( href, include_scheme_netloc=False, include_query=True, include_fragment=True ): ...","title":"Signature"},{"location":"pypowervm/util/#extend_basepath","text":"Show source in util.py:145 Extends the base path of an href, accounting for querystring/fragment. For example, extend_basepath('http://server:1234/foo?a=b&c=d#frag', '/bar') => 'http://server:1234/foo/bar?a=b&c=d#frag'","title":"extend_basepath"},{"location":"pypowervm/util/#arguments_3","text":"href - Path or href to augment. Scheme, netloc, query string, and fragment are allowed but not required. add - String to add onto the base path of the href. Must not contain unescaped special characters such as '?', '&', '#'.","title":"Arguments"},{"location":"pypowervm/util/#returns_3","text":"The augmented href.","title":"Returns"},{"location":"pypowervm/util/#signature_8","text":"def extend_basepath(href, add): ...","title":"Signature"},{"location":"pypowervm/util/#find_equivalent","text":"Show source in util.py:407 Returns the element from the list that is equal to the one passed in. For remove operations and what not, the exact object may need to be provided. This method will find the functionally equivalent element from the list.","title":"find_equivalent"},{"location":"pypowervm/util/#arguments_4","text":"elem - The original element. find_list - The list to search through.","title":"Arguments"},{"location":"pypowervm/util/#returns_4","text":"An element from the that is functionally equivalent (based on eq ). If it does not exist, None is returned.","title":"Returns"},{"location":"pypowervm/util/#signature_9","text":"def find_equivalent(elem, find_list): ...","title":"Signature"},{"location":"pypowervm/util/#find_wrapper","text":"Show source in util.py:425 Finds the corresponding wrapper from a list given the UUID.","title":"find_wrapper"},{"location":"pypowervm/util/#arguments_5","text":"haystack - A list of wrappers. Usually generated from a 'feed' that has been loaded via the wrapper's wrap(response) method. needle_uuid - The UUID of the object to find in the list.","title":"Arguments"},{"location":"pypowervm/util/#returns_5","text":"The corresponding wrapper for that UUID. If not found, None.","title":"Returns"},{"location":"pypowervm/util/#signature_10","text":"def find_wrapper(haystack, needle_uuid): ...","title":"Signature"},{"location":"pypowervm/util/#get_req_path_uuid","text":"Show source in util.py:229 Extract request target uuid of sanitized path.","title":"get_req_path_uuid"},{"location":"pypowervm/util/#arguments_6","text":"path - Path or URI from which to extract the UUID. preserve_case - If False, the returned UUID will be lowercased. If True, it will be returned as it exists in the path. root - If True, and path represents a CHILD entry, the UUID of the ROOT is returned. Otherwise, the UUID of the target is returned.","title":"Arguments"},{"location":"pypowervm/util/#signature_11","text":"def get_req_path_uuid(path, preserve_case=False, root=False): ...","title":"Signature"},{"location":"pypowervm/util/#get_uuid_xag_from_path","text":"Show source in util.py:253","title":"get_uuid_xag_from_path"},{"location":"pypowervm/util/#signature_12","text":"def get_uuid_xag_from_path(path): ...","title":"Signature"},{"location":"pypowervm/util/#is_instance_path","text":"Show source in util.py:163 Does the path or href represent an instance (end with UUID)?","title":"is_instance_path"},{"location":"pypowervm/util/#arguments_7","text":"href - Path or href to check. Scheme, netloc, query string, and fragment are allowed but not required.","title":"Arguments"},{"location":"pypowervm/util/#returns_6","text":"True if href's path ends with a UUID, indicating that it represents an instance (as opposed to a Feed or some special URI such as quick or search).","title":"Returns"},{"location":"pypowervm/util/#signature_13","text":"def is_instance_path(href): ...","title":"Signature"},{"location":"pypowervm/util/#my_partition_id","text":"Show source in util.py:469 Return the short ID (not UUID) of the current partition, as an int.","title":"my_partition_id"},{"location":"pypowervm/util/#signature_14","text":"def my_partition_id(): ...","title":"Signature"},{"location":"pypowervm/util/#parent_spec","text":"Show source in util.py:477 Produce a canonical parent type and UUID suitable for read().","title":"parent_spec"},{"location":"pypowervm/util/#arguments_8","text":"parent - EntryWrapper representing the parent. If specified, parent_type and parent_uuid are ignored. parent_type - EntryWrapper class or schema_type string representing the schema type of the parent. parent_uuid - String UUID of the parent.","title":"Arguments"},{"location":"pypowervm/util/#returns_7","text":"Type: parent_type String schema type of the parent. The parent_type and parent_uuid returns are both None or both valid strings. Type: parent_uuid String UUID of the parent. The parent_type and parent_uuid returns are both None or both valid strings.","title":"Returns"},{"location":"pypowervm/util/#raises","text":"ValueError - If parent is None and parent_type xor parent_uuid is specified.","title":"Raises"},{"location":"pypowervm/util/#signature_15","text":"def parent_spec(parent, parent_type, parent_uuid): ...","title":"Signature"},{"location":"pypowervm/util/#part_id_by_loc_code","text":"Show source in util.py:444 Get a partition short ID for a provided virtual device location code. All location codes on a virtual device are of the form: . . -V -C","title":"part_id_by_loc_code"},{"location":"pypowervm/util/#returns_8","text":"An int of the associated partition short ID.","title":"Returns"},{"location":"pypowervm/util/#signature_16","text":"def part_id_by_loc_code(loc_code): ...","title":"Signature"},{"location":"pypowervm/util/#retry_io_command","text":"Show source in util.py:510 PEP475: Retry syscalls if EINTR signal received. https://www.python.org/dev/peps/pep-0475/ Certain system calls can be interrupted by signal 4 (EINTR) for no good reason. Per PEP475, these signals should be ignored. This is implemented by default at the lowest level in py3, but we have to account for it in py2.","title":"retry_io_command"},{"location":"pypowervm/util/#arguments_9","text":"base_cmd - The syscall to wrap. argv - Arguments to the syscall.","title":"Arguments"},{"location":"pypowervm/util/#returns_9","text":"The return value from invoking the syscall.","title":"Returns"},{"location":"pypowervm/util/#signature_17","text":"def retry_io_command(base_cmd, *argv): ...","title":"Signature"},{"location":"pypowervm/util/#round_gb_size_up","text":"Show source in util.py:285 Rounds a GB disk size (as a decimal float) up to suit the platform. Use this method to ensure that new vdisks, LUs, etc. are big enough, as the platform generally rounds inputs to the nearest [whatever]. For example, a disk of size 4.321GB may wind up at 4.32GB after rounding, possibly leaving insufficient space for the image.","title":"round_gb_size_up"},{"location":"pypowervm/util/#arguments_10","text":"gb_size - A decimal float representing the GB size to be rounded. dp - The number of decimal places to round (up) to. May be zero (round to next highest integer) or negative, (e.g. -1 will round to the next highest ten).","title":"Arguments"},{"location":"pypowervm/util/#returns_10","text":"A new decimal float which is greater than or equal to the input.","title":"Returns"},{"location":"pypowervm/util/#signature_18","text":"def round_gb_size_up(gb_size, dp=2): ...","title":"Signature"},{"location":"pypowervm/util/#sanitize_bool_for_api","text":"Show source in util.py:314 Sanitizes a boolean value for use in the API.","title":"sanitize_bool_for_api"},{"location":"pypowervm/util/#signature_19","text":"def sanitize_bool_for_api(bool_val): ...","title":"Signature"},{"location":"pypowervm/util/#sanitize_file_name_for_api","text":"Show source in util.py:349 Generate a sanitized file name based on PowerVM's FileName.Pattern.","title":"sanitize_file_name_for_api"},{"location":"pypowervm/util/#arguments_11","text":"name - The base name to sanitize. prefix - (Optional) A prefix to prepend to the 'name'. No delimiter is added. suffix - (Optional) A suffix to append to the 'name'. No delimiter is added. max_len - (Optional) The maximum allowable length of the final sanitized string. Defaults to the API's defined length for FileName.Pattern.","title":"Arguments"},{"location":"pypowervm/util/#returns_11","text":"A string scrubbed of all forbidden characters and trimmed for length as necessary.","title":"Returns"},{"location":"pypowervm/util/#signature_20","text":"def sanitize_file_name_for_api( name, prefix=\"\", suffix=\"\", max_len=const.MaxLen.FILENAME_DEFAULT ): ...","title":"Signature"},{"location":"pypowervm/util/#sanitize_float_for_api","text":"Show source in util.py:319 Sanitizes a float value for use in the API.","title":"sanitize_float_for_api"},{"location":"pypowervm/util/#signature_21","text":"def sanitize_float_for_api(float_val, precision=2): ...","title":"Signature"},{"location":"pypowervm/util/#sanitize_mac_for_api","text":"Show source in util.py:302 Converts a generalized mac address to one for the API. Takes any standard mac (case-insensitive, with or without colons) and formats it to uppercase and removes colons. This is the format for the API.","title":"sanitize_mac_for_api"},{"location":"pypowervm/util/#arguments_12","text":"mac - The input mac.","title":"Arguments"},{"location":"pypowervm/util/#returns_12","text":"The sanitized mac.","title":"Returns"},{"location":"pypowervm/util/#signature_22","text":"def sanitize_mac_for_api(mac): ...","title":"Signature"},{"location":"pypowervm/util/#sanitize_partition_name_for_api","text":"Show source in util.py:380 Sanitize a string to be suitable for use as a partition name. PowerVM's partition name restrictions are: - Between 1 and 31 characters, inclusive; - Containing ASCII characters between 0x20 (space) and 0x7E (~), inclusive, except r()\\<>*$&?|[]'\"`","title":"sanitize_partition_name_for_api"},{"location":"pypowervm/util/#arguments_13","text":"name - The name to scrub. Invalid characters will be replaced with '_'. trunc_ok - If True, and name exceeds 31 characters, it is truncated. If False, and name exceeds 31 characters, ValueError is raised.","title":"Arguments"},{"location":"pypowervm/util/#returns_13","text":"The scrubbed string.","title":"Returns"},{"location":"pypowervm/util/#raises_1","text":"ValueError - If name is None or zero length; or if it exceeds length 31 and trunk_ok=False.","title":"Raises"},{"location":"pypowervm/util/#signature_23","text":"def sanitize_partition_name_for_api(name, trunc_ok=True): ...","title":"Signature"},{"location":"pypowervm/util/#sanitize_percent_for_api","text":"Show source in util.py:325 Sanitizes a percent value for use in the API.","title":"sanitize_percent_for_api"},{"location":"pypowervm/util/#arguments_14","text":"float_val - A float where valid values are 0.0 <= x <= 1.0. For example the input 0.02 will produce output '2%'.","title":"Arguments"},{"location":"pypowervm/util/#returns_14","text":"A string representation of the passed percentage.","title":"Returns"},{"location":"pypowervm/util/#signature_24","text":"def sanitize_percent_for_api(float_val, precision=2): ...","title":"Signature"},{"location":"pypowervm/util/#sanitize_wwpn_for_api","text":"Show source in util.py:340 Updates the format of the WWPN to match the expected PowerVM format.","title":"sanitize_wwpn_for_api"},{"location":"pypowervm/util/#arguments_15","text":"wwpn - The original WWPN.","title":"Arguments"},{"location":"pypowervm/util/#returns_15","text":"A WWPN of the format expected by the API.","title":"Returns"},{"location":"pypowervm/util/#signature_25","text":"def sanitize_wwpn_for_api(wwpn): ...","title":"Signature"},{"location":"pypowervm/util/#validate_certificate","text":"Show source in util.py:179","title":"validate_certificate"},{"location":"pypowervm/util/#signature_26","text":"def validate_certificate(host, port, certpath, certext): ...","title":"Signature"},{"location":"pypowervm/util/#xag_attrs","text":"Show source in util.py:456 Produce XML attributes for a property using extended attribute groups.","title":"xag_attrs"},{"location":"pypowervm/util/#arguments_16","text":"xagstr - Extended attribute group name (from pypowervm.const.XAG). base - The dict of attributes to which to add the extended attribute group. Usually one of the pypowervm.const values near DEFAULT_SCHEMA_ATTR (the default).","title":"Arguments"},{"location":"pypowervm/util/#returns_16","text":"Dict of XML attributes suitable for the 'attrib' kwarg of a (pypowervm.entities or etree) Element constructor.","title":"Returns"},{"location":"pypowervm/util/#signature_27","text":"def xag_attrs(xagstr, base=const.DEFAULT_SCHEMA_ATTR): ...","title":"Signature"},{"location":"pypowervm/util/#xpath","text":"Show source in util.py:439 Constructs an XPath out of the passed-in string components.","title":"xpath"},{"location":"pypowervm/util/#signature_28","text":"def xpath(*toks): ...","title":"Signature"},{"location":"pypowervm/hacking/","text":"Hacking Pypowervm Index / Pypowervm / Hacking Auto-generated documentation for pypowervm.hacking module. Hacking Modules Modules Checks","title":"Hacking"},{"location":"pypowervm/hacking/#hacking","text":"Pypowervm Index / Pypowervm / Hacking Auto-generated documentation for pypowervm.hacking module. Hacking Modules","title":"Hacking"},{"location":"pypowervm/hacking/#modules","text":"Checks","title":"Modules"},{"location":"pypowervm/hacking/checks/","text":"Checks Pypowervm Index / Pypowervm / Hacking / Checks Auto-generated documentation for pypowervm.hacking.checks module. Checks factory no_log_warn factory Show source in checks.py:26 Signature def factory(register): ... no_log_warn Show source in checks.py:18 Disallow 'LOG.warn(' Signature def no_log_warn(logical_line, filename): ...","title":"Checks"},{"location":"pypowervm/hacking/checks/#checks","text":"Pypowervm Index / Pypowervm / Hacking / Checks Auto-generated documentation for pypowervm.hacking.checks module. Checks factory no_log_warn","title":"Checks"},{"location":"pypowervm/hacking/checks/#factory","text":"Show source in checks.py:26","title":"factory"},{"location":"pypowervm/hacking/checks/#signature","text":"def factory(register): ...","title":"Signature"},{"location":"pypowervm/hacking/checks/#no_log_warn","text":"Show source in checks.py:18 Disallow 'LOG.warn('","title":"no_log_warn"},{"location":"pypowervm/hacking/checks/#signature_1","text":"def no_log_warn(logical_line, filename): ...","title":"Signature"},{"location":"pypowervm/helpers/","text":"Helpers Pypowervm Index / Pypowervm / Helpers Auto-generated documentation for pypowervm.helpers module. Helpers Modules Modules Log Helper Sample Helper Vios Busy","title":"Helpers"},{"location":"pypowervm/helpers/#helpers","text":"Pypowervm Index / Pypowervm / Helpers Auto-generated documentation for pypowervm.helpers module. Helpers Modules","title":"Helpers"},{"location":"pypowervm/helpers/#modules","text":"Log Helper Sample Helper Vios Busy","title":"Modules"},{"location":"pypowervm/helpers/log_helper/","text":"Log Helper Pypowervm Index / Pypowervm / Helpers / Log Helper Auto-generated documentation for pypowervm.helpers.log_helper module. Log Helper log_helper log_helper Show source in log_helper.py:123 Log recent requests/responses on exception. This helper stashes the requests/responses it sees passing through to thread local storage. If it then sees an exception surfacing, it will write the req/resp logs. Arguments func - The Adapter request method to call :param max_logs (int): Max number of req/resps to retain at a time This value can only be set once per thread. Once it's set, subsequent calls will ignore the value. Signature def log_helper(func, max_logs=3): ...","title":"Log Helper"},{"location":"pypowervm/helpers/log_helper/#log-helper","text":"Pypowervm Index / Pypowervm / Helpers / Log Helper Auto-generated documentation for pypowervm.helpers.log_helper module. Log Helper log_helper","title":"Log Helper"},{"location":"pypowervm/helpers/log_helper/#log_helper","text":"Show source in log_helper.py:123 Log recent requests/responses on exception. This helper stashes the requests/responses it sees passing through to thread local storage. If it then sees an exception surfacing, it will write the req/resp logs.","title":"log_helper"},{"location":"pypowervm/helpers/log_helper/#arguments","text":"func - The Adapter request method to call :param max_logs (int): Max number of req/resps to retain at a time This value can only be set once per thread. Once it's set, subsequent calls will ignore the value.","title":"Arguments"},{"location":"pypowervm/helpers/log_helper/#signature","text":"def log_helper(func, max_logs=3): ...","title":"Signature"},{"location":"pypowervm/helpers/sample_helper/","text":"Sample Helper Pypowervm Index / Pypowervm / Helpers / Sample Helper Auto-generated documentation for pypowervm.helpers.sample_helper module. Sample Helper sample_retry_helper sample_retry_helper Show source in sample_helper.py:31 This helper retries the request if the resource is busy. Arguments func - The Adapter request method to call max_logs int - Max number retries. Signature def sample_retry_helper(func, max_retries=1): ...","title":"Sample Helper"},{"location":"pypowervm/helpers/sample_helper/#sample-helper","text":"Pypowervm Index / Pypowervm / Helpers / Sample Helper Auto-generated documentation for pypowervm.helpers.sample_helper module. Sample Helper sample_retry_helper","title":"Sample Helper"},{"location":"pypowervm/helpers/sample_helper/#sample_retry_helper","text":"Show source in sample_helper.py:31 This helper retries the request if the resource is busy.","title":"sample_retry_helper"},{"location":"pypowervm/helpers/sample_helper/#arguments","text":"func - The Adapter request method to call max_logs int - Max number retries.","title":"Arguments"},{"location":"pypowervm/helpers/sample_helper/#signature","text":"def sample_retry_helper(func, max_retries=1): ...","title":"Signature"},{"location":"pypowervm/helpers/vios_busy/","text":"Vios Busy Pypowervm Index / Pypowervm / Helpers / Vios Busy Auto-generated documentation for pypowervm.helpers.vios_busy module. Attributes SLEEP - Make UT a little easier: time.sleep Vios Busy vios_busy_retry_helper vios_busy_retry_helper Show source in vios_busy.py:35 This helper retries the request if the resource is busy. Arguments func - The Adapter request method to call max_retries int - Max number retries. Signature def vios_busy_retry_helper(func, max_retries=3, delay=5): ...","title":"Vios Busy"},{"location":"pypowervm/helpers/vios_busy/#vios-busy","text":"Pypowervm Index / Pypowervm / Helpers / Vios Busy Auto-generated documentation for pypowervm.helpers.vios_busy module.","title":"Vios Busy"},{"location":"pypowervm/helpers/vios_busy/#attributes","text":"SLEEP - Make UT a little easier: time.sleep Vios Busy vios_busy_retry_helper","title":"Attributes"},{"location":"pypowervm/helpers/vios_busy/#vios_busy_retry_helper","text":"Show source in vios_busy.py:35 This helper retries the request if the resource is busy.","title":"vios_busy_retry_helper"},{"location":"pypowervm/helpers/vios_busy/#arguments","text":"func - The Adapter request method to call max_retries int - Max number retries.","title":"Arguments"},{"location":"pypowervm/helpers/vios_busy/#signature","text":"def vios_busy_retry_helper(func, max_retries=3, delay=5): ...","title":"Signature"},{"location":"pypowervm/tasks/","text":"Tasks Pypowervm Index / Pypowervm / Tasks Auto-generated documentation for pypowervm.tasks module. Tasks Modules Modules Client Storage Cluster Ssp Cna Hdisk Ibmi Management Console MasterMode Memory Migration Monitor NetworkBridger Partition Power Power Opts Scsi Mapper Slot Map Sriov Storage Vfc Mapper Vopt Vterm","title":"Tasks"},{"location":"pypowervm/tasks/#tasks","text":"Pypowervm Index / Pypowervm / Tasks Auto-generated documentation for pypowervm.tasks module. Tasks Modules","title":"Tasks"},{"location":"pypowervm/tasks/#modules","text":"Client Storage Cluster Ssp Cna Hdisk Ibmi Management Console MasterMode Memory Migration Monitor NetworkBridger Partition Power Power Opts Scsi Mapper Slot Map Sriov Storage Vfc Mapper Vopt Vterm","title":"Modules"},{"location":"pypowervm/tasks/client_storage/","text":"Client Storage Pypowervm Index / Pypowervm / Tasks / Client Storage Auto-generated documentation for pypowervm.tasks.client_storage module. Client Storage c_wwpn_to_vfc_mapping udid_to_scsi_mapping c_wwpn_to_vfc_mapping Show source in client_storage.py:56 Finds the vFC mapping (if any) for a given client WWPN. This is a helper method that will parse through a given VIOS wrapper (retrieved with pypowervm.const.XAG.VIO_FMAP) and will find the client vFC mapping for that WWPN. Arguments vios_w - The Virtual I/O Server wrapper. Should have pypowervm.const.XAG.VIO_FMAP associated with it. c_wwpn - One of the client's WWPNs. Returns The vFC mapping (or None) Signature def c_wwpn_to_vfc_mapping(vios_w, c_wwpn): ... udid_to_scsi_mapping Show source in client_storage.py:20 Finds the SCSI mapping (if any) for a given backing storage udid. This is a helper method that will parse through a given VIOS wrapper (retrieved with pypowervm.const.XAG.VIO_SMAP) and will find the client SCSI mapping for a given backing storage element (LU, PV, LV, VOpt). Arguments vios_w - The Virtual I/O Server wrapper. Should have the Storage and SCSI mapping XAG associated with it. udid - The volume's udid. lpar_id - The LPARs 'short' id. ignore_orphan - (Optional, Default: True) If set to True, any orphan SCSI mappings (those with no client adapter) will be ignored. Returns The first matching SCSI mapping (or None). Signature def udid_to_scsi_mapping(vios_w, udid, lpar_id, ignore_orphan=True): ...","title":"Client Storage"},{"location":"pypowervm/tasks/client_storage/#client-storage","text":"Pypowervm Index / Pypowervm / Tasks / Client Storage Auto-generated documentation for pypowervm.tasks.client_storage module. Client Storage c_wwpn_to_vfc_mapping udid_to_scsi_mapping","title":"Client Storage"},{"location":"pypowervm/tasks/client_storage/#c_wwpn_to_vfc_mapping","text":"Show source in client_storage.py:56 Finds the vFC mapping (if any) for a given client WWPN. This is a helper method that will parse through a given VIOS wrapper (retrieved with pypowervm.const.XAG.VIO_FMAP) and will find the client vFC mapping for that WWPN.","title":"c_wwpn_to_vfc_mapping"},{"location":"pypowervm/tasks/client_storage/#arguments","text":"vios_w - The Virtual I/O Server wrapper. Should have pypowervm.const.XAG.VIO_FMAP associated with it. c_wwpn - One of the client's WWPNs.","title":"Arguments"},{"location":"pypowervm/tasks/client_storage/#returns","text":"The vFC mapping (or None)","title":"Returns"},{"location":"pypowervm/tasks/client_storage/#signature","text":"def c_wwpn_to_vfc_mapping(vios_w, c_wwpn): ...","title":"Signature"},{"location":"pypowervm/tasks/client_storage/#udid_to_scsi_mapping","text":"Show source in client_storage.py:20 Finds the SCSI mapping (if any) for a given backing storage udid. This is a helper method that will parse through a given VIOS wrapper (retrieved with pypowervm.const.XAG.VIO_SMAP) and will find the client SCSI mapping for a given backing storage element (LU, PV, LV, VOpt).","title":"udid_to_scsi_mapping"},{"location":"pypowervm/tasks/client_storage/#arguments_1","text":"vios_w - The Virtual I/O Server wrapper. Should have the Storage and SCSI mapping XAG associated with it. udid - The volume's udid. lpar_id - The LPARs 'short' id. ignore_orphan - (Optional, Default: True) If set to True, any orphan SCSI mappings (those with no client adapter) will be ignored.","title":"Arguments"},{"location":"pypowervm/tasks/client_storage/#returns_1","text":"The first matching SCSI mapping (or None).","title":"Returns"},{"location":"pypowervm/tasks/client_storage/#signature_1","text":"def udid_to_scsi_mapping(vios_w, udid, lpar_id, ignore_orphan=True): ...","title":"Signature"},{"location":"pypowervm/tasks/cluster_ssp/","text":"Cluster Ssp Pypowervm Index / Pypowervm / Tasks / Cluster Ssp Auto-generated documentation for pypowervm.tasks.cluster_ssp module. Cluster Ssp crt_cluster_ssp get_or_upload_image_lu crt_cluster_ssp Show source in cluster_ssp.py:40 Creates a Cluster/SharedStoragePool via the ClusterCreate Job. The Job takes two parameters: clusterXml and sspXml. Arguments clust_name - String name for the Cluster. ssp_name - String name for the SharedStoragePool. repos_pv - storage.PV representing the repository hdisk. The name and udid properties must be specified. first_node - cluster.Node representing the initial VIOS in the cluster. (Cluster creation must be done with a single node; other nodes may be added later.) The Node wrapper must contain either - mtms, lpar_id, AND hostname; or - vios_uri The indicated node must be able to see each disk. data_pv_list - Iterable of storage.PV instances to use as the data volume(s) for the SharedStoragePool. Signature def crt_cluster_ssp(clust_name, ssp_name, repos_pv, first_node, data_pv_list): ... get_or_upload_image_lu Show source in cluster_ssp.py:155 Ensures our SSP has an LU containing the specified image. If an LU of type IMAGE with the specified luname already exists in our SSP, return it. Otherwise, create it, prime it with the image contents provided via stream_func, and return it. This method assumes that consumers employ a naming convention such that an LU with a given name represents the same data (size and content) no matter where/when it's created/uploaded - for example, by including the image's MD5 checksum in the name. This method is designed to coordinate the upload of a particular image LU across multiple hosts which use the same SSP, but otherwise can not communicate with each other. Arguments tier - Tier EntryWrapper of the Shared Storage Pool Tier on which the image LU is to be hosted. luname - The name of the image LU. Note that the name may be shortened to satisfy length restrictions. vios_uuid - The UUID of the Virtual I/O Server through which the upload should be performed, if necessary. io_handle - The I/O handle (as defined by the upload_type). This is only used if the image_lu needs to be uploaded. b_size - Integer size, in bytes, of the image provided by stream_func's return value. upload_type - (Optional, Default: IO_STREAM_BUILDER) Defines the way in which the LU should be uploaded. Refer to the UploadType enumeration for valid upload mechanisms. It defaults to IO_STREAM_BUILDER for legacy reasons. Returns LUEnt EntryWrapper representing the image LU. Signature def get_or_upload_image_lu( tier, luname, vios_uuid, io_handle, b_size, upload_type=tsk_stg.UploadType.IO_STREAM_BUILDER, ): ...","title":"Cluster Ssp"},{"location":"pypowervm/tasks/cluster_ssp/#cluster-ssp","text":"Pypowervm Index / Pypowervm / Tasks / Cluster Ssp Auto-generated documentation for pypowervm.tasks.cluster_ssp module. Cluster Ssp crt_cluster_ssp get_or_upload_image_lu","title":"Cluster Ssp"},{"location":"pypowervm/tasks/cluster_ssp/#crt_cluster_ssp","text":"Show source in cluster_ssp.py:40 Creates a Cluster/SharedStoragePool via the ClusterCreate Job. The Job takes two parameters: clusterXml and sspXml.","title":"crt_cluster_ssp"},{"location":"pypowervm/tasks/cluster_ssp/#arguments","text":"clust_name - String name for the Cluster. ssp_name - String name for the SharedStoragePool. repos_pv - storage.PV representing the repository hdisk. The name and udid properties must be specified. first_node - cluster.Node representing the initial VIOS in the cluster. (Cluster creation must be done with a single node; other nodes may be added later.) The Node wrapper must contain either - mtms, lpar_id, AND hostname; or - vios_uri The indicated node must be able to see each disk. data_pv_list - Iterable of storage.PV instances to use as the data volume(s) for the SharedStoragePool.","title":"Arguments"},{"location":"pypowervm/tasks/cluster_ssp/#signature","text":"def crt_cluster_ssp(clust_name, ssp_name, repos_pv, first_node, data_pv_list): ...","title":"Signature"},{"location":"pypowervm/tasks/cluster_ssp/#get_or_upload_image_lu","text":"Show source in cluster_ssp.py:155 Ensures our SSP has an LU containing the specified image. If an LU of type IMAGE with the specified luname already exists in our SSP, return it. Otherwise, create it, prime it with the image contents provided via stream_func, and return it. This method assumes that consumers employ a naming convention such that an LU with a given name represents the same data (size and content) no matter where/when it's created/uploaded - for example, by including the image's MD5 checksum in the name. This method is designed to coordinate the upload of a particular image LU across multiple hosts which use the same SSP, but otherwise can not communicate with each other.","title":"get_or_upload_image_lu"},{"location":"pypowervm/tasks/cluster_ssp/#arguments_1","text":"tier - Tier EntryWrapper of the Shared Storage Pool Tier on which the image LU is to be hosted. luname - The name of the image LU. Note that the name may be shortened to satisfy length restrictions. vios_uuid - The UUID of the Virtual I/O Server through which the upload should be performed, if necessary. io_handle - The I/O handle (as defined by the upload_type). This is only used if the image_lu needs to be uploaded. b_size - Integer size, in bytes, of the image provided by stream_func's return value. upload_type - (Optional, Default: IO_STREAM_BUILDER) Defines the way in which the LU should be uploaded. Refer to the UploadType enumeration for valid upload mechanisms. It defaults to IO_STREAM_BUILDER for legacy reasons.","title":"Arguments"},{"location":"pypowervm/tasks/cluster_ssp/#returns","text":"LUEnt EntryWrapper representing the image LU.","title":"Returns"},{"location":"pypowervm/tasks/cluster_ssp/#signature_1","text":"def get_or_upload_image_lu( tier, luname, vios_uuid, io_handle, b_size, upload_type=tsk_stg.UploadType.IO_STREAM_BUILDER, ): ...","title":"Signature"},{"location":"pypowervm/tasks/cna/","text":"Cna Pypowervm Index / Pypowervm / Tasks / Cna Auto-generated documentation for pypowervm.tasks.cna module. Cna assign_free_vlan crt_cna crt_p2p_cna crt_trunk_with_free_vlan find_cnas_on_trunk find_orphaned_trunks find_trunks assign_free_vlan Show source in cna.py:147 Assigns a free vlan to a given cna. Also ensure the CNA is enabled. Arguments adapter - The adapter to read the vnet information from. host_uuid - Not used. vswitch_w - The vswitch wrapper to find the free vlan on. cna - The CNA wrapper to be updated with a new vlan. ensure_enabled - (Optional, Default: False) If true, enable the CNA before updating. Returns The updated CNA. Signature @lockutils.synchronized(VLAN_LOCK) def assign_free_vlan(adapter, host_uuid, vswitch_w, cna, ensure_enabled=False): ... crt_cna Show source in cna.py:30 Puts a new ClientNetworkAdapter on a given LPAR. This will update the LPAR and put a new CNA on it. If the LPAR is active can only perform if there is an active RMC connection. If the LPAR is powered off, then it will update it offline. Arguments adapter - The pypowervm adapter to perform the update through. host_uuid - Not used. lpar_uuid - The lpar UUID to update. pvid - The primary VLAN ID. vswitch - The name of the virtual switch that this CNA will be attached to. crt_vswitch - A boolean to indicate that if the vSwitch can not be found, the system should attempt to create one (with the default parameters - ex: Veb mode). slot_num - Optional slot number to use for the CNA. If not specified, will utilize the next available slot on the LPAR. mac_addr - The optional mac address. If not specified, one will be auto generated. addl_vlans - Optional list of (up to 18) additional VLANs. Can be a list of Ints or Strings (that parse down to ints). Returns The CNA Wrapper that was created. Signature def crt_cna( adapter, host_uuid, lpar_uuid, pvid, vswitch=pvm_net.VSW_DEFAULT_VSWITCH, crt_vswitch=False, slot_num=None, mac_addr=None, addl_vlans=None, ): ... crt_p2p_cna Show source in cna.py:235 Creates a 'point-to-point' Client Network Adapter. A point to point connection is one that has a VLAN that is shared only between the lpar and the appropriate trunk adapter(s). The system will determine what a free VLAN is on the virtual switch and use that for the point to point connection. The method will return the Client Network Adapter and the corresponding Trunk Adapter that it has created. There may be multiple Trunk Adapters created if multiple src_io_host_uuids are passed in. The Trunk Adapters can be created against the Virtual I/O Servers or the NovaLink partition. Nothing prevents the system from allowing another Client Network Adapter from being created and attaching to the connection. The point-to-point connection is only guaranteed at the point in time at which it was created. NOTE: See the note in src_io_host_uuids. Currently this API will only support the NovaLink partition. Others will be added. This parameter is there for future facing compatibility. Arguments adapter - The pypowervm adapter to perform the update through. host_uuid - Not used. lpar_uuid - The lpar UUID to update. src_io_host_uuids - The list of UUIDs of the LPARs that will host the Trunk Adapters. At least one UUID is required. Multiple will be supported, and the Trunk Priority will increment per adapter (in the order that the I/O hosts are specified). pvid - The primary VLAN ID. vs_name - The name of the PowerVM Hypervisor Virtual Switch to create the p2p connection on. This is required because it is not recommended to create it on the default (ETHERNET0) virtual switch. crt_vswitch - (Optional, Default: True) A boolean to indicate that if the vSwitch can not be found, the system should attempt to create one (with the default parameters - ex: Veb mode). mac_addr - (Optional, Default: None) The mac address. If not specified, one will be auto generated. slot_num - (Optional, Default: None) The slot number to use for the CNA. If not specified, will utilize the next available slot on the LPAR. dev_name - (Optional, Default: None) The device name. Only valid if the src_io_host_uuids is a single entity and the uuid matches the mgmt lpar UUID. Otherwise leave as None. If set, the trunk adapter created on the mgmt lpar will be set to this value. ovs_bridge - (Optional, Default: None) If hosting through mgmt partition, this attribute specifies which Open vSwitch to connect to. ovs_ext_ids - (Optional, Default: None) Comma-delimited list of key=value pairs that get set as external-id metadata attributes on the OVS port. Only valid if ovs_bridge is set. configured_mtu - (Optional, Default: None) Sets the MTU on the adapter. May only be valid if adapter is being created against mgmt partition. Returns The CNA Wrapper that was created. The TrunkAdapters that were created. Match the order that the src_io_host_uuids were passed in. Signature def crt_p2p_cna( adapter, host_uuid, lpar_uuid, src_io_host_uuids, vs_name, crt_vswitch=True, mac_addr=None, slot_num=None, dev_name=None, ovs_bridge=None, ovs_ext_ids=None, configured_mtu=None, ): ... crt_trunk_with_free_vlan Show source in cna.py:168 Creates a trunk adapter(s) with a free VLAN on the system. Arguments adapter - The pypowervm adapter to perform the update through. host_uuid - Not used. src_io_host_uuids - The list of UUIDs of the LPARs that will host the Trunk Adapters. At least one UUID is required. Multiple will be supported, and the Trunk Priority will increment per adapter (in the order that the I/O hosts are specified). pvid - The port VLAN ID. vs_name - The name of the PowerVM Hypervisor Virtual Switch to create the p2p connection on. This is required because it is not recommended to create it on the default (ETHERNET0) virtual switch. crt_vswitch - (Optional, Default: True) A boolean to indicate that if the vSwitch can not be found, the system should attempt to create one (with the default parameters - ex: Veb mode). dev_name - (Optional, Default: None) The device name. Only valid if the src_io_host_uuids is a single entity and the uuid matches the mgmt lpar UUID. Otherwise leave as None. If set, the name of the trunk adapter created on the mgmt lpar will be set to this value. ovs_bridge - (Optional, Default: None) If hosting through mgmt partition, this attribute specifies which Open vSwitch to connect to. ovs_ext_ids - (Optional, Default: None) Comma-delimited list of key=value pairs that get set as external-id metadata attributes on the OVS port. Only valid if ovs_bridge is set. configured_mtu - (Optional, Default: None) Sets the MTU on the adapter. May only be valid if adapter is being created against mgmt partition. Returns The CNA Wrapper that was created. The TrunkAdapters that were created. Match the order that the src_io_host_uuids were passed in. Signature @lockutils.synchronized(VLAN_LOCK) def crt_trunk_with_free_vlan( adapter, host_uuid, src_io_host_uuids, vs_name, crt_vswitch=True, dev_name=None, ovs_bridge=None, ovs_ext_ids=None, configured_mtu=None, ): ... find_cnas_on_trunk Show source in cna.py:395 Returns the CNAs associated with the Trunk Adapter. Arguments trunk_w - The Trunk Adapter to find the Client Network Adapters for. cna_wraps - Optional param for passing in the list of CNA wraps to search. If the list is none, queries will be done to build the list. Returns A list of Client Network Adapters that are hosted by the Trunk Adapter. Signature def find_cnas_on_trunk(trunk_w, cna_wraps=None): ... find_orphaned_trunks Show source in cna.py:421 Returns all orphaned trunk adapters on a given vswitch. An orphaned trunk is a trunk adapter that does not have any associated CNAs. Arguments adapter - The pypowervm adapter to perform the search with. vswitch_name - The name of the vswitch to search for orphaned trunks on. Returns A list of trunk adapters that do not have any associated CNAs Signature def find_orphaned_trunks(adapter, vswitch_name): ... find_trunks Show source in cna.py:317 Returns the Trunk Adapters associated with the CNA. Arguments adapter - The pypowervm adapter to perform the search with. cna_w - The Client Network Adapter to find the Trunk Adapters for. Returns A list of Trunk Adapters (sorted by Trunk Priority) that host the Client Network Adapter. Signature def find_trunks(adapter, cna_w): ...","title":"Cna"},{"location":"pypowervm/tasks/cna/#cna","text":"Pypowervm Index / Pypowervm / Tasks / Cna Auto-generated documentation for pypowervm.tasks.cna module. Cna assign_free_vlan crt_cna crt_p2p_cna crt_trunk_with_free_vlan find_cnas_on_trunk find_orphaned_trunks find_trunks","title":"Cna"},{"location":"pypowervm/tasks/cna/#assign_free_vlan","text":"Show source in cna.py:147 Assigns a free vlan to a given cna. Also ensure the CNA is enabled.","title":"assign_free_vlan"},{"location":"pypowervm/tasks/cna/#arguments","text":"adapter - The adapter to read the vnet information from. host_uuid - Not used. vswitch_w - The vswitch wrapper to find the free vlan on. cna - The CNA wrapper to be updated with a new vlan. ensure_enabled - (Optional, Default: False) If true, enable the CNA before updating.","title":"Arguments"},{"location":"pypowervm/tasks/cna/#returns","text":"The updated CNA.","title":"Returns"},{"location":"pypowervm/tasks/cna/#signature","text":"@lockutils.synchronized(VLAN_LOCK) def assign_free_vlan(adapter, host_uuid, vswitch_w, cna, ensure_enabled=False): ...","title":"Signature"},{"location":"pypowervm/tasks/cna/#crt_cna","text":"Show source in cna.py:30 Puts a new ClientNetworkAdapter on a given LPAR. This will update the LPAR and put a new CNA on it. If the LPAR is active can only perform if there is an active RMC connection. If the LPAR is powered off, then it will update it offline.","title":"crt_cna"},{"location":"pypowervm/tasks/cna/#arguments_1","text":"adapter - The pypowervm adapter to perform the update through. host_uuid - Not used. lpar_uuid - The lpar UUID to update. pvid - The primary VLAN ID. vswitch - The name of the virtual switch that this CNA will be attached to. crt_vswitch - A boolean to indicate that if the vSwitch can not be found, the system should attempt to create one (with the default parameters - ex: Veb mode). slot_num - Optional slot number to use for the CNA. If not specified, will utilize the next available slot on the LPAR. mac_addr - The optional mac address. If not specified, one will be auto generated. addl_vlans - Optional list of (up to 18) additional VLANs. Can be a list of Ints or Strings (that parse down to ints).","title":"Arguments"},{"location":"pypowervm/tasks/cna/#returns_1","text":"The CNA Wrapper that was created.","title":"Returns"},{"location":"pypowervm/tasks/cna/#signature_1","text":"def crt_cna( adapter, host_uuid, lpar_uuid, pvid, vswitch=pvm_net.VSW_DEFAULT_VSWITCH, crt_vswitch=False, slot_num=None, mac_addr=None, addl_vlans=None, ): ...","title":"Signature"},{"location":"pypowervm/tasks/cna/#crt_p2p_cna","text":"Show source in cna.py:235 Creates a 'point-to-point' Client Network Adapter. A point to point connection is one that has a VLAN that is shared only between the lpar and the appropriate trunk adapter(s). The system will determine what a free VLAN is on the virtual switch and use that for the point to point connection. The method will return the Client Network Adapter and the corresponding Trunk Adapter that it has created. There may be multiple Trunk Adapters created if multiple src_io_host_uuids are passed in. The Trunk Adapters can be created against the Virtual I/O Servers or the NovaLink partition. Nothing prevents the system from allowing another Client Network Adapter from being created and attaching to the connection. The point-to-point connection is only guaranteed at the point in time at which it was created. NOTE: See the note in src_io_host_uuids. Currently this API will only support the NovaLink partition. Others will be added. This parameter is there for future facing compatibility.","title":"crt_p2p_cna"},{"location":"pypowervm/tasks/cna/#arguments_2","text":"adapter - The pypowervm adapter to perform the update through. host_uuid - Not used. lpar_uuid - The lpar UUID to update. src_io_host_uuids - The list of UUIDs of the LPARs that will host the Trunk Adapters. At least one UUID is required. Multiple will be supported, and the Trunk Priority will increment per adapter (in the order that the I/O hosts are specified). pvid - The primary VLAN ID. vs_name - The name of the PowerVM Hypervisor Virtual Switch to create the p2p connection on. This is required because it is not recommended to create it on the default (ETHERNET0) virtual switch. crt_vswitch - (Optional, Default: True) A boolean to indicate that if the vSwitch can not be found, the system should attempt to create one (with the default parameters - ex: Veb mode). mac_addr - (Optional, Default: None) The mac address. If not specified, one will be auto generated. slot_num - (Optional, Default: None) The slot number to use for the CNA. If not specified, will utilize the next available slot on the LPAR. dev_name - (Optional, Default: None) The device name. Only valid if the src_io_host_uuids is a single entity and the uuid matches the mgmt lpar UUID. Otherwise leave as None. If set, the trunk adapter created on the mgmt lpar will be set to this value. ovs_bridge - (Optional, Default: None) If hosting through mgmt partition, this attribute specifies which Open vSwitch to connect to. ovs_ext_ids - (Optional, Default: None) Comma-delimited list of key=value pairs that get set as external-id metadata attributes on the OVS port. Only valid if ovs_bridge is set. configured_mtu - (Optional, Default: None) Sets the MTU on the adapter. May only be valid if adapter is being created against mgmt partition.","title":"Arguments"},{"location":"pypowervm/tasks/cna/#returns_2","text":"The CNA Wrapper that was created. The TrunkAdapters that were created. Match the order that the src_io_host_uuids were passed in.","title":"Returns"},{"location":"pypowervm/tasks/cna/#signature_2","text":"def crt_p2p_cna( adapter, host_uuid, lpar_uuid, src_io_host_uuids, vs_name, crt_vswitch=True, mac_addr=None, slot_num=None, dev_name=None, ovs_bridge=None, ovs_ext_ids=None, configured_mtu=None, ): ...","title":"Signature"},{"location":"pypowervm/tasks/cna/#crt_trunk_with_free_vlan","text":"Show source in cna.py:168 Creates a trunk adapter(s) with a free VLAN on the system.","title":"crt_trunk_with_free_vlan"},{"location":"pypowervm/tasks/cna/#arguments_3","text":"adapter - The pypowervm adapter to perform the update through. host_uuid - Not used. src_io_host_uuids - The list of UUIDs of the LPARs that will host the Trunk Adapters. At least one UUID is required. Multiple will be supported, and the Trunk Priority will increment per adapter (in the order that the I/O hosts are specified). pvid - The port VLAN ID. vs_name - The name of the PowerVM Hypervisor Virtual Switch to create the p2p connection on. This is required because it is not recommended to create it on the default (ETHERNET0) virtual switch. crt_vswitch - (Optional, Default: True) A boolean to indicate that if the vSwitch can not be found, the system should attempt to create one (with the default parameters - ex: Veb mode). dev_name - (Optional, Default: None) The device name. Only valid if the src_io_host_uuids is a single entity and the uuid matches the mgmt lpar UUID. Otherwise leave as None. If set, the name of the trunk adapter created on the mgmt lpar will be set to this value. ovs_bridge - (Optional, Default: None) If hosting through mgmt partition, this attribute specifies which Open vSwitch to connect to. ovs_ext_ids - (Optional, Default: None) Comma-delimited list of key=value pairs that get set as external-id metadata attributes on the OVS port. Only valid if ovs_bridge is set. configured_mtu - (Optional, Default: None) Sets the MTU on the adapter. May only be valid if adapter is being created against mgmt partition.","title":"Arguments"},{"location":"pypowervm/tasks/cna/#returns_3","text":"The CNA Wrapper that was created. The TrunkAdapters that were created. Match the order that the src_io_host_uuids were passed in.","title":"Returns"},{"location":"pypowervm/tasks/cna/#signature_3","text":"@lockutils.synchronized(VLAN_LOCK) def crt_trunk_with_free_vlan( adapter, host_uuid, src_io_host_uuids, vs_name, crt_vswitch=True, dev_name=None, ovs_bridge=None, ovs_ext_ids=None, configured_mtu=None, ): ...","title":"Signature"},{"location":"pypowervm/tasks/cna/#find_cnas_on_trunk","text":"Show source in cna.py:395 Returns the CNAs associated with the Trunk Adapter.","title":"find_cnas_on_trunk"},{"location":"pypowervm/tasks/cna/#arguments_4","text":"trunk_w - The Trunk Adapter to find the Client Network Adapters for. cna_wraps - Optional param for passing in the list of CNA wraps to search. If the list is none, queries will be done to build the list.","title":"Arguments"},{"location":"pypowervm/tasks/cna/#returns_4","text":"A list of Client Network Adapters that are hosted by the Trunk Adapter.","title":"Returns"},{"location":"pypowervm/tasks/cna/#signature_4","text":"def find_cnas_on_trunk(trunk_w, cna_wraps=None): ...","title":"Signature"},{"location":"pypowervm/tasks/cna/#find_orphaned_trunks","text":"Show source in cna.py:421 Returns all orphaned trunk adapters on a given vswitch. An orphaned trunk is a trunk adapter that does not have any associated CNAs.","title":"find_orphaned_trunks"},{"location":"pypowervm/tasks/cna/#arguments_5","text":"adapter - The pypowervm adapter to perform the search with. vswitch_name - The name of the vswitch to search for orphaned trunks on.","title":"Arguments"},{"location":"pypowervm/tasks/cna/#returns_5","text":"A list of trunk adapters that do not have any associated CNAs","title":"Returns"},{"location":"pypowervm/tasks/cna/#signature_5","text":"def find_orphaned_trunks(adapter, vswitch_name): ...","title":"Signature"},{"location":"pypowervm/tasks/cna/#find_trunks","text":"Show source in cna.py:317 Returns the Trunk Adapters associated with the CNA.","title":"find_trunks"},{"location":"pypowervm/tasks/cna/#arguments_6","text":"adapter - The pypowervm adapter to perform the search with. cna_w - The Client Network Adapter to find the Trunk Adapters for.","title":"Arguments"},{"location":"pypowervm/tasks/cna/#returns_6","text":"A list of Trunk Adapters (sorted by Trunk Priority) that host the Client Network Adapter.","title":"Returns"},{"location":"pypowervm/tasks/cna/#signature_6","text":"def find_trunks(adapter, cna_w): ...","title":"Signature"},{"location":"pypowervm/tasks/ibmi/","text":"Ibmi Pypowervm Index / Pypowervm / Tasks / Ibmi Auto-generated documentation for pypowervm.tasks.ibmi module. Ibmi IBMiPanelOperations start_panel_job update_ibmi_settings IBMiPanelOperations Show source in ibmi.py:96 Signature class IBMiPanelOperations(object): ... start_panel_job Show source in ibmi.py:115 Run an IBMi Panel job operation. Arguments part - Partition (LPAR or VIOS) wrapper indicating the partition to run the panel function against. opt - One of the IBMiPanelOperations enum values to run. timeout - value in seconds for specifying how long to wait for the Job to complete. synchronous - If True, this method will not return until the Job completes (whether success or failure) or times out. If False, this method will return as soon as the Job has started on the server (that is, achieved any state beyond NOT_ACTIVE). Note that timeout is still possible in this case. Signature def start_panel_job( part, opt=None, timeout=CONF.pypowervm_job_request_timeout, synchronous=True ): ... update_ibmi_settings Show source in ibmi.py:38 Update TaggedIO, Keylock postion and IPL Source of IBMi VM. TaggedIO of IBMi vm will be updated to identify the load source, alternative load source and console type. Keylock position will be set to the value of NORMAL in KeylockPos enumration. IPL Source will be set to the value of B in IPLSrc enumration. Arguments adapter - The pypowervm adapter. lpar_w - The lpar wrapper. boot_type - The boot connectivity type of the VM. It is a string value that represents one of the values in the BootStorageType enumeration. Returns The updated LPAR wrapper. The update is not executed against the system, but rather the wrapper itself is updated locally. Signature def update_ibmi_settings(adapter, lpar_w, boot_type): ...","title":"Ibmi"},{"location":"pypowervm/tasks/ibmi/#ibmi","text":"Pypowervm Index / Pypowervm / Tasks / Ibmi Auto-generated documentation for pypowervm.tasks.ibmi module. Ibmi IBMiPanelOperations start_panel_job update_ibmi_settings","title":"Ibmi"},{"location":"pypowervm/tasks/ibmi/#ibmipaneloperations","text":"Show source in ibmi.py:96","title":"IBMiPanelOperations"},{"location":"pypowervm/tasks/ibmi/#signature","text":"class IBMiPanelOperations(object): ...","title":"Signature"},{"location":"pypowervm/tasks/ibmi/#start_panel_job","text":"Show source in ibmi.py:115 Run an IBMi Panel job operation.","title":"start_panel_job"},{"location":"pypowervm/tasks/ibmi/#arguments","text":"part - Partition (LPAR or VIOS) wrapper indicating the partition to run the panel function against. opt - One of the IBMiPanelOperations enum values to run. timeout - value in seconds for specifying how long to wait for the Job to complete. synchronous - If True, this method will not return until the Job completes (whether success or failure) or times out. If False, this method will return as soon as the Job has started on the server (that is, achieved any state beyond NOT_ACTIVE). Note that timeout is still possible in this case.","title":"Arguments"},{"location":"pypowervm/tasks/ibmi/#signature_1","text":"def start_panel_job( part, opt=None, timeout=CONF.pypowervm_job_request_timeout, synchronous=True ): ...","title":"Signature"},{"location":"pypowervm/tasks/ibmi/#update_ibmi_settings","text":"Show source in ibmi.py:38 Update TaggedIO, Keylock postion and IPL Source of IBMi VM. TaggedIO of IBMi vm will be updated to identify the load source, alternative load source and console type. Keylock position will be set to the value of NORMAL in KeylockPos enumration. IPL Source will be set to the value of B in IPLSrc enumration.","title":"update_ibmi_settings"},{"location":"pypowervm/tasks/ibmi/#arguments_1","text":"adapter - The pypowervm adapter. lpar_w - The lpar wrapper. boot_type - The boot connectivity type of the VM. It is a string value that represents one of the values in the BootStorageType enumeration.","title":"Arguments"},{"location":"pypowervm/tasks/ibmi/#returns","text":"The updated LPAR wrapper. The update is not executed against the system, but rather the wrapper itself is updated locally.","title":"Returns"},{"location":"pypowervm/tasks/ibmi/#signature_2","text":"def update_ibmi_settings(adapter, lpar_w, boot_type): ...","title":"Signature"},{"location":"pypowervm/tasks/management_console/","text":"Management Console Pypowervm Index / Pypowervm / Tasks / Management Console Auto-generated documentation for pypowervm.tasks.management_console module. Management Console add_authorized_key get_authorized_keys get_public_key add_authorized_key Show source in management_console.py:33 Add an authorized public key to the management console. The public_key will be added if it doesn't already exist. Arguments adapter - The adapter for the pypowervm API. public_key - The public key to be added. Signature def add_authorized_key(adapter, public_key): ... get_authorized_keys Show source in management_console.py:56 Get all authorized keys on the management console. Arguments adapter - The adapter for the pypowervm API. Signature def get_authorized_keys(adapter): ... get_public_key Show source in management_console.py:21 Get the public key for the management console. Arguments adapter - The adapter for the pypowervm API. Returns The public key Signature def get_public_key(adapter): ...","title":"Management Console"},{"location":"pypowervm/tasks/management_console/#management-console","text":"Pypowervm Index / Pypowervm / Tasks / Management Console Auto-generated documentation for pypowervm.tasks.management_console module. Management Console add_authorized_key get_authorized_keys get_public_key","title":"Management Console"},{"location":"pypowervm/tasks/management_console/#add_authorized_key","text":"Show source in management_console.py:33 Add an authorized public key to the management console. The public_key will be added if it doesn't already exist.","title":"add_authorized_key"},{"location":"pypowervm/tasks/management_console/#arguments","text":"adapter - The adapter for the pypowervm API. public_key - The public key to be added.","title":"Arguments"},{"location":"pypowervm/tasks/management_console/#signature","text":"def add_authorized_key(adapter, public_key): ...","title":"Signature"},{"location":"pypowervm/tasks/management_console/#get_authorized_keys","text":"Show source in management_console.py:56 Get all authorized keys on the management console.","title":"get_authorized_keys"},{"location":"pypowervm/tasks/management_console/#arguments_1","text":"adapter - The adapter for the pypowervm API.","title":"Arguments"},{"location":"pypowervm/tasks/management_console/#signature_1","text":"def get_authorized_keys(adapter): ...","title":"Signature"},{"location":"pypowervm/tasks/management_console/#get_public_key","text":"Show source in management_console.py:21 Get the public key for the management console.","title":"get_public_key"},{"location":"pypowervm/tasks/management_console/#arguments_2","text":"adapter - The adapter for the pypowervm API.","title":"Arguments"},{"location":"pypowervm/tasks/management_console/#returns","text":"The public key","title":"Returns"},{"location":"pypowervm/tasks/management_console/#signature_2","text":"def get_public_key(adapter): ...","title":"Signature"},{"location":"pypowervm/tasks/master_mode/","text":"MasterMode Pypowervm Index / Pypowervm / Tasks / MasterMode Auto-generated documentation for pypowervm.tasks.master_mode module. MasterMode MasterMode release_master request_master MasterMode Show source in master_mode.py:37 Valid master modes used when requesting master. NORMAL: Default mode TEMP: When released, the original master is immediately restored. Signature class MasterMode(object): ... release_master Show source in master_mode.py:69 Release master mode for the provided Managed System. Arguments msys - Managed System wrapper requesting master mode timeout - maximum number of seconds for job to complete Signature @lgc.logcall def release_master(msys, timeout=CONF.pypowervm_job_request_timeout): ... request_master Show source in master_mode.py:47 Request master mode for the provided Managed System. Arguments msys - Managed System wrapper requesting master mode mode - The requested master mode type. There are 2 options: MasterMode.NORMAL (\"norm\"): default MasterMode.TEMP (\"temp\"): when released, the original master is immediately restored timeout - maximum number of seconds for job to complete Signature @lgc.logcall def request_master( msys, mode=MasterMode.NORMAL, timeout=CONF.pypowervm_job_request_timeout ): ...","title":"MasterMode"},{"location":"pypowervm/tasks/master_mode/#mastermode","text":"Pypowervm Index / Pypowervm / Tasks / MasterMode Auto-generated documentation for pypowervm.tasks.master_mode module. MasterMode MasterMode release_master request_master","title":"MasterMode"},{"location":"pypowervm/tasks/master_mode/#mastermode_1","text":"Show source in master_mode.py:37 Valid master modes used when requesting master. NORMAL: Default mode TEMP: When released, the original master is immediately restored.","title":"MasterMode"},{"location":"pypowervm/tasks/master_mode/#signature","text":"class MasterMode(object): ...","title":"Signature"},{"location":"pypowervm/tasks/master_mode/#release_master","text":"Show source in master_mode.py:69 Release master mode for the provided Managed System.","title":"release_master"},{"location":"pypowervm/tasks/master_mode/#arguments","text":"msys - Managed System wrapper requesting master mode timeout - maximum number of seconds for job to complete","title":"Arguments"},{"location":"pypowervm/tasks/master_mode/#signature_1","text":"@lgc.logcall def release_master(msys, timeout=CONF.pypowervm_job_request_timeout): ...","title":"Signature"},{"location":"pypowervm/tasks/master_mode/#request_master","text":"Show source in master_mode.py:47 Request master mode for the provided Managed System.","title":"request_master"},{"location":"pypowervm/tasks/master_mode/#arguments_1","text":"msys - Managed System wrapper requesting master mode mode - The requested master mode type. There are 2 options: MasterMode.NORMAL (\"norm\"): default MasterMode.TEMP (\"temp\"): when released, the original master is immediately restored timeout - maximum number of seconds for job to complete","title":"Arguments"},{"location":"pypowervm/tasks/master_mode/#signature_2","text":"@lgc.logcall def request_master( msys, mode=MasterMode.NORMAL, timeout=CONF.pypowervm_job_request_timeout ): ...","title":"Signature"},{"location":"pypowervm/tasks/memory/","text":"Memory Pypowervm Index / Pypowervm / Tasks / Memory Auto-generated documentation for pypowervm.tasks.memory module. Memory calculate_memory_overhead_on_host calculate_memory_overhead_on_host Show source in memory.py:31 Calculate host memory overhead. A certain amount of additional memory, such as memory for firmware, is required from the host during the creation of an instance or while changing an instance's memory specifications. This method queries the host to get the reserved PHYP memory needed for an LPAR. The calculation is based off of the instance's max memory requested, network and I/O adapter configurations, and the host's HPT ratio. The job response contains a value for total memory required to create or change the LPAR, which is desired memory plus reserved PHYP memory. Arguments adapter - pypowervm adapter host_uuid - the UUID of the host reserve_mem_data - (Optional) dictionary with values for job params {'desired_mem': int, 'max_mem': int, 'lpar_env': 'AIX/Linux' OR 'OS400', 'num_virt_eth_adapters': int, 'num_vscsi_adapters': int, 'num_vfc_adapters': int} lmb_size - (Optional) logical memory block size default - (Optional) default value to use for required memory overhead value if there was an error with the job Returns Type: overhead reserved host memory Type: avail_mem available host memory Signature @lgc.logcall def calculate_memory_overhead_on_host( adapter, host_uuid, reserved_mem_data={}, lmb_size=None, default=512 ): ...","title":"Memory"},{"location":"pypowervm/tasks/memory/#memory","text":"Pypowervm Index / Pypowervm / Tasks / Memory Auto-generated documentation for pypowervm.tasks.memory module. Memory calculate_memory_overhead_on_host","title":"Memory"},{"location":"pypowervm/tasks/memory/#calculate_memory_overhead_on_host","text":"Show source in memory.py:31 Calculate host memory overhead. A certain amount of additional memory, such as memory for firmware, is required from the host during the creation of an instance or while changing an instance's memory specifications. This method queries the host to get the reserved PHYP memory needed for an LPAR. The calculation is based off of the instance's max memory requested, network and I/O adapter configurations, and the host's HPT ratio. The job response contains a value for total memory required to create or change the LPAR, which is desired memory plus reserved PHYP memory.","title":"calculate_memory_overhead_on_host"},{"location":"pypowervm/tasks/memory/#arguments","text":"adapter - pypowervm adapter host_uuid - the UUID of the host reserve_mem_data - (Optional) dictionary with values for job params {'desired_mem': int, 'max_mem': int, 'lpar_env': 'AIX/Linux' OR 'OS400', 'num_virt_eth_adapters': int, 'num_vscsi_adapters': int, 'num_vfc_adapters': int} lmb_size - (Optional) logical memory block size default - (Optional) default value to use for required memory overhead value if there was an error with the job","title":"Arguments"},{"location":"pypowervm/tasks/memory/#returns","text":"Type: overhead reserved host memory Type: avail_mem available host memory","title":"Returns"},{"location":"pypowervm/tasks/memory/#signature","text":"@lgc.logcall def calculate_memory_overhead_on_host( adapter, host_uuid, reserved_mem_data={}, lmb_size=None, default=512 ): ...","title":"Signature"},{"location":"pypowervm/tasks/migration/","text":"Migration Pypowervm Index / Pypowervm / Tasks / Migration Auto-generated documentation for pypowervm.tasks.migration module. Migration migrate_abort migrate_lpar migrate_recover migrate_abort Show source in migration.py:218 Method to abort a logical partition migration. Arguments lpar - The LPAR wrapper of the logical partition to abort the migration operation. timeout - maximum number of seconds for job to complete Signature def migrate_abort(lpar, timeout=CONF.pypowervm_job_request_timeout): ... migrate_lpar Show source in migration.py:49 Method to migrate a logical partition. Arguments lpar - The LPAR wrapper of the logical partition to migrate. tgt_mgd_sys - The name of the managed system to migrate to. validate_only - Indication of whether to just validate the migration or actually perform it. tgt_mgmt_svr - The ip of the PowerVM management platform managing the target host. tgt_mgmt_usr - The user id to use on the target PowerVM management platform. virtual_fc_mappings - The virtual fiber channel mappings to move during the migration. See information below. virtual_scsi_mappings - The virtual scsi mappings to move during the migration. See information below. dest_msp_name - A comma-separated list of destination VIOS IP addresses identifying which interface(s) the Mover Service Partition should use. source_msp_name - A comma-separated list of source VIOS IP addresses identifying which interface(s) the Mover Service Partition should use. spp_id - The shared processor pool id to use on the target system. timeout - maximum number of seconds for job to complete sdn_override - (Optional, Default: False) If set to True, will allow a migration where the networking is hosted on a non- traditional VIOS partition (ex. the NovaLink) vlan_check_override - (Optional, Default: False) If set to True, will tell the Virtual I/O Server not to validate that the other VIOS has the VLAN pre-provisioned. vlan_mappings - The vlan mappings that indicate what the VLAN should be on the target system for a given MAC address. If not provided, the original VLANs will be used. See information below. check_affinity_score - (Optional, Default: False) If set to True, will require a check that the LPAR's affinity score is not lower on the destination host. virtual_fc_mappings: List of virtual fibre channel adapter mappings, with each mapping having the following format: virtual-slot-number/vios-lpar-name/vios-lpar-ID [/[vios-virtual-slot-number][/[vios-fc-port-name]]] The first two '/' characters must be present. The third '/' character is optional, but it must be present if vios-virtual-slot-number or vios-fc-port-name is specified. The last '/' character is optional but it must be present if vios-fc-port-name is specified. Optional values may be omitted. Optional values are vios-lpar-name or vios-lpar-ID (one of those values is required, but not both), vios-virtual-slot-number, and vios-fc-port-name. For example: 4//1/14/fcs0 specifies a mapping of the virtual fibre channel client adapter with slot number 4 to the virtual fibre channel server adapter with slot number 14 in the VIOS partition with ID 1 on the destination managed system. In addition, the mapping specifies to use physical fibre channel port fcs0. virtual_scsi_mappings: List of virtual SCSI adapter mappings, with each mapping having the following format: virtual-slot-number/vios-lpar-name/vios-lpar-ID [/vios-virtual-slot-number] The first two '/' characters must be present. The last '/' character is optional, but it must be present if vios-virtual-slot-number is specified. Optional values may be omitted. Optional values are vios-lpar-name or vios-lpar-ID (one of those values is required, but not both), and vios-virtual-slot-number. For example: 12/vios1//16 specifies a mapping of the virtual SCSI adapter with slot number 12 to slot number 16 on the VIOS partition vios1 on the destination managed system. vlan_mappings: List of vlan mappings, with each mapping having the following format: MAC/PVID[/VLAN_A VLAN_B] The first '/' must be present. The first field is the MAC address of the adapter. The MAC address must be exactly 12 digits, case insensitive, without colons in it. The second is what the target PVID should be set to for that adapter. The remaining is a list of additional VLANs that could be specified for adapters that have additional VLANs. The list of additional VLANs is space delimited. For example: 001122334455/12 specifies a mapping where the adapter with MAC address 001122334455 should have a PVID of 12 on the target system. Signature def migrate_lpar( lpar, tgt_mgd_sys, validate_only=False, tgt_mgmt_svr=None, tgt_mgmt_usr=None, virtual_fc_mappings=None, virtual_scsi_mappings=None, dest_msp_name=None, source_msp_name=None, spp_id=None, timeout=CONF.pypowervm_job_request_timeout * 4, sdn_override=False, vlan_check_override=False, vlan_mappings=None, check_affinity_score=False, ): ... migrate_recover Show source in migration.py:197 Method to recover a failed logical partition migration. Arguments lpar - The LPAR wrapper of the logical partition to recover. force - Boolean specifying whether to force the migration to recover when errors are encountered. timeout - maximum number of seconds for job to complete Signature def migrate_recover(lpar, force=False, timeout=CONF.pypowervm_job_request_timeout): ...","title":"Migration"},{"location":"pypowervm/tasks/migration/#migration","text":"Pypowervm Index / Pypowervm / Tasks / Migration Auto-generated documentation for pypowervm.tasks.migration module. Migration migrate_abort migrate_lpar migrate_recover","title":"Migration"},{"location":"pypowervm/tasks/migration/#migrate_abort","text":"Show source in migration.py:218 Method to abort a logical partition migration.","title":"migrate_abort"},{"location":"pypowervm/tasks/migration/#arguments","text":"lpar - The LPAR wrapper of the logical partition to abort the migration operation. timeout - maximum number of seconds for job to complete","title":"Arguments"},{"location":"pypowervm/tasks/migration/#signature","text":"def migrate_abort(lpar, timeout=CONF.pypowervm_job_request_timeout): ...","title":"Signature"},{"location":"pypowervm/tasks/migration/#migrate_lpar","text":"Show source in migration.py:49 Method to migrate a logical partition.","title":"migrate_lpar"},{"location":"pypowervm/tasks/migration/#arguments_1","text":"lpar - The LPAR wrapper of the logical partition to migrate. tgt_mgd_sys - The name of the managed system to migrate to. validate_only - Indication of whether to just validate the migration or actually perform it. tgt_mgmt_svr - The ip of the PowerVM management platform managing the target host. tgt_mgmt_usr - The user id to use on the target PowerVM management platform. virtual_fc_mappings - The virtual fiber channel mappings to move during the migration. See information below. virtual_scsi_mappings - The virtual scsi mappings to move during the migration. See information below. dest_msp_name - A comma-separated list of destination VIOS IP addresses identifying which interface(s) the Mover Service Partition should use. source_msp_name - A comma-separated list of source VIOS IP addresses identifying which interface(s) the Mover Service Partition should use. spp_id - The shared processor pool id to use on the target system. timeout - maximum number of seconds for job to complete sdn_override - (Optional, Default: False) If set to True, will allow a migration where the networking is hosted on a non- traditional VIOS partition (ex. the NovaLink) vlan_check_override - (Optional, Default: False) If set to True, will tell the Virtual I/O Server not to validate that the other VIOS has the VLAN pre-provisioned. vlan_mappings - The vlan mappings that indicate what the VLAN should be on the target system for a given MAC address. If not provided, the original VLANs will be used. See information below. check_affinity_score - (Optional, Default: False) If set to True, will require a check that the LPAR's affinity score is not lower on the destination host. virtual_fc_mappings: List of virtual fibre channel adapter mappings, with each mapping having the following format: virtual-slot-number/vios-lpar-name/vios-lpar-ID [/[vios-virtual-slot-number][/[vios-fc-port-name]]] The first two '/' characters must be present. The third '/' character is optional, but it must be present if vios-virtual-slot-number or vios-fc-port-name is specified. The last '/' character is optional but it must be present if vios-fc-port-name is specified. Optional values may be omitted. Optional values are vios-lpar-name or vios-lpar-ID (one of those values is required, but not both), vios-virtual-slot-number, and vios-fc-port-name. For example: 4//1/14/fcs0 specifies a mapping of the virtual fibre channel client adapter with slot number 4 to the virtual fibre channel server adapter with slot number 14 in the VIOS partition with ID 1 on the destination managed system. In addition, the mapping specifies to use physical fibre channel port fcs0. virtual_scsi_mappings: List of virtual SCSI adapter mappings, with each mapping having the following format: virtual-slot-number/vios-lpar-name/vios-lpar-ID [/vios-virtual-slot-number] The first two '/' characters must be present. The last '/' character is optional, but it must be present if vios-virtual-slot-number is specified. Optional values may be omitted. Optional values are vios-lpar-name or vios-lpar-ID (one of those values is required, but not both), and vios-virtual-slot-number. For example: 12/vios1//16 specifies a mapping of the virtual SCSI adapter with slot number 12 to slot number 16 on the VIOS partition vios1 on the destination managed system. vlan_mappings: List of vlan mappings, with each mapping having the following format: MAC/PVID[/VLAN_A VLAN_B] The first '/' must be present. The first field is the MAC address of the adapter. The MAC address must be exactly 12 digits, case insensitive, without colons in it. The second is what the target PVID should be set to for that adapter. The remaining is a list of additional VLANs that could be specified for adapters that have additional VLANs. The list of additional VLANs is space delimited. For example: 001122334455/12 specifies a mapping where the adapter with MAC address 001122334455 should have a PVID of 12 on the target system.","title":"Arguments"},{"location":"pypowervm/tasks/migration/#signature_1","text":"def migrate_lpar( lpar, tgt_mgd_sys, validate_only=False, tgt_mgmt_svr=None, tgt_mgmt_usr=None, virtual_fc_mappings=None, virtual_scsi_mappings=None, dest_msp_name=None, source_msp_name=None, spp_id=None, timeout=CONF.pypowervm_job_request_timeout * 4, sdn_override=False, vlan_check_override=False, vlan_mappings=None, check_affinity_score=False, ): ...","title":"Signature"},{"location":"pypowervm/tasks/migration/#migrate_recover","text":"Show source in migration.py:197 Method to recover a failed logical partition migration.","title":"migrate_recover"},{"location":"pypowervm/tasks/migration/#arguments_2","text":"lpar - The LPAR wrapper of the logical partition to recover. force - Boolean specifying whether to force the migration to recover when errors are encountered. timeout - maximum number of seconds for job to complete","title":"Arguments"},{"location":"pypowervm/tasks/migration/#signature_2","text":"def migrate_recover(lpar, force=False, timeout=CONF.pypowervm_job_request_timeout): ...","title":"Signature"},{"location":"pypowervm/tasks/network_bridger/","text":"NetworkBridger Pypowervm Index / Pypowervm / Tasks / NetworkBridger Auto-generated documentation for pypowervm.tasks.network_bridger module. NetworkBridger NetworkBridger NetworkBridger().ensure_vlans_on_nb NetworkBridger().remove_vlan_from_nb NetworkBridgerTA NetworkBridgerVNET ensure_vlan_on_nb ensure_vlans_on_nb remove_vlan_from_nb NetworkBridger Show source in network_bridger.py:138 Defines the high level flows for the VLAN provisioning. This class has the generic flows, subclasses extend this for the derivations of vnet_aware and direct VLAN application. Signature class NetworkBridger(object): def __init__(self, adapter, host_uuid): ... NetworkBridger().ensure_vlans_on_nb Show source in network_bridger.py:155 Will make sure that the VLANs are assigned to the Network Bridge. This method will reorder the arbitrary VLAN IDs as needed (those which are the PVID of the TrunkAdapter, but not the primary TrunkAdapter). VLANs are always added to TrunkAdapters that are 'non-primary' (not the first TrunkAdapter). However, if the VLAN is on the primary TrunkAdapter then it is left on the system. The only 'untagged' VLAN that is allowed is the primary TrunkAdapter's PVID. If the VLAN specified is on another Network Bridge's TrunkAdapter (which happens to be on the same virtual switch): - An error will be thrown if it is on the primary TrunkAdapter. - It will be removed off the Network Bridge if it is on the non-primary TrunkAdapter. This method will not remove VLAN IDs from the network bridge that aren't part of the vlan_ids list. Instead, each VLAN is simply added to the Network Bridge's VLAN list. Arguments nb_uuid - The Network Bridge UUID. vlan_ids - The list of VLANs to ensure are on the Network Bridge. Signature @lock.synchronized(_ENSURE_VLAN_LOCK) def ensure_vlans_on_nb(self, nb_uuid, vlan_ids): ... NetworkBridger().remove_vlan_from_nb Show source in network_bridger.py:248 Will remove the VLAN from a given Network Bridge. Arguments nb_uuid - The Network Bridge UUID. vlan_id - The VLAN identifier. fail_if_pvid - If set to true, will raise an exception if this is the PVID on a Network Bridge. existing_nbs - Optional. If set, should be the existing network bridge wrappers. If not provided, will gather from the system directly. Signature @lock.synchronized(_ENSURE_VLAN_LOCK) def remove_vlan_from_nb(self, nb_uuid, vlan_id, fail_if_pvid=False, existing_nbs=None): ... NetworkBridgerTA Show source in network_bridger.py:770 The Trunk Adapter aware NetworkBridger. Signature class NetworkBridgerTA(NetworkBridger): ... See also NetworkBridger NetworkBridgerVNET Show source in network_bridger.py:532 The virtual network aware NetworkBridger. Signature class NetworkBridgerVNET(NetworkBridger): ... See also NetworkBridger ensure_vlan_on_nb Show source in network_bridger.py:86 Will make sure that the VLAN is assigned to the Network Bridge. This method will reorder the arbitrary VLAN IDs as needed (those which are the PVID of the VEAs, but not the primary VEA). VLANs are always added to VEAs that are 'non-primary' (not the first VEA). However, if the VLAN is on the primary VEA then it is left on the system. The only 'untagged' VLAN that is allowed is the primary VEA's PVID. If the VLAN specified is on another Network Bridge's VEA (which happens to be on the same virtual switch): - An error will be thrown if it is on the primary VEA. - It will be removed off the Network Bridge if it is on the non-primary VEA. Arguments adapter - The pypowervm Adapter. host_uuid - The Server's UUID nb_uuid - The Network Bridge UUID. vlan_id - The VLAN identifier to ensure is on the system. Signature def ensure_vlan_on_nb(adapter, host_uuid, nb_uuid, vlan_id): ... ensure_vlans_on_nb Show source in network_bridger.py:58 Will make sure that the VLANs are assigned to the Network Bridge. This method will reorder the arbitrary VLAN IDs as needed (those which are the PVID of the VEAs, but not the primary VEA). VLANs are always added to VEAs that are 'non-primary' (not the first VEA). However, if the VLAN is on the primary VEA then it is left on the system. The only 'untagged' VLAN that is allowed is the primary VEA's PVID. If the VLAN specified is on another Network Bridge's VEA (which happens to be on the same virtual switch): - An error will be thrown if it is on the primary VEA. - It will be removed off the Network Bridge if it is on the non-primary VEA. This method will not remove VLAN IDs from the network bridge that aren't part of the vlan_ids list. Instead, each VLAN is simply added to the Network Bridge's VLAN list. Arguments adapter - The pypowervm Adapter. host_uuid - The Server's UUID nb_uuid - The Network Bridge UUID. vlan_ids - The list of VLANs to ensure are on the Network Bridge. Signature def ensure_vlans_on_nb(adapter, host_uuid, nb_uuid, vlan_ids): ... remove_vlan_from_nb Show source in network_bridger.py:110 Will remove the VLAN from a given Network Bridge. Arguments adapter - The pypowervm Adapter. host_uuid - The host system UUID. nb_uuid - The Network Bridge UUID. vlan_id - The VLAN identifier. fail_if_pvid - If set to true, will raise an exception if this is the PVID on a Network Bridge. existing_nbs - Optional. If set, should be the existing network bridge wrappers. If not provided, will gather from the system directly. Signature def remove_vlan_from_nb( adapter, host_uuid, nb_uuid, vlan_id, fail_if_pvid=False, existing_nbs=None ): ...","title":"NetworkBridger"},{"location":"pypowervm/tasks/network_bridger/#networkbridger","text":"Pypowervm Index / Pypowervm / Tasks / NetworkBridger Auto-generated documentation for pypowervm.tasks.network_bridger module. NetworkBridger NetworkBridger NetworkBridger().ensure_vlans_on_nb NetworkBridger().remove_vlan_from_nb NetworkBridgerTA NetworkBridgerVNET ensure_vlan_on_nb ensure_vlans_on_nb remove_vlan_from_nb","title":"NetworkBridger"},{"location":"pypowervm/tasks/network_bridger/#networkbridger_1","text":"Show source in network_bridger.py:138 Defines the high level flows for the VLAN provisioning. This class has the generic flows, subclasses extend this for the derivations of vnet_aware and direct VLAN application.","title":"NetworkBridger"},{"location":"pypowervm/tasks/network_bridger/#signature","text":"class NetworkBridger(object): def __init__(self, adapter, host_uuid): ...","title":"Signature"},{"location":"pypowervm/tasks/network_bridger/#networkbridgerensure_vlans_on_nb","text":"Show source in network_bridger.py:155 Will make sure that the VLANs are assigned to the Network Bridge. This method will reorder the arbitrary VLAN IDs as needed (those which are the PVID of the TrunkAdapter, but not the primary TrunkAdapter). VLANs are always added to TrunkAdapters that are 'non-primary' (not the first TrunkAdapter). However, if the VLAN is on the primary TrunkAdapter then it is left on the system. The only 'untagged' VLAN that is allowed is the primary TrunkAdapter's PVID. If the VLAN specified is on another Network Bridge's TrunkAdapter (which happens to be on the same virtual switch): - An error will be thrown if it is on the primary TrunkAdapter. - It will be removed off the Network Bridge if it is on the non-primary TrunkAdapter. This method will not remove VLAN IDs from the network bridge that aren't part of the vlan_ids list. Instead, each VLAN is simply added to the Network Bridge's VLAN list.","title":"NetworkBridger().ensure_vlans_on_nb"},{"location":"pypowervm/tasks/network_bridger/#arguments","text":"nb_uuid - The Network Bridge UUID. vlan_ids - The list of VLANs to ensure are on the Network Bridge.","title":"Arguments"},{"location":"pypowervm/tasks/network_bridger/#signature_1","text":"@lock.synchronized(_ENSURE_VLAN_LOCK) def ensure_vlans_on_nb(self, nb_uuid, vlan_ids): ...","title":"Signature"},{"location":"pypowervm/tasks/network_bridger/#networkbridgerremove_vlan_from_nb","text":"Show source in network_bridger.py:248 Will remove the VLAN from a given Network Bridge.","title":"NetworkBridger().remove_vlan_from_nb"},{"location":"pypowervm/tasks/network_bridger/#arguments_1","text":"nb_uuid - The Network Bridge UUID. vlan_id - The VLAN identifier. fail_if_pvid - If set to true, will raise an exception if this is the PVID on a Network Bridge. existing_nbs - Optional. If set, should be the existing network bridge wrappers. If not provided, will gather from the system directly.","title":"Arguments"},{"location":"pypowervm/tasks/network_bridger/#signature_2","text":"@lock.synchronized(_ENSURE_VLAN_LOCK) def remove_vlan_from_nb(self, nb_uuid, vlan_id, fail_if_pvid=False, existing_nbs=None): ...","title":"Signature"},{"location":"pypowervm/tasks/network_bridger/#networkbridgerta","text":"Show source in network_bridger.py:770 The Trunk Adapter aware NetworkBridger.","title":"NetworkBridgerTA"},{"location":"pypowervm/tasks/network_bridger/#signature_3","text":"class NetworkBridgerTA(NetworkBridger): ...","title":"Signature"},{"location":"pypowervm/tasks/network_bridger/#see-also","text":"NetworkBridger","title":"See also"},{"location":"pypowervm/tasks/network_bridger/#networkbridgervnet","text":"Show source in network_bridger.py:532 The virtual network aware NetworkBridger.","title":"NetworkBridgerVNET"},{"location":"pypowervm/tasks/network_bridger/#signature_4","text":"class NetworkBridgerVNET(NetworkBridger): ...","title":"Signature"},{"location":"pypowervm/tasks/network_bridger/#see-also_1","text":"NetworkBridger","title":"See also"},{"location":"pypowervm/tasks/network_bridger/#ensure_vlan_on_nb","text":"Show source in network_bridger.py:86 Will make sure that the VLAN is assigned to the Network Bridge. This method will reorder the arbitrary VLAN IDs as needed (those which are the PVID of the VEAs, but not the primary VEA). VLANs are always added to VEAs that are 'non-primary' (not the first VEA). However, if the VLAN is on the primary VEA then it is left on the system. The only 'untagged' VLAN that is allowed is the primary VEA's PVID. If the VLAN specified is on another Network Bridge's VEA (which happens to be on the same virtual switch): - An error will be thrown if it is on the primary VEA. - It will be removed off the Network Bridge if it is on the non-primary VEA.","title":"ensure_vlan_on_nb"},{"location":"pypowervm/tasks/network_bridger/#arguments_2","text":"adapter - The pypowervm Adapter. host_uuid - The Server's UUID nb_uuid - The Network Bridge UUID. vlan_id - The VLAN identifier to ensure is on the system.","title":"Arguments"},{"location":"pypowervm/tasks/network_bridger/#signature_5","text":"def ensure_vlan_on_nb(adapter, host_uuid, nb_uuid, vlan_id): ...","title":"Signature"},{"location":"pypowervm/tasks/network_bridger/#ensure_vlans_on_nb","text":"Show source in network_bridger.py:58 Will make sure that the VLANs are assigned to the Network Bridge. This method will reorder the arbitrary VLAN IDs as needed (those which are the PVID of the VEAs, but not the primary VEA). VLANs are always added to VEAs that are 'non-primary' (not the first VEA). However, if the VLAN is on the primary VEA then it is left on the system. The only 'untagged' VLAN that is allowed is the primary VEA's PVID. If the VLAN specified is on another Network Bridge's VEA (which happens to be on the same virtual switch): - An error will be thrown if it is on the primary VEA. - It will be removed off the Network Bridge if it is on the non-primary VEA. This method will not remove VLAN IDs from the network bridge that aren't part of the vlan_ids list. Instead, each VLAN is simply added to the Network Bridge's VLAN list.","title":"ensure_vlans_on_nb"},{"location":"pypowervm/tasks/network_bridger/#arguments_3","text":"adapter - The pypowervm Adapter. host_uuid - The Server's UUID nb_uuid - The Network Bridge UUID. vlan_ids - The list of VLANs to ensure are on the Network Bridge.","title":"Arguments"},{"location":"pypowervm/tasks/network_bridger/#signature_6","text":"def ensure_vlans_on_nb(adapter, host_uuid, nb_uuid, vlan_ids): ...","title":"Signature"},{"location":"pypowervm/tasks/network_bridger/#remove_vlan_from_nb","text":"Show source in network_bridger.py:110 Will remove the VLAN from a given Network Bridge.","title":"remove_vlan_from_nb"},{"location":"pypowervm/tasks/network_bridger/#arguments_4","text":"adapter - The pypowervm Adapter. host_uuid - The host system UUID. nb_uuid - The Network Bridge UUID. vlan_id - The VLAN identifier. fail_if_pvid - If set to true, will raise an exception if this is the PVID on a Network Bridge. existing_nbs - Optional. If set, should be the existing network bridge wrappers. If not provided, will gather from the system directly.","title":"Arguments"},{"location":"pypowervm/tasks/network_bridger/#signature_7","text":"def remove_vlan_from_nb( adapter, host_uuid, nb_uuid, vlan_id, fail_if_pvid=False, existing_nbs=None ): ...","title":"Signature"},{"location":"pypowervm/tasks/partition/","text":"Partition Pypowervm Index / Pypowervm / Tasks / Partition Auto-generated documentation for pypowervm.tasks.partition module. Partition build_active_vio_feed_task clone_uuid get_active_vioses get_mgmt_partition get_partitions get_physical_wwpns get_this_partition has_physical_io ibmi_add_license_key validate_vios_ready build_active_vio_feed_task Show source in partition.py:204 Builds a FeedTask for all active VIOSes. The transaction FeedTask enables users to collect a set of 'WrapperTasks' against a feed of entities (in this case a set of active VIOSes). The WrapperTask (within the FeedTask) handles lock and retry. This is useful to batch together a set of updates across a feed of elements (and multiple updates within a given wrapper). This allows for significant performance improvements. Arguments adapter - The pypowervm adapter for the query. name - (Optional) The name of the feed manager. Defaults to vio_feed_task. xag - (Optional) Iterable of extended attributes to use. If not specified, defaults to all mapping/storage options (as this is most common case for using a transaction manager). Raises NotEnoughActiveVioses - if there is not at least one active VIOS. Signature def build_active_vio_feed_task( adapter, name=\"vio_feed_task\", xag=(c.XAG.VIO_STOR, c.XAG.VIO_SMAP, c.XAG.VIO_FMAP) ): ... clone_uuid Show source in partition.py:384 Issue the CloneUUID job. The CloneUUID job deletes the original LPAR and changes the surrogate LPAR's UUID to be the original LPAR's UUID. Arguments adapter - The pypowervm adapter to issue the job. lpar_uuid - Original LPAR's UUID. surrogate_lpar_name - Surrogate LPAR's name. Signature def clone_uuid(adapter, lpar_uuid, surrogate_lpar_name): ... get_active_vioses Show source in partition.py:114 Returns a list of active Virtual I/O Server Wrappers for a host. Active is defined by powered on and RMC state being 'active'. The VIOSes will be sorted such that if the Mgmt partition is a VIOS, it is the first in the list. Arguments adapter - The pypowervm adapter for the query. xag - (Optional, Default: ()) Iterable of extended attributes to use. vios_wraps - (Optional, Default: None) A list of VIOS wrappers. If specified, the method will check for active VIOSes in this list instead of issuing a GET. find_min - (Optional, Default: None) If specified, the minimum acceptable number of active VIOSes. If fewer are found, this method raises NotEnoughActiveVioses. Returns List of VIOS wrappers. Raises NotEnoughActiveVioses - If find_min is specified and the number of active VIOSes is less than the specified number. Signature def get_active_vioses(adapter, xag=(), vios_wraps=None, find_min=None): ... get_mgmt_partition Show source in partition.py:57 Get the LPAR/VIOS wrapper representing the PowerVM management partition. Arguments adapter - The pypowervm.adapter.Adapter through which to query the REST API. Returns pypowervm.wrappers.logical_partition.LPAR/virtual_io_server.VIOS wrapper representing the management partition. Raises ManagementPartitionNotFoundException - if we don't find exactly one management partition. Signature def get_mgmt_partition(adapter): ... get_partitions Show source in partition.py:151 Get a list of partitions. Can include LPARs, VIOSes, and the management partition. Arguments adapter - The pypowervm adapter. lpars - If True, the result will include all LPARs. vioses - If True, the result will include all VIOSes. mgmt - If True, the result is guaranteed to include the management partition, even if it would not otherwise have been included based on get_lpars/get_vioses. Signature def get_partitions(adapter, lpars=True, vioses=True, mgmt=False): ... get_physical_wwpns Show source in partition.py:184 Returns the active WWPNs of the FC ports across all VIOSes on system. Arguments adapter - pypowervm.adapter.Adapter for REST API communication. force_refresh - The value discovered by this method is cached. If force_refresh is False, the cached value is returned. If True, the value is refetched from the server (and re-cached). Signature def get_physical_wwpns(adapter, force_refresh=True): ... get_this_partition Show source in partition.py:85 Get the LPAR/VIOS wrapper of the node on which this method is running. Arguments adapter - The pypowervm.adapter.Adapter through which to query the REST API. Returns pypowervm.wrappers.logical_partition.LPAR/virtual_io_server.VIOS wrapper representing the local partition. Raises LocalPartitionNotFoundException - if we don't find exactly one LPAR/ VIOS with the local VM's short ID. Signature def get_this_partition(adapter): ... has_physical_io Show source in partition.py:345 Determine whether a partition has any physical I/O adapters attached. This method looks over all of the slots on the partition and returns True if any of the slots has something in it, except for the following: - USB Device - Graphics - Empty Slot All other devices are considered I/O. Arguments part_w - Wrapper (LPAR or VIOS) of the partition to check. Returns True if any physical I/O adapter was found attached to the partition; False otherwise. Signature def has_physical_io(part_w): ... ibmi_add_license_key Show source in partition.py:404 Issue the AddLicense job. The AddLicense job submits a license key to IBMi partition. Arguments adapter - The pypowervm adapter to issue the job. lpar_uuid - Original LPAR's UUID. license_key - License key for IBMi partition. Signature def ibmi_add_license_key(adapter, lpar_uuid, license_key): ... validate_vios_ready Show source in partition.py:312 Check whether VIOS rmc is up and running on this host. Will query the VIOSes for a period of time attempting to ensure all running VIOSes get an active RMC. If no VIOSes are ready by the timeout, ViosNotAvailable is raised. If only some of the VIOSes had RMC go active by the end of the wait period, the method will complete. Arguments adapter - The pypowervm adapter for the query. max_wait_time - Integer maximum number of seconds to wait for running VIOSes to get an active RMC connection. Defaults to None, in which case the system will determine an appropriate amount of time to wait. This can be influenced by whether or not the VIOS just booted. :raises: A ViosNotAvailable exception if a VIOS is not available by a given timeout. Signature def validate_vios_ready(adapter, max_wait_time=None): ...","title":"Partition"},{"location":"pypowervm/tasks/partition/#partition","text":"Pypowervm Index / Pypowervm / Tasks / Partition Auto-generated documentation for pypowervm.tasks.partition module. Partition build_active_vio_feed_task clone_uuid get_active_vioses get_mgmt_partition get_partitions get_physical_wwpns get_this_partition has_physical_io ibmi_add_license_key validate_vios_ready","title":"Partition"},{"location":"pypowervm/tasks/partition/#build_active_vio_feed_task","text":"Show source in partition.py:204 Builds a FeedTask for all active VIOSes. The transaction FeedTask enables users to collect a set of 'WrapperTasks' against a feed of entities (in this case a set of active VIOSes). The WrapperTask (within the FeedTask) handles lock and retry. This is useful to batch together a set of updates across a feed of elements (and multiple updates within a given wrapper). This allows for significant performance improvements.","title":"build_active_vio_feed_task"},{"location":"pypowervm/tasks/partition/#arguments","text":"adapter - The pypowervm adapter for the query. name - (Optional) The name of the feed manager. Defaults to vio_feed_task. xag - (Optional) Iterable of extended attributes to use. If not specified, defaults to all mapping/storage options (as this is most common case for using a transaction manager).","title":"Arguments"},{"location":"pypowervm/tasks/partition/#raises","text":"NotEnoughActiveVioses - if there is not at least one active VIOS.","title":"Raises"},{"location":"pypowervm/tasks/partition/#signature","text":"def build_active_vio_feed_task( adapter, name=\"vio_feed_task\", xag=(c.XAG.VIO_STOR, c.XAG.VIO_SMAP, c.XAG.VIO_FMAP) ): ...","title":"Signature"},{"location":"pypowervm/tasks/partition/#clone_uuid","text":"Show source in partition.py:384 Issue the CloneUUID job. The CloneUUID job deletes the original LPAR and changes the surrogate LPAR's UUID to be the original LPAR's UUID.","title":"clone_uuid"},{"location":"pypowervm/tasks/partition/#arguments_1","text":"adapter - The pypowervm adapter to issue the job. lpar_uuid - Original LPAR's UUID. surrogate_lpar_name - Surrogate LPAR's name.","title":"Arguments"},{"location":"pypowervm/tasks/partition/#signature_1","text":"def clone_uuid(adapter, lpar_uuid, surrogate_lpar_name): ...","title":"Signature"},{"location":"pypowervm/tasks/partition/#get_active_vioses","text":"Show source in partition.py:114 Returns a list of active Virtual I/O Server Wrappers for a host. Active is defined by powered on and RMC state being 'active'. The VIOSes will be sorted such that if the Mgmt partition is a VIOS, it is the first in the list.","title":"get_active_vioses"},{"location":"pypowervm/tasks/partition/#arguments_2","text":"adapter - The pypowervm adapter for the query. xag - (Optional, Default: ()) Iterable of extended attributes to use. vios_wraps - (Optional, Default: None) A list of VIOS wrappers. If specified, the method will check for active VIOSes in this list instead of issuing a GET. find_min - (Optional, Default: None) If specified, the minimum acceptable number of active VIOSes. If fewer are found, this method raises NotEnoughActiveVioses.","title":"Arguments"},{"location":"pypowervm/tasks/partition/#returns","text":"List of VIOS wrappers.","title":"Returns"},{"location":"pypowervm/tasks/partition/#raises_1","text":"NotEnoughActiveVioses - If find_min is specified and the number of active VIOSes is less than the specified number.","title":"Raises"},{"location":"pypowervm/tasks/partition/#signature_2","text":"def get_active_vioses(adapter, xag=(), vios_wraps=None, find_min=None): ...","title":"Signature"},{"location":"pypowervm/tasks/partition/#get_mgmt_partition","text":"Show source in partition.py:57 Get the LPAR/VIOS wrapper representing the PowerVM management partition.","title":"get_mgmt_partition"},{"location":"pypowervm/tasks/partition/#arguments_3","text":"adapter - The pypowervm.adapter.Adapter through which to query the REST API.","title":"Arguments"},{"location":"pypowervm/tasks/partition/#returns_1","text":"pypowervm.wrappers.logical_partition.LPAR/virtual_io_server.VIOS wrapper representing the management partition.","title":"Returns"},{"location":"pypowervm/tasks/partition/#raises_2","text":"ManagementPartitionNotFoundException - if we don't find exactly one management partition.","title":"Raises"},{"location":"pypowervm/tasks/partition/#signature_3","text":"def get_mgmt_partition(adapter): ...","title":"Signature"},{"location":"pypowervm/tasks/partition/#get_partitions","text":"Show source in partition.py:151 Get a list of partitions. Can include LPARs, VIOSes, and the management partition.","title":"get_partitions"},{"location":"pypowervm/tasks/partition/#arguments_4","text":"adapter - The pypowervm adapter. lpars - If True, the result will include all LPARs. vioses - If True, the result will include all VIOSes. mgmt - If True, the result is guaranteed to include the management partition, even if it would not otherwise have been included based on get_lpars/get_vioses.","title":"Arguments"},{"location":"pypowervm/tasks/partition/#signature_4","text":"def get_partitions(adapter, lpars=True, vioses=True, mgmt=False): ...","title":"Signature"},{"location":"pypowervm/tasks/partition/#get_physical_wwpns","text":"Show source in partition.py:184 Returns the active WWPNs of the FC ports across all VIOSes on system.","title":"get_physical_wwpns"},{"location":"pypowervm/tasks/partition/#arguments_5","text":"adapter - pypowervm.adapter.Adapter for REST API communication. force_refresh - The value discovered by this method is cached. If force_refresh is False, the cached value is returned. If True, the value is refetched from the server (and re-cached).","title":"Arguments"},{"location":"pypowervm/tasks/partition/#signature_5","text":"def get_physical_wwpns(adapter, force_refresh=True): ...","title":"Signature"},{"location":"pypowervm/tasks/partition/#get_this_partition","text":"Show source in partition.py:85 Get the LPAR/VIOS wrapper of the node on which this method is running.","title":"get_this_partition"},{"location":"pypowervm/tasks/partition/#arguments_6","text":"adapter - The pypowervm.adapter.Adapter through which to query the REST API.","title":"Arguments"},{"location":"pypowervm/tasks/partition/#returns_2","text":"pypowervm.wrappers.logical_partition.LPAR/virtual_io_server.VIOS wrapper representing the local partition.","title":"Returns"},{"location":"pypowervm/tasks/partition/#raises_3","text":"LocalPartitionNotFoundException - if we don't find exactly one LPAR/ VIOS with the local VM's short ID.","title":"Raises"},{"location":"pypowervm/tasks/partition/#signature_6","text":"def get_this_partition(adapter): ...","title":"Signature"},{"location":"pypowervm/tasks/partition/#has_physical_io","text":"Show source in partition.py:345 Determine whether a partition has any physical I/O adapters attached. This method looks over all of the slots on the partition and returns True if any of the slots has something in it, except for the following: - USB Device - Graphics - Empty Slot All other devices are considered I/O.","title":"has_physical_io"},{"location":"pypowervm/tasks/partition/#arguments_7","text":"part_w - Wrapper (LPAR or VIOS) of the partition to check.","title":"Arguments"},{"location":"pypowervm/tasks/partition/#returns_3","text":"True if any physical I/O adapter was found attached to the partition; False otherwise.","title":"Returns"},{"location":"pypowervm/tasks/partition/#signature_7","text":"def has_physical_io(part_w): ...","title":"Signature"},{"location":"pypowervm/tasks/partition/#ibmi_add_license_key","text":"Show source in partition.py:404 Issue the AddLicense job. The AddLicense job submits a license key to IBMi partition.","title":"ibmi_add_license_key"},{"location":"pypowervm/tasks/partition/#arguments_8","text":"adapter - The pypowervm adapter to issue the job. lpar_uuid - Original LPAR's UUID. license_key - License key for IBMi partition.","title":"Arguments"},{"location":"pypowervm/tasks/partition/#signature_8","text":"def ibmi_add_license_key(adapter, lpar_uuid, license_key): ...","title":"Signature"},{"location":"pypowervm/tasks/partition/#validate_vios_ready","text":"Show source in partition.py:312 Check whether VIOS rmc is up and running on this host. Will query the VIOSes for a period of time attempting to ensure all running VIOSes get an active RMC. If no VIOSes are ready by the timeout, ViosNotAvailable is raised. If only some of the VIOSes had RMC go active by the end of the wait period, the method will complete.","title":"validate_vios_ready"},{"location":"pypowervm/tasks/partition/#arguments_9","text":"adapter - The pypowervm adapter for the query. max_wait_time - Integer maximum number of seconds to wait for running VIOSes to get an active RMC connection. Defaults to None, in which case the system will determine an appropriate amount of time to wait. This can be influenced by whether or not the VIOS just booted. :raises: A ViosNotAvailable exception if a VIOS is not available by a given timeout.","title":"Arguments"},{"location":"pypowervm/tasks/partition/#signature_9","text":"def validate_vios_ready(adapter, max_wait_time=None): ...","title":"Signature"},{"location":"pypowervm/tasks/power/","text":"Power Pypowervm Index / Pypowervm / Tasks / Power Auto-generated documentation for pypowervm.tasks.power module. Power PowerOp PowerOp.start PowerOp.stop power_off power_off_progressive power_on PowerOp Show source in power.py:48 Provides granular control over a partition PowerOn/Off Job. Use the start or stop @classmethod to invoke the appropriate Job. Jobs invoked through these methods are never retried. If they fail or time out, they raise relevant exceptions - see the methods' docstrings for details. Signature class PowerOp(object): ... PowerOp.start Show source in power.py:55 Power on a partition. Arguments part - Partition (LPAR or VIOS) wrapper indicating the partition to power on. opts - An instance of power_opts.PowerOnOpts indicating additional options to specify to the PowerOn operation. By default, no additional options are used. timeout - value in seconds for specifying how long to wait for the Job to complete. synchronous - If True, this method will not return until the Job completes (whether success or failure) or times out. If False, this method will return as soon as the Job has started on the server (that is, achieved any state beyond NOT_ACTIVE). Note that timeout is still possible in this case. Raises VMPowerOnTimeout - If the Job timed out. VMPowerOnFailure - If the Job failed for some reason other than that the partition was already powered on. Signature @classmethod def start( cls, part, opts=None, timeout=CONF.pypowervm_job_request_timeout, synchronous=True ): ... PowerOp.stop Show source in power.py:93 Power off a partition. Arguments part - LPAR/VIOS wrapper indicating the partition to power off. opts - An instance of power_opts.PowerOffOpts indicating the type of shutdown to perform, and any additional options. If not specified, PowerOffOpts.soft_detect is used, with no restart. timeout - value in seconds for specifying how long to wait for the Job to complete. synchronous - If True, this method will not return until the Job completes (whether success or failure) or times out. If False, this method will return as soon as the Job has started on the server (that is, achieved any state beyond NOT_ACTIVE). Note that timeout is still possible in this case. Raises VMPowerOffTimeout - If the Job timed out. VMPowerOffFailure - If the Job failed for some reason other than that the partition was already powered off, and restart was not requested. OSShutdownNoRMC - OP_PWROFF_OS was requested on a non-IBMi partition with no RMC connection. Returns A PowerOp instance which can be invoked via the run method. Signature @classmethod def stop( cls, part, opts=None, timeout=CONF.pypowervm_job_request_timeout, synchronous=True ): ... power_off Show source in power.py:390 Will Power Off a Logical Partition or Virtual I/O Server. DEPRECATED. Use PowerOp.stop() for single power-off. Use power_off_progressive for soft-retry flows. Depending on the force_immediate flag and the partition's type and RMC state, this method may attempt increasingly aggressive mechanisms for shutting down the OS if initial attempts fail or time out. Arguments part - The LPAR/VIOS wrapper of the instance to power off. host_uuid - Not used. Retained for backward compatibility. force_immediate - DEPRECATED. If you want Force.NO_RETRY behavior, use PowerOp.stop() with the specific operation/immediate settings desired. If you want Force.TRUE behavior, use PowerOp.stop(..., opts=PowerOffOpts().vsp_hard()) If add_parms is a PowerOffOpts with an operation set, force_immediate (and restart) is ignored - the method call is equivalent to: PowerOp.stop(part, opts=add_parms, timeout=timeout) This flag retains its legacy behavior only if add_parms is either a legacy dict or a PowerOffOpts with no operation set: Force.TRUE: The force-immediate option is included on the first pass. Force.NO_RETRY: The force-immediate option is not included. If the power-off fails or times out, VMPowerOffFailure is raised immediately. Force.ON_FAILURE: The force-immediate option is not included on the first pass; but if the power-off fails (including timeout), it is retried with the force-immediate option added. restart - DEPRECATED: Use a PowerOffOpts instance for add_parms, with restart specified therein. Boolean. Perform a restart after the power off. If add_parms is a PowerOffOpts instance, this parameter is ignored. timeout - Time in seconds to wait for the instance to stop. add_parms - A power_opts.PowerOffOpts instance; or (deprecated) a dict of parameters to pass directly to the job template. If unspecified, a default PowerOffOpts instance is used, with operation/immediate/restart depending on the force_immediate and restart parameters, and no additional options. Raises VMPowerOffFailure - If the operation failed (possibly after retrying) VMPowerOffTimeout - If the operation timed out (possibly after retrying). Signature @lgc.logcall_args def power_off( part, host_uuid, force_immediate=Force.ON_FAILURE, restart=False, timeout=CONF.pypowervm_job_request_timeout, add_parms=None, ): ... power_off_progressive Show source in power.py:468 Attempt soft power-off, retrying with increasing aggression on failure. IBMi partitions always start with OS shutdown. If ibmi_immed == False, os-normal shutdown is tried first; then os-immediate; then vsp-normal; then vsp-hard. If ibmi_immed == True, os-normal is skipped, but the rest of the progression is the same. For non-IBMi partitions: If RMC is up, os-immediate is tried first. If this times out, vsp hard is performed next; otherwise, vsp-normal is attempted before vsp-hard. If RMC is down, vsp-normal is tried first, then vsp-hard. Arguments part - The LPAR/VIOS wrapper of the instance to power off. restart - Boolean. Perform a restart after the power off. ibmi_immed - Boolean. Indicates whether to try os-normal first (False, the default) before progressing to os-immediate. If True, skip trying os-normal shutdown. Only applies to IBMi partitions. timeout - Time in seconds to wait for the instance to stop. This is only applied to the first attempt in the progression. Raises VMPowerOffFailure - If the last attempt in the progression failed. VMPowerOffTimeout - If the last attempt in the progression timed out. Signature def power_off_progressive( part, restart=False, ibmi_immed=False, timeout=CONF.pypowervm_job_request_timeout ): ... power_on Show source in power.py:205 Will Power On a Logical Partition or Virtual I/O Server. Arguments part - The LPAR/VIOS wrapper of the partition to power on. host_uuid - Not used. Retained for backward compatibility. add_parms - A power_opts.PowerOnOpts instance; or (deprecated) a dict of parameters to pass directly to the job template. If unspecified, a default PowerOnOpts instance is used, with no additional parameters. synchronous - If True (the default), this method will not return until the PowerOn Job completes (whether success or failure) or times out. If False, this method will return as soon as the Job has started on the server (that is, achieved any state beyond NOT_ACTIVE). Note that timeout is still possible in this case. Raises VMPowerOnFailure - If the operation failed. VMPowerOnTimeout - If the operation timed out. Signature @lgc.logcall_args def power_on(part, host_uuid, add_parms=None, synchronous=True): ...","title":"Power"},{"location":"pypowervm/tasks/power/#power","text":"Pypowervm Index / Pypowervm / Tasks / Power Auto-generated documentation for pypowervm.tasks.power module. Power PowerOp PowerOp.start PowerOp.stop power_off power_off_progressive power_on","title":"Power"},{"location":"pypowervm/tasks/power/#powerop","text":"Show source in power.py:48 Provides granular control over a partition PowerOn/Off Job. Use the start or stop @classmethod to invoke the appropriate Job. Jobs invoked through these methods are never retried. If they fail or time out, they raise relevant exceptions - see the methods' docstrings for details.","title":"PowerOp"},{"location":"pypowervm/tasks/power/#signature","text":"class PowerOp(object): ...","title":"Signature"},{"location":"pypowervm/tasks/power/#poweropstart","text":"Show source in power.py:55 Power on a partition.","title":"PowerOp.start"},{"location":"pypowervm/tasks/power/#arguments","text":"part - Partition (LPAR or VIOS) wrapper indicating the partition to power on. opts - An instance of power_opts.PowerOnOpts indicating additional options to specify to the PowerOn operation. By default, no additional options are used. timeout - value in seconds for specifying how long to wait for the Job to complete. synchronous - If True, this method will not return until the Job completes (whether success or failure) or times out. If False, this method will return as soon as the Job has started on the server (that is, achieved any state beyond NOT_ACTIVE). Note that timeout is still possible in this case.","title":"Arguments"},{"location":"pypowervm/tasks/power/#raises","text":"VMPowerOnTimeout - If the Job timed out. VMPowerOnFailure - If the Job failed for some reason other than that the partition was already powered on.","title":"Raises"},{"location":"pypowervm/tasks/power/#signature_1","text":"@classmethod def start( cls, part, opts=None, timeout=CONF.pypowervm_job_request_timeout, synchronous=True ): ...","title":"Signature"},{"location":"pypowervm/tasks/power/#poweropstop","text":"Show source in power.py:93 Power off a partition.","title":"PowerOp.stop"},{"location":"pypowervm/tasks/power/#arguments_1","text":"part - LPAR/VIOS wrapper indicating the partition to power off. opts - An instance of power_opts.PowerOffOpts indicating the type of shutdown to perform, and any additional options. If not specified, PowerOffOpts.soft_detect is used, with no restart. timeout - value in seconds for specifying how long to wait for the Job to complete. synchronous - If True, this method will not return until the Job completes (whether success or failure) or times out. If False, this method will return as soon as the Job has started on the server (that is, achieved any state beyond NOT_ACTIVE). Note that timeout is still possible in this case.","title":"Arguments"},{"location":"pypowervm/tasks/power/#raises_1","text":"VMPowerOffTimeout - If the Job timed out. VMPowerOffFailure - If the Job failed for some reason other than that the partition was already powered off, and restart was not requested. OSShutdownNoRMC - OP_PWROFF_OS was requested on a non-IBMi partition with no RMC connection.","title":"Raises"},{"location":"pypowervm/tasks/power/#returns","text":"A PowerOp instance which can be invoked via the run method.","title":"Returns"},{"location":"pypowervm/tasks/power/#signature_2","text":"@classmethod def stop( cls, part, opts=None, timeout=CONF.pypowervm_job_request_timeout, synchronous=True ): ...","title":"Signature"},{"location":"pypowervm/tasks/power/#power_off","text":"Show source in power.py:390 Will Power Off a Logical Partition or Virtual I/O Server. DEPRECATED. Use PowerOp.stop() for single power-off. Use power_off_progressive for soft-retry flows. Depending on the force_immediate flag and the partition's type and RMC state, this method may attempt increasingly aggressive mechanisms for shutting down the OS if initial attempts fail or time out.","title":"power_off"},{"location":"pypowervm/tasks/power/#arguments_2","text":"part - The LPAR/VIOS wrapper of the instance to power off. host_uuid - Not used. Retained for backward compatibility. force_immediate - DEPRECATED. If you want Force.NO_RETRY behavior, use PowerOp.stop() with the specific operation/immediate settings desired. If you want Force.TRUE behavior, use PowerOp.stop(..., opts=PowerOffOpts().vsp_hard()) If add_parms is a PowerOffOpts with an operation set, force_immediate (and restart) is ignored - the method call is equivalent to: PowerOp.stop(part, opts=add_parms, timeout=timeout) This flag retains its legacy behavior only if add_parms is either a legacy dict or a PowerOffOpts with no operation set: Force.TRUE: The force-immediate option is included on the first pass. Force.NO_RETRY: The force-immediate option is not included. If the power-off fails or times out, VMPowerOffFailure is raised immediately. Force.ON_FAILURE: The force-immediate option is not included on the first pass; but if the power-off fails (including timeout), it is retried with the force-immediate option added. restart - DEPRECATED: Use a PowerOffOpts instance for add_parms, with restart specified therein. Boolean. Perform a restart after the power off. If add_parms is a PowerOffOpts instance, this parameter is ignored. timeout - Time in seconds to wait for the instance to stop. add_parms - A power_opts.PowerOffOpts instance; or (deprecated) a dict of parameters to pass directly to the job template. If unspecified, a default PowerOffOpts instance is used, with operation/immediate/restart depending on the force_immediate and restart parameters, and no additional options.","title":"Arguments"},{"location":"pypowervm/tasks/power/#raises_2","text":"VMPowerOffFailure - If the operation failed (possibly after retrying) VMPowerOffTimeout - If the operation timed out (possibly after retrying).","title":"Raises"},{"location":"pypowervm/tasks/power/#signature_3","text":"@lgc.logcall_args def power_off( part, host_uuid, force_immediate=Force.ON_FAILURE, restart=False, timeout=CONF.pypowervm_job_request_timeout, add_parms=None, ): ...","title":"Signature"},{"location":"pypowervm/tasks/power/#power_off_progressive","text":"Show source in power.py:468 Attempt soft power-off, retrying with increasing aggression on failure. IBMi partitions always start with OS shutdown. If ibmi_immed == False, os-normal shutdown is tried first; then os-immediate; then vsp-normal; then vsp-hard. If ibmi_immed == True, os-normal is skipped, but the rest of the progression is the same. For non-IBMi partitions: If RMC is up, os-immediate is tried first. If this times out, vsp hard is performed next; otherwise, vsp-normal is attempted before vsp-hard. If RMC is down, vsp-normal is tried first, then vsp-hard.","title":"power_off_progressive"},{"location":"pypowervm/tasks/power/#arguments_3","text":"part - The LPAR/VIOS wrapper of the instance to power off. restart - Boolean. Perform a restart after the power off. ibmi_immed - Boolean. Indicates whether to try os-normal first (False, the default) before progressing to os-immediate. If True, skip trying os-normal shutdown. Only applies to IBMi partitions. timeout - Time in seconds to wait for the instance to stop. This is only applied to the first attempt in the progression.","title":"Arguments"},{"location":"pypowervm/tasks/power/#raises_3","text":"VMPowerOffFailure - If the last attempt in the progression failed. VMPowerOffTimeout - If the last attempt in the progression timed out.","title":"Raises"},{"location":"pypowervm/tasks/power/#signature_4","text":"def power_off_progressive( part, restart=False, ibmi_immed=False, timeout=CONF.pypowervm_job_request_timeout ): ...","title":"Signature"},{"location":"pypowervm/tasks/power/#power_on","text":"Show source in power.py:205 Will Power On a Logical Partition or Virtual I/O Server.","title":"power_on"},{"location":"pypowervm/tasks/power/#arguments_4","text":"part - The LPAR/VIOS wrapper of the partition to power on. host_uuid - Not used. Retained for backward compatibility. add_parms - A power_opts.PowerOnOpts instance; or (deprecated) a dict of parameters to pass directly to the job template. If unspecified, a default PowerOnOpts instance is used, with no additional parameters. synchronous - If True (the default), this method will not return until the PowerOn Job completes (whether success or failure) or times out. If False, this method will return as soon as the Job has started on the server (that is, achieved any state beyond NOT_ACTIVE). Note that timeout is still possible in this case.","title":"Arguments"},{"location":"pypowervm/tasks/power/#raises_4","text":"VMPowerOnFailure - If the operation failed. VMPowerOnTimeout - If the operation timed out.","title":"Raises"},{"location":"pypowervm/tasks/power/#signature_5","text":"@lgc.logcall_args def power_on(part, host_uuid, add_parms=None, synchronous=True): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/","text":"Power Opts Pypowervm Index / Pypowervm / Tasks / Power Opts Auto-generated documentation for pypowervm.tasks.power_opts module. Power Opts BootMode Force IBMiOperationType KeylockPos PowerOffOperation PowerOffOpts PowerOffOpts.can_os_shutdown PowerOffOpts().immediate PowerOffOpts().is_immediate PowerOffOpts().is_os PowerOffOpts().is_restart PowerOffOpts().operation PowerOffOpts().os_immediate PowerOffOpts().os_normal PowerOffOpts().restart PowerOffOpts().soft_detect PowerOffOpts().vsp_hard PowerOffOpts().vsp_normal PowerOnOpts PowerOnOpts().bootmode PowerOnOpts().bootstring PowerOnOpts().force PowerOnOpts().ibmi_ipl_source PowerOnOpts().ibmi_netboot_params PowerOnOpts().ibmi_op_type PowerOnOpts().keylock_pos PowerOnOpts().remove_optical RemoveOptical RemoveOptical.bld_map BootMode Show source in power_opts.py:34 Valid values for the 'bootmode' parameter in power_on. Not to be confused with pypowervm.wrappers.base_partition.BootMode. Example usage: power_on(..., add_parms={BootMode.KEY: BootMode.SMS, ...}) Signature class BootMode(object): ... Force Show source in power_opts.py:105 Attributes TRUE - The force-immediate option is included on the first pass.: True ON_FAILURE - The force-immediate option is not included on the first pass; but if the power-off fails, it is retried with the force-immediate option included. This value is False for backward compatibility.: False NO_RETRY - The force-immediate option is not included. If the power-off fails, it is not retried.: 'no retry' Enumeration indicating the strategy for forcing power-off. Signature class Force(object): ... IBMiOperationType Show source in power_opts.py:87 Valid values for the IBMi operation type in power_on. Signature class IBMiOperationType(object): ... KeylockPos Show source in power_opts.py:52 Valid values for the 'keylock' parameter in power_on. Not to be confused with pypowervm.wrappers.base_partition.KeylockPos. Example usage: power_on(..., add_parms={KeylockPos.KEY: KeylockPos.MANUAL, ...}) Signature class KeylockPos(object): ... PowerOffOperation Show source in power_opts.py:96 Valid values for the operation in power_off. Signature class PowerOffOperation(object): ... PowerOffOpts Show source in power_opts.py:295 Job parameters for pypowervm.tasks.power.power_off/PowerOp.stop. Use one of os_normal, os_immediate, vsp_normal, vsp_hard, or soft_detect. Optionally specify restart. Signature class PowerOffOpts(_PowerOpts): ... PowerOffOpts.can_os_shutdown Show source in power_opts.py:336 Can the specified partition perform an OS shutdown? Arguments part - LPAR/VIOS wrapper indicating the partition to inspect. Returns True if the specified partition is capable of OS shutdown; False otherwise. Signature @staticmethod def can_os_shutdown(part): ... PowerOffOpts().immediate Show source in power_opts.py:305 Whether to include immediate=true. This corresponds to \"hard\" for VSP, \"immediate\" for OS. This should only be used with operation(DUMPRESTART). Otherwise, one of the os_normal, os_immediate, vsp_normal, vsp_hard, or soft_detect methods should be used. Arguments value - A bool (True/False) or string ('true', 'false', case-insensitive). Returns Type: self For chaining. Signature def immediate(self, value=True): ... PowerOffOpts().is_immediate Show source in power_opts.py:320 Signature @property def is_immediate(self): ... PowerOffOpts().is_os Show source in power_opts.py:349 Signature @property def is_os(self): ... PowerOffOpts().is_restart Show source in power_opts.py:362 Signature @property def is_restart(self): ... PowerOffOpts().operation Show source in power_opts.py:324 The PowerOff operation to perform. This should only be used for DUMPRESTART. Otherwise, one of the os_normal, os_immediate, vsp_normal, vsp_hard, or soft_detect methods should be used. Arguments value - One of the PowerOffOperation enum values. Returns Type: self For chaining. Signature def operation(self, value): ... PowerOffOpts().os_immediate Show source in power_opts.py:375 Set up immediate OS shutdown. Sends the 'shutdown -t now' command to the operating system. Returns Type: self For chaining. Signature def os_immediate(self): ... PowerOffOpts().os_normal Show source in power_opts.py:366 Set up normal OS shutdown. Sends the 'shutdown' command to the operating system. Returns Type: self For chaining. Signature def os_normal(self): ... PowerOffOpts().restart Show source in power_opts.py:353 Whether to restart the partition after power-off. Arguments value - A bool (True/False) or string ('true', 'false', case-insensitive). Default: True. Returns Type: self For chaining. Signature def restart(self, value=True): ... PowerOffOpts().soft_detect Show source in power_opts.py:405 Determine the appropriate soft shutdown operation for a partition. For IBMi partitions, this will always set up an OS shutdown. For non-IBMi partitions with active RMC, this will set up an OS shutdown. For non-IBMi partitions without RMC, this will set up a normal VSP shutdown. Arguments part - LPAR or VIOS wrapper indicating the partition being shut down. immed_if_os - If this method determines that an OS shutdown is to be performed, this parameter indicates whether that shutdown should be immediate (True) or not (False). The default is False for IBMi partitions, and True for non-IBMi partitions. This parameter is ignored if a VSP shutdown is detected. Returns Type: self For chaining. Signature def soft_detect(self, part, immed_if_os=None): ... PowerOffOpts().vsp_hard Show source in power_opts.py:394 Set up hard VSP shutdown. Akin to pulling the plug from the partition. Processors are stopped immediately, and any pending I/O is lost. May result in data corruption. Returns Type: self For chaining. Signature def vsp_hard(self): ... PowerOffOpts().vsp_normal Show source in power_opts.py:384 Set up normal VSP shutdown. The Virtual Service Processor sends the equivalent of an EPOW event to the operating system. The result is OS-dependent. Returns Type: self For chaining. Signature def vsp_normal(self): ... PowerOnOpts Show source in power_opts.py:196 Job parameters for pypowervm.tasks.power.power_on/PowerOp.start. Signature class PowerOnOpts(_PowerOpts): ... PowerOnOpts().bootmode Show source in power_opts.py:201 Set the boot mode. Arguments value - One of the BootMode enum values. Returns Type: self For chaining. Signature def bootmode(self, value): ... PowerOnOpts().bootstring Show source in power_opts.py:217 Set the boot string. Arguments value - The boot string to use. Returns Type: self For chaining. Signature def bootstring(self, value): ... PowerOnOpts().force Show source in power_opts.py:226 Add the force option. Arguments value - A bool (True/False) or string ('true', 'false', case-insensitive). Default: True. Returns Type: self For chaining. Signature def force(self, value=True): ... PowerOnOpts().ibmi_ipl_source Show source in power_opts.py:245 Set the IBMi IPL Source. Arguments value - One of the IPLSrc enum values. Returns Type: self For chaining. Signature def ibmi_ipl_source(self, value): ... PowerOnOpts().ibmi_netboot_params Show source in power_opts.py:261 Set parameters for IBMi netboot. Use with ibmi_op_type(IBMiOperationType.NETBOOT). Arguments ipaddr - IP (v4 or v6) address of the client VM. serverip - IP (v4 or v6) address of the netboot server. gateway - IP (v4 or v6) address of the gateway. serverdir - Location of the netboot image on the server. subnet - Subnet mask. IPv4 only. connspeed - Connection speed. duplex - Duplex mode. mtu - Maximum Transmission Unit. vlanid - VLAN ID. Returns Type: self For chaining. Signature def ibmi_netboot_params( self, ipaddr, serverip, gateway, serverdir, subnet=None, connspeed=None, duplex=None, mtu=None, vlanid=None, ): ... PowerOnOpts().ibmi_op_type Show source in power_opts.py:253 Set the IBMi Operation Type. Arguments value - One of the IBMiOperationType enum values. Returns Type: self For chaining. Signature def ibmi_op_type(self, value): ... PowerOnOpts().keylock_pos Show source in power_opts.py:209 Set the Keylock Position. Arguments value - One of the KeylockPos enum values. Returns Type: self For chaining. Signature def keylock_pos(self, value): ... PowerOnOpts().remove_optical Show source in power_opts.py:235 Add options to remove an optical drive after boot. Arguments name - The name of a VirtualOpticalMedia name to remove. time - The time, in minutes, to wait before deleting the media. Returns Type: self For chaining. Signature def remove_optical(self, name, time=0): ... RemoveOptical Show source in power_opts.py:67 Valid values for the 'remove_optical_*' parameters in power_on. This is primarily used to remove the config drive after install. KEY_NAME is required and maps to a VirtualOpticalMedia name to remove. KEY_TIME is optional and maps to the time, in minutes, to wait before deleting the media. Example usage: power_on(..., add_parms={RemoveOptical.KEY_TIME: , RemoveOptical.KEY_NAME: }, ...) Signature class RemoveOptical(object): ... RemoveOptical.bld_map Show source in power_opts.py:82 Signature @classmethod def bld_map(cls, name, time=0): ...","title":"Power Opts"},{"location":"pypowervm/tasks/power_opts/#power-opts","text":"Pypowervm Index / Pypowervm / Tasks / Power Opts Auto-generated documentation for pypowervm.tasks.power_opts module. Power Opts BootMode Force IBMiOperationType KeylockPos PowerOffOperation PowerOffOpts PowerOffOpts.can_os_shutdown PowerOffOpts().immediate PowerOffOpts().is_immediate PowerOffOpts().is_os PowerOffOpts().is_restart PowerOffOpts().operation PowerOffOpts().os_immediate PowerOffOpts().os_normal PowerOffOpts().restart PowerOffOpts().soft_detect PowerOffOpts().vsp_hard PowerOffOpts().vsp_normal PowerOnOpts PowerOnOpts().bootmode PowerOnOpts().bootstring PowerOnOpts().force PowerOnOpts().ibmi_ipl_source PowerOnOpts().ibmi_netboot_params PowerOnOpts().ibmi_op_type PowerOnOpts().keylock_pos PowerOnOpts().remove_optical RemoveOptical RemoveOptical.bld_map","title":"Power Opts"},{"location":"pypowervm/tasks/power_opts/#bootmode","text":"Show source in power_opts.py:34 Valid values for the 'bootmode' parameter in power_on. Not to be confused with pypowervm.wrappers.base_partition.BootMode. Example usage: power_on(..., add_parms={BootMode.KEY: BootMode.SMS, ...})","title":"BootMode"},{"location":"pypowervm/tasks/power_opts/#signature","text":"class BootMode(object): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#force","text":"Show source in power_opts.py:105","title":"Force"},{"location":"pypowervm/tasks/power_opts/#attributes","text":"TRUE - The force-immediate option is included on the first pass.: True ON_FAILURE - The force-immediate option is not included on the first pass; but if the power-off fails, it is retried with the force-immediate option included. This value is False for backward compatibility.: False NO_RETRY - The force-immediate option is not included. If the power-off fails, it is not retried.: 'no retry' Enumeration indicating the strategy for forcing power-off.","title":"Attributes"},{"location":"pypowervm/tasks/power_opts/#signature_1","text":"class Force(object): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#ibmioperationtype","text":"Show source in power_opts.py:87 Valid values for the IBMi operation type in power_on.","title":"IBMiOperationType"},{"location":"pypowervm/tasks/power_opts/#signature_2","text":"class IBMiOperationType(object): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#keylockpos","text":"Show source in power_opts.py:52 Valid values for the 'keylock' parameter in power_on. Not to be confused with pypowervm.wrappers.base_partition.KeylockPos. Example usage: power_on(..., add_parms={KeylockPos.KEY: KeylockPos.MANUAL, ...})","title":"KeylockPos"},{"location":"pypowervm/tasks/power_opts/#signature_3","text":"class KeylockPos(object): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoperation","text":"Show source in power_opts.py:96 Valid values for the operation in power_off.","title":"PowerOffOperation"},{"location":"pypowervm/tasks/power_opts/#signature_4","text":"class PowerOffOperation(object): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffopts","text":"Show source in power_opts.py:295 Job parameters for pypowervm.tasks.power.power_off/PowerOp.stop. Use one of os_normal, os_immediate, vsp_normal, vsp_hard, or soft_detect. Optionally specify restart.","title":"PowerOffOpts"},{"location":"pypowervm/tasks/power_opts/#signature_5","text":"class PowerOffOpts(_PowerOpts): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptscan_os_shutdown","text":"Show source in power_opts.py:336 Can the specified partition perform an OS shutdown?","title":"PowerOffOpts.can_os_shutdown"},{"location":"pypowervm/tasks/power_opts/#arguments","text":"part - LPAR/VIOS wrapper indicating the partition to inspect.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns","text":"True if the specified partition is capable of OS shutdown; False otherwise.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_6","text":"@staticmethod def can_os_shutdown(part): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptsimmediate","text":"Show source in power_opts.py:305 Whether to include immediate=true. This corresponds to \"hard\" for VSP, \"immediate\" for OS. This should only be used with operation(DUMPRESTART). Otherwise, one of the os_normal, os_immediate, vsp_normal, vsp_hard, or soft_detect methods should be used.","title":"PowerOffOpts().immediate"},{"location":"pypowervm/tasks/power_opts/#arguments_1","text":"value - A bool (True/False) or string ('true', 'false', case-insensitive).","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_1","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_7","text":"def immediate(self, value=True): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptsis_immediate","text":"Show source in power_opts.py:320","title":"PowerOffOpts().is_immediate"},{"location":"pypowervm/tasks/power_opts/#signature_8","text":"@property def is_immediate(self): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptsis_os","text":"Show source in power_opts.py:349","title":"PowerOffOpts().is_os"},{"location":"pypowervm/tasks/power_opts/#signature_9","text":"@property def is_os(self): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptsis_restart","text":"Show source in power_opts.py:362","title":"PowerOffOpts().is_restart"},{"location":"pypowervm/tasks/power_opts/#signature_10","text":"@property def is_restart(self): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptsoperation","text":"Show source in power_opts.py:324 The PowerOff operation to perform. This should only be used for DUMPRESTART. Otherwise, one of the os_normal, os_immediate, vsp_normal, vsp_hard, or soft_detect methods should be used.","title":"PowerOffOpts().operation"},{"location":"pypowervm/tasks/power_opts/#arguments_2","text":"value - One of the PowerOffOperation enum values.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_2","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_11","text":"def operation(self, value): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptsos_immediate","text":"Show source in power_opts.py:375 Set up immediate OS shutdown. Sends the 'shutdown -t now' command to the operating system.","title":"PowerOffOpts().os_immediate"},{"location":"pypowervm/tasks/power_opts/#returns_3","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_12","text":"def os_immediate(self): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptsos_normal","text":"Show source in power_opts.py:366 Set up normal OS shutdown. Sends the 'shutdown' command to the operating system.","title":"PowerOffOpts().os_normal"},{"location":"pypowervm/tasks/power_opts/#returns_4","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_13","text":"def os_normal(self): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptsrestart","text":"Show source in power_opts.py:353 Whether to restart the partition after power-off.","title":"PowerOffOpts().restart"},{"location":"pypowervm/tasks/power_opts/#arguments_3","text":"value - A bool (True/False) or string ('true', 'false', case-insensitive). Default: True.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_5","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_14","text":"def restart(self, value=True): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptssoft_detect","text":"Show source in power_opts.py:405 Determine the appropriate soft shutdown operation for a partition. For IBMi partitions, this will always set up an OS shutdown. For non-IBMi partitions with active RMC, this will set up an OS shutdown. For non-IBMi partitions without RMC, this will set up a normal VSP shutdown.","title":"PowerOffOpts().soft_detect"},{"location":"pypowervm/tasks/power_opts/#arguments_4","text":"part - LPAR or VIOS wrapper indicating the partition being shut down. immed_if_os - If this method determines that an OS shutdown is to be performed, this parameter indicates whether that shutdown should be immediate (True) or not (False). The default is False for IBMi partitions, and True for non-IBMi partitions. This parameter is ignored if a VSP shutdown is detected.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_6","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_15","text":"def soft_detect(self, part, immed_if_os=None): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptsvsp_hard","text":"Show source in power_opts.py:394 Set up hard VSP shutdown. Akin to pulling the plug from the partition. Processors are stopped immediately, and any pending I/O is lost. May result in data corruption.","title":"PowerOffOpts().vsp_hard"},{"location":"pypowervm/tasks/power_opts/#returns_7","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_16","text":"def vsp_hard(self): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweroffoptsvsp_normal","text":"Show source in power_opts.py:384 Set up normal VSP shutdown. The Virtual Service Processor sends the equivalent of an EPOW event to the operating system. The result is OS-dependent.","title":"PowerOffOpts().vsp_normal"},{"location":"pypowervm/tasks/power_opts/#returns_8","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_17","text":"def vsp_normal(self): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweronopts","text":"Show source in power_opts.py:196 Job parameters for pypowervm.tasks.power.power_on/PowerOp.start.","title":"PowerOnOpts"},{"location":"pypowervm/tasks/power_opts/#signature_18","text":"class PowerOnOpts(_PowerOpts): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweronoptsbootmode","text":"Show source in power_opts.py:201 Set the boot mode.","title":"PowerOnOpts().bootmode"},{"location":"pypowervm/tasks/power_opts/#arguments_5","text":"value - One of the BootMode enum values.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_9","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_19","text":"def bootmode(self, value): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweronoptsbootstring","text":"Show source in power_opts.py:217 Set the boot string.","title":"PowerOnOpts().bootstring"},{"location":"pypowervm/tasks/power_opts/#arguments_6","text":"value - The boot string to use.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_10","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_20","text":"def bootstring(self, value): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweronoptsforce","text":"Show source in power_opts.py:226 Add the force option.","title":"PowerOnOpts().force"},{"location":"pypowervm/tasks/power_opts/#arguments_7","text":"value - A bool (True/False) or string ('true', 'false', case-insensitive). Default: True.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_11","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_21","text":"def force(self, value=True): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweronoptsibmi_ipl_source","text":"Show source in power_opts.py:245 Set the IBMi IPL Source.","title":"PowerOnOpts().ibmi_ipl_source"},{"location":"pypowervm/tasks/power_opts/#arguments_8","text":"value - One of the IPLSrc enum values.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_12","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_22","text":"def ibmi_ipl_source(self, value): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweronoptsibmi_netboot_params","text":"Show source in power_opts.py:261 Set parameters for IBMi netboot. Use with ibmi_op_type(IBMiOperationType.NETBOOT).","title":"PowerOnOpts().ibmi_netboot_params"},{"location":"pypowervm/tasks/power_opts/#arguments_9","text":"ipaddr - IP (v4 or v6) address of the client VM. serverip - IP (v4 or v6) address of the netboot server. gateway - IP (v4 or v6) address of the gateway. serverdir - Location of the netboot image on the server. subnet - Subnet mask. IPv4 only. connspeed - Connection speed. duplex - Duplex mode. mtu - Maximum Transmission Unit. vlanid - VLAN ID.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_13","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_23","text":"def ibmi_netboot_params( self, ipaddr, serverip, gateway, serverdir, subnet=None, connspeed=None, duplex=None, mtu=None, vlanid=None, ): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweronoptsibmi_op_type","text":"Show source in power_opts.py:253 Set the IBMi Operation Type.","title":"PowerOnOpts().ibmi_op_type"},{"location":"pypowervm/tasks/power_opts/#arguments_10","text":"value - One of the IBMiOperationType enum values.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_14","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_24","text":"def ibmi_op_type(self, value): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweronoptskeylock_pos","text":"Show source in power_opts.py:209 Set the Keylock Position.","title":"PowerOnOpts().keylock_pos"},{"location":"pypowervm/tasks/power_opts/#arguments_11","text":"value - One of the KeylockPos enum values.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_15","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_25","text":"def keylock_pos(self, value): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#poweronoptsremove_optical","text":"Show source in power_opts.py:235 Add options to remove an optical drive after boot.","title":"PowerOnOpts().remove_optical"},{"location":"pypowervm/tasks/power_opts/#arguments_12","text":"name - The name of a VirtualOpticalMedia name to remove. time - The time, in minutes, to wait before deleting the media.","title":"Arguments"},{"location":"pypowervm/tasks/power_opts/#returns_16","text":"Type: self For chaining.","title":"Returns"},{"location":"pypowervm/tasks/power_opts/#signature_26","text":"def remove_optical(self, name, time=0): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#removeoptical","text":"Show source in power_opts.py:67 Valid values for the 'remove_optical_*' parameters in power_on. This is primarily used to remove the config drive after install. KEY_NAME is required and maps to a VirtualOpticalMedia name to remove. KEY_TIME is optional and maps to the time, in minutes, to wait before deleting the media. Example usage: power_on(..., add_parms={RemoveOptical.KEY_TIME: , RemoveOptical.KEY_NAME: }, ...)","title":"RemoveOptical"},{"location":"pypowervm/tasks/power_opts/#signature_27","text":"class RemoveOptical(object): ...","title":"Signature"},{"location":"pypowervm/tasks/power_opts/#removeopticalbld_map","text":"Show source in power_opts.py:82","title":"RemoveOptical.bld_map"},{"location":"pypowervm/tasks/power_opts/#signature_28","text":"@classmethod def bld_map(cls, name, time=0): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/","text":"Scsi Mapper Pypowervm Index / Pypowervm / Tasks / Scsi Mapper Auto-generated documentation for pypowervm.tasks.scsi_mapper module. Scsi Mapper add_map add_vscsi_mapping build_vscsi_mapping detach_storage find_maps gen_match_func index_mappings modify_vopt_mapping remove_lu_mapping remove_maps remove_pv_mapping remove_vdisk_mapping remove_vopt_mapping add_map Show source in scsi_mapper.py:231 Will add the mapping to the VIOS wrapper, if not already included. This method has the logic in place to detect if the storage from the mapping is already part of a SCSI mapping. If so, it will not re-add the mapping to the VIOS wrapper. The new mapping is added to the wrapper, but it is up to the invoker to call the update method on the wrapper. Arguments vios_w - The Virtual I/O Server wrapping to add the mapping to. scsi_mapping - The scsi mapping to include in the VIOS. Returns The scsi_mapping that was added. None if the mapping was already on the vios_w. Signature def add_map(vios_w, scsi_mapping): ... add_vscsi_mapping Show source in scsi_mapper.py:47 Will add a vSCSI mapping to a Virtual I/O Server. This method is used to connect a storage element (either a vDisk, vOpt, PV or LU) that resides on a Virtual I/O Server to a Virtual Machine. This is achieved using a 'vSCSI Mapping'. The invoker does not need to interact with the mapping. A given mapping is essentially a 'vSCSI bus', which can host multiple storage elements. This method has a fuse limit which throttles the number of devices on a given vSCSI bus. The throttle should be lower if the storage elements are high I/O, and higher otherwise. Arguments host_uuid - Not used. vios - The virtual I/O server to which the mapping should be added. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. lpar_uuid - The UUID of the LPAR that will have the connected storage. storage_elem - The storage element (either a vDisk, vOpt, LU or PV) that is to be connected. fuse_limit - (Optional, Default: 32) The max number of devices to allow on one scsi bus before creating a second SCSI bus. lpar_slot_num - (Optional, Default: None) The slot number for the client LPAR to use in the mapping. If None, the next available slot number is assigned by the server. lua - (Optional. Default: None) Logical Unit Address to set on the TargetDevice. If None, the LUA will be assigned by the server. Should be specified for all of the VSCSIMappings for a particular bus, or none of them. Returns The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. Signature @lock.synchronized(\"vscsi_mapping\") @pvm_retry.retry( tries=60, argmod_func=_argmod, delay_func=pvm_retry.STEPPED_RANDOM_DELAY ) def add_vscsi_mapping( host_uuid, vios, lpar_uuid, storage_elem, fuse_limit=32, lpar_slot_num=None, lua=None ): ... build_vscsi_mapping Show source in scsi_mapper.py:128 Will build a vSCSI mapping that can be added to a VIOS. This method is used to create a mapping element (for either a vDisk, vOpt, PV or LU) that connects a Virtual I/O Server to a LPAR. A given mapping is essentially a 'vSCSI bus', which can host multiple storage elements. This method has a fuse limit which throttles the number of devices on a given vSCSI bus. The throttle should be lower if the storage elements are high I/O, and higher otherwise. Arguments host_uuid - Not used. vios_w - The virtual I/O server wrapper that the mapping is intended to be attached to. The method will call the update against the API. It will only update the in memory wrapper. lpar_uuid - The UUID of the LPAR that will have the connected storage. storage_elem - The storage element (either a vDisk, vOpt, LU or PV) that is to be connected. fuse_limit - (Optional, Default: 32) The max number of devices to allow on one scsi bus before creating a second SCSI bus. lpar_slot_num - (Optional, Default: None) The slot number for the client LPAR to use in the mapping. If None, the next available slot number is assigned by the server. lua - (Optional. Default: None) Logical Unit Address to set on the TargetDevice. If None, the LUA will be assigned by the server. Should be specified for all of the VSCSIMappings for a particular bus, or none of them. target_name - (Optional, Default: None) The name of the Target mapping. If None, the target_name will be assigned by the server. Returns The SCSI mapping that can be added to the vios_w. This does not do any updates to the wrapper itself. Signature def build_vscsi_mapping( host_uuid, vios_w, lpar_uuid, storage_elem, fuse_limit=32, lpar_slot_num=None, lua=None, target_name=None, ): ... detach_storage Show source in scsi_mapper.py:286 Detach the storage from all matching SCSI mappings. We do this by removing the Storage and TargetDevice child elements. This method only updates the vwrap. It does not POST back to the REST server. It does not lock. Arguments vwrap - VIOS EntryWrapper representing the Virtual I/O Server whose SCSI mappings are to be updated. client_lpar_id - The integer short ID or string UUID of the client VM match_func - (Optional) Matching function suitable for passing to find_maps. See that method's match_func parameter. Defaults to None (match only on client_lpar_id). Returns The list of SCSI mappings which were modified, in their original (storage-attached) form. Signature def detach_storage(vwrap, client_lpar_id, match_func=None): ... find_maps Show source in scsi_mapper.py:445 Filter a list of scsi mappings by LPAR ID/UUID and a matching function. Arguments mapping_list - The mappings to filter. Iterable of VSCSIMapping. client_lpar_id - Integer short ID or string UUID of the LPAR on the client side of the mapping. Note that the UUID form relies on the presence of the client_lpar_href field. Some mappings lack this field, and would therefore be ignored. If client_lpar_id is not passed it will return matching mappings for all the lpar_ids. match_func - Callable with the following specification: def match_func(storage_elem) param storage_elem: A backing storage element wrapper (VOpt, VDisk, PV, or LU) to be analyzed. May be None (some mappings have no backing storage). return: True if the storage_elem's mapping should be included; False otherwise. If neither match_func nor stg_elem is specified, the default is to match everything - that is, find_maps will return all mappings for the specified client_lpar_id. It is illegal to specify both match_func and stg_elem. stg_elem - Match mappings associated with a specific storage element. Effectively, this generates a default match_func which matches on the type and name of the storage element. If neither match_func nor stg_elem is specified, the default is to match everything - that is, find_maps will return all mappings for the specified client_lpar_id. It is illegal to specify both match_func and stg_elem. include_orphans - An \"orphan\" contains a server adapter but no client adapter. If this parameter is True, mappings with no client adapter will still be considered for inclusion. If False, mappings with no client adapter will be skipped entirely, regardless of any other criteria. Returns A list comprising the subset of the input mapping_list whose client LPAR IDs match client_lpar_id and whose backing storage elements satisfy match_func. Raises ValueError - If both match_func and stg_elem are specified. Signature def find_maps( mapping_list, client_lpar_id=None, match_func=None, stg_elem=None, include_orphans=False, ): ... gen_match_func Show source in scsi_mapper.py:406 Generate a matching function for find_maps' match_func param. Arguments wcls - The Wrapper class of the object being matched. name_prop - The property of the Wrapper class on which to match. names - (Optional) A list of names to match. If names and prefixes are both None or empty, all inputs of the specified wcls will be matched. prefixes - (Optional) A list of prefixes that can be specified to serve as identifiers for potential matches. Ignored if names is specified. If names and prefixes are both None or empty, all inputs of the specified wcls will be matched. udids - (Optional) A list of UDIDs that can be specified to serve as identifiers for potential matches. Ignored if names or prefixes are specified. If all three are None or empty, all inputs of the specified wcls will be matched. Returns A callable matching function suitable for passing to the match_func parameter of the find_maps method. Signature def gen_match_func(wcls, name_prop=\"name\", names=None, prefixes=None, udids=None): ... index_mappings Show source in scsi_mapper.py:527 Create an index dict of SCSI mappings to facilitate reverse lookups. Arguments maps - Iterable of VSCSIMapping to index. Returns A dict of the form: { 'by-lpar-id': { str(lpar_id): [VSCSIMapping, ...], ... }, 'by-lpar-uuid': { lpar_uuid: [VSCSIMapping, ...], ... }, 'by-storage-udid': { storage_udid: [VSCSIMapping, ...], ... } } ...where: - lpar_id is the short integer ID (not UUID) of the LPAR, stringified. - lpar_uuid is the UUID of the LPAR. - storage_udid is the Unique Device Identifier (UDID) of the backing Storage element associated with the mapping. While the outermost dict is guaranteed to have all keys, the inner dicts may be empty. However, if an inner dict has a member, its list of mappings is guaranteed to be nonempty. Signature def index_mappings(maps): ... modify_vopt_mapping Show source in scsi_mapper.py:582 Will remap VOpt media mapping with another backing storage element. This method will change the VOptMedia storage element associated with a specific SCSI mapping. This is found by searching media name or udid for existing storage, and will raise exception if zero or more than one is returned. Arguments adapter - The pypowervm adapter for API communication. vios - The virtual I/O server on which the mapping should be modified. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. client_lpar_id - The integer short ID or string UUID of the client VM new_media - VOptMedia wrapper representing the new storage element to be associated with the specified SCSI mapping. media_name - (Optional) The name of the current virtual optical media to replace on the SCSI bus. udid - (Optional) The UDID of the current virtual optical media to replace on the SCSI bus. Ignored if media_name is specified. If neither is specified, search will return all mappings on LPAR and fail if there's more than one. Returns The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. The remapped SCSI mapping with new backing storage. :raises: SingleMappingNotFoundRemapError: If the number of VOptMedia matches found for the given media name and/or udid is not one. Signature def modify_vopt_mapping( adapter, vios, client_lpar_id, new_media, media_name=None, udid=None ): ... remove_lu_mapping Show source in scsi_mapper.py:695 Remove mappings for one or more SSP LUs associated with an LPAR. This method will remove the mapping between the Logical Unit and the client partition. It does not delete the LU. Will leave other elements on the vSCSI bus intact. Arguments adapter - The pypowervm adapter for API communication. vios - The virtual I/O server from which the mapping should be removed. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. client_lpar_id - The integer short ID or string UUID of the client VM disk_names - (Optional) A list of names of the LUs to remove from the SCSI bus. If disk_names, disk_prefixes, and udids are all None/empty, will remove all logical unit mappings associated with the specified client_lpar_id. disk_prefixes - (Optional) A list of prefixes that can be specified to serve as identifiers for potential disks. Ignored if disk_names is specified. If disk_names, disk_prefixes, and udids are all None/empty, will remove all logical unit mappings associated with the specified client_lpar_id. udids - (Optional) A list of UDIDs of the logical units to remove from the SCSI bus. Ignored if disk_names or disk_prefixes are specified. If all three are None/empty, will remove all logical unit mappings associated with the specified client_lpar_id. Returns The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. A list of LU EntryWrappers representing the mappings that were removed. Signature def remove_lu_mapping( adapter, vios, client_lpar_id, disk_names=None, disk_prefixes=None, udids=None ): ... remove_maps Show source in scsi_mapper.py:258 Remove one or more SCSI mappings from a VIOS wrapper. The changes are not flushed back to the REST server. Arguments vwrap - VIOS EntryWrapper representing the Virtual I/O Server whose SCSI mappings are to be updated. client_lpar_id - The integer short ID or string UUID of the client VM match_func - (Optional) Matching function suitable for passing to find_maps. See that method's match_func parameter. Defaults to None (match only on client_lpar_id). include_orphans - (Optional) An \"orphan\" contains a server adapter but no client adapter. If this parameter is True, mappings with no client adapter will be considered for removal. If False, mappings with no client adapter will be left alone, regardless of any other criteria. Default: True (remove orphans). Returns The list of removed mappings. Signature def remove_maps(vwrap, client_lpar_id, match_func=None, include_orphans=True): ... remove_pv_mapping Show source in scsi_mapper.py:736 Will remove the PV mapping. This method will remove the pv mapping. It does not delete the device. Will leave other elements on the vSCSI bus intact. Arguments adapter - The pypowervm adapter for API communication. vios - The virtual I/O server from which the mapping should be removed. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. client_lpar_id - The integer short ID or string UUID of the client VM backing_dev - The physical volume name to be removed. If both backing_dev and udid are None, will remove all physical volume mappings associated with the specfied client_lpar_id. udid - (Optional) UDID of the physical volume to remove from the SCSI bus. Ignored if backing_dev is not None. If backing_dev and udid are both None, will remove all physical volume mappings associated with the specified client_lpar_id. Returns The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. A list of the backing physical device objects that were removed. Signature def remove_pv_mapping(adapter, vios, client_lpar_id, backing_dev, udid=None): ... remove_vdisk_mapping Show source in scsi_mapper.py:655 Will remove the mapping for VDisk media. This method will remove the mapping between the virtual disk and the client partition. It does not delete the virtual disk. Will leave other elements on the vSCSI bus intact. Arguments adapter - The pypowervm adapter for API communication. vios - The virtual I/O server from which the mapping should be removed. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. client_lpar_id - The integer short ID or string UUID of the client VM disk_names - (Optional) A list of names of the virtual disk to remove from the SCSI bus. If disk_names, disk_prefixes, and udids are all None/empty, will remove all virtual disk mappings associated with the specified client_lpar_id. disk_prefixes - (Optional) A list of prefixes that can be specified to serve as identifiers for potential disks. Ignored if disk_names is specified. If disk_names, disk_prefixes, and udids are all None/empty, will remove all virtual disk mappings associated with the specified client_lpar_id. udids - (Optional) A list of UDIDs of the virtual disks to remove from the SCSI bus. Ignored if disk_names or disk_prefixes are specified. If all three are None/empty, will remove all virtual disk mappings associated with the specified client_lpar_id. Returns The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. A list of the backing VDisk objects that were removed. Signature def remove_vdisk_mapping( adapter, vios, client_lpar_id, disk_names=None, disk_prefixes=None, udids=None ): ... remove_vopt_mapping Show source in scsi_mapper.py:621 Will remove the mapping for VOpt media. This method will remove the mapping between the virtual optical media and the client partition. It does not delete the virtual optical media. Will leave other elements on the vSCSI bus intact. Arguments adapter - The pypowervm adapter for API communication. vios - The virtual I/O server from which the mapping should be removed. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. client_lpar_id - The integer short ID or string UUID of the client VM media_name - (Optional) The name of the virtual optical media to remove from the SCSI bus. If both media_name and udid are None, will remove all virtual optical media mappings associated with the specified client_lpar_id udid - (Optional) The UDID of the virtual optical media to remove from the SCSI bus. Ignored if media_name is specified. If both media_name and udid are None, will remove all virtual optical media mappings associated with the client_lpar_id. Returns The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. A list of the backing VOpt media that was removed. Signature def remove_vopt_mapping(adapter, vios, client_lpar_id, media_name=None, udid=None): ...","title":"Scsi Mapper"},{"location":"pypowervm/tasks/scsi_mapper/#scsi-mapper","text":"Pypowervm Index / Pypowervm / Tasks / Scsi Mapper Auto-generated documentation for pypowervm.tasks.scsi_mapper module. Scsi Mapper add_map add_vscsi_mapping build_vscsi_mapping detach_storage find_maps gen_match_func index_mappings modify_vopt_mapping remove_lu_mapping remove_maps remove_pv_mapping remove_vdisk_mapping remove_vopt_mapping","title":"Scsi Mapper"},{"location":"pypowervm/tasks/scsi_mapper/#add_map","text":"Show source in scsi_mapper.py:231 Will add the mapping to the VIOS wrapper, if not already included. This method has the logic in place to detect if the storage from the mapping is already part of a SCSI mapping. If so, it will not re-add the mapping to the VIOS wrapper. The new mapping is added to the wrapper, but it is up to the invoker to call the update method on the wrapper.","title":"add_map"},{"location":"pypowervm/tasks/scsi_mapper/#arguments","text":"vios_w - The Virtual I/O Server wrapping to add the mapping to. scsi_mapping - The scsi mapping to include in the VIOS.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns","text":"The scsi_mapping that was added. None if the mapping was already on the vios_w.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature","text":"def add_map(vios_w, scsi_mapping): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#add_vscsi_mapping","text":"Show source in scsi_mapper.py:47 Will add a vSCSI mapping to a Virtual I/O Server. This method is used to connect a storage element (either a vDisk, vOpt, PV or LU) that resides on a Virtual I/O Server to a Virtual Machine. This is achieved using a 'vSCSI Mapping'. The invoker does not need to interact with the mapping. A given mapping is essentially a 'vSCSI bus', which can host multiple storage elements. This method has a fuse limit which throttles the number of devices on a given vSCSI bus. The throttle should be lower if the storage elements are high I/O, and higher otherwise.","title":"add_vscsi_mapping"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_1","text":"host_uuid - Not used. vios - The virtual I/O server to which the mapping should be added. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. lpar_uuid - The UUID of the LPAR that will have the connected storage. storage_elem - The storage element (either a vDisk, vOpt, LU or PV) that is to be connected. fuse_limit - (Optional, Default: 32) The max number of devices to allow on one scsi bus before creating a second SCSI bus. lpar_slot_num - (Optional, Default: None) The slot number for the client LPAR to use in the mapping. If None, the next available slot number is assigned by the server. lua - (Optional. Default: None) Logical Unit Address to set on the TargetDevice. If None, the LUA will be assigned by the server. Should be specified for all of the VSCSIMappings for a particular bus, or none of them.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_1","text":"The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_1","text":"@lock.synchronized(\"vscsi_mapping\") @pvm_retry.retry( tries=60, argmod_func=_argmod, delay_func=pvm_retry.STEPPED_RANDOM_DELAY ) def add_vscsi_mapping( host_uuid, vios, lpar_uuid, storage_elem, fuse_limit=32, lpar_slot_num=None, lua=None ): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#build_vscsi_mapping","text":"Show source in scsi_mapper.py:128 Will build a vSCSI mapping that can be added to a VIOS. This method is used to create a mapping element (for either a vDisk, vOpt, PV or LU) that connects a Virtual I/O Server to a LPAR. A given mapping is essentially a 'vSCSI bus', which can host multiple storage elements. This method has a fuse limit which throttles the number of devices on a given vSCSI bus. The throttle should be lower if the storage elements are high I/O, and higher otherwise.","title":"build_vscsi_mapping"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_2","text":"host_uuid - Not used. vios_w - The virtual I/O server wrapper that the mapping is intended to be attached to. The method will call the update against the API. It will only update the in memory wrapper. lpar_uuid - The UUID of the LPAR that will have the connected storage. storage_elem - The storage element (either a vDisk, vOpt, LU or PV) that is to be connected. fuse_limit - (Optional, Default: 32) The max number of devices to allow on one scsi bus before creating a second SCSI bus. lpar_slot_num - (Optional, Default: None) The slot number for the client LPAR to use in the mapping. If None, the next available slot number is assigned by the server. lua - (Optional. Default: None) Logical Unit Address to set on the TargetDevice. If None, the LUA will be assigned by the server. Should be specified for all of the VSCSIMappings for a particular bus, or none of them. target_name - (Optional, Default: None) The name of the Target mapping. If None, the target_name will be assigned by the server.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_2","text":"The SCSI mapping that can be added to the vios_w. This does not do any updates to the wrapper itself.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_2","text":"def build_vscsi_mapping( host_uuid, vios_w, lpar_uuid, storage_elem, fuse_limit=32, lpar_slot_num=None, lua=None, target_name=None, ): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#detach_storage","text":"Show source in scsi_mapper.py:286 Detach the storage from all matching SCSI mappings. We do this by removing the Storage and TargetDevice child elements. This method only updates the vwrap. It does not POST back to the REST server. It does not lock.","title":"detach_storage"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_3","text":"vwrap - VIOS EntryWrapper representing the Virtual I/O Server whose SCSI mappings are to be updated. client_lpar_id - The integer short ID or string UUID of the client VM match_func - (Optional) Matching function suitable for passing to find_maps. See that method's match_func parameter. Defaults to None (match only on client_lpar_id).","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_3","text":"The list of SCSI mappings which were modified, in their original (storage-attached) form.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_3","text":"def detach_storage(vwrap, client_lpar_id, match_func=None): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#find_maps","text":"Show source in scsi_mapper.py:445 Filter a list of scsi mappings by LPAR ID/UUID and a matching function.","title":"find_maps"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_4","text":"mapping_list - The mappings to filter. Iterable of VSCSIMapping. client_lpar_id - Integer short ID or string UUID of the LPAR on the client side of the mapping. Note that the UUID form relies on the presence of the client_lpar_href field. Some mappings lack this field, and would therefore be ignored. If client_lpar_id is not passed it will return matching mappings for all the lpar_ids. match_func - Callable with the following specification: def match_func(storage_elem) param storage_elem: A backing storage element wrapper (VOpt, VDisk, PV, or LU) to be analyzed. May be None (some mappings have no backing storage). return: True if the storage_elem's mapping should be included; False otherwise. If neither match_func nor stg_elem is specified, the default is to match everything - that is, find_maps will return all mappings for the specified client_lpar_id. It is illegal to specify both match_func and stg_elem. stg_elem - Match mappings associated with a specific storage element. Effectively, this generates a default match_func which matches on the type and name of the storage element. If neither match_func nor stg_elem is specified, the default is to match everything - that is, find_maps will return all mappings for the specified client_lpar_id. It is illegal to specify both match_func and stg_elem. include_orphans - An \"orphan\" contains a server adapter but no client adapter. If this parameter is True, mappings with no client adapter will still be considered for inclusion. If False, mappings with no client adapter will be skipped entirely, regardless of any other criteria.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_4","text":"A list comprising the subset of the input mapping_list whose client LPAR IDs match client_lpar_id and whose backing storage elements satisfy match_func.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#raises","text":"ValueError - If both match_func and stg_elem are specified.","title":"Raises"},{"location":"pypowervm/tasks/scsi_mapper/#signature_4","text":"def find_maps( mapping_list, client_lpar_id=None, match_func=None, stg_elem=None, include_orphans=False, ): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#gen_match_func","text":"Show source in scsi_mapper.py:406 Generate a matching function for find_maps' match_func param.","title":"gen_match_func"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_5","text":"wcls - The Wrapper class of the object being matched. name_prop - The property of the Wrapper class on which to match. names - (Optional) A list of names to match. If names and prefixes are both None or empty, all inputs of the specified wcls will be matched. prefixes - (Optional) A list of prefixes that can be specified to serve as identifiers for potential matches. Ignored if names is specified. If names and prefixes are both None or empty, all inputs of the specified wcls will be matched. udids - (Optional) A list of UDIDs that can be specified to serve as identifiers for potential matches. Ignored if names or prefixes are specified. If all three are None or empty, all inputs of the specified wcls will be matched.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_5","text":"A callable matching function suitable for passing to the match_func parameter of the find_maps method.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_5","text":"def gen_match_func(wcls, name_prop=\"name\", names=None, prefixes=None, udids=None): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#index_mappings","text":"Show source in scsi_mapper.py:527 Create an index dict of SCSI mappings to facilitate reverse lookups.","title":"index_mappings"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_6","text":"maps - Iterable of VSCSIMapping to index.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_6","text":"A dict of the form: { 'by-lpar-id': { str(lpar_id): [VSCSIMapping, ...], ... }, 'by-lpar-uuid': { lpar_uuid: [VSCSIMapping, ...], ... }, 'by-storage-udid': { storage_udid: [VSCSIMapping, ...], ... } } ...where: - lpar_id is the short integer ID (not UUID) of the LPAR, stringified. - lpar_uuid is the UUID of the LPAR. - storage_udid is the Unique Device Identifier (UDID) of the backing Storage element associated with the mapping. While the outermost dict is guaranteed to have all keys, the inner dicts may be empty. However, if an inner dict has a member, its list of mappings is guaranteed to be nonempty.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_6","text":"def index_mappings(maps): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#modify_vopt_mapping","text":"Show source in scsi_mapper.py:582 Will remap VOpt media mapping with another backing storage element. This method will change the VOptMedia storage element associated with a specific SCSI mapping. This is found by searching media name or udid for existing storage, and will raise exception if zero or more than one is returned.","title":"modify_vopt_mapping"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_7","text":"adapter - The pypowervm adapter for API communication. vios - The virtual I/O server on which the mapping should be modified. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. client_lpar_id - The integer short ID or string UUID of the client VM new_media - VOptMedia wrapper representing the new storage element to be associated with the specified SCSI mapping. media_name - (Optional) The name of the current virtual optical media to replace on the SCSI bus. udid - (Optional) The UDID of the current virtual optical media to replace on the SCSI bus. Ignored if media_name is specified. If neither is specified, search will return all mappings on LPAR and fail if there's more than one.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_7","text":"The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. The remapped SCSI mapping with new backing storage. :raises: SingleMappingNotFoundRemapError: If the number of VOptMedia matches found for the given media name and/or udid is not one.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_7","text":"def modify_vopt_mapping( adapter, vios, client_lpar_id, new_media, media_name=None, udid=None ): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#remove_lu_mapping","text":"Show source in scsi_mapper.py:695 Remove mappings for one or more SSP LUs associated with an LPAR. This method will remove the mapping between the Logical Unit and the client partition. It does not delete the LU. Will leave other elements on the vSCSI bus intact.","title":"remove_lu_mapping"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_8","text":"adapter - The pypowervm adapter for API communication. vios - The virtual I/O server from which the mapping should be removed. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. client_lpar_id - The integer short ID or string UUID of the client VM disk_names - (Optional) A list of names of the LUs to remove from the SCSI bus. If disk_names, disk_prefixes, and udids are all None/empty, will remove all logical unit mappings associated with the specified client_lpar_id. disk_prefixes - (Optional) A list of prefixes that can be specified to serve as identifiers for potential disks. Ignored if disk_names is specified. If disk_names, disk_prefixes, and udids are all None/empty, will remove all logical unit mappings associated with the specified client_lpar_id. udids - (Optional) A list of UDIDs of the logical units to remove from the SCSI bus. Ignored if disk_names or disk_prefixes are specified. If all three are None/empty, will remove all logical unit mappings associated with the specified client_lpar_id.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_8","text":"The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. A list of LU EntryWrappers representing the mappings that were removed.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_8","text":"def remove_lu_mapping( adapter, vios, client_lpar_id, disk_names=None, disk_prefixes=None, udids=None ): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#remove_maps","text":"Show source in scsi_mapper.py:258 Remove one or more SCSI mappings from a VIOS wrapper. The changes are not flushed back to the REST server.","title":"remove_maps"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_9","text":"vwrap - VIOS EntryWrapper representing the Virtual I/O Server whose SCSI mappings are to be updated. client_lpar_id - The integer short ID or string UUID of the client VM match_func - (Optional) Matching function suitable for passing to find_maps. See that method's match_func parameter. Defaults to None (match only on client_lpar_id). include_orphans - (Optional) An \"orphan\" contains a server adapter but no client adapter. If this parameter is True, mappings with no client adapter will be considered for removal. If False, mappings with no client adapter will be left alone, regardless of any other criteria. Default: True (remove orphans).","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_9","text":"The list of removed mappings.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_9","text":"def remove_maps(vwrap, client_lpar_id, match_func=None, include_orphans=True): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#remove_pv_mapping","text":"Show source in scsi_mapper.py:736 Will remove the PV mapping. This method will remove the pv mapping. It does not delete the device. Will leave other elements on the vSCSI bus intact.","title":"remove_pv_mapping"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_10","text":"adapter - The pypowervm adapter for API communication. vios - The virtual I/O server from which the mapping should be removed. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. client_lpar_id - The integer short ID or string UUID of the client VM backing_dev - The physical volume name to be removed. If both backing_dev and udid are None, will remove all physical volume mappings associated with the specfied client_lpar_id. udid - (Optional) UDID of the physical volume to remove from the SCSI bus. Ignored if backing_dev is not None. If backing_dev and udid are both None, will remove all physical volume mappings associated with the specified client_lpar_id.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_10","text":"The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. A list of the backing physical device objects that were removed.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_10","text":"def remove_pv_mapping(adapter, vios, client_lpar_id, backing_dev, udid=None): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#remove_vdisk_mapping","text":"Show source in scsi_mapper.py:655 Will remove the mapping for VDisk media. This method will remove the mapping between the virtual disk and the client partition. It does not delete the virtual disk. Will leave other elements on the vSCSI bus intact.","title":"remove_vdisk_mapping"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_11","text":"adapter - The pypowervm adapter for API communication. vios - The virtual I/O server from which the mapping should be removed. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. client_lpar_id - The integer short ID or string UUID of the client VM disk_names - (Optional) A list of names of the virtual disk to remove from the SCSI bus. If disk_names, disk_prefixes, and udids are all None/empty, will remove all virtual disk mappings associated with the specified client_lpar_id. disk_prefixes - (Optional) A list of prefixes that can be specified to serve as identifiers for potential disks. Ignored if disk_names is specified. If disk_names, disk_prefixes, and udids are all None/empty, will remove all virtual disk mappings associated with the specified client_lpar_id. udids - (Optional) A list of UDIDs of the virtual disks to remove from the SCSI bus. Ignored if disk_names or disk_prefixes are specified. If all three are None/empty, will remove all virtual disk mappings associated with the specified client_lpar_id.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_11","text":"The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. A list of the backing VDisk objects that were removed.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_11","text":"def remove_vdisk_mapping( adapter, vios, client_lpar_id, disk_names=None, disk_prefixes=None, udids=None ): ...","title":"Signature"},{"location":"pypowervm/tasks/scsi_mapper/#remove_vopt_mapping","text":"Show source in scsi_mapper.py:621 Will remove the mapping for VOpt media. This method will remove the mapping between the virtual optical media and the client partition. It does not delete the virtual optical media. Will leave other elements on the vSCSI bus intact.","title":"remove_vopt_mapping"},{"location":"pypowervm/tasks/scsi_mapper/#arguments_12","text":"adapter - The pypowervm adapter for API communication. vios - The virtual I/O server from which the mapping should be removed. This may be the VIOS's UUID string OR an existing VIOS EntryWrapper. If the latter, it must have been retrieved using the VIO_SMAP extended attribute group. client_lpar_id - The integer short ID or string UUID of the client VM media_name - (Optional) The name of the virtual optical media to remove from the SCSI bus. If both media_name and udid are None, will remove all virtual optical media mappings associated with the specified client_lpar_id udid - (Optional) The UDID of the virtual optical media to remove from the SCSI bus. Ignored if media_name is specified. If both media_name and udid are None, will remove all virtual optical media mappings associated with the client_lpar_id.","title":"Arguments"},{"location":"pypowervm/tasks/scsi_mapper/#returns_12","text":"The VIOS wrapper representing the updated Virtual I/O Server. This is current with respect to etag and SCSI mappings. A list of the backing VOpt media that was removed.","title":"Returns"},{"location":"pypowervm/tasks/scsi_mapper/#signature_12","text":"def remove_vopt_mapping(adapter, vios, client_lpar_id, media_name=None, udid=None): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/","text":"Slot Map Pypowervm Index / Pypowervm / Tasks / Slot Map Auto-generated documentation for pypowervm.tasks.slot_map module. Slot Map BuildSlotMap BuildSlotMap().get_max_vslots BuildSlotMap().get_mgmt_vea_slot BuildSlotMap().get_pv_vscsi_slot BuildSlotMap().get_vea_slot BuildSlotMap().get_vfc_slots BuildSlotMap().get_vnet_slot BuildSlotMap().get_vscsi_slot IOCLASS RebuildSlotMap RebuildSlotMap().get_mgmt_vea_slot SlotMapStore SlotMapStore().delete SlotMapStore().drop_cna SlotMapStore().drop_vfc_mapping SlotMapStore().drop_vnet SlotMapStore().drop_vscsi_mapping SlotMapStore().load SlotMapStore().max_vslots SlotMapStore().register_cna SlotMapStore().register_max_vslots SlotMapStore().register_vfc_mapping SlotMapStore().register_vnet SlotMapStore().register_vscsi_mapping SlotMapStore().save SlotMapStore().serialized SlotMapStore().topology BuildSlotMap Show source in slot_map.py:417 Provides information on which slots should be used for LPAR creates. This class takes in a SlotMapStore and provides information on which slots should be used on the client adapters. If not overridden, this base implementation returns a client slot that allows the deploy implementation to choose the 'next available' slot. Signature class BuildSlotMap(object): def __init__(self, slot_store): ... BuildSlotMap().get_max_vslots Show source in slot_map.py:528 Retrieve or derive the maximum number of virtual slots for the LPAR. If the source LPAR's maximum number of virtual slots was registered in the source slot map, that value is returned. Otherwise, we attempt to derive a reasonable value based on the highest registered slot number. If none was registered, the minimum returned value will be the default from pypowervm.utils.lpar_builder.DEF_MAX_SLOT. It is the caller's responsibility to determine whether the value returned by this method is sufficiently high for the LPAR being created. Signature def get_max_vslots(self): ... BuildSlotMap().get_mgmt_vea_slot Show source in slot_map.py:483 Gets the client slot and MAC for the mgmt VEA. Returns MAC Address for the NIC. Integer client slot number for the NIC. Signature def get_mgmt_vea_slot(self): ... BuildSlotMap().get_pv_vscsi_slot Show source in slot_map.py:455 DEPRECATED; Gets the vSCSI client slot for the PV. Use get_vscsi_slot. This method will be removed shortly. Arguments vios_w - VIOS wrapper. udid - UDID of the physical volume. Returns Integer client slot number on which to create the VSCSIMapping from the specified VIOS for the PV with the specified udid. Signature def get_pv_vscsi_slot(self, vios_w, udid): ... BuildSlotMap().get_vea_slot Show source in slot_map.py:471 Gets the client slot for the VEA. Arguments mac - MAC address string to look up. Returns Integer client slot number on which to create a CNA with the specified MAC address. Signature def get_vea_slot(self, mac): ... BuildSlotMap().get_vfc_slots Show source in slot_map.py:505 Gets the client slot list for a given NPIV fabric. Arguments fabric - Fabric name. number_of_slots - The number of slots for the specified fabric. Returns List of integer client slot numbers on which to map the given fabric. :raises: InvalidHostForRebuildSlotMismatch : if the target server requires more or less slots than the source server had. If this is a first deploy (ex. a standard BuildSlotMap) will not matter, and will return an array of None's (indicating to use the next available slots). Signature def get_vfc_slots(self, fabric, number_of_slots): ... BuildSlotMap().get_vnet_slot Show source in slot_map.py:492 Gets the client slot for the VEA or VNIC, mgmt VEA not included. Arguments mac - MAC address string to look up. Returns Integer client slot number on which to create a CNA or VNIC with the specified MAC address. Signature def get_vnet_slot(self, mac): ... BuildSlotMap().get_vscsi_slot Show source in slot_map.py:435 Gets the vSCSI client slot and extra spec for the VSCSI device. Arguments vios_w - VIOS wrapper. udid - UDID of the VSCSI device. Returns Integer client slot number on which to create the VSCSIMapping from the specified VIOS for the storage with the specified udid. Extra specification appropriate to the storage type. See the SlotMapStore.topology @property. Signature def get_vscsi_slot(self, vios_w, udid): ... IOCLASS Show source in slot_map.py:39 Enumeration of differently-handled I/O classes. Signature class IOCLASS(object): ... RebuildSlotMap Show source in slot_map.py:552 Used to determine the slot topology when rebuilding a VM. A LPAR rebuild needs to configure the client slots with the exact topology as their source. This implementation requires additional details from the target server, but then provides the LPAR's appropriate client slot layout. Signature class RebuildSlotMap(BuildSlotMap): def __init__(self, slot_store, vios_wraps, vscsi_vol_to_vio, npiv_fabrics): ... See also BuildSlotMap RebuildSlotMap().get_mgmt_vea_slot Show source in slot_map.py:588 Gets the client slot and MAC for the mgmt VEA. There should only be one MGMT VEA per system. As such, subsequent calls to this will return the single MGMT VEA. Returns MAC Address for the NIC. Integer client slot number for the NIC. Signature def get_mgmt_vea_slot(self): ... SlotMapStore Show source in slot_map.py:51 Save/fetch slot-to-I/O topology for an LPAR. This class should be extended by something that can interact with a persistent storage device to implement the save, load, and delete methods. The slot metadata is used during a rebuild operation (e.g. Remote Restart) to ensure that the client devices are in the same slots on the target. Typically this map is constructed on the source system and then saved. It is loaded on the target system and used to rebuild an LPARthe same way. Signature class SlotMapStore(object): def __init__(self, inst_key, load=True): ... SlotMapStore().delete Show source in slot_map.py:144 Remove the back-end storage for this slot map. Signature def delete(self): ... SlotMapStore().drop_cna Show source in slot_map.py:206 Drops the client network adapter from the slot topology. :deprecated: Use drop_vnet instead. Arguments cna - CNA EntryWrapper to drop. Signature def drop_cna(self, cna): ... SlotMapStore().drop_vfc_mapping Show source in slot_map.py:232 Drops the client network adapter from the slot topology. Arguments vfcmap - VFCMapping ElementWrapper representing the mapping to be removed. fab - The fabric name associated with the mapping. Signature def drop_vfc_mapping(self, vfcmap, fab): ... SlotMapStore().drop_vnet Show source in slot_map.py:182 Drops the slot number for a CNA or VNIC. Arguments vnet_w - Either a CNA wrapper or a VNIC wrapper. :raises: InvalidVirtualNetworkDeviceType: If the wrapper passed in is not a CNA or VNIC this will be raised. Signature def drop_vnet(self, vnet_w): ... SlotMapStore().drop_vscsi_mapping Show source in slot_map.py:296 Drops the vscsi mapping from the slot topology. Arguments vscsimap - VSCSIMapping ElementWrapper to be removed from the slot topology. Signature def drop_vscsi_mapping(self, vscsimap): ... SlotMapStore().load Show source in slot_map.py:97 Internal use only. Do not override. Do not invoke. Signature def load(self): ... SlotMapStore().max_vslots Show source in slot_map.py:340 Returns the highest slot number for the LPAR, or None if not set. This number corresponds to base_partition.max_virtual_slots, and indicates the maximum number of virtual slots (I/O buses) allowed on the LPAR. If register_max_vslots has never bene called, this value will be None. Signature @property def max_vslots(self): ... SlotMapStore().register_cna Show source in slot_map.py:196 Register the slot and switch topology of a client network adapter. :deprecated: Use register_vnet instead. Arguments cna - CNA EntryWrapper to register. Signature def register_cna(self, cna): ... SlotMapStore().register_max_vslots Show source in slot_map.py:159 Register the maximum number of virtual slots on the source LPAR. Arguments SlotMapStore().max_vslots - The maximum number of virtual slots on the LPAR. Signature def register_max_vslots(self, max_vslots): ... SlotMapStore().register_vfc_mapping Show source in slot_map.py:216 Incorporate the slot topology associated with a VFC mapping. Arguments vfcmap - VFCMapping ElementWrapper representing the mapping to be incorporated. fab - The fabric name associated with the mapping. Signature def register_vfc_mapping(self, vfcmap, fab): ... SlotMapStore().register_vnet Show source in slot_map.py:166 Register the slot number for a CNA or VNIC. Arguments vnet_w - Either a CNA wrapper or a VNIC wrapper. :raises: InvalidVirtualNetworkDeviceType: If the wrapper passed in is not a CNA or VNIC this will be raised. Signature def register_vnet(self, vnet_w): ... SlotMapStore().register_vscsi_mapping Show source in slot_map.py:285 Incorporate the slot topology associated with a VSCSI mapping. Arguments vscsimap - VSCSIMapping ElementWrapper to be incorporated into the slot topology. Signature def register_vscsi_mapping(self, vscsimap): ... SlotMapStore().save Show source in slot_map.py:116 Save this slot map to storage, if needed. Signature def save(self): ... SlotMapStore().serialized Show source in slot_map.py:89 Internal use only. Do not override. Do not invoke. Signature @property def serialized(self): ... SlotMapStore().topology Show source in slot_map.py:307 Produce the slot-to-I/O topology structure from this SlotMapStore. Returns A dict of the form: { slot_num: { IOCLASS: { io_key: extra_spec } } } ...where: slot_num: Integer client slot ID. IOCLASS: The IOCLASS enum indicating the type of I/O. Each IOCLASS enum is only present if the source had at least one I/O element of that type. io_key: The unique identifier of the mapped I/O element. This differs by IOCLASS type - see below. extra_spec: Additional information about the I/O element. This differs by IOCLASS type - see below. IOCLASS stg_key extra_spec CNA CNA.mac VSwitch.name VOPT VOptMedia.udid Media name VDISK VDisk.udid VDisk.capacity (float) PV PV.udid LUA LU LU.udid LUA VFC fabric name None VNIC VNIC.mac None Signature @property def topology(self): ...","title":"Slot Map"},{"location":"pypowervm/tasks/slot_map/#slot-map","text":"Pypowervm Index / Pypowervm / Tasks / Slot Map Auto-generated documentation for pypowervm.tasks.slot_map module. Slot Map BuildSlotMap BuildSlotMap().get_max_vslots BuildSlotMap().get_mgmt_vea_slot BuildSlotMap().get_pv_vscsi_slot BuildSlotMap().get_vea_slot BuildSlotMap().get_vfc_slots BuildSlotMap().get_vnet_slot BuildSlotMap().get_vscsi_slot IOCLASS RebuildSlotMap RebuildSlotMap().get_mgmt_vea_slot SlotMapStore SlotMapStore().delete SlotMapStore().drop_cna SlotMapStore().drop_vfc_mapping SlotMapStore().drop_vnet SlotMapStore().drop_vscsi_mapping SlotMapStore().load SlotMapStore().max_vslots SlotMapStore().register_cna SlotMapStore().register_max_vslots SlotMapStore().register_vfc_mapping SlotMapStore().register_vnet SlotMapStore().register_vscsi_mapping SlotMapStore().save SlotMapStore().serialized SlotMapStore().topology","title":"Slot Map"},{"location":"pypowervm/tasks/slot_map/#buildslotmap","text":"Show source in slot_map.py:417 Provides information on which slots should be used for LPAR creates. This class takes in a SlotMapStore and provides information on which slots should be used on the client adapters. If not overridden, this base implementation returns a client slot that allows the deploy implementation to choose the 'next available' slot.","title":"BuildSlotMap"},{"location":"pypowervm/tasks/slot_map/#signature","text":"class BuildSlotMap(object): def __init__(self, slot_store): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#buildslotmapget_max_vslots","text":"Show source in slot_map.py:528 Retrieve or derive the maximum number of virtual slots for the LPAR. If the source LPAR's maximum number of virtual slots was registered in the source slot map, that value is returned. Otherwise, we attempt to derive a reasonable value based on the highest registered slot number. If none was registered, the minimum returned value will be the default from pypowervm.utils.lpar_builder.DEF_MAX_SLOT. It is the caller's responsibility to determine whether the value returned by this method is sufficiently high for the LPAR being created.","title":"BuildSlotMap().get_max_vslots"},{"location":"pypowervm/tasks/slot_map/#signature_1","text":"def get_max_vslots(self): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#buildslotmapget_mgmt_vea_slot","text":"Show source in slot_map.py:483 Gets the client slot and MAC for the mgmt VEA.","title":"BuildSlotMap().get_mgmt_vea_slot"},{"location":"pypowervm/tasks/slot_map/#returns","text":"MAC Address for the NIC. Integer client slot number for the NIC.","title":"Returns"},{"location":"pypowervm/tasks/slot_map/#signature_2","text":"def get_mgmt_vea_slot(self): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#buildslotmapget_pv_vscsi_slot","text":"Show source in slot_map.py:455 DEPRECATED; Gets the vSCSI client slot for the PV. Use get_vscsi_slot. This method will be removed shortly.","title":"BuildSlotMap().get_pv_vscsi_slot"},{"location":"pypowervm/tasks/slot_map/#arguments","text":"vios_w - VIOS wrapper. udid - UDID of the physical volume.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#returns_1","text":"Integer client slot number on which to create the VSCSIMapping from the specified VIOS for the PV with the specified udid.","title":"Returns"},{"location":"pypowervm/tasks/slot_map/#signature_3","text":"def get_pv_vscsi_slot(self, vios_w, udid): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#buildslotmapget_vea_slot","text":"Show source in slot_map.py:471 Gets the client slot for the VEA.","title":"BuildSlotMap().get_vea_slot"},{"location":"pypowervm/tasks/slot_map/#arguments_1","text":"mac - MAC address string to look up.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#returns_2","text":"Integer client slot number on which to create a CNA with the specified MAC address.","title":"Returns"},{"location":"pypowervm/tasks/slot_map/#signature_4","text":"def get_vea_slot(self, mac): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#buildslotmapget_vfc_slots","text":"Show source in slot_map.py:505 Gets the client slot list for a given NPIV fabric.","title":"BuildSlotMap().get_vfc_slots"},{"location":"pypowervm/tasks/slot_map/#arguments_2","text":"fabric - Fabric name. number_of_slots - The number of slots for the specified fabric.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#returns_3","text":"List of integer client slot numbers on which to map the given fabric. :raises: InvalidHostForRebuildSlotMismatch : if the target server requires more or less slots than the source server had. If this is a first deploy (ex. a standard BuildSlotMap) will not matter, and will return an array of None's (indicating to use the next available slots).","title":"Returns"},{"location":"pypowervm/tasks/slot_map/#signature_5","text":"def get_vfc_slots(self, fabric, number_of_slots): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#buildslotmapget_vnet_slot","text":"Show source in slot_map.py:492 Gets the client slot for the VEA or VNIC, mgmt VEA not included.","title":"BuildSlotMap().get_vnet_slot"},{"location":"pypowervm/tasks/slot_map/#arguments_3","text":"mac - MAC address string to look up.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#returns_4","text":"Integer client slot number on which to create a CNA or VNIC with the specified MAC address.","title":"Returns"},{"location":"pypowervm/tasks/slot_map/#signature_6","text":"def get_vnet_slot(self, mac): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#buildslotmapget_vscsi_slot","text":"Show source in slot_map.py:435 Gets the vSCSI client slot and extra spec for the VSCSI device.","title":"BuildSlotMap().get_vscsi_slot"},{"location":"pypowervm/tasks/slot_map/#arguments_4","text":"vios_w - VIOS wrapper. udid - UDID of the VSCSI device.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#returns_5","text":"Integer client slot number on which to create the VSCSIMapping from the specified VIOS for the storage with the specified udid. Extra specification appropriate to the storage type. See the SlotMapStore.topology @property.","title":"Returns"},{"location":"pypowervm/tasks/slot_map/#signature_7","text":"def get_vscsi_slot(self, vios_w, udid): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#ioclass","text":"Show source in slot_map.py:39 Enumeration of differently-handled I/O classes.","title":"IOCLASS"},{"location":"pypowervm/tasks/slot_map/#signature_8","text":"class IOCLASS(object): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#rebuildslotmap","text":"Show source in slot_map.py:552 Used to determine the slot topology when rebuilding a VM. A LPAR rebuild needs to configure the client slots with the exact topology as their source. This implementation requires additional details from the target server, but then provides the LPAR's appropriate client slot layout.","title":"RebuildSlotMap"},{"location":"pypowervm/tasks/slot_map/#signature_9","text":"class RebuildSlotMap(BuildSlotMap): def __init__(self, slot_store, vios_wraps, vscsi_vol_to_vio, npiv_fabrics): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#see-also","text":"BuildSlotMap","title":"See also"},{"location":"pypowervm/tasks/slot_map/#rebuildslotmapget_mgmt_vea_slot","text":"Show source in slot_map.py:588 Gets the client slot and MAC for the mgmt VEA. There should only be one MGMT VEA per system. As such, subsequent calls to this will return the single MGMT VEA.","title":"RebuildSlotMap().get_mgmt_vea_slot"},{"location":"pypowervm/tasks/slot_map/#returns_6","text":"MAC Address for the NIC. Integer client slot number for the NIC.","title":"Returns"},{"location":"pypowervm/tasks/slot_map/#signature_10","text":"def get_mgmt_vea_slot(self): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstore","text":"Show source in slot_map.py:51 Save/fetch slot-to-I/O topology for an LPAR. This class should be extended by something that can interact with a persistent storage device to implement the save, load, and delete methods. The slot metadata is used during a rebuild operation (e.g. Remote Restart) to ensure that the client devices are in the same slots on the target. Typically this map is constructed on the source system and then saved. It is loaded on the target system and used to rebuild an LPARthe same way.","title":"SlotMapStore"},{"location":"pypowervm/tasks/slot_map/#signature_11","text":"class SlotMapStore(object): def __init__(self, inst_key, load=True): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoredelete","text":"Show source in slot_map.py:144 Remove the back-end storage for this slot map.","title":"SlotMapStore().delete"},{"location":"pypowervm/tasks/slot_map/#signature_12","text":"def delete(self): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoredrop_cna","text":"Show source in slot_map.py:206 Drops the client network adapter from the slot topology. :deprecated: Use drop_vnet instead.","title":"SlotMapStore().drop_cna"},{"location":"pypowervm/tasks/slot_map/#arguments_5","text":"cna - CNA EntryWrapper to drop.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#signature_13","text":"def drop_cna(self, cna): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoredrop_vfc_mapping","text":"Show source in slot_map.py:232 Drops the client network adapter from the slot topology.","title":"SlotMapStore().drop_vfc_mapping"},{"location":"pypowervm/tasks/slot_map/#arguments_6","text":"vfcmap - VFCMapping ElementWrapper representing the mapping to be removed. fab - The fabric name associated with the mapping.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#signature_14","text":"def drop_vfc_mapping(self, vfcmap, fab): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoredrop_vnet","text":"Show source in slot_map.py:182 Drops the slot number for a CNA or VNIC.","title":"SlotMapStore().drop_vnet"},{"location":"pypowervm/tasks/slot_map/#arguments_7","text":"vnet_w - Either a CNA wrapper or a VNIC wrapper. :raises: InvalidVirtualNetworkDeviceType: If the wrapper passed in is not a CNA or VNIC this will be raised.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#signature_15","text":"def drop_vnet(self, vnet_w): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoredrop_vscsi_mapping","text":"Show source in slot_map.py:296 Drops the vscsi mapping from the slot topology.","title":"SlotMapStore().drop_vscsi_mapping"},{"location":"pypowervm/tasks/slot_map/#arguments_8","text":"vscsimap - VSCSIMapping ElementWrapper to be removed from the slot topology.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#signature_16","text":"def drop_vscsi_mapping(self, vscsimap): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoreload","text":"Show source in slot_map.py:97 Internal use only. Do not override. Do not invoke.","title":"SlotMapStore().load"},{"location":"pypowervm/tasks/slot_map/#signature_17","text":"def load(self): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoremax_vslots","text":"Show source in slot_map.py:340 Returns the highest slot number for the LPAR, or None if not set. This number corresponds to base_partition.max_virtual_slots, and indicates the maximum number of virtual slots (I/O buses) allowed on the LPAR. If register_max_vslots has never bene called, this value will be None.","title":"SlotMapStore().max_vslots"},{"location":"pypowervm/tasks/slot_map/#signature_18","text":"@property def max_vslots(self): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoreregister_cna","text":"Show source in slot_map.py:196 Register the slot and switch topology of a client network adapter. :deprecated: Use register_vnet instead.","title":"SlotMapStore().register_cna"},{"location":"pypowervm/tasks/slot_map/#arguments_9","text":"cna - CNA EntryWrapper to register.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#signature_19","text":"def register_cna(self, cna): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoreregister_max_vslots","text":"Show source in slot_map.py:159 Register the maximum number of virtual slots on the source LPAR.","title":"SlotMapStore().register_max_vslots"},{"location":"pypowervm/tasks/slot_map/#arguments_10","text":"SlotMapStore().max_vslots - The maximum number of virtual slots on the LPAR.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#signature_20","text":"def register_max_vslots(self, max_vslots): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoreregister_vfc_mapping","text":"Show source in slot_map.py:216 Incorporate the slot topology associated with a VFC mapping.","title":"SlotMapStore().register_vfc_mapping"},{"location":"pypowervm/tasks/slot_map/#arguments_11","text":"vfcmap - VFCMapping ElementWrapper representing the mapping to be incorporated. fab - The fabric name associated with the mapping.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#signature_21","text":"def register_vfc_mapping(self, vfcmap, fab): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoreregister_vnet","text":"Show source in slot_map.py:166 Register the slot number for a CNA or VNIC.","title":"SlotMapStore().register_vnet"},{"location":"pypowervm/tasks/slot_map/#arguments_12","text":"vnet_w - Either a CNA wrapper or a VNIC wrapper. :raises: InvalidVirtualNetworkDeviceType: If the wrapper passed in is not a CNA or VNIC this will be raised.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#signature_22","text":"def register_vnet(self, vnet_w): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoreregister_vscsi_mapping","text":"Show source in slot_map.py:285 Incorporate the slot topology associated with a VSCSI mapping.","title":"SlotMapStore().register_vscsi_mapping"},{"location":"pypowervm/tasks/slot_map/#arguments_13","text":"vscsimap - VSCSIMapping ElementWrapper to be incorporated into the slot topology.","title":"Arguments"},{"location":"pypowervm/tasks/slot_map/#signature_23","text":"def register_vscsi_mapping(self, vscsimap): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoresave","text":"Show source in slot_map.py:116 Save this slot map to storage, if needed.","title":"SlotMapStore().save"},{"location":"pypowervm/tasks/slot_map/#signature_24","text":"def save(self): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoreserialized","text":"Show source in slot_map.py:89 Internal use only. Do not override. Do not invoke.","title":"SlotMapStore().serialized"},{"location":"pypowervm/tasks/slot_map/#signature_25","text":"@property def serialized(self): ...","title":"Signature"},{"location":"pypowervm/tasks/slot_map/#slotmapstoretopology","text":"Show source in slot_map.py:307 Produce the slot-to-I/O topology structure from this SlotMapStore.","title":"SlotMapStore().topology"},{"location":"pypowervm/tasks/slot_map/#returns_7","text":"A dict of the form: { slot_num: { IOCLASS: { io_key: extra_spec } } } ...where: slot_num: Integer client slot ID. IOCLASS: The IOCLASS enum indicating the type of I/O. Each IOCLASS enum is only present if the source had at least one I/O element of that type. io_key: The unique identifier of the mapped I/O element. This differs by IOCLASS type - see below. extra_spec: Additional information about the I/O element. This differs by IOCLASS type - see below.","title":"Returns"},{"location":"pypowervm/tasks/slot_map/#ioclass-stg_key-extra_spec","text":"CNA CNA.mac VSwitch.name VOPT VOptMedia.udid Media name VDISK VDisk.udid VDisk.capacity (float) PV PV.udid LUA LU LU.udid LUA VFC fabric name None VNIC VNIC.mac None","title":"IOCLASS     stg_key                     extra_spec"},{"location":"pypowervm/tasks/slot_map/#signature_26","text":"@property def topology(self): ...","title":"Signature"},{"location":"pypowervm/tasks/sriov/","text":"Sriov Pypowervm Index / Pypowervm / Tasks / Sriov Auto-generated documentation for pypowervm.tasks.sriov module. Attributes PPORT_MOD_LOCK - Take read_lock on operations that create/delete VFs (including VNIC). This is a read_lock so we don't serialize all VF creation globally. Take write_lock on operations that modify properties of physical ports and rely on knowing the usage counts thereon (e.g. changing port labels).: lock.ReaderWriterLock() Sriov find_pport find_pports_for_portlabel get_lpar_vnics safe_update_pports set_vnic_back_devs find_pport Show source in sriov.py:568 Find an SR-IOV physical port based on its location code. Arguments sys_w - pypowervm.wrappers.managed_system.System wrapper of the host. physloc - Physical location code string (per SRIOV*PPort.loc_code) of the SR-IOV physical port to find. Returns SRIOVEthPPort or SRIOVConvPPort wrapper with the specified location code, or None if no such port exists in sys_w. Signature def find_pport(sys_w, physloc): ... find_pports_for_portlabel Show source in sriov.py:547 Find SR-IOV physical ports based on the port label. Arguments portlabel - portlabel of the SR-IOV physical ports to find. adapter - The pypowervm adapter API interface. msys - pypowervm.wrappers.managed_system.System wrapper.If not specified, it will be retrieved from the server. Returns List of SRIOVEthPPort or SRIOVConvPPort wrappers for the specified port label, or the empty list if no such port exists. Signature def find_pports_for_portlabel(portlabel, adapter, msys=None): ... get_lpar_vnics Show source in sriov.py:392 Return a dict mapping LPAR wrappers to their VNIC feeds. Arguments adapter - The pypowervm.adapter.Adapter for REST API communication. Returns A dict of the form { LPAR: [VNIC, ...] }, where the keys are pypowervm.wrappers.logical_partition.LPAR and the values are lists of the pypowervm.wrappers.iocard.VNIC they own. Signature def get_lpar_vnics(adapter): ... safe_update_pports Show source in sriov.py:463 Retrying entry transaction for safe updates to SR-IOV physical ports. Usage: def changes(sys_w): for sriov in sys_w.asio_config.sriov_adapters: ... sriov.phys_ports[n].pport.label = some_new_label ... update_needed = True ... return update_needed sys_w = safe_update_pports(System.getter(adap), changes, force=maybe) The consumer passes a callback method which makes changes to the labels of the physical ports of the ManagedSystem's SR-IOV adapters. If the callback returns a False value (indicating that no update is necessary), safe_update_pports immediately returns the sys_w. If the callback returns a True value, safe_update_pports first checks whether any of the changed ports are in use by vNICs (see \"Why vNICs?\" below). If the force option is not True, and any uses were found, this method raises an exception whose text includes details about the found usages. Otherwise, the found usages are logged as warnings. Assuming no exception is raised, safe_update_pports attempts to update the sys_w wrapper with the REST server. (The caller does not do the update.) If an etag mismatch is encountered, safe_update_pports refreshes the sys_w wrapper and retries, according to the semantics of entry_transaction. Why vNICs? Care must be taken when changing port labels on the fly because those labels are used by LPM to ensure that the LPAR on the target system gets equivalent connectivity. Direct-attached VFs - either those belonging to VIOSes (e.g. for SEA) or to LPARs - mean the partition is not migratable, so the labels can be changed with impunity. And the only way a VF is migratable is if it belongs to a vNIC on a migratable LPAR. Arguments sys_w - pypowervm.wrappers.managed_system.System wrapper or getter thereof. callback_func - Method executing the actual changes on the sys_w. The method must accept sys_w (a System wrapper) as its only argument. Its return value will be interpreted as a boolean to determine whether to perform the update() (True) or not (False). force - If False (the default) and any of the updated physical ports are found to be in use by vNICs, the method will raise. If True, warnings are logged for each such usage, but the method will succeed. Returns The (possibly-updated) sys_w. Raises CantUpdatePPortsInUse - If any of the relabeled physical ports are in use by vNICs and the force option is False. Signature @tx.entry_transaction def safe_update_pports(sys_w, callback_func, force=False): ... set_vnic_back_devs Show source in sriov.py:52 Set a vNIC's backing devices over given SRIOV physical ports and VIOSes. Assign the backing devices to a iocard.VNIC wrapper using an anti-affinity algorithm. That is, the method attempts to distribute the backing devices across as diverse a range of physical SRIOV adapters and VIOSes as possible, using the least-saturated ports first. For example, given: vios1, vios2 SRIOVAdapter1 PPortA (50% allocated) PPortB (20%) PPortC (45%) SRIOVAdapter2 PPortD (10%) PPortE (2%) PPortF (11%) set_vnic_back_devs(vnic, [PPortA, PPortB, PPortC, PPortD, PPortE, PPortF], [vios1, vios2], redundancy=4) ...we will create backing devices like: [(vios1, PPortE), (vios2, PPortB), (vios1, PPortD), (vios2, PPortC)] As part of the algorithm, we will use sriov_adaps to filter out physical ports which are already saturated. This could err either way due to out-of-band changes: - We may end up excluding a port which has had some capacity freed up since sriov_adaps was retrieved; or - We may attempt to include a port which has become saturated since sriov_adaps was retrieved, resulting in an error from the REST server. This method acts on the vNIC-related capabilities on the system and VIOSes: - If the system is not vNIC capable, the method will fail. - If none of the active VIOSes are vNIC capable, the method will fail. - If redundancy > 1, - the system must be vNIC failover capable, and - at least one active VIOS must be vNIC failover capable. - If any VIOSes are vNIC failover capable, failover-incapable VIOSes will be ignored. Arguments vnic_w - iocard.VNIC wrapper, as created via VNIC.bld(). If vnic_w.back_devs is nonempty, it is cleared and replaced. This parameter is modified by the method (there is no return value). If this method raises an exception, vnic_w is guaranteed to be unchanged. pports - List of physical location code strings (corresponding to the loc_code @property of iocard.SRIOV*PPort) for all SRIOV physical ports to be considered as backing devices for the vNIC. This does not mean that all of these ports will be used. sys_w - Pre-fetched pypowervm.wrappers.managed_system.System wrapper. If not specified, it will be fetched from the server. vioses - List of VIOS wrappers to consider for distribution of vNIC servers. Not all listed VIOSes will necessarily be used. If not specified, the feed of all active (including RMC) VIOSes will be fetched from the server. If specified, the list will be filtered to include only active (including RMC) VIOSes (according to the wrappers - the server is not re- checked). The list is also filtered to remove VIOSes which are not vNIC capable; and, if min_redundancy > 1, to remove VIOSes which are not vNIC failover capable. redundancy - Number of backing devices to assign. If the method can't allocate this many VFs after filtering the pports list, InsufficientSRIOVCapacity will be raised. Note that at most one VF is created on each physical port. capacity - (float) Minimum capacity to assign to each backing device. Must be between 0.0 and 1.0, and must be a multiple of the min_granularity of all of the pports. (Capacity may be assigned to each individual backing device after the fact to achieve more control; but in that case, the consumer is responsible for validating sufficient available capacity.) max_capacity - (float) Maximum capacity to assign to each backing device. Must be greater or equal to capacity and less than 1.0. redundant_pports - List of physical location code strings (corresponding to the loc_code @property of iocard.SRIOV*PPort) for all SRIOV redundant physical ports to be considered as backing devices for the vNIC. This does not mean that all of these ports will be used. check_port_status - If True, only ports with link-up status will be considered for allocation. If False (the default), link-down ports may be used. Raises NoRunningSharedSriovAdapters - If no SR-IOV adapters in Sriov mode and Running state can be found. NotEnoughActiveVioses - If no active (including RMC) VIOSes can be found. InsufficientSRIOVCapacity - If the method was not able to allocate enough VFs to satisfy the specified redundancy. SystemNotVNICCapable - If the managed system is not vNIC capable. NoVNICCapableVIOSes - If there are no vNIC-capable VIOSes. VNICFailoverNotSupportedSys - If redundancy > 1, and the system is not vNIC failover capable. VNICFailoverNotSupportedVIOS - If redundancy > 1, and there are no vNIC failover-capable VIOSes. Signature def set_vnic_back_devs( vnic_w, pports, sys_w=None, vioses=None, redundancy=1, capacity=None, max_capacity=None, check_port_status=False, redundant_pports=None, ): ...","title":"Sriov"},{"location":"pypowervm/tasks/sriov/#sriov","text":"Pypowervm Index / Pypowervm / Tasks / Sriov Auto-generated documentation for pypowervm.tasks.sriov module.","title":"Sriov"},{"location":"pypowervm/tasks/sriov/#attributes","text":"PPORT_MOD_LOCK - Take read_lock on operations that create/delete VFs (including VNIC). This is a read_lock so we don't serialize all VF creation globally. Take write_lock on operations that modify properties of physical ports and rely on knowing the usage counts thereon (e.g. changing port labels).: lock.ReaderWriterLock() Sriov find_pport find_pports_for_portlabel get_lpar_vnics safe_update_pports set_vnic_back_devs","title":"Attributes"},{"location":"pypowervm/tasks/sriov/#find_pport","text":"Show source in sriov.py:568 Find an SR-IOV physical port based on its location code.","title":"find_pport"},{"location":"pypowervm/tasks/sriov/#arguments","text":"sys_w - pypowervm.wrappers.managed_system.System wrapper of the host. physloc - Physical location code string (per SRIOV*PPort.loc_code) of the SR-IOV physical port to find.","title":"Arguments"},{"location":"pypowervm/tasks/sriov/#returns","text":"SRIOVEthPPort or SRIOVConvPPort wrapper with the specified location code, or None if no such port exists in sys_w.","title":"Returns"},{"location":"pypowervm/tasks/sriov/#signature","text":"def find_pport(sys_w, physloc): ...","title":"Signature"},{"location":"pypowervm/tasks/sriov/#find_pports_for_portlabel","text":"Show source in sriov.py:547 Find SR-IOV physical ports based on the port label.","title":"find_pports_for_portlabel"},{"location":"pypowervm/tasks/sriov/#arguments_1","text":"portlabel - portlabel of the SR-IOV physical ports to find. adapter - The pypowervm adapter API interface. msys - pypowervm.wrappers.managed_system.System wrapper.If not specified, it will be retrieved from the server.","title":"Arguments"},{"location":"pypowervm/tasks/sriov/#returns_1","text":"List of SRIOVEthPPort or SRIOVConvPPort wrappers for the specified port label, or the empty list if no such port exists.","title":"Returns"},{"location":"pypowervm/tasks/sriov/#signature_1","text":"def find_pports_for_portlabel(portlabel, adapter, msys=None): ...","title":"Signature"},{"location":"pypowervm/tasks/sriov/#get_lpar_vnics","text":"Show source in sriov.py:392 Return a dict mapping LPAR wrappers to their VNIC feeds.","title":"get_lpar_vnics"},{"location":"pypowervm/tasks/sriov/#arguments_2","text":"adapter - The pypowervm.adapter.Adapter for REST API communication.","title":"Arguments"},{"location":"pypowervm/tasks/sriov/#returns_2","text":"A dict of the form { LPAR: [VNIC, ...] }, where the keys are pypowervm.wrappers.logical_partition.LPAR and the values are lists of the pypowervm.wrappers.iocard.VNIC they own.","title":"Returns"},{"location":"pypowervm/tasks/sriov/#signature_2","text":"def get_lpar_vnics(adapter): ...","title":"Signature"},{"location":"pypowervm/tasks/sriov/#safe_update_pports","text":"Show source in sriov.py:463 Retrying entry transaction for safe updates to SR-IOV physical ports. Usage: def changes(sys_w): for sriov in sys_w.asio_config.sriov_adapters: ... sriov.phys_ports[n].pport.label = some_new_label ... update_needed = True ... return update_needed sys_w = safe_update_pports(System.getter(adap), changes, force=maybe) The consumer passes a callback method which makes changes to the labels of the physical ports of the ManagedSystem's SR-IOV adapters. If the callback returns a False value (indicating that no update is necessary), safe_update_pports immediately returns the sys_w. If the callback returns a True value, safe_update_pports first checks whether any of the changed ports are in use by vNICs (see \"Why vNICs?\" below). If the force option is not True, and any uses were found, this method raises an exception whose text includes details about the found usages. Otherwise, the found usages are logged as warnings. Assuming no exception is raised, safe_update_pports attempts to update the sys_w wrapper with the REST server. (The caller does not do the update.) If an etag mismatch is encountered, safe_update_pports refreshes the sys_w wrapper and retries, according to the semantics of entry_transaction. Why vNICs? Care must be taken when changing port labels on the fly because those labels are used by LPM to ensure that the LPAR on the target system gets equivalent connectivity. Direct-attached VFs - either those belonging to VIOSes (e.g. for SEA) or to LPARs - mean the partition is not migratable, so the labels can be changed with impunity. And the only way a VF is migratable is if it belongs to a vNIC on a migratable LPAR.","title":"safe_update_pports"},{"location":"pypowervm/tasks/sriov/#arguments_3","text":"sys_w - pypowervm.wrappers.managed_system.System wrapper or getter thereof. callback_func - Method executing the actual changes on the sys_w. The method must accept sys_w (a System wrapper) as its only argument. Its return value will be interpreted as a boolean to determine whether to perform the update() (True) or not (False). force - If False (the default) and any of the updated physical ports are found to be in use by vNICs, the method will raise. If True, warnings are logged for each such usage, but the method will succeed.","title":"Arguments"},{"location":"pypowervm/tasks/sriov/#returns_3","text":"The (possibly-updated) sys_w.","title":"Returns"},{"location":"pypowervm/tasks/sriov/#raises","text":"CantUpdatePPortsInUse - If any of the relabeled physical ports are in use by vNICs and the force option is False.","title":"Raises"},{"location":"pypowervm/tasks/sriov/#signature_3","text":"@tx.entry_transaction def safe_update_pports(sys_w, callback_func, force=False): ...","title":"Signature"},{"location":"pypowervm/tasks/sriov/#set_vnic_back_devs","text":"Show source in sriov.py:52 Set a vNIC's backing devices over given SRIOV physical ports and VIOSes. Assign the backing devices to a iocard.VNIC wrapper using an anti-affinity algorithm. That is, the method attempts to distribute the backing devices across as diverse a range of physical SRIOV adapters and VIOSes as possible, using the least-saturated ports first. For example, given: vios1, vios2 SRIOVAdapter1 PPortA (50% allocated) PPortB (20%) PPortC (45%) SRIOVAdapter2 PPortD (10%) PPortE (2%) PPortF (11%) set_vnic_back_devs(vnic, [PPortA, PPortB, PPortC, PPortD, PPortE, PPortF], [vios1, vios2], redundancy=4) ...we will create backing devices like: [(vios1, PPortE), (vios2, PPortB), (vios1, PPortD), (vios2, PPortC)] As part of the algorithm, we will use sriov_adaps to filter out physical ports which are already saturated. This could err either way due to out-of-band changes: - We may end up excluding a port which has had some capacity freed up since sriov_adaps was retrieved; or - We may attempt to include a port which has become saturated since sriov_adaps was retrieved, resulting in an error from the REST server. This method acts on the vNIC-related capabilities on the system and VIOSes: - If the system is not vNIC capable, the method will fail. - If none of the active VIOSes are vNIC capable, the method will fail. - If redundancy > 1, - the system must be vNIC failover capable, and - at least one active VIOS must be vNIC failover capable. - If any VIOSes are vNIC failover capable, failover-incapable VIOSes will be ignored.","title":"set_vnic_back_devs"},{"location":"pypowervm/tasks/sriov/#arguments_4","text":"vnic_w - iocard.VNIC wrapper, as created via VNIC.bld(). If vnic_w.back_devs is nonempty, it is cleared and replaced. This parameter is modified by the method (there is no return value). If this method raises an exception, vnic_w is guaranteed to be unchanged. pports - List of physical location code strings (corresponding to the loc_code @property of iocard.SRIOV*PPort) for all SRIOV physical ports to be considered as backing devices for the vNIC. This does not mean that all of these ports will be used. sys_w - Pre-fetched pypowervm.wrappers.managed_system.System wrapper. If not specified, it will be fetched from the server. vioses - List of VIOS wrappers to consider for distribution of vNIC servers. Not all listed VIOSes will necessarily be used. If not specified, the feed of all active (including RMC) VIOSes will be fetched from the server. If specified, the list will be filtered to include only active (including RMC) VIOSes (according to the wrappers - the server is not re- checked). The list is also filtered to remove VIOSes which are not vNIC capable; and, if min_redundancy > 1, to remove VIOSes which are not vNIC failover capable. redundancy - Number of backing devices to assign. If the method can't allocate this many VFs after filtering the pports list, InsufficientSRIOVCapacity will be raised. Note that at most one VF is created on each physical port. capacity - (float) Minimum capacity to assign to each backing device. Must be between 0.0 and 1.0, and must be a multiple of the min_granularity of all of the pports. (Capacity may be assigned to each individual backing device after the fact to achieve more control; but in that case, the consumer is responsible for validating sufficient available capacity.) max_capacity - (float) Maximum capacity to assign to each backing device. Must be greater or equal to capacity and less than 1.0. redundant_pports - List of physical location code strings (corresponding to the loc_code @property of iocard.SRIOV*PPort) for all SRIOV redundant physical ports to be considered as backing devices for the vNIC. This does not mean that all of these ports will be used. check_port_status - If True, only ports with link-up status will be considered for allocation. If False (the default), link-down ports may be used.","title":"Arguments"},{"location":"pypowervm/tasks/sriov/#raises_1","text":"NoRunningSharedSriovAdapters - If no SR-IOV adapters in Sriov mode and Running state can be found. NotEnoughActiveVioses - If no active (including RMC) VIOSes can be found. InsufficientSRIOVCapacity - If the method was not able to allocate enough VFs to satisfy the specified redundancy. SystemNotVNICCapable - If the managed system is not vNIC capable. NoVNICCapableVIOSes - If there are no vNIC-capable VIOSes. VNICFailoverNotSupportedSys - If redundancy > 1, and the system is not vNIC failover capable. VNICFailoverNotSupportedVIOS - If redundancy > 1, and there are no vNIC failover-capable VIOSes.","title":"Raises"},{"location":"pypowervm/tasks/sriov/#signature_4","text":"def set_vnic_back_devs( vnic_w, pports, sys_w=None, vioses=None, redundancy=1, capacity=None, max_capacity=None, check_port_status=False, redundant_pports=None, ): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/","text":"Storage Pypowervm Index / Pypowervm / Tasks / Storage Auto-generated documentation for pypowervm.tasks.storage module. Attributes LOG - Setup logging: logging.getLogger(__name__) Storage ComprehensiveScrub ScrubOrphanStorageForLpar ScrubPortlessVFCMaps UploadType add_lpar_storage_scrub_tasks add_orphan_storage_scrub_tasks crt_copy_vdisk crt_lu crt_lu_linked_clone crt_vdisk default_tier_for_ssp find_stale_lpars find_vg rescan_vstor rm_ssp_storage rm_tier_storage rm_vg_storage upload_lu upload_new_lu Default/legacy behavior With return_ssp=True upload_new_vdisk upload_vopt ComprehensiveScrub Show source in storage.py:1278 Scrub all the stale/orphan mappings/storage we can find. A FeedTask which does the following: For all VIOSes (on the host): For each stale LPAR Scrub mappings & storage Scrub all orphan mappings (those without client adapters) Signature class ComprehensiveScrub(tx.FeedTask): def __init__(self, adapter, host_uuid=None): ... ScrubOrphanStorageForLpar Show source in storage.py:1320 Scrub orphan mappings and their storage for one specific LPAR. Signature class ScrubOrphanStorageForLpar(tx.FeedTask): def __init__(self, adapter, lpar_id, host_uuid=None): ... ScrubPortlessVFCMaps Show source in storage.py:1348 Scrub virtual fibre channel mappings which have no backing port. Signature class ScrubPortlessVFCMaps(tx.FeedTask): def __init__(self, adapter, lpar_id=None, host_uuid=None): ... UploadType Show source in storage.py:62 Attributes IO_STREAM - The data stream (either a file handle or stream) to upload. Must have the 'read' method that returns a chunk of bytes.: 'stream' IO_STREAM_BUILDER - A parameter-less function that builds an IO_STREAM.: 'stream_builder' FUNC - DEPRECATED: Known issues combining threads and greenlets may cause hangs. A method function that will be invoked to stream the data into the virtual disk. Only one parameter is passed in, and that is the path to the file to stream the data into.: 'delegate_function' Used in conjunction with the upload_xx methods. Indicates how the invoker will pass in the handle to the data. Signature class UploadType(object): ... add_lpar_storage_scrub_tasks Show source in storage.py:1165 Delete storage mappings and elements associated with an LPAR ID. This should typically be used to clean leftovers from an LPAR that has been deleted, since stale storage artifacts can cause conflicts with a new LPAR recycling that ID. This operates by inspecting mappings first, since we have no other way to associate a mapping-less storage element with an LPAR ID. Storage elements are deleted if their only mappings are to the LPAR ID being scrubbed (and remove_storage=True). This method only adds subtasks/post-execs to the passed-in FeedTask. The caller is responsible for executing that FeedTask in an appropriate Flow or other context. Arguments lpar_ids - List of integer short IDs (not UUIDs) of the LPAR whose storage artifacts are to be scrubbed. ftsk - FeedTask to which the scrubbing actions should be added, for execution by the caller. The FeedTask must be built for all the VIOSes from which mappings and storage should be scrubbed. The feed/getter must use the VIO_SMAP and VIO_FMAP xags. lpars_exist - (Optional) If set to False (the default), storage artifacts associated with an extant LPAR will be ignored (NOT scrubbed). Otherwise, we will scrub whether the LPAR exists or not. Thus, set to True only if intentionally removing mappings associated with extant LPARs. remove_storage - If True (the default), storage elements associated with stale mappings are removed, assuming it can be verified that they were only in use by this LPAR. If False, no storage removal is attempted. Signature def add_lpar_storage_scrub_tasks(lpar_ids, ftsk, lpars_exist=False, remove_storage=True): ... add_orphan_storage_scrub_tasks Show source in storage.py:1235 Delete orphan mappings (no client adapter) and their storage elements. Arguments ftsk - FeedTask to which the scrubbing actions should be added, for execution by the caller. The FeedTask must be built for all the VIOSes from which mappings and storage should be scrubbed. The feed/getter must use the VIO_SMAP and VIO_FMAP xags. lpar_id - (Optional) Only orphan mappings associated with the specified LPAR ID will be removed. If None (the default), all LPARs' mappings will be considered. Signature def add_orphan_storage_scrub_tasks(ftsk, lpar_id=None): ... crt_copy_vdisk Show source in storage.py:106 Create a new virtual disk that contains all the data of the src given. Arguments adapter - The adapter to talk over the API. v_uuid - The UUID of the Virtual I/O Server that will host the new VDisk. vol_grp_uuid - The UUID of the volume group that will host the new VDisk. src - UDID of virtual disk to copy data from f_size - The size (in bytes) of the src disk. d_name - The name that should be given to the disk on the Virtual I/O Server that will contain the file. d_size - (Optional) The desired size of the new VDisk in bytes. If omitted or smaller than f_size, it will be set to match f_size. file_format - (Optional) File format of src VDisk. See stor.FileFormatType enumeration for valid formats. Returns The virtual disk that the file is uploaded into. Signature def crt_copy_vdisk( adapter, v_uuid, vol_grp_uuid, src, f_size, d_name, d_size=None, file_format=None ): ... crt_lu Show source in storage.py:821 Create a Logical Unit on the specified Tier. Arguments tier_or_ssp - Tier or SSP EntryWrapper denoting the Tier or Shared Storage Pool on which to create the LU. If an SSP is supplied, the LU is created on the default Tier. name - Name for the new Logical Unit. size - LU size in GB with decimal precision. thin - Provision the new LU as Thin (True) or Thick (False). If unspecified, use the server default. typ - The type of LU to create, one of the LUType values. If unspecified, use the server default. clone - If the new LU is to be a linked clone, this param is a LU(Ent) wrapper representing the backing image LU. Returns If the tier_or_ssp argument is an SSP, the updated SSP wrapper (containing the new LU and with a new etag) is returned. Otherwise, the first return value is the Tier. LU ElementWrapper representing the Logical Unit just created. Signature def crt_lu(tier_or_ssp, name, size, thin=None, typ=None, clone=None): ... crt_lu_linked_clone Show source in storage.py:512 Create a new LU as a linked clone to a backing image LU. :deprecated: Use crt_lu instead. Arguments ssp - The SSP EntryWrapper representing the SharedStoragePool on which to create the new LU. cluster - The Cluster EntryWrapper representing the Cluster against which to invoke the LULinkedClone Job. src_lu - The LU ElementWrapper or LUEnt EntryWrapper representing the link source. new_lu_name - The name to be given to the new LU. lu_size_gb - The size of the new LU in GB with decimal precision. If this is not specified or is smaller than the size of the image_lu, the size of the image_lu is used. Returns The updated SSP EntryWrapper containing the newly-created LU. The newly created and linked LU. Signature def crt_lu_linked_clone(ssp, cluster, src_lu, new_lu_name, lu_size_gb=0): ... crt_vdisk Show source in storage.py:623 Creates a new Virtual Disk in the specified volume group. Arguments adapter - The pypowervm.adapter.Adapter through which to request the change. v_uuid - The UUID of the Virtual I/O Server that will host the disk. vol_grp_uuid - The volume group that will host the new Virtual Disk. d_name - The name that should be given to the disk on the Virtual I/O Server that will contain the file. d_size_gb - The size of the disk in GB. base_image - (Optional) The UDID of a VDisk to copy data from. file_format - (Optional) File format of the new VirtualDisk. See stor.FileFormatType enumeration for valid formats. Returns VDisk ElementWrapper representing the new VirtualDisk from the server response (i.e. UDID will be populated). :raise exc.Error: If the server response from attempting to add the VDisk does not contain the new VDisk. Signature @lock.synchronized(_LOCK_VOL_GRP) def crt_vdisk( adapter, v_uuid, vol_grp_uuid, d_name, d_size_gb, base_image=None, file_format=None ): ... default_tier_for_ssp Show source in storage.py:497 Find the default Tier for the given Shared Storage Pool. Arguments ssp - The SSP EntryWrapper whose default Tier is to be retrieved. Returns Tier EntryWrapper representing ssp's default Tier. Raises NoDefaultTierFoundOnSSP - If no default Tier is found on the specified Shared Storage Pool. Signature def default_tier_for_ssp(ssp): ... find_stale_lpars Show source in storage.py:1252 Find orphan LPAR IDs in a Virtual I/O Server's VSCSI/VFC mappings. This method collates all client LPAR IDs from the VSCSI/VFC mappings of the specified VIOS wrapper and compares to the list of LPAR IDs on that VIOS's host, returning the list of any IDs which exist in the former but not the latter. Arguments vios_w - VIOS EntryWrapper. To be effective, this must have been retrieved with the VIO_SMAP and VIO_FMAP extended attribute groups. Returns List of LPAR IDs (integer short IDs, not UUIDs) which don't exist on the system. The list is guaranteed to contain no duplicates. Signature def find_stale_lpars(vios_w): ... find_vg Show source in storage.py:589 Returns the VIOS and VG wrappers for the volume group. Arguments adapter - pypowervm.adapter.Adapter for REST communication. vg_name - Name of the volume group to find. vios_name - The name of the VIOS on which to search for the volume group. If not specified, all VIOSes are searched. Returns Type: vios_wrap The VIOS wrapper representing the Virtual I/O Server on which the volume group was found. Type: vg_wrap The VG wrapper representing the volume group. Raises VIOSNotFound - If vios_name was specified and no such VIOS exists. VGNotFound - If no volume group of the specified vg_name could be found. Signature def find_vg(adapter, vg_name, vios_name=None): ... rescan_vstor Show source in storage.py:668 Update the internal metadata for a virtual storage object. Arguments vio - A VIOS wrapper or UUID string of the VIOS on which to perform the rescan. vstor - The VDisk wrapper or udid of the storage object to rescan. adapter - A pypowervm.adapter.Adapter for REST API communication. Required if neither vio nor vstor is a wrapper, optional otherwise. Raises AdapterNotFound - If no adapter attribute can be found. JobRequestFailed - If the rescan failed. JobRequestTimedOut - If the rescan Job timed out. Signature def rescan_vstor(vio, vstor, adapter=None): ... rm_ssp_storage Show source in storage.py:941 Remove some number of LogicalUnits from a SharedStoragePool. The changes are flushed back to the REST server. Arguments ssp_wrap - SSP EntryWrapper representing the SharedStoragePool to modify. lus - Iterable of LU ElementWrappers or LUEnt EntryWrappers representing the LogicalUnits to delete. del_unused_images - If True, and a removed Disk LU was the last one linked to its backing Image LU, the backing Image LU is also removed. Returns The (possibly) modified SSP wrapper. Signature @tx.entry_transaction def rm_ssp_storage(ssp_wrap, lus, del_unused_images=True): ... rm_tier_storage Show source in storage.py:898 Remove Logical Units from a Shared Storage Pool Tier. Arguments lus_to_rm - Iterable of LU ElementWrappers or LUEnt EntryWrappers representing the LogicalUnits to delete. tier - Tier EntryWrapper representing the SSP Tier on which the lus_to_rm (and their backing images) reside. Either tier or lufeed is required. If both are specified, tier is ignored. lufeed - Pre-fetched list of LUEnt (i.e. result of a GET of Tier/{uuid}/LogicalUnit) where we expect to find the lus_to_rm (and their backing images). Either tier or lufeed is required. If both are specified, tier is ignored. del_unused_images - If True, and a removed Disk LU was the last one linked to its backing Image LU, the backing Image LU is also removed. Raises ValueError - - If neither tier nor lufeed was supplied. - If lufeed was supplied but doesn't contain LUEnt EntryWrappers (e.g. the caller provided SSP.logical_units). Signature def rm_tier_storage(lus_to_rm, tier=None, lufeed=None, del_unused_images=True): ... rm_vg_storage Show source in storage.py:706 Remove storage elements from a volume group. Changes are flushed back to the REST server. Arguments vg_wrap - VG wrapper representing the Volume Group to update. vdisks - Iterable of VDisk wrappers representing the Virtual Disks to delete. Ignored if None or empty. vopts - Iterable of VOptMedia wrappers representing Virtual Optical devices to delete. Ignored if None or empty. Returns The (possibly) updated vg_wrap. Signature @lock.synchronized(_LOCK_VOL_GRP) @retry.retry( argmod_func=retry.refresh_wrapper, tries=60, delay_func=retry.STEPPED_RANDOM_DELAY ) def rm_vg_storage(vg_wrap, vdisks=None, vopts=None): ... upload_lu Show source in storage.py:307 Uploads a data stream to an existing SSP Logical Unit. Arguments v_uuid - The UUID of the Virtual I/O Server through which to perform the upload. lu - LU Wrapper representing the Logical Unit to which to upload the data. The LU must already exist in the SSP. io_handle - The I/O handle (as defined by the upload_type) f_size - The size (in bytes) of the stream to be uploaded. sha_chksum - (Optional) The SHA256 checksum for the file. Useful for integrity checks. upload_type - (Optional, Default: IO_STREAM) Defines the way in which the LU should be uploaded. Refer to the UploadType enumeration for valid upload mechanisms. Returns Normally the return value will be None, indicating that the image was uploaded without issue. If for some reason the File metadata for the VIOS was not cleaned up, the return value is the LU EntryWrapper. This is simply a marker to be later used to retry the cleanup. Signature def upload_lu( v_uuid, lu, io_handle, f_size, sha_chksum=None, upload_type=UploadType.IO_STREAM ): ... upload_new_lu Show source in storage.py:249 Creates a new SSP Logical Unit and uploads an image to it. Note: return spec varies based on the return_ssp parameter: Default/legacy behavior new_lu, maybe_file = upload_new_lu(..., return_ssp=False) With return_ssp=True ssp, new_lu, maybe_file = upload_new_lu(..., return_ssp=True) Arguments v_uuid - The UUID of the Virtual I/O Server through which to perform the upload. (Note that the new LU will be visible from any VIOS in the Shared Storage Pool's Cluster.) ssp - SSP EntryWrapper representing the Shared Storage Pool on which to create the new Logical Unit. io_handle - The I/O handle (as defined by the upload_type) lu_name - The name that should be given to the new LU. f_size - The size (in bytes) of the stream to be uploaded. d_size - (OPTIONAL) The size of the LU (in bytes). Not required if it should match the file. Must be at least as large as the file. sha_chksum - (Optional) The SHA256 checksum for the file. Useful for integrity checks. return_ssp - (Optional) If True, the return value of the method is a three-member tuple whose third value is the updated SSP EntryWrapper. If False (the default), the method returns a two-member tuple. upload_type - (Optional, Default: IO_STREAM) Defines the way in which the LU should be uploaded. Refer to the UploadType enumeration for valid upload mechanisms. Returns If the return_ssp parameter is True, the first return value is the updated SSP EntryWrapper, containing the newly-created and -uploaded LU. If return_ssp is False, this return value is absent - only the below two values are returned. An LU EntryWrapper corresponding to the Logical Unit into which the file was uploaded. Normally None, indicating that the LU was created and the image was uploaded without issue. If for some reason the File metadata for the VIOS was not cleaned up, the return value is the File EntryWrapper. This is simply a marker to be later used to retry the cleanup. Signature def upload_new_lu( v_uuid, ssp, io_handle, lu_name, f_size, d_size=None, sha_chksum=None, return_ssp=False, upload_type=UploadType.IO_STREAM, ): ... upload_new_vdisk Show source in storage.py:151 Uploads a new virtual disk. Arguments adapter - The adapter to talk over the API. v_uuid - The Virtual I/O Server UUID that will host the disk. vol_grp_uuid - The volume group that will host the Virtual Disk's UUID. io_handle - The I/O handle (as defined by the upload_type) d_name - The name that should be given to the disk on the Virtual I/O Server that will contain the file. f_size - The size (in bytes) of the stream to be uploaded. d_size - (Optional) The desired size of the new VDisk in bytes. If omitted or smaller than f_size, it will be set to match f_size. sha_chksum - (Optional) The SHA256 checksum for the file. Useful for integrity checks. upload_type - (Optional, Default: IO_STREAM) Defines the way in which the vdisk should be uploaded. Refer to the UploadType enumeration for valid upload mechanisms. file_format - (Optional) Format of file coming from io_handle. See stor.FileFormatType enumeration for valid formats. Returns The first return value is the virtual disk that the file is uploaded into. Normally the second return value will be None, indicating that the disk and image were uploaded without issue. If for some reason the File metadata for the VIOS was not cleaned up, the return value is the File EntryWrapper. This is simply a metadata marker to be later used to retry the cleanup. Signature def upload_new_vdisk( adapter, v_uuid, vol_grp_uuid, io_handle, d_name, f_size, d_size=None, sha_chksum=None, upload_type=UploadType.IO_STREAM, file_format=None, ): ... upload_vopt Show source in storage.py:213 Upload a file/stream into a virtual media repository on the VIOS. Arguments adapter - The adapter to talk over the API. v_uuid - The Virtual I/O Server UUID that will host the file. d_stream - A file path or data stream (must have 'read' method) to upload. f_name - The name that should be given to the file. f_size - (OPTIONAL) The size in bytes of the file to upload. Useful for integrity checks. sha_chksum - (OPTIONAL) The SHA256 checksum for the file. Useful for integrity checks. Returns The vOpt loaded into the media repository. This is a reference, for use in scsi mappings. Normally this method will return None, indicating that the disk and image were uploaded without issue. If for some reason the File metadata for the VIOS was not cleaned up, the return value is the File EntryWrapper. This is simply a marker to be later used to retry the cleanup. Signature def upload_vopt(adapter, v_uuid, d_stream, f_name, f_size=None, sha_chksum=None): ...","title":"Storage"},{"location":"pypowervm/tasks/storage/#storage","text":"Pypowervm Index / Pypowervm / Tasks / Storage Auto-generated documentation for pypowervm.tasks.storage module.","title":"Storage"},{"location":"pypowervm/tasks/storage/#attributes","text":"LOG - Setup logging: logging.getLogger(__name__) Storage ComprehensiveScrub ScrubOrphanStorageForLpar ScrubPortlessVFCMaps UploadType add_lpar_storage_scrub_tasks add_orphan_storage_scrub_tasks crt_copy_vdisk crt_lu crt_lu_linked_clone crt_vdisk default_tier_for_ssp find_stale_lpars find_vg rescan_vstor rm_ssp_storage rm_tier_storage rm_vg_storage upload_lu upload_new_lu Default/legacy behavior With return_ssp=True upload_new_vdisk upload_vopt","title":"Attributes"},{"location":"pypowervm/tasks/storage/#comprehensivescrub","text":"Show source in storage.py:1278 Scrub all the stale/orphan mappings/storage we can find. A FeedTask which does the following: For all VIOSes (on the host): For each stale LPAR Scrub mappings & storage Scrub all orphan mappings (those without client adapters)","title":"ComprehensiveScrub"},{"location":"pypowervm/tasks/storage/#signature","text":"class ComprehensiveScrub(tx.FeedTask): def __init__(self, adapter, host_uuid=None): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#scruborphanstorageforlpar","text":"Show source in storage.py:1320 Scrub orphan mappings and their storage for one specific LPAR.","title":"ScrubOrphanStorageForLpar"},{"location":"pypowervm/tasks/storage/#signature_1","text":"class ScrubOrphanStorageForLpar(tx.FeedTask): def __init__(self, adapter, lpar_id, host_uuid=None): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#scrubportlessvfcmaps","text":"Show source in storage.py:1348 Scrub virtual fibre channel mappings which have no backing port.","title":"ScrubPortlessVFCMaps"},{"location":"pypowervm/tasks/storage/#signature_2","text":"class ScrubPortlessVFCMaps(tx.FeedTask): def __init__(self, adapter, lpar_id=None, host_uuid=None): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#uploadtype","text":"Show source in storage.py:62","title":"UploadType"},{"location":"pypowervm/tasks/storage/#attributes_1","text":"IO_STREAM - The data stream (either a file handle or stream) to upload. Must have the 'read' method that returns a chunk of bytes.: 'stream' IO_STREAM_BUILDER - A parameter-less function that builds an IO_STREAM.: 'stream_builder' FUNC - DEPRECATED: Known issues combining threads and greenlets may cause hangs. A method function that will be invoked to stream the data into the virtual disk. Only one parameter is passed in, and that is the path to the file to stream the data into.: 'delegate_function' Used in conjunction with the upload_xx methods. Indicates how the invoker will pass in the handle to the data.","title":"Attributes"},{"location":"pypowervm/tasks/storage/#signature_3","text":"class UploadType(object): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#add_lpar_storage_scrub_tasks","text":"Show source in storage.py:1165 Delete storage mappings and elements associated with an LPAR ID. This should typically be used to clean leftovers from an LPAR that has been deleted, since stale storage artifacts can cause conflicts with a new LPAR recycling that ID. This operates by inspecting mappings first, since we have no other way to associate a mapping-less storage element with an LPAR ID. Storage elements are deleted if their only mappings are to the LPAR ID being scrubbed (and remove_storage=True). This method only adds subtasks/post-execs to the passed-in FeedTask. The caller is responsible for executing that FeedTask in an appropriate Flow or other context.","title":"add_lpar_storage_scrub_tasks"},{"location":"pypowervm/tasks/storage/#arguments","text":"lpar_ids - List of integer short IDs (not UUIDs) of the LPAR whose storage artifacts are to be scrubbed. ftsk - FeedTask to which the scrubbing actions should be added, for execution by the caller. The FeedTask must be built for all the VIOSes from which mappings and storage should be scrubbed. The feed/getter must use the VIO_SMAP and VIO_FMAP xags. lpars_exist - (Optional) If set to False (the default), storage artifacts associated with an extant LPAR will be ignored (NOT scrubbed). Otherwise, we will scrub whether the LPAR exists or not. Thus, set to True only if intentionally removing mappings associated with extant LPARs. remove_storage - If True (the default), storage elements associated with stale mappings are removed, assuming it can be verified that they were only in use by this LPAR. If False, no storage removal is attempted.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#signature_4","text":"def add_lpar_storage_scrub_tasks(lpar_ids, ftsk, lpars_exist=False, remove_storage=True): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#add_orphan_storage_scrub_tasks","text":"Show source in storage.py:1235 Delete orphan mappings (no client adapter) and their storage elements.","title":"add_orphan_storage_scrub_tasks"},{"location":"pypowervm/tasks/storage/#arguments_1","text":"ftsk - FeedTask to which the scrubbing actions should be added, for execution by the caller. The FeedTask must be built for all the VIOSes from which mappings and storage should be scrubbed. The feed/getter must use the VIO_SMAP and VIO_FMAP xags. lpar_id - (Optional) Only orphan mappings associated with the specified LPAR ID will be removed. If None (the default), all LPARs' mappings will be considered.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#signature_5","text":"def add_orphan_storage_scrub_tasks(ftsk, lpar_id=None): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#crt_copy_vdisk","text":"Show source in storage.py:106 Create a new virtual disk that contains all the data of the src given.","title":"crt_copy_vdisk"},{"location":"pypowervm/tasks/storage/#arguments_2","text":"adapter - The adapter to talk over the API. v_uuid - The UUID of the Virtual I/O Server that will host the new VDisk. vol_grp_uuid - The UUID of the volume group that will host the new VDisk. src - UDID of virtual disk to copy data from f_size - The size (in bytes) of the src disk. d_name - The name that should be given to the disk on the Virtual I/O Server that will contain the file. d_size - (Optional) The desired size of the new VDisk in bytes. If omitted or smaller than f_size, it will be set to match f_size. file_format - (Optional) File format of src VDisk. See stor.FileFormatType enumeration for valid formats.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns","text":"The virtual disk that the file is uploaded into.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_6","text":"def crt_copy_vdisk( adapter, v_uuid, vol_grp_uuid, src, f_size, d_name, d_size=None, file_format=None ): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#crt_lu","text":"Show source in storage.py:821 Create a Logical Unit on the specified Tier.","title":"crt_lu"},{"location":"pypowervm/tasks/storage/#arguments_3","text":"tier_or_ssp - Tier or SSP EntryWrapper denoting the Tier or Shared Storage Pool on which to create the LU. If an SSP is supplied, the LU is created on the default Tier. name - Name for the new Logical Unit. size - LU size in GB with decimal precision. thin - Provision the new LU as Thin (True) or Thick (False). If unspecified, use the server default. typ - The type of LU to create, one of the LUType values. If unspecified, use the server default. clone - If the new LU is to be a linked clone, this param is a LU(Ent) wrapper representing the backing image LU.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_1","text":"If the tier_or_ssp argument is an SSP, the updated SSP wrapper (containing the new LU and with a new etag) is returned. Otherwise, the first return value is the Tier. LU ElementWrapper representing the Logical Unit just created.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_7","text":"def crt_lu(tier_or_ssp, name, size, thin=None, typ=None, clone=None): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#crt_lu_linked_clone","text":"Show source in storage.py:512 Create a new LU as a linked clone to a backing image LU. :deprecated: Use crt_lu instead.","title":"crt_lu_linked_clone"},{"location":"pypowervm/tasks/storage/#arguments_4","text":"ssp - The SSP EntryWrapper representing the SharedStoragePool on which to create the new LU. cluster - The Cluster EntryWrapper representing the Cluster against which to invoke the LULinkedClone Job. src_lu - The LU ElementWrapper or LUEnt EntryWrapper representing the link source. new_lu_name - The name to be given to the new LU. lu_size_gb - The size of the new LU in GB with decimal precision. If this is not specified or is smaller than the size of the image_lu, the size of the image_lu is used.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_2","text":"The updated SSP EntryWrapper containing the newly-created LU. The newly created and linked LU.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_8","text":"def crt_lu_linked_clone(ssp, cluster, src_lu, new_lu_name, lu_size_gb=0): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#crt_vdisk","text":"Show source in storage.py:623 Creates a new Virtual Disk in the specified volume group.","title":"crt_vdisk"},{"location":"pypowervm/tasks/storage/#arguments_5","text":"adapter - The pypowervm.adapter.Adapter through which to request the change. v_uuid - The UUID of the Virtual I/O Server that will host the disk. vol_grp_uuid - The volume group that will host the new Virtual Disk. d_name - The name that should be given to the disk on the Virtual I/O Server that will contain the file. d_size_gb - The size of the disk in GB. base_image - (Optional) The UDID of a VDisk to copy data from. file_format - (Optional) File format of the new VirtualDisk. See stor.FileFormatType enumeration for valid formats.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_3","text":"VDisk ElementWrapper representing the new VirtualDisk from the server response (i.e. UDID will be populated). :raise exc.Error: If the server response from attempting to add the VDisk does not contain the new VDisk.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_9","text":"@lock.synchronized(_LOCK_VOL_GRP) def crt_vdisk( adapter, v_uuid, vol_grp_uuid, d_name, d_size_gb, base_image=None, file_format=None ): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#default_tier_for_ssp","text":"Show source in storage.py:497 Find the default Tier for the given Shared Storage Pool.","title":"default_tier_for_ssp"},{"location":"pypowervm/tasks/storage/#arguments_6","text":"ssp - The SSP EntryWrapper whose default Tier is to be retrieved.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_4","text":"Tier EntryWrapper representing ssp's default Tier.","title":"Returns"},{"location":"pypowervm/tasks/storage/#raises","text":"NoDefaultTierFoundOnSSP - If no default Tier is found on the specified Shared Storage Pool.","title":"Raises"},{"location":"pypowervm/tasks/storage/#signature_10","text":"def default_tier_for_ssp(ssp): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#find_stale_lpars","text":"Show source in storage.py:1252 Find orphan LPAR IDs in a Virtual I/O Server's VSCSI/VFC mappings. This method collates all client LPAR IDs from the VSCSI/VFC mappings of the specified VIOS wrapper and compares to the list of LPAR IDs on that VIOS's host, returning the list of any IDs which exist in the former but not the latter.","title":"find_stale_lpars"},{"location":"pypowervm/tasks/storage/#arguments_7","text":"vios_w - VIOS EntryWrapper. To be effective, this must have been retrieved with the VIO_SMAP and VIO_FMAP extended attribute groups.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_5","text":"List of LPAR IDs (integer short IDs, not UUIDs) which don't exist on the system. The list is guaranteed to contain no duplicates.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_11","text":"def find_stale_lpars(vios_w): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#find_vg","text":"Show source in storage.py:589 Returns the VIOS and VG wrappers for the volume group.","title":"find_vg"},{"location":"pypowervm/tasks/storage/#arguments_8","text":"adapter - pypowervm.adapter.Adapter for REST communication. vg_name - Name of the volume group to find. vios_name - The name of the VIOS on which to search for the volume group. If not specified, all VIOSes are searched.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_6","text":"Type: vios_wrap The VIOS wrapper representing the Virtual I/O Server on which the volume group was found. Type: vg_wrap The VG wrapper representing the volume group.","title":"Returns"},{"location":"pypowervm/tasks/storage/#raises_1","text":"VIOSNotFound - If vios_name was specified and no such VIOS exists. VGNotFound - If no volume group of the specified vg_name could be found.","title":"Raises"},{"location":"pypowervm/tasks/storage/#signature_12","text":"def find_vg(adapter, vg_name, vios_name=None): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#rescan_vstor","text":"Show source in storage.py:668 Update the internal metadata for a virtual storage object.","title":"rescan_vstor"},{"location":"pypowervm/tasks/storage/#arguments_9","text":"vio - A VIOS wrapper or UUID string of the VIOS on which to perform the rescan. vstor - The VDisk wrapper or udid of the storage object to rescan. adapter - A pypowervm.adapter.Adapter for REST API communication. Required if neither vio nor vstor is a wrapper, optional otherwise.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#raises_2","text":"AdapterNotFound - If no adapter attribute can be found. JobRequestFailed - If the rescan failed. JobRequestTimedOut - If the rescan Job timed out.","title":"Raises"},{"location":"pypowervm/tasks/storage/#signature_13","text":"def rescan_vstor(vio, vstor, adapter=None): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#rm_ssp_storage","text":"Show source in storage.py:941 Remove some number of LogicalUnits from a SharedStoragePool. The changes are flushed back to the REST server.","title":"rm_ssp_storage"},{"location":"pypowervm/tasks/storage/#arguments_10","text":"ssp_wrap - SSP EntryWrapper representing the SharedStoragePool to modify. lus - Iterable of LU ElementWrappers or LUEnt EntryWrappers representing the LogicalUnits to delete. del_unused_images - If True, and a removed Disk LU was the last one linked to its backing Image LU, the backing Image LU is also removed.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_7","text":"The (possibly) modified SSP wrapper.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_14","text":"@tx.entry_transaction def rm_ssp_storage(ssp_wrap, lus, del_unused_images=True): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#rm_tier_storage","text":"Show source in storage.py:898 Remove Logical Units from a Shared Storage Pool Tier.","title":"rm_tier_storage"},{"location":"pypowervm/tasks/storage/#arguments_11","text":"lus_to_rm - Iterable of LU ElementWrappers or LUEnt EntryWrappers representing the LogicalUnits to delete. tier - Tier EntryWrapper representing the SSP Tier on which the lus_to_rm (and their backing images) reside. Either tier or lufeed is required. If both are specified, tier is ignored. lufeed - Pre-fetched list of LUEnt (i.e. result of a GET of Tier/{uuid}/LogicalUnit) where we expect to find the lus_to_rm (and their backing images). Either tier or lufeed is required. If both are specified, tier is ignored. del_unused_images - If True, and a removed Disk LU was the last one linked to its backing Image LU, the backing Image LU is also removed.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#raises_3","text":"ValueError - - If neither tier nor lufeed was supplied. - If lufeed was supplied but doesn't contain LUEnt EntryWrappers (e.g. the caller provided SSP.logical_units).","title":"Raises"},{"location":"pypowervm/tasks/storage/#signature_15","text":"def rm_tier_storage(lus_to_rm, tier=None, lufeed=None, del_unused_images=True): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#rm_vg_storage","text":"Show source in storage.py:706 Remove storage elements from a volume group. Changes are flushed back to the REST server.","title":"rm_vg_storage"},{"location":"pypowervm/tasks/storage/#arguments_12","text":"vg_wrap - VG wrapper representing the Volume Group to update. vdisks - Iterable of VDisk wrappers representing the Virtual Disks to delete. Ignored if None or empty. vopts - Iterable of VOptMedia wrappers representing Virtual Optical devices to delete. Ignored if None or empty.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_8","text":"The (possibly) updated vg_wrap.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_16","text":"@lock.synchronized(_LOCK_VOL_GRP) @retry.retry( argmod_func=retry.refresh_wrapper, tries=60, delay_func=retry.STEPPED_RANDOM_DELAY ) def rm_vg_storage(vg_wrap, vdisks=None, vopts=None): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#upload_lu","text":"Show source in storage.py:307 Uploads a data stream to an existing SSP Logical Unit.","title":"upload_lu"},{"location":"pypowervm/tasks/storage/#arguments_13","text":"v_uuid - The UUID of the Virtual I/O Server through which to perform the upload. lu - LU Wrapper representing the Logical Unit to which to upload the data. The LU must already exist in the SSP. io_handle - The I/O handle (as defined by the upload_type) f_size - The size (in bytes) of the stream to be uploaded. sha_chksum - (Optional) The SHA256 checksum for the file. Useful for integrity checks. upload_type - (Optional, Default: IO_STREAM) Defines the way in which the LU should be uploaded. Refer to the UploadType enumeration for valid upload mechanisms.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_9","text":"Normally the return value will be None, indicating that the image was uploaded without issue. If for some reason the File metadata for the VIOS was not cleaned up, the return value is the LU EntryWrapper. This is simply a marker to be later used to retry the cleanup.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_17","text":"def upload_lu( v_uuid, lu, io_handle, f_size, sha_chksum=None, upload_type=UploadType.IO_STREAM ): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#upload_new_lu","text":"Show source in storage.py:249 Creates a new SSP Logical Unit and uploads an image to it. Note: return spec varies based on the return_ssp parameter:","title":"upload_new_lu"},{"location":"pypowervm/tasks/storage/#defaultlegacy-behavior","text":"new_lu, maybe_file = upload_new_lu(..., return_ssp=False)","title":"Default/legacy behavior"},{"location":"pypowervm/tasks/storage/#with-return_ssptrue","text":"ssp, new_lu, maybe_file = upload_new_lu(..., return_ssp=True)","title":"With return_ssp=True"},{"location":"pypowervm/tasks/storage/#arguments_14","text":"v_uuid - The UUID of the Virtual I/O Server through which to perform the upload. (Note that the new LU will be visible from any VIOS in the Shared Storage Pool's Cluster.) ssp - SSP EntryWrapper representing the Shared Storage Pool on which to create the new Logical Unit. io_handle - The I/O handle (as defined by the upload_type) lu_name - The name that should be given to the new LU. f_size - The size (in bytes) of the stream to be uploaded. d_size - (OPTIONAL) The size of the LU (in bytes). Not required if it should match the file. Must be at least as large as the file. sha_chksum - (Optional) The SHA256 checksum for the file. Useful for integrity checks. return_ssp - (Optional) If True, the return value of the method is a three-member tuple whose third value is the updated SSP EntryWrapper. If False (the default), the method returns a two-member tuple. upload_type - (Optional, Default: IO_STREAM) Defines the way in which the LU should be uploaded. Refer to the UploadType enumeration for valid upload mechanisms.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_10","text":"If the return_ssp parameter is True, the first return value is the updated SSP EntryWrapper, containing the newly-created and -uploaded LU. If return_ssp is False, this return value is absent - only the below two values are returned. An LU EntryWrapper corresponding to the Logical Unit into which the file was uploaded. Normally None, indicating that the LU was created and the image was uploaded without issue. If for some reason the File metadata for the VIOS was not cleaned up, the return value is the File EntryWrapper. This is simply a marker to be later used to retry the cleanup.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_18","text":"def upload_new_lu( v_uuid, ssp, io_handle, lu_name, f_size, d_size=None, sha_chksum=None, return_ssp=False, upload_type=UploadType.IO_STREAM, ): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#upload_new_vdisk","text":"Show source in storage.py:151 Uploads a new virtual disk.","title":"upload_new_vdisk"},{"location":"pypowervm/tasks/storage/#arguments_15","text":"adapter - The adapter to talk over the API. v_uuid - The Virtual I/O Server UUID that will host the disk. vol_grp_uuid - The volume group that will host the Virtual Disk's UUID. io_handle - The I/O handle (as defined by the upload_type) d_name - The name that should be given to the disk on the Virtual I/O Server that will contain the file. f_size - The size (in bytes) of the stream to be uploaded. d_size - (Optional) The desired size of the new VDisk in bytes. If omitted or smaller than f_size, it will be set to match f_size. sha_chksum - (Optional) The SHA256 checksum for the file. Useful for integrity checks. upload_type - (Optional, Default: IO_STREAM) Defines the way in which the vdisk should be uploaded. Refer to the UploadType enumeration for valid upload mechanisms. file_format - (Optional) Format of file coming from io_handle. See stor.FileFormatType enumeration for valid formats.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_11","text":"The first return value is the virtual disk that the file is uploaded into. Normally the second return value will be None, indicating that the disk and image were uploaded without issue. If for some reason the File metadata for the VIOS was not cleaned up, the return value is the File EntryWrapper. This is simply a metadata marker to be later used to retry the cleanup.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_19","text":"def upload_new_vdisk( adapter, v_uuid, vol_grp_uuid, io_handle, d_name, f_size, d_size=None, sha_chksum=None, upload_type=UploadType.IO_STREAM, file_format=None, ): ...","title":"Signature"},{"location":"pypowervm/tasks/storage/#upload_vopt","text":"Show source in storage.py:213 Upload a file/stream into a virtual media repository on the VIOS.","title":"upload_vopt"},{"location":"pypowervm/tasks/storage/#arguments_16","text":"adapter - The adapter to talk over the API. v_uuid - The Virtual I/O Server UUID that will host the file. d_stream - A file path or data stream (must have 'read' method) to upload. f_name - The name that should be given to the file. f_size - (OPTIONAL) The size in bytes of the file to upload. Useful for integrity checks. sha_chksum - (OPTIONAL) The SHA256 checksum for the file. Useful for integrity checks.","title":"Arguments"},{"location":"pypowervm/tasks/storage/#returns_12","text":"The vOpt loaded into the media repository. This is a reference, for use in scsi mappings. Normally this method will return None, indicating that the disk and image were uploaded without issue. If for some reason the File metadata for the VIOS was not cleaned up, the return value is the File EntryWrapper. This is simply a marker to be later used to retry the cleanup.","title":"Returns"},{"location":"pypowervm/tasks/storage/#signature_20","text":"def upload_vopt(adapter, v_uuid, d_stream, f_name, f_size=None, sha_chksum=None): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/","text":"Vfc Mapper Pypowervm Index / Pypowervm / Tasks / Vfc Mapper Auto-generated documentation for pypowervm.tasks.vfc_mapper module. Vfc Mapper add_map build_migration_mappings build_migration_mappings_for_fabric build_wwpn_pair derive_base_npiv_map derive_npiv_map find_maps find_pfc_wwpn_by_name find_vios_for_port_map find_vios_for_vfc_wwpns find_vios_for_wwpn has_client_wwpns intersect_wwpns remove_maps add_map Show source in vfc_mapper.py:516 Adds a vFC mapping to a given VIOS wrapper. These changes are not flushed back to the REST server. The wrapper itself is simply modified. Arguments vios_w - VIOS EntryWrapper representing the Virtual I/O Server whose VFC mappings are to be updated. host_uuid - The pypowervm UUID of the host. lpar_uuid - The pypowervm UUID of the client LPAR to attach to. port_map - The port mapping (as defined by the derive_npiv_map method). error_if_invalid - (Optional, Default: True) If the port mapping physical port can not be found, raise an error. lpar_slot_num - (Optional, Default: None) The client adapter VirtualSlotNumber to be set. If None the next available slot would be used. Returns The VFCMapping that was added or updated with a missing backing port. If the mapping already existed then None is returned. Signature def add_map( vios_w, host_uuid, lpar_uuid, port_map, error_if_invalid=True, lpar_slot_num=None ): ... build_migration_mappings Show source in vfc_mapper.py:711 Builds the vFC migration mappings. Looks holistically at the system. Should generally be used instead of build_migration_mappings_for_fabric. Arguments vios_wraps - The VIOS wrappers for the target system. Must have the VIO_FMAP xag specified. fabric_data - Dictionary where the key is the fabric name. The value is another dictionary with the slots and the p_port_wwpns. Ex: { 'A': {'slots': [3, 4, 5], p_port_wwpns: [1, 2, 3] }, 'B': {'slots': [6, 7, 8], p_port_wwpns: [4, 5] } } The slot indicates which slots from the client slots align with which fabric. slot_peers - An array of arrays. Indicates all of the slots that need to be grouped together on a given VIOS. Ex: [ [3, 6, 7], [4, 8], [5] ] Indicates that (based on the data from fabric_data) one VIOS must host client slot 3 (from fabric A) and slots 6 and 7 (from fabric B). Then another VIOS must host client slot 4 (from fabric A) and client slot 8 (from fabric B). And the third VIOS must only host client slot 5 (from fabric A). Returns List of mappings that can be passed into the migration.py for the live migration. The format is defined within the migration.py, migrate_lpar method. Signature def build_migration_mappings(vios_wraps, fabric_data, slot_peers): ... build_migration_mappings_for_fabric Show source in vfc_mapper.py:616 Builds the vFC migration mappings for a given fabric. This method will build the migration mappings for a given fabric. The response is a list of strings that can be used in the migration.py Note: If you have multiple fabrics, then each fabric will need to independently call this method with the appropriate p_port_wwpns. Note: This must be run on the destination server before the migration. It is typically input back to the source server for the migration call. Arguments vios_wraps - The VIOS wrappers for the target system. Must have the VIO_FMAP xag specified. p_port_wwpns - The physical port WWPNs that can be used for this specific fabric. May span multiple VIOSes, but each must be part of the vios_wraps. client_slots - A list of integers which represent the source system's LPAR virtual Fibre Channel slots that are participating in this fabric. Returns List of mappings that can be passed into the migration.py for the live migration. The format is defined within the migration.py, migrate_lpar method. Signature def build_migration_mappings_for_fabric(vios_wraps, p_port_wwpns, client_slots): ... build_wwpn_pair Show source in vfc_mapper.py:41 Builds a WWPN pair that can be used for a VirtualFCAdapter. Note: The API will only generate up to 8 pairs at a time. Any more will cause the API to raise an error. Arguments adapter - The adapter to talk over the API. host_uuid - The host system for the generation. pair_count - (Optional, Default: 1) The number of WWPN pairs to generate. Can not be more than 8 or else the API will fail. Returns Non-mutable WWPN Pairs (list) Signature def build_wwpn_pair(adapter, host_uuid, pair_count=1): ... derive_base_npiv_map Show source in vfc_mapper.py:129 Builds a blank NPIV port mapping, without any known vFC WWPNs. This method is functionally similar to the derive_npiv_map. However, the derive_npiv_map method assumes knowledge of the Virtual Fibre Channel mappings beforehand. This method will generate a similar map, but when sent to the add_map method, that method will allow the API to generate the globally unique WWPNs rather than pre-seeding them. Arguments vios_wraps - A list of VIOS wrappers. Can be built using the extended attribute group (xag) of VIO_FMAP. p_port_wwpns - A list of the WWPNs (strings) that can be used to map the ports to. These WWPNs should reside on Physical FC Ports on the VIOS wrappers that were passed in. v_port_count - The number of virtual ports to create. Returns A list of sets. The format will be similar to that of the derive_npiv_map method. However, instead of a fused_vfc_port_wwpn a marker will be used to indicate that the API should generate the WWPN. Signature def derive_base_npiv_map(vios_wraps, p_port_wwpns, v_port_count): ... derive_npiv_map Show source in vfc_mapper.py:155 This method will derive a NPIV map. A NPIV map is the linkage between an NPIV virtual FC Port and the backing physical port. Two v_port_wwpns get tied to an individual p_port_wwpn. A list of the 'mappings' will be returned. One per pair of v_port_wwpns. The mappings will first attempt to spread across the VIOSes. Within each VIOS, the port with the most available free NPIV ports will be selected. There are scenarios where ports on a single VIOS could be reused. - 4 v_port_wwpns, all p_port_wwpns reside on single VIOS - 8 v_port_wwpns, only two VIOSes - Etc... In these scenarios, the ports will be spread such that they're running across all the physical ports (that were passed in) on a given VIOS. In even rarer scenarios, the same physical port may be re-used if the v_port_wwpn pairs exceed the total number of p_port_wwpns. Arguments vios_wraps - A list of VIOS wrappers. Can be built using the extended attribute group (xag) of VIO_FMAP. p_port_wwpns - A list of the WWPNs (strings) that can be used to map the ports to. These WWPNs should reside on Physical FC Ports on the VIOS wrappers that were passed in. v_port_wwpns - A list of the virtual fibre channel port WWPNs. Must be an even number of ports. preserve - (Optional, Default=True) If True, existing mappings with matching virtual fibre channel ports are preserved. Else new mappings are generated. Returns A list of tuples representing both new and preserved mappings. The format will be: [ (p_port_wwpn1, fused_vfc_port_wwpn1), (p_port_wwpn2, fused_vfc_port_wwpn2), etc... ] A 'fused_vfc_port_wwpn' is simply taking two v_port_wwpns, sanitizing them and then putting them into a single string separated by a space. Signature def derive_npiv_map(vios_wraps, p_port_wwpns, v_port_wwpns, preserve=True): ... find_maps Show source in vfc_mapper.py:393 Filter a list of VFC mappings by LPAR ID. This is based on scsi_mapper.find_maps, but does not yet provide all the same functionality. Arguments mapping_list - The mappings to filter. Iterable of VFCMapping. client_lpar_id - Integer short ID or string UUID of the LPAR on the client side of the mapping. Note that the UUID form relies on the presence of the client_lpar_href field. Some mappings lack this field, and would therefore be ignored. client_adpt - (Optional, Default=None) If set, will only include the mapping if the client adapter's WWPNs match as well. port_map - (Optional, Default=None) If set, will look for a matching mapping based off the client WWPNs as specified by the port mapping. The format of this is defined by the derive_npiv_map method. Returns A list comprising the subset of the input mapping_list whose client LPAR IDs match client_lpar_id. Signature def find_maps(mapping_list, client_lpar_id, client_adpt=None, port_map=None): ... find_pfc_wwpn_by_name Show source in vfc_mapper.py:381 Returns the physical port wwpn within a VIOS based off the FC port name. Arguments vios_w - VIOS wrapper. pfc_name - The physical fibre channel port name. Signature def find_pfc_wwpn_by_name(vios_w, pfc_name): ... find_vios_for_port_map Show source in vfc_mapper.py:490 Finds the appropriate VIOS wrapper for a given port map. Note that the algorithm first checks based off of the client WWPNs. If the client WWPNs can not be found (perhaps the map is still -1 -1 from the derive_base_npiv_map) then the physical port WWPN will be checked. Arguments vios_wraps - A list of Virtual I/O Server wrapper objects. port_map - The port mapping (as defined by the derive_npiv_map method). Returns The Virtual I/O Server wrapper that supports the port map. Signature def find_vios_for_port_map(vios_wraps, port_map): ... find_vios_for_vfc_wwpns Show source in vfc_mapper.py:88 Will find the VIOS that is hosting the vfc_wwpns. Arguments vios_wraps - A list or set of VIOS wrappers. vfc_wwpns - The list or set of virtual fibre channel WWPNs. Returns The VIOS wrapper that supports the vfc adapters. If there is not one, then None will be returned. The VFCMapping on the VIOS that supports the client adapters. Signature def find_vios_for_vfc_wwpns(vios_wraps, vfc_wwpns): ... find_vios_for_wwpn Show source in vfc_mapper.py:68 Will find the VIOS that has a PhysFCPort for the p_port_wwpn. Arguments vios_wraps - A list or set of VIOS wrappers. p_port_wwpn - The physical port's WWPN. Returns The VIOS wrapper that contains a physical port with the WWPN. If there is not one, then None will be returned. The port (which is a PhysFCPort wrapper) on the VIOS wrapper that represents the physical port. Signature def find_vios_for_wwpn(vios_wraps, p_port_wwpn): ... has_client_wwpns Show source in vfc_mapper.py:590 Returns the vios wrapper and vfc map if the client WWPNs already exist. Arguments vios_wraps - The VIOS wrappers. Should be queried with the VIO_FMAP extended attribute. client_wwpn_pair - The pair (list or set) of the client WWPNs. Returns Type: vios_w The VIOS wrapper containing the wwpn pair. None if none of the wrappers contain the pair. Type: vfc_map The mapping containing the client pair. May be None. Signature def has_client_wwpns(vios_wraps, client_wwpn_pair): ... intersect_wwpns Show source in vfc_mapper.py:116 Will return the intersection of WWPNs between the two sets. Arguments wwpn_set1 - A list of WWPNs. wwpn_set2 - A list of WWPNs. Returns The intersection of the WWPNs. Will maintain the WWPN format of wwpn_set1, but the comparison done will be agnostic of formats (ex. colons and/or upper/lower case). Signature def intersect_wwpns(wwpn_set1, wwpn_set2): ... remove_maps Show source in vfc_mapper.py:464 Remove one or more VFC mappings from a VIOS wrapper. The changes are not flushed back to the REST server. Arguments v_wrap - VIOS EntryWrapper representing the Virtual I/O Server whose VFC mappings are to be updated. client_lpar_id - The integer short ID or string UUID of the client VM client_adpt - (Optional, Default=None) If set, will only add the mapping if the client adapter's WWPNs match as well. port_map - (Optional, Default=None) If set, will look for a matching mapping based off the client WWPNs as specified by the port mapping. The format of this is defined by the derive_npiv_map method. Returns The mappings removed from the VIOS wrapper. Signature def remove_maps(v_wrap, client_lpar_id, client_adpt=None, port_map=None): ...","title":"Vfc Mapper"},{"location":"pypowervm/tasks/vfc_mapper/#vfc-mapper","text":"Pypowervm Index / Pypowervm / Tasks / Vfc Mapper Auto-generated documentation for pypowervm.tasks.vfc_mapper module. Vfc Mapper add_map build_migration_mappings build_migration_mappings_for_fabric build_wwpn_pair derive_base_npiv_map derive_npiv_map find_maps find_pfc_wwpn_by_name find_vios_for_port_map find_vios_for_vfc_wwpns find_vios_for_wwpn has_client_wwpns intersect_wwpns remove_maps","title":"Vfc Mapper"},{"location":"pypowervm/tasks/vfc_mapper/#add_map","text":"Show source in vfc_mapper.py:516 Adds a vFC mapping to a given VIOS wrapper. These changes are not flushed back to the REST server. The wrapper itself is simply modified.","title":"add_map"},{"location":"pypowervm/tasks/vfc_mapper/#arguments","text":"vios_w - VIOS EntryWrapper representing the Virtual I/O Server whose VFC mappings are to be updated. host_uuid - The pypowervm UUID of the host. lpar_uuid - The pypowervm UUID of the client LPAR to attach to. port_map - The port mapping (as defined by the derive_npiv_map method). error_if_invalid - (Optional, Default: True) If the port mapping physical port can not be found, raise an error. lpar_slot_num - (Optional, Default: None) The client adapter VirtualSlotNumber to be set. If None the next available slot would be used.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns","text":"The VFCMapping that was added or updated with a missing backing port. If the mapping already existed then None is returned.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature","text":"def add_map( vios_w, host_uuid, lpar_uuid, port_map, error_if_invalid=True, lpar_slot_num=None ): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#build_migration_mappings","text":"Show source in vfc_mapper.py:711 Builds the vFC migration mappings. Looks holistically at the system. Should generally be used instead of build_migration_mappings_for_fabric.","title":"build_migration_mappings"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_1","text":"vios_wraps - The VIOS wrappers for the target system. Must have the VIO_FMAP xag specified. fabric_data - Dictionary where the key is the fabric name. The value is another dictionary with the slots and the p_port_wwpns. Ex: { 'A': {'slots': [3, 4, 5], p_port_wwpns: [1, 2, 3] }, 'B': {'slots': [6, 7, 8], p_port_wwpns: [4, 5] } } The slot indicates which slots from the client slots align with which fabric. slot_peers - An array of arrays. Indicates all of the slots that need to be grouped together on a given VIOS. Ex: [ [3, 6, 7], [4, 8], [5] ] Indicates that (based on the data from fabric_data) one VIOS must host client slot 3 (from fabric A) and slots 6 and 7 (from fabric B). Then another VIOS must host client slot 4 (from fabric A) and client slot 8 (from fabric B). And the third VIOS must only host client slot 5 (from fabric A).","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_1","text":"List of mappings that can be passed into the migration.py for the live migration. The format is defined within the migration.py, migrate_lpar method.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_1","text":"def build_migration_mappings(vios_wraps, fabric_data, slot_peers): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#build_migration_mappings_for_fabric","text":"Show source in vfc_mapper.py:616 Builds the vFC migration mappings for a given fabric. This method will build the migration mappings for a given fabric. The response is a list of strings that can be used in the migration.py Note: If you have multiple fabrics, then each fabric will need to independently call this method with the appropriate p_port_wwpns. Note: This must be run on the destination server before the migration. It is typically input back to the source server for the migration call.","title":"build_migration_mappings_for_fabric"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_2","text":"vios_wraps - The VIOS wrappers for the target system. Must have the VIO_FMAP xag specified. p_port_wwpns - The physical port WWPNs that can be used for this specific fabric. May span multiple VIOSes, but each must be part of the vios_wraps. client_slots - A list of integers which represent the source system's LPAR virtual Fibre Channel slots that are participating in this fabric.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_2","text":"List of mappings that can be passed into the migration.py for the live migration. The format is defined within the migration.py, migrate_lpar method.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_2","text":"def build_migration_mappings_for_fabric(vios_wraps, p_port_wwpns, client_slots): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#build_wwpn_pair","text":"Show source in vfc_mapper.py:41 Builds a WWPN pair that can be used for a VirtualFCAdapter. Note: The API will only generate up to 8 pairs at a time. Any more will cause the API to raise an error.","title":"build_wwpn_pair"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_3","text":"adapter - The adapter to talk over the API. host_uuid - The host system for the generation. pair_count - (Optional, Default: 1) The number of WWPN pairs to generate. Can not be more than 8 or else the API will fail.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_3","text":"Non-mutable WWPN Pairs (list)","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_3","text":"def build_wwpn_pair(adapter, host_uuid, pair_count=1): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#derive_base_npiv_map","text":"Show source in vfc_mapper.py:129 Builds a blank NPIV port mapping, without any known vFC WWPNs. This method is functionally similar to the derive_npiv_map. However, the derive_npiv_map method assumes knowledge of the Virtual Fibre Channel mappings beforehand. This method will generate a similar map, but when sent to the add_map method, that method will allow the API to generate the globally unique WWPNs rather than pre-seeding them.","title":"derive_base_npiv_map"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_4","text":"vios_wraps - A list of VIOS wrappers. Can be built using the extended attribute group (xag) of VIO_FMAP. p_port_wwpns - A list of the WWPNs (strings) that can be used to map the ports to. These WWPNs should reside on Physical FC Ports on the VIOS wrappers that were passed in. v_port_count - The number of virtual ports to create.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_4","text":"A list of sets. The format will be similar to that of the derive_npiv_map method. However, instead of a fused_vfc_port_wwpn a marker will be used to indicate that the API should generate the WWPN.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_4","text":"def derive_base_npiv_map(vios_wraps, p_port_wwpns, v_port_count): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#derive_npiv_map","text":"Show source in vfc_mapper.py:155 This method will derive a NPIV map. A NPIV map is the linkage between an NPIV virtual FC Port and the backing physical port. Two v_port_wwpns get tied to an individual p_port_wwpn. A list of the 'mappings' will be returned. One per pair of v_port_wwpns. The mappings will first attempt to spread across the VIOSes. Within each VIOS, the port with the most available free NPIV ports will be selected. There are scenarios where ports on a single VIOS could be reused. - 4 v_port_wwpns, all p_port_wwpns reside on single VIOS - 8 v_port_wwpns, only two VIOSes - Etc... In these scenarios, the ports will be spread such that they're running across all the physical ports (that were passed in) on a given VIOS. In even rarer scenarios, the same physical port may be re-used if the v_port_wwpn pairs exceed the total number of p_port_wwpns.","title":"derive_npiv_map"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_5","text":"vios_wraps - A list of VIOS wrappers. Can be built using the extended attribute group (xag) of VIO_FMAP. p_port_wwpns - A list of the WWPNs (strings) that can be used to map the ports to. These WWPNs should reside on Physical FC Ports on the VIOS wrappers that were passed in. v_port_wwpns - A list of the virtual fibre channel port WWPNs. Must be an even number of ports. preserve - (Optional, Default=True) If True, existing mappings with matching virtual fibre channel ports are preserved. Else new mappings are generated.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_5","text":"A list of tuples representing both new and preserved mappings. The format will be: [ (p_port_wwpn1, fused_vfc_port_wwpn1), (p_port_wwpn2, fused_vfc_port_wwpn2), etc... ] A 'fused_vfc_port_wwpn' is simply taking two v_port_wwpns, sanitizing them and then putting them into a single string separated by a space.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_5","text":"def derive_npiv_map(vios_wraps, p_port_wwpns, v_port_wwpns, preserve=True): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#find_maps","text":"Show source in vfc_mapper.py:393 Filter a list of VFC mappings by LPAR ID. This is based on scsi_mapper.find_maps, but does not yet provide all the same functionality.","title":"find_maps"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_6","text":"mapping_list - The mappings to filter. Iterable of VFCMapping. client_lpar_id - Integer short ID or string UUID of the LPAR on the client side of the mapping. Note that the UUID form relies on the presence of the client_lpar_href field. Some mappings lack this field, and would therefore be ignored. client_adpt - (Optional, Default=None) If set, will only include the mapping if the client adapter's WWPNs match as well. port_map - (Optional, Default=None) If set, will look for a matching mapping based off the client WWPNs as specified by the port mapping. The format of this is defined by the derive_npiv_map method.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_6","text":"A list comprising the subset of the input mapping_list whose client LPAR IDs match client_lpar_id.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_6","text":"def find_maps(mapping_list, client_lpar_id, client_adpt=None, port_map=None): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#find_pfc_wwpn_by_name","text":"Show source in vfc_mapper.py:381 Returns the physical port wwpn within a VIOS based off the FC port name.","title":"find_pfc_wwpn_by_name"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_7","text":"vios_w - VIOS wrapper. pfc_name - The physical fibre channel port name.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#signature_7","text":"def find_pfc_wwpn_by_name(vios_w, pfc_name): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#find_vios_for_port_map","text":"Show source in vfc_mapper.py:490 Finds the appropriate VIOS wrapper for a given port map. Note that the algorithm first checks based off of the client WWPNs. If the client WWPNs can not be found (perhaps the map is still -1 -1 from the derive_base_npiv_map) then the physical port WWPN will be checked.","title":"find_vios_for_port_map"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_8","text":"vios_wraps - A list of Virtual I/O Server wrapper objects. port_map - The port mapping (as defined by the derive_npiv_map method).","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_7","text":"The Virtual I/O Server wrapper that supports the port map.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_8","text":"def find_vios_for_port_map(vios_wraps, port_map): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#find_vios_for_vfc_wwpns","text":"Show source in vfc_mapper.py:88 Will find the VIOS that is hosting the vfc_wwpns.","title":"find_vios_for_vfc_wwpns"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_9","text":"vios_wraps - A list or set of VIOS wrappers. vfc_wwpns - The list or set of virtual fibre channel WWPNs.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_8","text":"The VIOS wrapper that supports the vfc adapters. If there is not one, then None will be returned. The VFCMapping on the VIOS that supports the client adapters.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_9","text":"def find_vios_for_vfc_wwpns(vios_wraps, vfc_wwpns): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#find_vios_for_wwpn","text":"Show source in vfc_mapper.py:68 Will find the VIOS that has a PhysFCPort for the p_port_wwpn.","title":"find_vios_for_wwpn"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_10","text":"vios_wraps - A list or set of VIOS wrappers. p_port_wwpn - The physical port's WWPN.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_9","text":"The VIOS wrapper that contains a physical port with the WWPN. If there is not one, then None will be returned. The port (which is a PhysFCPort wrapper) on the VIOS wrapper that represents the physical port.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_10","text":"def find_vios_for_wwpn(vios_wraps, p_port_wwpn): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#has_client_wwpns","text":"Show source in vfc_mapper.py:590 Returns the vios wrapper and vfc map if the client WWPNs already exist.","title":"has_client_wwpns"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_11","text":"vios_wraps - The VIOS wrappers. Should be queried with the VIO_FMAP extended attribute. client_wwpn_pair - The pair (list or set) of the client WWPNs.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_10","text":"Type: vios_w The VIOS wrapper containing the wwpn pair. None if none of the wrappers contain the pair. Type: vfc_map The mapping containing the client pair. May be None.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_11","text":"def has_client_wwpns(vios_wraps, client_wwpn_pair): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#intersect_wwpns","text":"Show source in vfc_mapper.py:116 Will return the intersection of WWPNs between the two sets.","title":"intersect_wwpns"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_12","text":"wwpn_set1 - A list of WWPNs. wwpn_set2 - A list of WWPNs.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_11","text":"The intersection of the WWPNs. Will maintain the WWPN format of wwpn_set1, but the comparison done will be agnostic of formats (ex. colons and/or upper/lower case).","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_12","text":"def intersect_wwpns(wwpn_set1, wwpn_set2): ...","title":"Signature"},{"location":"pypowervm/tasks/vfc_mapper/#remove_maps","text":"Show source in vfc_mapper.py:464 Remove one or more VFC mappings from a VIOS wrapper. The changes are not flushed back to the REST server.","title":"remove_maps"},{"location":"pypowervm/tasks/vfc_mapper/#arguments_13","text":"v_wrap - VIOS EntryWrapper representing the Virtual I/O Server whose VFC mappings are to be updated. client_lpar_id - The integer short ID or string UUID of the client VM client_adpt - (Optional, Default=None) If set, will only add the mapping if the client adapter's WWPNs match as well. port_map - (Optional, Default=None) If set, will look for a matching mapping based off the client WWPNs as specified by the port mapping. The format of this is defined by the derive_npiv_map method.","title":"Arguments"},{"location":"pypowervm/tasks/vfc_mapper/#returns_12","text":"The mappings removed from the VIOS wrapper.","title":"Returns"},{"location":"pypowervm/tasks/vfc_mapper/#signature_13","text":"def remove_maps(v_wrap, client_lpar_id, client_adpt=None, port_map=None): ...","title":"Signature"},{"location":"pypowervm/tasks/vopt/","text":"Vopt Pypowervm Index / Pypowervm / Tasks / Vopt Auto-generated documentation for pypowervm.tasks.vopt module. Vopt validate_vopt_repo_exists validate_vopt_repo_exists Show source in vopt.py:33 Will ensure that the virtual optical media repository exists. Checks to make sure that at least one Virtual I/O Server has a virtual optical media repository. If the volume group on an I/O Server goes down (perhaps due to maintenance), the system will rescan to determine if there is another I/O Server that can host the request. The very first invocation may be expensive. It may also be expensive to call if a Virtual I/O Server unexpectedly goes down. Arguments adapter - The pypowervm adapter. vopt_media_volume_group - (Optional, Default: rootvg) The volume group to use if the vopt media repo needs to be created. vopt_media_rep_size - (Optional, Default: 1) The size of the virtual optical media (in GB) if the repo needs to be created. Returns Type: vios_uuid The VIOS uuid hosting the VG Type: vg_uuid The volume group uuid hosting the vopt. Raises NoMediaRepoVolumeGroupFound - Raised when there are no VIOSes that can support the virtual optical media. Signature @pvm_retry.retry(tries=6) def validate_vopt_repo_exists( adapter, vopt_media_volume_group=\"rootvg\", vopt_media_rep_size=1 ): ...","title":"Vopt"},{"location":"pypowervm/tasks/vopt/#vopt","text":"Pypowervm Index / Pypowervm / Tasks / Vopt Auto-generated documentation for pypowervm.tasks.vopt module. Vopt validate_vopt_repo_exists","title":"Vopt"},{"location":"pypowervm/tasks/vopt/#validate_vopt_repo_exists","text":"Show source in vopt.py:33 Will ensure that the virtual optical media repository exists. Checks to make sure that at least one Virtual I/O Server has a virtual optical media repository. If the volume group on an I/O Server goes down (perhaps due to maintenance), the system will rescan to determine if there is another I/O Server that can host the request. The very first invocation may be expensive. It may also be expensive to call if a Virtual I/O Server unexpectedly goes down.","title":"validate_vopt_repo_exists"},{"location":"pypowervm/tasks/vopt/#arguments","text":"adapter - The pypowervm adapter. vopt_media_volume_group - (Optional, Default: rootvg) The volume group to use if the vopt media repo needs to be created. vopt_media_rep_size - (Optional, Default: 1) The size of the virtual optical media (in GB) if the repo needs to be created.","title":"Arguments"},{"location":"pypowervm/tasks/vopt/#returns","text":"Type: vios_uuid The VIOS uuid hosting the VG Type: vg_uuid The volume group uuid hosting the vopt.","title":"Returns"},{"location":"pypowervm/tasks/vopt/#raises","text":"NoMediaRepoVolumeGroupFound - Raised when there are no VIOSes that can support the virtual optical media.","title":"Raises"},{"location":"pypowervm/tasks/vopt/#signature","text":"@pvm_retry.retry(tries=6) def validate_vopt_repo_exists( adapter, vopt_media_volume_group=\"rootvg\", vopt_media_rep_size=1 ): ...","title":"Signature"},{"location":"pypowervm/tasks/vterm/","text":"Vterm Pypowervm Index / Pypowervm / Tasks / Vterm Auto-generated documentation for pypowervm.tasks.vterm module. Vterm close_vterm open_localhost_vnc_vterm open_remotable_vnc_vterm close_vterm Show source in vterm.py:59 Close the vterm associated with an lpar Arguments adapter - The adapter to talk over the API. lpar_uuid - partition uuid Signature def close_vterm(adapter, lpar_uuid): ... open_localhost_vnc_vterm Show source in vterm.py:110 Opens a VNC vTerm to a given LPAR. Always binds to localhost. Arguments adapter - The adapter to drive the PowerVM API lpar_uuid - Partition UUID. force - (Optional, Default: False) If set to true will force the console to be opened as VNC even if it is already opened via some other means. codepage - (Optional, Default: 037) Language code for IBMi console. Default is 037 for English language. Returns The VNC Port that the terminal is running on. Signature def open_localhost_vnc_vterm(adapter, lpar_uuid, force=False, codepage=\"037\"): ... open_remotable_vnc_vterm Show source in vterm.py:182 Opens a VNC vTerm to a given LPAR. Wraps in some validation. Must run on the management partition. Arguments adapter - The adapter to drive the PowerVM API lpar_uuid - Partition UUID. local_ip - The IP Address to bind the VNC server to. This would be the IP of the management network on the system. remote_ips - (Optional, Default: None) A binding to only accept clients that are from a specific list of IP addresses through. Default is None, and therefore will allow any remote IP to connect. vnc_path - (Optional, Default: None) If provided, the vnc client must pass in this path (in HTTP format) to connect to the VNC server. The path is in HTTP format. So if the vnc_path is 'Test' the first packet request into the VNC must be: \"CONNECT Test HTTP/1.1 \" If the client passes in an invalid request, a 400 Bad Request will be returned. If the client sends in the correct path a 200 OK will be returned. If no vnc_path is specified, then no path is expected to be passed in by the VNC client and it will listen on the same remote port as local port. If the path is specified then it will listen on the on a single remote port of 5901 and determine the LPAR based on this path. use_x509_auth - (Optional, Default: False) If enabled, uses X509 Authentication for the VNC sessions started for VMs. ca_certs - (Optional, Default: None) Path to CA certificate to use for verifying VNC X509 Authentication. Only used if use_x509_auth is set to True. server_cert - (Optional, Default: None) Path to Server certificate to use for verifying VNC X509 Authentication. Only used if use_x509_auth is set to True. server_key - (Optional, Default: None) Path to Server private key to use for verifying VNC X509 Authentication. Only used if use_x509_auth is set to True. force - (Optional, Default: False) If set to true will force the console to be opened as VNC even if it is already opened via some other means. codepage - (Optional, Default: 037) Language code for IBMi console. Default is 037 for English language. Returns The VNC Port that the terminal is running on. Signature def open_remotable_vnc_vterm( adapter, lpar_uuid, local_ip, remote_ips=None, vnc_path=None, use_x509_auth=False, ca_certs=None, server_cert=None, server_key=None, force=False, codepage=\"037\", ): ...","title":"Vterm"},{"location":"pypowervm/tasks/vterm/#vterm","text":"Pypowervm Index / Pypowervm / Tasks / Vterm Auto-generated documentation for pypowervm.tasks.vterm module. Vterm close_vterm open_localhost_vnc_vterm open_remotable_vnc_vterm","title":"Vterm"},{"location":"pypowervm/tasks/vterm/#close_vterm","text":"Show source in vterm.py:59 Close the vterm associated with an lpar","title":"close_vterm"},{"location":"pypowervm/tasks/vterm/#arguments","text":"adapter - The adapter to talk over the API. lpar_uuid - partition uuid","title":"Arguments"},{"location":"pypowervm/tasks/vterm/#signature","text":"def close_vterm(adapter, lpar_uuid): ...","title":"Signature"},{"location":"pypowervm/tasks/vterm/#open_localhost_vnc_vterm","text":"Show source in vterm.py:110 Opens a VNC vTerm to a given LPAR. Always binds to localhost.","title":"open_localhost_vnc_vterm"},{"location":"pypowervm/tasks/vterm/#arguments_1","text":"adapter - The adapter to drive the PowerVM API lpar_uuid - Partition UUID. force - (Optional, Default: False) If set to true will force the console to be opened as VNC even if it is already opened via some other means. codepage - (Optional, Default: 037) Language code for IBMi console. Default is 037 for English language.","title":"Arguments"},{"location":"pypowervm/tasks/vterm/#returns","text":"The VNC Port that the terminal is running on.","title":"Returns"},{"location":"pypowervm/tasks/vterm/#signature_1","text":"def open_localhost_vnc_vterm(adapter, lpar_uuid, force=False, codepage=\"037\"): ...","title":"Signature"},{"location":"pypowervm/tasks/vterm/#open_remotable_vnc_vterm","text":"Show source in vterm.py:182 Opens a VNC vTerm to a given LPAR. Wraps in some validation. Must run on the management partition.","title":"open_remotable_vnc_vterm"},{"location":"pypowervm/tasks/vterm/#arguments_2","text":"adapter - The adapter to drive the PowerVM API lpar_uuid - Partition UUID. local_ip - The IP Address to bind the VNC server to. This would be the IP of the management network on the system. remote_ips - (Optional, Default: None) A binding to only accept clients that are from a specific list of IP addresses through. Default is None, and therefore will allow any remote IP to connect. vnc_path - (Optional, Default: None) If provided, the vnc client must pass in this path (in HTTP format) to connect to the VNC server. The path is in HTTP format. So if the vnc_path is 'Test' the first packet request into the VNC must be: \"CONNECT Test HTTP/1.1 \" If the client passes in an invalid request, a 400 Bad Request will be returned. If the client sends in the correct path a 200 OK will be returned. If no vnc_path is specified, then no path is expected to be passed in by the VNC client and it will listen on the same remote port as local port. If the path is specified then it will listen on the on a single remote port of 5901 and determine the LPAR based on this path. use_x509_auth - (Optional, Default: False) If enabled, uses X509 Authentication for the VNC sessions started for VMs. ca_certs - (Optional, Default: None) Path to CA certificate to use for verifying VNC X509 Authentication. Only used if use_x509_auth is set to True. server_cert - (Optional, Default: None) Path to Server certificate to use for verifying VNC X509 Authentication. Only used if use_x509_auth is set to True. server_key - (Optional, Default: None) Path to Server private key to use for verifying VNC X509 Authentication. Only used if use_x509_auth is set to True. force - (Optional, Default: False) If set to true will force the console to be opened as VNC even if it is already opened via some other means. codepage - (Optional, Default: 037) Language code for IBMi console. Default is 037 for English language.","title":"Arguments"},{"location":"pypowervm/tasks/vterm/#returns_1","text":"The VNC Port that the terminal is running on.","title":"Returns"},{"location":"pypowervm/tasks/vterm/#signature_2","text":"def open_remotable_vnc_vterm( adapter, lpar_uuid, local_ip, remote_ips=None, vnc_path=None, use_x509_auth=False, ca_certs=None, server_cert=None, server_key=None, force=False, codepage=\"037\", ): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/","text":"Hdisk Pypowervm Index / Pypowervm / Tasks / Hdisk Auto-generated documentation for pypowervm.tasks.hdisk module. Hdisk Modules Modules Fc Iscsi Rbd","title":"Hdisk"},{"location":"pypowervm/tasks/hdisk/#hdisk","text":"Pypowervm Index / Pypowervm / Tasks / Hdisk Auto-generated documentation for pypowervm.tasks.hdisk module. Hdisk Modules","title":"Hdisk"},{"location":"pypowervm/tasks/hdisk/#modules","text":"Fc Iscsi Rbd","title":"Modules"},{"location":"pypowervm/tasks/hdisk/_fc/","text":"Fc Pypowervm Index / Pypowervm / Tasks / Hdisk / Fc Auto-generated documentation for pypowervm.tasks.hdisk._fc module. Fc ITL LUAStatus LUAType build_itls discover_hdisk get_pg83_via_job good_discovery lua_recovery normalize_lun remove_hdisk ITL Show source in _fc.py:84 The Nexus ITL. See SCSI ITL. This is the grouping of the SCSI initiator, target and LUN. Signature class ITL(object): def __init__(self, initiator, target, lun): ... LUAStatus Show source in _fc.py:53 LUA Recovery status codes. Signature class LUAStatus(object): ... LUAType Show source in _fc.py:43 LUA Vendors. Signature class LUAType(object): ... build_itls Show source in _fc.py:137 This method builds the list of ITLs for all of the permutations. An ITL is specific to an initiator, target, and LUN. However, with multi pathing, there are several scenarios where a given LUN will have many ITLs because of multiple initiators or targets. The initiators should be tied to a given Virtual I/O Server (or perhaps specific WWPNs within a VIOS). Arguments i_wwpns - List or set of initiator WWPNs. t_wwpns - List or set of target WWPNs. lun - The LUN identifier. Ex. 2 (an int). The identifier will be formatted from a generic integer LUN ID to match PowerVM's LUN Identifier format. Returns List of all the ITL permutations. Signature def build_itls(i_wwpns, t_wwpns, lun): ... discover_hdisk Show source in _fc.py:157 Attempt to discover a hard disk attached to a Virtual I/O Server. See lua_recovery. This method attempts that call and analyzes the results. On certain failure conditions (see below), this method will find stale LPARs, scrub storage artifacts associated with them, and then retry lua_recovery. The retry is only attempted once; that result is returned regardless. The main objective of this method is to resolve errors resulting from incomplete cleanup of previous LPARs. The stale LPAR's storage mappings can cause hdisk discovery to fail because it thinks the hdisk is already in use. Retry conditions: The scrub-and-retry will be triggered if: o dev_name is None; or o status is anything other than DEVICE_AVAILABLE or FOUND_ITL_ERR. (The latter is acceptable because it means we discovered some, but not all, of the ITLs. This is okay as long as dev_name is set.) Arguments adapter - The pypowervm adapter. vios_uuid - The Virtual I/O Server UUID. itls - A list of ITL objects. vendor - The vendor for the LUN. See the LUAType.* constants. device_id - The device ID parameter in the LUA input XML. Typically the base 64 encoded pg83 value. Returns Type: status The status code from the discover process. See LUAStatus. constants. Type: dev_name The name of the discovered hdisk. Type: udid* The UDID of the device. Signature def discover_hdisk(adapter, vios_uuid, itls, vendor=LUAType.OTHER, device_id=None): ... get_pg83_via_job Show source in _fc.py:434 Inventory call to fetch the encoded SCSI Page 0x83 descriptor for a PV. Arguments adapter - The pypowervm adapter through which to run the Job. vios_uuid - The UUID of the Virtual I/O Server owning the PV. udid - The UDID of the PV to query. Returns SCSI PG83 NAA descriptor, base64-encoded. May be None. Signature def get_pg83_via_job(adapter, vios_uuid, udid): ... good_discovery Show source in _fc.py:119 Checks the hdisk discovery results for a good discovery. Acceptable LUA discovery statuses are :- DEVICE_AVAILABLE: hdisk discovered on all the ITL paths and available. DEVICE_IN_USE: hdisk discovered on all the ITL paths and is in-use by the server. FOUND_ITL_ERR: hdisk is discovered on some of the ITL paths and available. This can happen if there are multiple ITL nexus paths are passed, and hdisk is discovered on few of the paths only. This can happen if multiple target wwpns and vios wwpns exists and only few are connected. If hdisk can be discovered on ANY of the paths its considered for good discovery. Signature def good_discovery(status, device_name): ... lua_recovery Show source in _fc.py:212 Logical Unit Address Recovery - discovery of a FC-attached hdisk. When a new disk is created externally (say on a block device), the Virtual I/O Server may or may not discover it immediately. This method forces a discovery on a given Virtual I/O Server. Arguments adapter - The pypowervm adapter. vios_uuid - The Virtual I/O Server UUID. itls - A list of ITL objects. vendor - The vendor for the LUN. See the LUAType.* constants. device_id - The device ID parameter in the LUA input XML. Typically the base 64 encoded pg83 value. Returns Type: status The status code from the discover process. See LUAStatus. constants. Type: dev_name The name of the discovered hdisk. Type: udid* The UDID of the device. Signature def lua_recovery(adapter, vios_uuid, itls, vendor=LUAType.OTHER, device_id=None): ... normalize_lun Show source in _fc.py:65 Normalize the lun id to Big Endian Arguments scsi_id - Volume lun id Returns Converted LUN id in Big Endian as per the RFC 4455 Signature def normalize_lun(scsi_id): ... remove_hdisk Show source in _fc.py:364 Command to remove the device from the VIOS. Arguments adapter - The pypowervm adapter. host_name - The name of the host. dev_name - The name of the device to remove. vios_uuid - The Virtual I/O Server UUID. Signature def remove_hdisk(adapter, host_name, dev_name, vios_uuid): ...","title":"Fc"},{"location":"pypowervm/tasks/hdisk/_fc/#fc","text":"Pypowervm Index / Pypowervm / Tasks / Hdisk / Fc Auto-generated documentation for pypowervm.tasks.hdisk._fc module. Fc ITL LUAStatus LUAType build_itls discover_hdisk get_pg83_via_job good_discovery lua_recovery normalize_lun remove_hdisk","title":"Fc"},{"location":"pypowervm/tasks/hdisk/_fc/#itl","text":"Show source in _fc.py:84 The Nexus ITL. See SCSI ITL. This is the grouping of the SCSI initiator, target and LUN.","title":"ITL"},{"location":"pypowervm/tasks/hdisk/_fc/#signature","text":"class ITL(object): def __init__(self, initiator, target, lun): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_fc/#luastatus","text":"Show source in _fc.py:53 LUA Recovery status codes.","title":"LUAStatus"},{"location":"pypowervm/tasks/hdisk/_fc/#signature_1","text":"class LUAStatus(object): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_fc/#luatype","text":"Show source in _fc.py:43 LUA Vendors.","title":"LUAType"},{"location":"pypowervm/tasks/hdisk/_fc/#signature_2","text":"class LUAType(object): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_fc/#build_itls","text":"Show source in _fc.py:137 This method builds the list of ITLs for all of the permutations. An ITL is specific to an initiator, target, and LUN. However, with multi pathing, there are several scenarios where a given LUN will have many ITLs because of multiple initiators or targets. The initiators should be tied to a given Virtual I/O Server (or perhaps specific WWPNs within a VIOS).","title":"build_itls"},{"location":"pypowervm/tasks/hdisk/_fc/#arguments","text":"i_wwpns - List or set of initiator WWPNs. t_wwpns - List or set of target WWPNs. lun - The LUN identifier. Ex. 2 (an int). The identifier will be formatted from a generic integer LUN ID to match PowerVM's LUN Identifier format.","title":"Arguments"},{"location":"pypowervm/tasks/hdisk/_fc/#returns","text":"List of all the ITL permutations.","title":"Returns"},{"location":"pypowervm/tasks/hdisk/_fc/#signature_3","text":"def build_itls(i_wwpns, t_wwpns, lun): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_fc/#discover_hdisk","text":"Show source in _fc.py:157 Attempt to discover a hard disk attached to a Virtual I/O Server. See lua_recovery. This method attempts that call and analyzes the results. On certain failure conditions (see below), this method will find stale LPARs, scrub storage artifacts associated with them, and then retry lua_recovery. The retry is only attempted once; that result is returned regardless. The main objective of this method is to resolve errors resulting from incomplete cleanup of previous LPARs. The stale LPAR's storage mappings can cause hdisk discovery to fail because it thinks the hdisk is already in use. Retry conditions: The scrub-and-retry will be triggered if: o dev_name is None; or o status is anything other than DEVICE_AVAILABLE or FOUND_ITL_ERR. (The latter is acceptable because it means we discovered some, but not all, of the ITLs. This is okay as long as dev_name is set.)","title":"discover_hdisk"},{"location":"pypowervm/tasks/hdisk/_fc/#arguments_1","text":"adapter - The pypowervm adapter. vios_uuid - The Virtual I/O Server UUID. itls - A list of ITL objects. vendor - The vendor for the LUN. See the LUAType.* constants. device_id - The device ID parameter in the LUA input XML. Typically the base 64 encoded pg83 value.","title":"Arguments"},{"location":"pypowervm/tasks/hdisk/_fc/#returns_1","text":"Type: status The status code from the discover process. See LUAStatus. constants. Type: dev_name The name of the discovered hdisk. Type: udid* The UDID of the device.","title":"Returns"},{"location":"pypowervm/tasks/hdisk/_fc/#signature_4","text":"def discover_hdisk(adapter, vios_uuid, itls, vendor=LUAType.OTHER, device_id=None): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_fc/#get_pg83_via_job","text":"Show source in _fc.py:434 Inventory call to fetch the encoded SCSI Page 0x83 descriptor for a PV.","title":"get_pg83_via_job"},{"location":"pypowervm/tasks/hdisk/_fc/#arguments_2","text":"adapter - The pypowervm adapter through which to run the Job. vios_uuid - The UUID of the Virtual I/O Server owning the PV. udid - The UDID of the PV to query.","title":"Arguments"},{"location":"pypowervm/tasks/hdisk/_fc/#returns_2","text":"SCSI PG83 NAA descriptor, base64-encoded. May be None.","title":"Returns"},{"location":"pypowervm/tasks/hdisk/_fc/#signature_5","text":"def get_pg83_via_job(adapter, vios_uuid, udid): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_fc/#good_discovery","text":"Show source in _fc.py:119 Checks the hdisk discovery results for a good discovery. Acceptable LUA discovery statuses are :- DEVICE_AVAILABLE: hdisk discovered on all the ITL paths and available. DEVICE_IN_USE: hdisk discovered on all the ITL paths and is in-use by the server. FOUND_ITL_ERR: hdisk is discovered on some of the ITL paths and available. This can happen if there are multiple ITL nexus paths are passed, and hdisk is discovered on few of the paths only. This can happen if multiple target wwpns and vios wwpns exists and only few are connected. If hdisk can be discovered on ANY of the paths its considered for good discovery.","title":"good_discovery"},{"location":"pypowervm/tasks/hdisk/_fc/#signature_6","text":"def good_discovery(status, device_name): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_fc/#lua_recovery","text":"Show source in _fc.py:212 Logical Unit Address Recovery - discovery of a FC-attached hdisk. When a new disk is created externally (say on a block device), the Virtual I/O Server may or may not discover it immediately. This method forces a discovery on a given Virtual I/O Server.","title":"lua_recovery"},{"location":"pypowervm/tasks/hdisk/_fc/#arguments_3","text":"adapter - The pypowervm adapter. vios_uuid - The Virtual I/O Server UUID. itls - A list of ITL objects. vendor - The vendor for the LUN. See the LUAType.* constants. device_id - The device ID parameter in the LUA input XML. Typically the base 64 encoded pg83 value.","title":"Arguments"},{"location":"pypowervm/tasks/hdisk/_fc/#returns_3","text":"Type: status The status code from the discover process. See LUAStatus. constants. Type: dev_name The name of the discovered hdisk. Type: udid* The UDID of the device.","title":"Returns"},{"location":"pypowervm/tasks/hdisk/_fc/#signature_7","text":"def lua_recovery(adapter, vios_uuid, itls, vendor=LUAType.OTHER, device_id=None): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_fc/#normalize_lun","text":"Show source in _fc.py:65 Normalize the lun id to Big Endian","title":"normalize_lun"},{"location":"pypowervm/tasks/hdisk/_fc/#arguments_4","text":"scsi_id - Volume lun id","title":"Arguments"},{"location":"pypowervm/tasks/hdisk/_fc/#returns_4","text":"Converted LUN id in Big Endian as per the RFC 4455","title":"Returns"},{"location":"pypowervm/tasks/hdisk/_fc/#signature_8","text":"def normalize_lun(scsi_id): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_fc/#remove_hdisk","text":"Show source in _fc.py:364 Command to remove the device from the VIOS.","title":"remove_hdisk"},{"location":"pypowervm/tasks/hdisk/_fc/#arguments_5","text":"adapter - The pypowervm adapter. host_name - The name of the host. dev_name - The name of the device to remove. vios_uuid - The Virtual I/O Server UUID.","title":"Arguments"},{"location":"pypowervm/tasks/hdisk/_fc/#signature_9","text":"def remove_hdisk(adapter, host_name, dev_name, vios_uuid): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_iscsi/","text":"Iscsi Pypowervm Index / Pypowervm / Tasks / Hdisk / Iscsi Auto-generated documentation for pypowervm.tasks.hdisk._iscsi module. Iscsi ISCSIStatus discover_iscsi discover_iscsi_initiator good_discovery remove_iscsi ISCSIStatus Show source in _iscsi.py:36 ISCSI status codes. Signature class ISCSIStatus(object): ... discover_iscsi Show source in _iscsi.py:234 Initiates the iSCSI discovery and login job Arguments adapter - pypowervm adapter host_ip - The portal or list of portals for the iscsi target. A portal looks like ip:port. user - The username needed for authentication. password - The password needed for authentication. iqn - The IQN (iSCSI Qualified Name) or list of IQNs for the created volume on the target (e.g. iqn.2016-06.world.srv:target00). vios_uuid - The uuid of the VIOS (VIOS must be a Novalink VIOS type). transport_type - (Deprecated) Transport type of the volume to be connected. Use iface_name instead. lunid - Target LUN ID or list of LUN IDs for the volume. iface_name - Iscsi iface name to use for the connection. auth - Authentication type discovery_auth - Discovery authentication type. discovery_username - The username needed for discovery authentication. discovery_password - The password needed for discovery authentication. multipath - Whether the connection is multipath or not. Returns The device name of the created volume. The UniqueDeviceId of the create volume. :raise: ISCSIDiscoveryFailed in case of bad return code. :raise: JobRequestFailed in case of failure Signature def discover_iscsi( adapter, host_ip, user, password, iqn, vios_uuid, transport_type=None, lunid=None, iface_name=None, auth=None, discovery_auth=None, discovery_username=None, discovery_password=None, multipath=False, ): ... discover_iscsi_initiator Show source in _iscsi.py:308 Discovers the initiator name. Arguments adapter - pypowervm adapter vios_uuid - The uuid of the VIOS (VIOS must be a Novalink VIOS type). Returns The iscsi initiator name. :raise: ISCSIDiscoveryFailed in case of failure. Signature def discover_iscsi_initiator(adapter, vios_uuid): ... good_discovery Show source in _iscsi.py:95 Checks the hdisk discovery results for a good discovery. Acceptable discovery statuses are _GOOD_DISCOVERY_STATUSES Signature def good_discovery(status, device_name): ... remove_iscsi Show source in _iscsi.py:332 Remove an iSCSI lun from a session. If the last lun was removed from the session, also logout of the session. The iSCSI volume with the given targetIQN must not have any mappings from the VIOS to a client when this is called. Arguments adapter - pypowervm adapter targetIQN - The IQN (iSCSI Qualified Name) or list of IQNs for the created volume on the target. (e.g. iqn.2016-06.world.srv:target00) vios_uuid - The uuid of the VIOS (VIOS must be a Novalink VIOS type). iface_name - Name of the iface used for the connection. lun - The lun or list of luns to be removed. portal - The portal or list of portals associated with the created volume (ip:port). multipath - Whether the connection is multipath or not. :raise: ISCSIRemoveFailed in case of bad return code. :raise: JobRequestFailed in case of failure. Signature def remove_iscsi( adapter, targetIQN, vios_uuid, iface_name=None, lun=None, portal=None, multipath=False, ): ...","title":"Iscsi"},{"location":"pypowervm/tasks/hdisk/_iscsi/#iscsi","text":"Pypowervm Index / Pypowervm / Tasks / Hdisk / Iscsi Auto-generated documentation for pypowervm.tasks.hdisk._iscsi module. Iscsi ISCSIStatus discover_iscsi discover_iscsi_initiator good_discovery remove_iscsi","title":"Iscsi"},{"location":"pypowervm/tasks/hdisk/_iscsi/#iscsistatus","text":"Show source in _iscsi.py:36 ISCSI status codes.","title":"ISCSIStatus"},{"location":"pypowervm/tasks/hdisk/_iscsi/#signature","text":"class ISCSIStatus(object): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_iscsi/#discover_iscsi","text":"Show source in _iscsi.py:234 Initiates the iSCSI discovery and login job","title":"discover_iscsi"},{"location":"pypowervm/tasks/hdisk/_iscsi/#arguments","text":"adapter - pypowervm adapter host_ip - The portal or list of portals for the iscsi target. A portal looks like ip:port. user - The username needed for authentication. password - The password needed for authentication. iqn - The IQN (iSCSI Qualified Name) or list of IQNs for the created volume on the target (e.g. iqn.2016-06.world.srv:target00). vios_uuid - The uuid of the VIOS (VIOS must be a Novalink VIOS type). transport_type - (Deprecated) Transport type of the volume to be connected. Use iface_name instead. lunid - Target LUN ID or list of LUN IDs for the volume. iface_name - Iscsi iface name to use for the connection. auth - Authentication type discovery_auth - Discovery authentication type. discovery_username - The username needed for discovery authentication. discovery_password - The password needed for discovery authentication. multipath - Whether the connection is multipath or not.","title":"Arguments"},{"location":"pypowervm/tasks/hdisk/_iscsi/#returns","text":"The device name of the created volume. The UniqueDeviceId of the create volume. :raise: ISCSIDiscoveryFailed in case of bad return code. :raise: JobRequestFailed in case of failure","title":"Returns"},{"location":"pypowervm/tasks/hdisk/_iscsi/#signature_1","text":"def discover_iscsi( adapter, host_ip, user, password, iqn, vios_uuid, transport_type=None, lunid=None, iface_name=None, auth=None, discovery_auth=None, discovery_username=None, discovery_password=None, multipath=False, ): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_iscsi/#discover_iscsi_initiator","text":"Show source in _iscsi.py:308 Discovers the initiator name.","title":"discover_iscsi_initiator"},{"location":"pypowervm/tasks/hdisk/_iscsi/#arguments_1","text":"adapter - pypowervm adapter vios_uuid - The uuid of the VIOS (VIOS must be a Novalink VIOS type).","title":"Arguments"},{"location":"pypowervm/tasks/hdisk/_iscsi/#returns_1","text":"The iscsi initiator name. :raise: ISCSIDiscoveryFailed in case of failure.","title":"Returns"},{"location":"pypowervm/tasks/hdisk/_iscsi/#signature_2","text":"def discover_iscsi_initiator(adapter, vios_uuid): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_iscsi/#good_discovery","text":"Show source in _iscsi.py:95 Checks the hdisk discovery results for a good discovery. Acceptable discovery statuses are _GOOD_DISCOVERY_STATUSES","title":"good_discovery"},{"location":"pypowervm/tasks/hdisk/_iscsi/#signature_3","text":"def good_discovery(status, device_name): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_iscsi/#remove_iscsi","text":"Show source in _iscsi.py:332 Remove an iSCSI lun from a session. If the last lun was removed from the session, also logout of the session. The iSCSI volume with the given targetIQN must not have any mappings from the VIOS to a client when this is called.","title":"remove_iscsi"},{"location":"pypowervm/tasks/hdisk/_iscsi/#arguments_2","text":"adapter - pypowervm adapter targetIQN - The IQN (iSCSI Qualified Name) or list of IQNs for the created volume on the target. (e.g. iqn.2016-06.world.srv:target00) vios_uuid - The uuid of the VIOS (VIOS must be a Novalink VIOS type). iface_name - Name of the iface used for the connection. lun - The lun or list of luns to be removed. portal - The portal or list of portals associated with the created volume (ip:port). multipath - Whether the connection is multipath or not. :raise: ISCSIRemoveFailed in case of bad return code. :raise: JobRequestFailed in case of failure.","title":"Arguments"},{"location":"pypowervm/tasks/hdisk/_iscsi/#signature_4","text":"def remove_iscsi( adapter, targetIQN, vios_uuid, iface_name=None, lun=None, portal=None, multipath=False, ): ...","title":"Signature"},{"location":"pypowervm/tasks/hdisk/_rbd/","text":"Rbd Pypowervm Index / Pypowervm / Tasks / Hdisk / Rbd Auto-generated documentation for pypowervm.tasks.hdisk._rbd module. Rbd rbd_exists rbd_exists Show source in _rbd.py:26 Check if rbd exists on vios Arguments adapter - pypowervm adapter vios_uuid - The uuid of the VIOS (VIOS must be a Novalink VIOS type). name - Name of the rbd volume (pool/image) Returns The device name of the created volume. Signature def rbd_exists(adapter, vios_uuid, name): ...","title":"Rbd"},{"location":"pypowervm/tasks/hdisk/_rbd/#rbd","text":"Pypowervm Index / Pypowervm / Tasks / Hdisk / Rbd Auto-generated documentation for pypowervm.tasks.hdisk._rbd module. Rbd rbd_exists","title":"Rbd"},{"location":"pypowervm/tasks/hdisk/_rbd/#rbd_exists","text":"Show source in _rbd.py:26 Check if rbd exists on vios","title":"rbd_exists"},{"location":"pypowervm/tasks/hdisk/_rbd/#arguments","text":"adapter - pypowervm adapter vios_uuid - The uuid of the VIOS (VIOS must be a Novalink VIOS type). name - Name of the rbd volume (pool/image)","title":"Arguments"},{"location":"pypowervm/tasks/hdisk/_rbd/#returns","text":"The device name of the created volume.","title":"Returns"},{"location":"pypowervm/tasks/hdisk/_rbd/#signature","text":"def rbd_exists(adapter, vios_uuid, name): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/","text":"Monitor Pypowervm Index / Pypowervm / Tasks / Monitor Auto-generated documentation for pypowervm.tasks.monitor module. Monitor Modules Modules Host Cpu Lpar Util","title":"Monitor"},{"location":"pypowervm/tasks/monitor/#monitor","text":"Pypowervm Index / Pypowervm / Tasks / Monitor Auto-generated documentation for pypowervm.tasks.monitor module. Monitor Modules","title":"Monitor"},{"location":"pypowervm/tasks/monitor/#modules","text":"Host Cpu Lpar Util","title":"Modules"},{"location":"pypowervm/tasks/monitor/host_cpu/","text":"Host Cpu Pypowervm Index / Pypowervm / Tasks / Monitor / Host Cpu Auto-generated documentation for pypowervm.tasks.monitor.host_cpu module. Host Cpu HostCPUMetricCache HostCPUMetricCache().refresh HostCPUMetricCache Show source in host_cpu.py:24 Collects the PowerVM CPU metrics. PowerVM only gathers the CPU statistics once every 30 seconds. It does this to reduce overhead. There is a function to gather statistics quicker, but that can be very expensive. Therefore, to ensure that the client's workload is not impacted, these 'longer term' metrics will be used. This class builds off of a base pypowervm function where it can obtain the samples through a PCM 'cache'. If a new sample is available, the cache pulls the sample. If it is not, the existing sample is used. This can result in multiple, quickly successive calls to the host stats returning the same data (because a new sample may not be available yet). The class analyzes the data and keeps running counts of total, user, and firmware cycles. Signature class HostCPUMetricCache(pcm_util.MetricCache): def __init__(self, adapter, host_uuid): ... HostCPUMetricCache().refresh Show source in host_cpu.py:61 Updates the host-level CPU metrics if needed. Signature def refresh(self): ...","title":"Host Cpu"},{"location":"pypowervm/tasks/monitor/host_cpu/#host-cpu","text":"Pypowervm Index / Pypowervm / Tasks / Monitor / Host Cpu Auto-generated documentation for pypowervm.tasks.monitor.host_cpu module. Host Cpu HostCPUMetricCache HostCPUMetricCache().refresh","title":"Host Cpu"},{"location":"pypowervm/tasks/monitor/host_cpu/#hostcpumetriccache","text":"Show source in host_cpu.py:24 Collects the PowerVM CPU metrics. PowerVM only gathers the CPU statistics once every 30 seconds. It does this to reduce overhead. There is a function to gather statistics quicker, but that can be very expensive. Therefore, to ensure that the client's workload is not impacted, these 'longer term' metrics will be used. This class builds off of a base pypowervm function where it can obtain the samples through a PCM 'cache'. If a new sample is available, the cache pulls the sample. If it is not, the existing sample is used. This can result in multiple, quickly successive calls to the host stats returning the same data (because a new sample may not be available yet). The class analyzes the data and keeps running counts of total, user, and firmware cycles.","title":"HostCPUMetricCache"},{"location":"pypowervm/tasks/monitor/host_cpu/#signature","text":"class HostCPUMetricCache(pcm_util.MetricCache): def __init__(self, adapter, host_uuid): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/host_cpu/#hostcpumetriccacherefresh","text":"Show source in host_cpu.py:61 Updates the host-level CPU metrics if needed.","title":"HostCPUMetricCache().refresh"},{"location":"pypowervm/tasks/monitor/host_cpu/#signature_1","text":"def refresh(self): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/","text":"Lpar Pypowervm Index / Pypowervm / Tasks / Monitor / Lpar Auto-generated documentation for pypowervm.tasks.monitor.lpar module. Lpar LparCNA LparMemory LparMetric LparNetwork LparPhysAdpt LparProc LparStorage LparStorageAdpt LparVFCAdpt LparVFCAdpt().type LparVirtStorageAdpt PropertyWrapper LparCNA Show source in lpar.py:420 Represents a Client Network Adapter on a LPAR. Requires the PhypVEA raw metric as input. The supported metrics are as follows: - vlan_id: The PVID of the Client Network Adapter. - vswitch_id: The virtual switch ID (not UUID). - physical_location: The physical location for the Client Network Adapter. - received_packets: The count of packets received to the Client Network Adapter. - sent_packets: The count of packets sent by the Client Network Adapter. - dropped_packets: The count of the packets dropped by the Client Network Adapter. - sent_bytes: The count of the bytes sent by the Client Network Adapter. - received_bytes: The count of the bytes received by the Client Network Adapter. Signature class LparCNA(PropertyWrapper): ... See also PropertyWrapper LparMemory Show source in lpar.py:67 Represents the memory for a given LPAR. Requires the following as inputs: - PhypLparMemory raw metric - LparInfo.LparUtil raw metric. These metrics are got from IBM.Host Resource Manager through RMC. The supported metrics are as follows: - logical_mem: The amount of memory on the LPAR. - backed_physical_mem: The amount of backing physical memory used by the LPAR. - pct_real_mem_avbl: Percentage of available memory on VMs. It is only available for newer RSCT packages. This statistic does not count cached memory as in use. - total_pg_count: Page count of swap space for this VM. Page size is 4k. - free_pg_count: Page count of free swap space for this VM. Page size is 4k. - active_pg_count: Page count of total active memory for this VM. Page size is 4k. - real_mem_size_bytes: Total amount of memory assigned to this VM in bytes. - pct_real_mem_free: Percentage of real page frames that are currently available on the VMM (Virtual Memory Manager) free list. VMM manages the allocation of real memory page frames, resolves references to virtual memory pages that are not currently in real memory and manages the reading and writing of pages to disk storage. - vm_pg_in_rate: Represents the rate (in pages per second) that the VMM is reading both persistent and working pages from disk storage. A -1 value indicates that system could not determine this metric. - vm_pg_out_rate: Represents the rate (in pages per second) that the VMM is writing both persistent and working pages to disk storage. A -1 value indicates that system could not determine this metric. - vm_pg_swap_in_rate: Represents the rate (in pages per second) that the VMM is reading working pages from paging-space disk storage. A -1 value indicates that system could not determine this metric. - vm_pg_swap_out_rate: Represents the rate (in pages per second) that the VMM is writing working pages to paging-space disk storage. A -1 value indicates that system could not determine this metric. Signature class LparMemory(object): def __init__(self, lpar_mem_phyp, lpar_mem_pcm): ... LparMetric Show source in lpar.py:24 Represents a set of metrics for a given LPAR. This is a reduction and consolidation of the raw PCM statistics. Signature class LparMetric(object): def __init__(self, uuid): ... LparNetwork Show source in lpar.py:397 Represents the Network statistics for a given LPAR. Requires the PhypNetwork raw metric as input. Aggregates the various types of network statistics for a given LPAR. - cnas - List of the Client Network Adapter stats. Signature class LparNetwork(object): def __init__(self, lpar_sample_net): ... LparPhysAdpt Show source in lpar.py:363 A physical adapter (ex SAS drive) on the LPAR. Requires the ViosStoragePAdpt raw metric as input. The supported metrics are as follows: - name: The identifier of the adapter. Ex: vhost2. - physical_location: The physical location code of the adapter. - num_reads: The number of read operations done against the adapter. - num_writes: The number of write operations done against the adapter. - read_bytes: The number of bytes read from the adapter. - write_bytes: The number of bytes written to the adapter. - type: The type of the adapter. Signature class LparPhysAdpt(LparStorageAdpt): ... See also LparStorageAdpt LparProc Show source in lpar.py:141 Represents the CPU statistics for a given LPAR. Requires the PhypLparProc raw metric as input. The supported metrics are as follows: - pool_id: The CPU pool for this LPAR. - mode: The CPU mode. Typically cap or uncap. - virt_procs: The number of virtual processors assigned to the LPAR. - proc_units: The number of proc units assigned to the LPAR. Ex. if virt_procs is 4 and proc_units is .4, then each virtual processor has .1 CPUs. weight: The CPU weight for uncapped processors. This defines how aggressive this CPU should be when using unused cycles from other LPARs (as compared to other VMs that may also request those unused cycles). - entitled_proc_cycles: The entitled number of processor cycles. - util_cap_proc_cycles: The number of used processor cycles from its capped capacity. - util_uncap_proc_cycles: The number of utilized processor cycles pulled from uncap spare. - idle_proc_cycles: The CPU cycles spent idling. - donated_proc_cycles: The number of CPU cycles donated to other VMs due to no need. - time_wait_dispatch: Time spent waiting for CPU dispatch. - total_instructions: The total instructions executed. - total_inst_exec_time: The time for the instructions to execute. Signature class LparProc(PropertyWrapper): ... See also PropertyWrapper LparStorage Show source in lpar.py:180 Represents the Storage statistics for a given LPAR. Requires the PhypLparStorage and list of ViosInfo raw metrics as input. Contains the various LPAR storage statistic elements. - virt_adapters - List of LparVirtStorageAdpt on the LPAR - vfc_adpts - List of LparVFCAdpt on the LPAR Signature class LparStorage(object): def __init__(self, lpar_phyp_storage, vios_metrics): ... LparStorageAdpt Show source in lpar.py:317 Base class for storage adapters on a given LPAR. Requires the vios storage adapter raw metric as input. Specific classes are defined by the subclasses. The supported metrics are as follows: - name: The identifier of the adapter. Ex: vhost2. - physical_location: The physical location code of the adapter. - num_reads: The number of read operations done against the adapter. - num_writes: The number of write operations done against the adapter. - read_bytes: The number of bytes read from the adapter. - write_bytes: The number of bytes written to the adapter. - type: The type of the adapter. Signature class LparStorageAdpt(PropertyWrapper): ... See also PropertyWrapper LparVFCAdpt Show source in lpar.py:337 A Virtual Fibre Channel Adapter attached to the LPAR. Requires the ViosFCVirtAdpt raw metric as input. The supported metrics are as follows: - name: The identifier of the adapter. Ex: vhost2. - physical_location: The physical location code of the adapter. - num_reads: The number of read operations done against the adapter. - num_writes: The number of write operations done against the adapter. - read_bytes: The number of bytes read from the adapter. - write_bytes: The number of bytes written to the adapter. - type: The type of the adapter. Will be set to VFC. Signature class LparVFCAdpt(LparStorageAdpt): ... See also LparStorageAdpt LparVFCAdpt().type Show source in lpar.py:352 Overrides the type property as the raw metric. The VFC Adapter does not natively have a type in the raw metric. This property overrides and circumvents the standard property lookup mechanism. Signature @property def type(self): ... LparVirtStorageAdpt Show source in lpar.py:380 A Virutal Storage Adapter (ex. vscsi) attached to the LPAR. Requires the ViosStorageVAdpt raw metric as input. The supported metrics are as follows: - name: The identifier of the adapter. Ex: vhost2. - physical_location: The physical location code of the adapter. - num_reads: The number of read operations done against the adapter. - num_writes: The number of write operations done against the adapter. - read_bytes: The number of bytes read from the adapter. - write_bytes: The number of bytes written to the adapter. - type: The type of the adapter. Signature class LparVirtStorageAdpt(LparStorageAdpt): ... See also LparStorageAdpt PropertyWrapper Show source in lpar.py:52 Provides a thin wrapper around the raw metrics class. Sub class should have the _supported_metrics element defined. Signature class PropertyWrapper(object): def __init__(self, elem): ...","title":"Lpar"},{"location":"pypowervm/tasks/monitor/lpar/#lpar","text":"Pypowervm Index / Pypowervm / Tasks / Monitor / Lpar Auto-generated documentation for pypowervm.tasks.monitor.lpar module. Lpar LparCNA LparMemory LparMetric LparNetwork LparPhysAdpt LparProc LparStorage LparStorageAdpt LparVFCAdpt LparVFCAdpt().type LparVirtStorageAdpt PropertyWrapper","title":"Lpar"},{"location":"pypowervm/tasks/monitor/lpar/#lparcna","text":"Show source in lpar.py:420 Represents a Client Network Adapter on a LPAR. Requires the PhypVEA raw metric as input. The supported metrics are as follows: - vlan_id: The PVID of the Client Network Adapter. - vswitch_id: The virtual switch ID (not UUID). - physical_location: The physical location for the Client Network Adapter. - received_packets: The count of packets received to the Client Network Adapter. - sent_packets: The count of packets sent by the Client Network Adapter. - dropped_packets: The count of the packets dropped by the Client Network Adapter. - sent_bytes: The count of the bytes sent by the Client Network Adapter. - received_bytes: The count of the bytes received by the Client Network Adapter.","title":"LparCNA"},{"location":"pypowervm/tasks/monitor/lpar/#signature","text":"class LparCNA(PropertyWrapper): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#see-also","text":"PropertyWrapper","title":"See also"},{"location":"pypowervm/tasks/monitor/lpar/#lparmemory","text":"Show source in lpar.py:67 Represents the memory for a given LPAR. Requires the following as inputs: - PhypLparMemory raw metric - LparInfo.LparUtil raw metric. These metrics are got from IBM.Host Resource Manager through RMC. The supported metrics are as follows: - logical_mem: The amount of memory on the LPAR. - backed_physical_mem: The amount of backing physical memory used by the LPAR. - pct_real_mem_avbl: Percentage of available memory on VMs. It is only available for newer RSCT packages. This statistic does not count cached memory as in use. - total_pg_count: Page count of swap space for this VM. Page size is 4k. - free_pg_count: Page count of free swap space for this VM. Page size is 4k. - active_pg_count: Page count of total active memory for this VM. Page size is 4k. - real_mem_size_bytes: Total amount of memory assigned to this VM in bytes. - pct_real_mem_free: Percentage of real page frames that are currently available on the VMM (Virtual Memory Manager) free list. VMM manages the allocation of real memory page frames, resolves references to virtual memory pages that are not currently in real memory and manages the reading and writing of pages to disk storage. - vm_pg_in_rate: Represents the rate (in pages per second) that the VMM is reading both persistent and working pages from disk storage. A -1 value indicates that system could not determine this metric. - vm_pg_out_rate: Represents the rate (in pages per second) that the VMM is writing both persistent and working pages to disk storage. A -1 value indicates that system could not determine this metric. - vm_pg_swap_in_rate: Represents the rate (in pages per second) that the VMM is reading working pages from paging-space disk storage. A -1 value indicates that system could not determine this metric. - vm_pg_swap_out_rate: Represents the rate (in pages per second) that the VMM is writing working pages to paging-space disk storage. A -1 value indicates that system could not determine this metric.","title":"LparMemory"},{"location":"pypowervm/tasks/monitor/lpar/#signature_1","text":"class LparMemory(object): def __init__(self, lpar_mem_phyp, lpar_mem_pcm): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#lparmetric","text":"Show source in lpar.py:24 Represents a set of metrics for a given LPAR. This is a reduction and consolidation of the raw PCM statistics.","title":"LparMetric"},{"location":"pypowervm/tasks/monitor/lpar/#signature_2","text":"class LparMetric(object): def __init__(self, uuid): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#lparnetwork","text":"Show source in lpar.py:397 Represents the Network statistics for a given LPAR. Requires the PhypNetwork raw metric as input. Aggregates the various types of network statistics for a given LPAR. - cnas - List of the Client Network Adapter stats.","title":"LparNetwork"},{"location":"pypowervm/tasks/monitor/lpar/#signature_3","text":"class LparNetwork(object): def __init__(self, lpar_sample_net): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#lparphysadpt","text":"Show source in lpar.py:363 A physical adapter (ex SAS drive) on the LPAR. Requires the ViosStoragePAdpt raw metric as input. The supported metrics are as follows: - name: The identifier of the adapter. Ex: vhost2. - physical_location: The physical location code of the adapter. - num_reads: The number of read operations done against the adapter. - num_writes: The number of write operations done against the adapter. - read_bytes: The number of bytes read from the adapter. - write_bytes: The number of bytes written to the adapter. - type: The type of the adapter.","title":"LparPhysAdpt"},{"location":"pypowervm/tasks/monitor/lpar/#signature_4","text":"class LparPhysAdpt(LparStorageAdpt): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#see-also_1","text":"LparStorageAdpt","title":"See also"},{"location":"pypowervm/tasks/monitor/lpar/#lparproc","text":"Show source in lpar.py:141 Represents the CPU statistics for a given LPAR. Requires the PhypLparProc raw metric as input. The supported metrics are as follows: - pool_id: The CPU pool for this LPAR. - mode: The CPU mode. Typically cap or uncap. - virt_procs: The number of virtual processors assigned to the LPAR. - proc_units: The number of proc units assigned to the LPAR. Ex. if virt_procs is 4 and proc_units is .4, then each virtual processor has .1 CPUs. weight: The CPU weight for uncapped processors. This defines how aggressive this CPU should be when using unused cycles from other LPARs (as compared to other VMs that may also request those unused cycles). - entitled_proc_cycles: The entitled number of processor cycles. - util_cap_proc_cycles: The number of used processor cycles from its capped capacity. - util_uncap_proc_cycles: The number of utilized processor cycles pulled from uncap spare. - idle_proc_cycles: The CPU cycles spent idling. - donated_proc_cycles: The number of CPU cycles donated to other VMs due to no need. - time_wait_dispatch: Time spent waiting for CPU dispatch. - total_instructions: The total instructions executed. - total_inst_exec_time: The time for the instructions to execute.","title":"LparProc"},{"location":"pypowervm/tasks/monitor/lpar/#signature_5","text":"class LparProc(PropertyWrapper): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#see-also_2","text":"PropertyWrapper","title":"See also"},{"location":"pypowervm/tasks/monitor/lpar/#lparstorage","text":"Show source in lpar.py:180 Represents the Storage statistics for a given LPAR. Requires the PhypLparStorage and list of ViosInfo raw metrics as input. Contains the various LPAR storage statistic elements. - virt_adapters - List of LparVirtStorageAdpt on the LPAR - vfc_adpts - List of LparVFCAdpt on the LPAR","title":"LparStorage"},{"location":"pypowervm/tasks/monitor/lpar/#signature_6","text":"class LparStorage(object): def __init__(self, lpar_phyp_storage, vios_metrics): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#lparstorageadpt","text":"Show source in lpar.py:317 Base class for storage adapters on a given LPAR. Requires the vios storage adapter raw metric as input. Specific classes are defined by the subclasses. The supported metrics are as follows: - name: The identifier of the adapter. Ex: vhost2. - physical_location: The physical location code of the adapter. - num_reads: The number of read operations done against the adapter. - num_writes: The number of write operations done against the adapter. - read_bytes: The number of bytes read from the adapter. - write_bytes: The number of bytes written to the adapter. - type: The type of the adapter.","title":"LparStorageAdpt"},{"location":"pypowervm/tasks/monitor/lpar/#signature_7","text":"class LparStorageAdpt(PropertyWrapper): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#see-also_3","text":"PropertyWrapper","title":"See also"},{"location":"pypowervm/tasks/monitor/lpar/#lparvfcadpt","text":"Show source in lpar.py:337 A Virtual Fibre Channel Adapter attached to the LPAR. Requires the ViosFCVirtAdpt raw metric as input. The supported metrics are as follows: - name: The identifier of the adapter. Ex: vhost2. - physical_location: The physical location code of the adapter. - num_reads: The number of read operations done against the adapter. - num_writes: The number of write operations done against the adapter. - read_bytes: The number of bytes read from the adapter. - write_bytes: The number of bytes written to the adapter. - type: The type of the adapter. Will be set to VFC.","title":"LparVFCAdpt"},{"location":"pypowervm/tasks/monitor/lpar/#signature_8","text":"class LparVFCAdpt(LparStorageAdpt): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#see-also_4","text":"LparStorageAdpt","title":"See also"},{"location":"pypowervm/tasks/monitor/lpar/#lparvfcadpttype","text":"Show source in lpar.py:352 Overrides the type property as the raw metric. The VFC Adapter does not natively have a type in the raw metric. This property overrides and circumvents the standard property lookup mechanism.","title":"LparVFCAdpt().type"},{"location":"pypowervm/tasks/monitor/lpar/#signature_9","text":"@property def type(self): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#lparvirtstorageadpt","text":"Show source in lpar.py:380 A Virutal Storage Adapter (ex. vscsi) attached to the LPAR. Requires the ViosStorageVAdpt raw metric as input. The supported metrics are as follows: - name: The identifier of the adapter. Ex: vhost2. - physical_location: The physical location code of the adapter. - num_reads: The number of read operations done against the adapter. - num_writes: The number of write operations done against the adapter. - read_bytes: The number of bytes read from the adapter. - write_bytes: The number of bytes written to the adapter. - type: The type of the adapter.","title":"LparVirtStorageAdpt"},{"location":"pypowervm/tasks/monitor/lpar/#signature_10","text":"class LparVirtStorageAdpt(LparStorageAdpt): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/lpar/#see-also_5","text":"LparStorageAdpt","title":"See also"},{"location":"pypowervm/tasks/monitor/lpar/#propertywrapper","text":"Show source in lpar.py:52 Provides a thin wrapper around the raw metrics class. Sub class should have the _supported_metrics element defined.","title":"PropertyWrapper"},{"location":"pypowervm/tasks/monitor/lpar/#signature_11","text":"class PropertyWrapper(object): def __init__(self, elem): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/util/","text":"Util Pypowervm Index / Pypowervm / Tasks / Monitor / Util Auto-generated documentation for pypowervm.tasks.monitor.util module. Util LparMetricCache LparMetricCache().get_latest_metric LparMetricCache().get_previous_metric MetricCache ensure_ltm_monitors get_lpar_metrics latest_stats query_ltm_feed vm_metrics LparMetricCache Show source in util.py:137 Provides a cache of metrics on a per LPAR level. Metrics are expensive to gather and to parse. It is expensive because the backing API gathers all of the metrics at the Hypervisor and Virtual I/O Server levels. This returns all of the LPARs. Therefore, this cache parses in all of the data once, and allows the invoker to get individual LPAR metrics without having to re-query the API server. This class provides a caching mechanism along with a built in refresh mechanism if enough time has passed since last gathering the metrics. This cache will obtain the metrics for a given system, separate them out into an individual LparMetric cache. If another LPAR is required, the cache will be used (so a subsequent API call is not required). There is a refresh_interval as well. If the interval is passed, a subsequent query of the metrics will force a refresh of the cache. The previous metric is also saved within the cache. This is useful for generating rates on the metrics (a previous element to compare against). The cache will only contain the last two samples of hypervisor/vios data. This is so that the current sample and the previous sample are maintained. The data is maintained for all of the systems that metrics data has data for - but this is still quite thin. This cache does not have support to maintain additional samples. Trimming is done upon each refresh (which is triggered by the get_latest_metric). To wipe the cache, the user should just have the cache go out of scope and it will be cleared. No manual clean up is required. Signature class LparMetricCache(MetricCache): def __init__(self, adapter, host_uuid, refresh_delta=30, include_vio=True): ... See also MetricCache LparMetricCache().get_latest_metric Show source in util.py:195 Returns the latest metrics for a given LPAR. This will pull from the cache, but will refresh the cache if the refresh interval has passed. Arguments lpar_uuid - The UUID of the LPAR to query for the metrics. Returns Two elements. - First is the date of the metric. - Second is the LparMetric Note that both of these can be None. If the date of the metric is None, that indicates that there was no previous metric (or something is wrong with the gather flow). If the date of the metric is None, then the second value will be None as well. If the date of the metric is set, but None is returned for the value then the LPAR had no metrics for it. Scenarios can occur where the current metric may have a value but not the previous (ex. when a LPAR was just created). Signature @lockutils.synchronized(\"pvm_lpar_metrics_get\") def get_latest_metric(self, lpar_uuid): ... LparMetricCache().get_previous_metric Show source in util.py:228 Returns the previous metric for a given LPAR. This will NOT update the cache. That can only be triggered from the get_latest_metric method. Arguments lpar_uuid - The UUID of the LPAR to query for the metrics. Returns Two elements. - First is the date of the metric. - Second is the LparMetric Note that both of these can be None. If the date of the metric is None, that indicates that there was no previous metric (or something is wrong with the gather flow). If the date of the metric is None, then the second value will be None as well. If the date of the metric is set, but None is returned for the value then the LPAR had no metrics for it. Scenarios can occur where the current metric may have a value but not the previous (ex. when a LPAR was just created). Signature @lockutils.synchronized(\"pvm_lpar_metrics_get\") def get_previous_metric(self, lpar_uuid): ... MetricCache Show source in util.py:43 Provides a cache of the metrics data. The core LongTermMetrics API only refreshes its internal metric data once (generally) every 30 seconds. This class provides a generalized cache of the metrics. It stores both the raw phyp and vios metrics (if available) and will only refresh them after a specified time period has elapsed (30 seconds by default). Signature class MetricCache(object): def __init__(self, adapter, host_uuid, refresh_delta=30, include_vio=True): ... ensure_ltm_monitors Show source in util.py:385 Ensures that the Long Term Monitors are enabled. Arguments adapter - The pypowervm adapter. host_uuid - The host systems UUID. override_to_default - (Optional) If True will ensure that the defaults are set on the system. This means: - Short Term Metrics - disabled - Aggregation - turned on If left off, the previous values will be adhered to. compute_ltm - (Optional - Defaults to False) If set, will turn on only the compute long term metrics, and the VIOS and network metrics will not be considered. Signature def ensure_ltm_monitors( adapter, host_uuid, override_to_default=False, compute_ltm=False ): ... get_lpar_metrics Show source in util.py:332 This method returns LPAR metrics of type LparInfo Arguments ltm_metrics - The LTM metrics adapter - The pypowervm adapter. second_latest - (Optional) Defaults to False. If set to True, it will pull the second to last metric for the return data. Returns LparInfo object representing the LPAR metrics. None is returned if there are no LTM metrics collected. Signature def get_lpar_metrics(ltm_metrics, adapter, second_latest=False): ... latest_stats Show source in util.py:269 Returns the latest PHYP and (optionally) VIOS statistics. Arguments adapter - The pypowervm adapter. host_uuid - The host system's UUID. include_vio - (Optional) Defaults to True. If set to false, the VIO metrics will always be returned as an empty list. second_latest - (Optional) Defaults to False. If set to True, it will pull the second to last metric for the return data. Returns datetime - When the metrics were pulled. phyp_data - The PhypInfo object for the raw metrics. May be None if there are issues gathering the metrics. vios_datas - The list of ViosInfo objects. May be empty if the metrics are unavailable or if the include_vio flag is False. Is a list as the system may have many Virtual I/O Servers. lpar_metrics - The list of Lpar metrics received from querying IBM.Host Resource Manager via RMC. It may be empty is the metrics are unavailable or if the include_lpars flag is False. lpar_metrics are generally collected once every two minutes, as opposed to the other data which is collected every 30 seconds. Signature def latest_stats(adapter, host_uuid, include_vio=True, second_latest=False): ... query_ltm_feed Show source in util.py:365 Will query the long term metrics feed for a given host. This method is useful due to the difference in nature of the pcm URIs compared to the standard uom. PCM URI: ManagedSystem/host_uuid/RawMetrics/LongTermMonitor Arguments adapter - The pypowervm adapter. host_uuid - The host system's UUID. Returns A list of the LTMMetrics. Note that both PHYP and VIOS entries are returned (assuming both are enabled). Signature def query_ltm_feed(adapter, host_uuid): ... vm_metrics Show source in util.py:424 Reduces the metrics to a per VM basis. The metrics returned by PCM are on a global level. The anchor points are PHYP and the Virtual I/O Servers. Typical consumption models for metrics are on a 'per-VM' basis. The dictionary returned contains the LPAR UUID and a LparMetric object. That object breaks down the PHYP and VIOS statistics to be approached on a LPAR level. Arguments phyp - The PhypInfo for the metrics. vioses - A list of the ViosInfos for the Virtual I/O Server components. lpars - The LparInfo object representing Lpar metrics collected via RMC. Returns Type: vm_data A dictionary where the UUID is the client LPAR UUID, but the data is a LparMetric for that VM. Note: Data can not be guaranteed. It may exist in one sample, but then not in another (ex. VM was powered off between gathers). Always validate that data is 'not None' before use. Signature def vm_metrics(phyp, vioses, lpars): ...","title":"Util"},{"location":"pypowervm/tasks/monitor/util/#util","text":"Pypowervm Index / Pypowervm / Tasks / Monitor / Util Auto-generated documentation for pypowervm.tasks.monitor.util module. Util LparMetricCache LparMetricCache().get_latest_metric LparMetricCache().get_previous_metric MetricCache ensure_ltm_monitors get_lpar_metrics latest_stats query_ltm_feed vm_metrics","title":"Util"},{"location":"pypowervm/tasks/monitor/util/#lparmetriccache","text":"Show source in util.py:137 Provides a cache of metrics on a per LPAR level. Metrics are expensive to gather and to parse. It is expensive because the backing API gathers all of the metrics at the Hypervisor and Virtual I/O Server levels. This returns all of the LPARs. Therefore, this cache parses in all of the data once, and allows the invoker to get individual LPAR metrics without having to re-query the API server. This class provides a caching mechanism along with a built in refresh mechanism if enough time has passed since last gathering the metrics. This cache will obtain the metrics for a given system, separate them out into an individual LparMetric cache. If another LPAR is required, the cache will be used (so a subsequent API call is not required). There is a refresh_interval as well. If the interval is passed, a subsequent query of the metrics will force a refresh of the cache. The previous metric is also saved within the cache. This is useful for generating rates on the metrics (a previous element to compare against). The cache will only contain the last two samples of hypervisor/vios data. This is so that the current sample and the previous sample are maintained. The data is maintained for all of the systems that metrics data has data for - but this is still quite thin. This cache does not have support to maintain additional samples. Trimming is done upon each refresh (which is triggered by the get_latest_metric). To wipe the cache, the user should just have the cache go out of scope and it will be cleared. No manual clean up is required.","title":"LparMetricCache"},{"location":"pypowervm/tasks/monitor/util/#signature","text":"class LparMetricCache(MetricCache): def __init__(self, adapter, host_uuid, refresh_delta=30, include_vio=True): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/util/#see-also","text":"MetricCache","title":"See also"},{"location":"pypowervm/tasks/monitor/util/#lparmetriccacheget_latest_metric","text":"Show source in util.py:195 Returns the latest metrics for a given LPAR. This will pull from the cache, but will refresh the cache if the refresh interval has passed.","title":"LparMetricCache().get_latest_metric"},{"location":"pypowervm/tasks/monitor/util/#arguments","text":"lpar_uuid - The UUID of the LPAR to query for the metrics.","title":"Arguments"},{"location":"pypowervm/tasks/monitor/util/#returns","text":"Two elements. - First is the date of the metric. - Second is the LparMetric Note that both of these can be None. If the date of the metric is None, that indicates that there was no previous metric (or something is wrong with the gather flow). If the date of the metric is None, then the second value will be None as well. If the date of the metric is set, but None is returned for the value then the LPAR had no metrics for it. Scenarios can occur where the current metric may have a value but not the previous (ex. when a LPAR was just created).","title":"Returns"},{"location":"pypowervm/tasks/monitor/util/#signature_1","text":"@lockutils.synchronized(\"pvm_lpar_metrics_get\") def get_latest_metric(self, lpar_uuid): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/util/#lparmetriccacheget_previous_metric","text":"Show source in util.py:228 Returns the previous metric for a given LPAR. This will NOT update the cache. That can only be triggered from the get_latest_metric method.","title":"LparMetricCache().get_previous_metric"},{"location":"pypowervm/tasks/monitor/util/#arguments_1","text":"lpar_uuid - The UUID of the LPAR to query for the metrics.","title":"Arguments"},{"location":"pypowervm/tasks/monitor/util/#returns_1","text":"Two elements. - First is the date of the metric. - Second is the LparMetric Note that both of these can be None. If the date of the metric is None, that indicates that there was no previous metric (or something is wrong with the gather flow). If the date of the metric is None, then the second value will be None as well. If the date of the metric is set, but None is returned for the value then the LPAR had no metrics for it. Scenarios can occur where the current metric may have a value but not the previous (ex. when a LPAR was just created).","title":"Returns"},{"location":"pypowervm/tasks/monitor/util/#signature_2","text":"@lockutils.synchronized(\"pvm_lpar_metrics_get\") def get_previous_metric(self, lpar_uuid): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/util/#metriccache","text":"Show source in util.py:43 Provides a cache of the metrics data. The core LongTermMetrics API only refreshes its internal metric data once (generally) every 30 seconds. This class provides a generalized cache of the metrics. It stores both the raw phyp and vios metrics (if available) and will only refresh them after a specified time period has elapsed (30 seconds by default).","title":"MetricCache"},{"location":"pypowervm/tasks/monitor/util/#signature_3","text":"class MetricCache(object): def __init__(self, adapter, host_uuid, refresh_delta=30, include_vio=True): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/util/#ensure_ltm_monitors","text":"Show source in util.py:385 Ensures that the Long Term Monitors are enabled.","title":"ensure_ltm_monitors"},{"location":"pypowervm/tasks/monitor/util/#arguments_2","text":"adapter - The pypowervm adapter. host_uuid - The host systems UUID. override_to_default - (Optional) If True will ensure that the defaults are set on the system. This means: - Short Term Metrics - disabled - Aggregation - turned on If left off, the previous values will be adhered to. compute_ltm - (Optional - Defaults to False) If set, will turn on only the compute long term metrics, and the VIOS and network metrics will not be considered.","title":"Arguments"},{"location":"pypowervm/tasks/monitor/util/#signature_4","text":"def ensure_ltm_monitors( adapter, host_uuid, override_to_default=False, compute_ltm=False ): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/util/#get_lpar_metrics","text":"Show source in util.py:332 This method returns LPAR metrics of type LparInfo","title":"get_lpar_metrics"},{"location":"pypowervm/tasks/monitor/util/#arguments_3","text":"ltm_metrics - The LTM metrics adapter - The pypowervm adapter. second_latest - (Optional) Defaults to False. If set to True, it will pull the second to last metric for the return data.","title":"Arguments"},{"location":"pypowervm/tasks/monitor/util/#returns_2","text":"LparInfo object representing the LPAR metrics. None is returned if there are no LTM metrics collected.","title":"Returns"},{"location":"pypowervm/tasks/monitor/util/#signature_5","text":"def get_lpar_metrics(ltm_metrics, adapter, second_latest=False): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/util/#latest_stats","text":"Show source in util.py:269 Returns the latest PHYP and (optionally) VIOS statistics.","title":"latest_stats"},{"location":"pypowervm/tasks/monitor/util/#arguments_4","text":"adapter - The pypowervm adapter. host_uuid - The host system's UUID. include_vio - (Optional) Defaults to True. If set to false, the VIO metrics will always be returned as an empty list. second_latest - (Optional) Defaults to False. If set to True, it will pull the second to last metric for the return data.","title":"Arguments"},{"location":"pypowervm/tasks/monitor/util/#returns_3","text":"datetime - When the metrics were pulled. phyp_data - The PhypInfo object for the raw metrics. May be None if there are issues gathering the metrics. vios_datas - The list of ViosInfo objects. May be empty if the metrics are unavailable or if the include_vio flag is False. Is a list as the system may have many Virtual I/O Servers. lpar_metrics - The list of Lpar metrics received from querying IBM.Host Resource Manager via RMC. It may be empty is the metrics are unavailable or if the include_lpars flag is False. lpar_metrics are generally collected once every two minutes, as opposed to the other data which is collected every 30 seconds.","title":"Returns"},{"location":"pypowervm/tasks/monitor/util/#signature_6","text":"def latest_stats(adapter, host_uuid, include_vio=True, second_latest=False): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/util/#query_ltm_feed","text":"Show source in util.py:365 Will query the long term metrics feed for a given host. This method is useful due to the difference in nature of the pcm URIs compared to the standard uom. PCM URI: ManagedSystem/host_uuid/RawMetrics/LongTermMonitor","title":"query_ltm_feed"},{"location":"pypowervm/tasks/monitor/util/#arguments_5","text":"adapter - The pypowervm adapter. host_uuid - The host system's UUID.","title":"Arguments"},{"location":"pypowervm/tasks/monitor/util/#returns_4","text":"A list of the LTMMetrics. Note that both PHYP and VIOS entries are returned (assuming both are enabled).","title":"Returns"},{"location":"pypowervm/tasks/monitor/util/#signature_7","text":"def query_ltm_feed(adapter, host_uuid): ...","title":"Signature"},{"location":"pypowervm/tasks/monitor/util/#vm_metrics","text":"Show source in util.py:424 Reduces the metrics to a per VM basis. The metrics returned by PCM are on a global level. The anchor points are PHYP and the Virtual I/O Servers. Typical consumption models for metrics are on a 'per-VM' basis. The dictionary returned contains the LPAR UUID and a LparMetric object. That object breaks down the PHYP and VIOS statistics to be approached on a LPAR level.","title":"vm_metrics"},{"location":"pypowervm/tasks/monitor/util/#arguments_6","text":"phyp - The PhypInfo for the metrics. vioses - A list of the ViosInfos for the Virtual I/O Server components. lpars - The LparInfo object representing Lpar metrics collected via RMC.","title":"Arguments"},{"location":"pypowervm/tasks/monitor/util/#returns_5","text":"Type: vm_data A dictionary where the UUID is the client LPAR UUID, but the data is a LparMetric for that VM. Note: Data can not be guaranteed. It may exist in one sample, but then not in another (ex. VM was powered off between gathers). Always validate that data is 'not None' before use.","title":"Returns"},{"location":"pypowervm/tasks/monitor/util/#signature_8","text":"def vm_metrics(phyp, vioses, lpars): ...","title":"Signature"},{"location":"pypowervm/tests/","text":"Tests Pypowervm Index / Pypowervm / Tests Auto-generated documentation for pypowervm.tests module. Tests Modules Modules Helpers Lib Tasks TestAdapter TestExceptions Test Fixtures TestHelpers Test I18n TestSession TestTraits TestUtil Test Utils Utils Wrappers","title":"Tests"},{"location":"pypowervm/tests/#tests","text":"Pypowervm Index / Pypowervm / Tests Auto-generated documentation for pypowervm.tests module. Tests Modules","title":"Tests"},{"location":"pypowervm/tests/#modules","text":"Helpers Lib Tasks TestAdapter TestExceptions Test Fixtures TestHelpers Test I18n TestSession TestTraits TestUtil Test Utils Utils Wrappers","title":"Modules"},{"location":"pypowervm/tests/lib/","text":"Lib Pypowervm Index / Pypowervm / Tests / Lib Auto-generated documentation for pypowervm.tests.lib module. Lib file2b file2b Show source in lib.py:24 Reads a file into a byte string. Arguments basename - The base name (no path) of the file to consume. The file is expected to reside in the data/ subdirectory of the path containing this library. Returns Python 2- and 3-compatible byte string of the input file's contents, unaltered and unprocessed. Signature def file2b(basename): ...","title":"Lib"},{"location":"pypowervm/tests/lib/#lib","text":"Pypowervm Index / Pypowervm / Tests / Lib Auto-generated documentation for pypowervm.tests.lib module. Lib file2b","title":"Lib"},{"location":"pypowervm/tests/lib/#file2b","text":"Show source in lib.py:24 Reads a file into a byte string.","title":"file2b"},{"location":"pypowervm/tests/lib/#arguments","text":"basename - The base name (no path) of the file to consume. The file is expected to reside in the data/ subdirectory of the path containing this library.","title":"Arguments"},{"location":"pypowervm/tests/lib/#returns","text":"Python 2- and 3-compatible byte string of the input file's contents, unaltered and unprocessed.","title":"Returns"},{"location":"pypowervm/tests/lib/#signature","text":"def file2b(basename): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/","text":"TestAdapter Pypowervm Index / Pypowervm / Tests / TestAdapter Auto-generated documentation for pypowervm.tests.test_adapter module. TestAdapter TestAdapter TestAdapter().setUp TestAdapter().tearDown TestAdapter().test_auth_file_error TestAdapter().test_build_path TestAdapter().test_create TestAdapter().test_delete TestAdapter().test_element_iter TestAdapter().test_empty_init TestAdapter().test_event_listener TestAdapter().test_extend_path TestAdapter().test_extract_atom TestAdapter().test_headers TestAdapter().test_no_cache TestAdapter().test_read TestAdapter().test_read2 TestAdapter().test_read_by_href TestAdapter().test_sys_uuid TestAdapter().test_unauthorized_error TestAdapter().test_update TestAdapter().test_upload TestAdapter().test_upload_request_fh TestAdapter().test_upload_request_iter TestAdapterClasses TestAdapterClasses().setUp TestAdapterClasses().test_instantiation TestAdapterClasses().test_shutdown_adapter TestAdapterClasses().test_shutdown_session TestElement TestElement().setUp TestElement().test_cdata TestElement().test_tag_namespace TestElementInject TestElementInject().assert_expected_children TestElementInject().setUp TestElementInject().test_first_populated TestElementInject().test_first_sparse TestElementInject().test_last_populated TestElementInject().test_last_sparse TestElementInject().test_middle_populated TestElementInject().test_middle_sparse TestElementInject().test_no_children TestElementInject().test_subelement_found_mult_replace_true TestElementInject().test_subelement_found_one_replace_true TestElementInject().test_subelement_found_replace_false TestElementInject().test_subelement_not_in_ordering_list TestElementWrapper TestElementWrapper().setUp TestElementWrapper().test_equality TestElementWrapper().test_inequality_by_subelem_change TestAdapter Show source in test_adapter.py:54 Test cases to test the adapter classes and methods. Signature class TestAdapter(testtools.TestCase): ... TestAdapter().setUp Show source in test_adapter.py:81 Signature def setUp(self): ... TestAdapter().tearDown Show source in test_adapter.py:106 Tear down the Session instance. Signature def tearDown(self): ... TestAdapter().test_auth_file_error Show source in test_adapter.py:720 Signature @mock.patch.object(builtins, \"open\") def test_auth_file_error(self, mock_open_patch): ... TestAdapter().test_build_path Show source in test_adapter.py:302 Validate build_path. Signature @mock.patch(\"pypowervm.adapter.Adapter.extend_path\") def test_build_path(self, mock_exp): ... TestAdapter().test_create Show source in test_adapter.py:397 Test create() method found in the Adapter class. Signature @mock.patch(\"requests.Session\") def test_create(self, mock_session): ... TestAdapter().test_delete Show source in test_adapter.py:694 Test delete() method found in the Adapter class. Signature @mock.patch(\"requests.Session\") def test_delete(self, mock_session): ... TestAdapter().test_element_iter Show source in test_adapter.py:757 Test the ETElement iter() method found in the Adapter class. Signature def test_element_iter(self): ... TestAdapter().test_empty_init Show source in test_adapter.py:224 Signature @mock.patch(\"pypowervm.adapter.Session\") def test_empty_init(self, mock_sess): ... TestAdapter().test_event_listener Show source in test_adapter.py:111 Signature @mock.patch(\"pypowervm.wrappers.event.Event.wrap\") @mock.patch(\"time.sleep\") def test_event_listener(self, mock_sleep, mock_evt_wrap): ... TestAdapter().test_extend_path Show source in test_adapter.py:533 Signature @mock.patch(\"requests.Session\") def test_extend_path(self, mock_session): ... TestAdapter().test_extract_atom Show source in test_adapter.py:802 Signature @mock.patch(\"pypowervm.entities.Feed.unmarshal_atom_feed\") @mock.patch(\"pypowervm.entities.Entry.unmarshal_atom_entry\") @mock.patch(\"lxml.etree.fromstring\") def test_extract_atom(self, mock_fromstring, mock_unm_ent, mock_unm_feed): ... TestAdapter().test_headers Show source in test_adapter.py:339 Signature @mock.patch(\"pypowervm.adapter.Adapter._request\") def test_headers(self, mock_request): ... TestAdapter().test_no_cache Show source in test_adapter.py:229 Signature def test_no_cache(self): ... TestAdapter().test_read Show source in test_adapter.py:233 Test read() method found in the Adapter class. Signature @mock.patch(\"requests.Session\") def test_read(self, mock_session): ... TestAdapter().test_read2 Show source in test_adapter.py:264 Validate shallow flow & arg passing. Signature @mock.patch(\"pypowervm.adapter.Adapter._validate\") @mock.patch(\"pypowervm.adapter.Adapter.build_path\") @mock.patch(\"pypowervm.adapter.Adapter.read_by_path\") def test_read2(self, mock_rbp, mock_bld, mock_val): ... TestAdapter().test_read_by_href Show source in test_adapter.py:660 Ensure read_by_href correctly extends, preserves query strings. Signature @mock.patch(\"pypowervm.adapter.LOG\") @mock.patch(\"pypowervm.adapter.Adapter.read_by_path\") def test_read_by_href(self, mock_read_by_path, mock_log): ... TestAdapter().test_sys_uuid Show source in test_adapter.py:845 Signature @mock.patch(\"pypowervm.adapter.Adapter.read\") def test_sys_uuid(self, mock_read): ... TestAdapter().test_unauthorized_error Show source in test_adapter.py:732 401 (unauthorized) calling Adapter.create(). Signature @mock.patch(\"pypowervm.adapter.LOG\") @mock.patch(\"requests.Session\") def test_unauthorized_error(self, mock_session, mock_log): ... TestAdapter().test_update Show source in test_adapter.py:429 Test update() method found in the Adapter class. Signature @mock.patch(\"requests.Session\") def test_update(self, mock_session): ... TestAdapter().test_upload Show source in test_adapter.py:457 Signature @mock.patch(\"requests.Session\") def test_upload(self, mock_session): ... TestAdapter().test_upload_request_fh Show source in test_adapter.py:500 Test an upload request with a filehandle. Signature @mock.patch(\"requests.sessions.Session.request\") def test_upload_request_fh(self, mock_rq): ... TestAdapter().test_upload_request_iter Show source in test_adapter.py:494 Test an upload request with an iterable. Signature @mock.patch(\"requests.sessions.Session.request\") def test_upload_request_iter(self, mock_rq): ... TestAdapterClasses Show source in test_adapter.py:908 Signature class TestAdapterClasses(subunit.IsolatedTestCase, testtools.TestCase): ... TestAdapterClasses().setUp Show source in test_adapter.py:909 Signature def setUp(self): ... TestAdapterClasses().test_instantiation Show source in test_adapter.py:920 Direct instantiation of EventListener is not allowed. Signature def test_instantiation(self): ... TestAdapterClasses().test_shutdown_adapter Show source in test_adapter.py:957 Signature def test_shutdown_adapter(self): ... TestAdapterClasses().test_shutdown_session Show source in test_adapter.py:932 Signature def test_shutdown_session(self): ... TestElement Show source in test_adapter.py:864 Signature class TestElement(testtools.TestCase): ... TestElement().setUp Show source in test_adapter.py:865 Signature def setUp(self): ... TestElement().test_cdata Show source in test_adapter.py:869 Signature def test_cdata(self): ... TestElement().test_tag_namespace Show source in test_adapter.py:881 Signature def test_tag_namespace(self): ... TestElementInject Show source in test_adapter.py:976 Signature class TestElementInject(testtools.TestCase): ... TestElementInject().assert_expected_children Show source in test_adapter.py:1002 Assert that *children are the children of parent, in that order. Arguments parent - Parent adapter.Element children - Child adapter.Elements Signature def assert_expected_children(self, parent, *expected_children): ... TestElementInject().setUp Show source in test_adapter.py:978 Signature def setUp(self): ... TestElementInject().test_first_populated Show source in test_adapter.py:1068 Inject the first child when children are otherwise populated. Signature def test_first_populated(self): ... TestElementInject().test_first_sparse Show source in test_adapter.py:1075 Inject the first child when children are sparsely populated. Signature def test_first_sparse(self): ... TestElementInject().test_last_populated Show source in test_adapter.py:1083 Inject the last child when children are otherwise populated. Signature def test_last_populated(self): ... TestElementInject().test_last_sparse Show source in test_adapter.py:1090 Inject the last child when children are sparsely populated. Signature def test_last_sparse(self): ... TestElementInject().test_middle_populated Show source in test_adapter.py:1098 Inject a middle child when children are otherwise populated. Signature def test_middle_populated(self): ... TestElementInject().test_middle_sparse Show source in test_adapter.py:1105 Inject a middle child when children are sparsely populated. Signature def test_middle_sparse(self): ... TestElementInject().test_no_children Show source in test_adapter.py:1014 Inject when the element has no children - should \"append\". Signature def test_no_children(self): ... TestElementInject().test_subelement_found_mult_replace_true Show source in test_adapter.py:1036 Replace existing child with same tag when >1 such children. Should replace the last such child. Signature def test_subelement_found_mult_replace_true(self): ... TestElementInject().test_subelement_found_one_replace_true Show source in test_adapter.py:1024 Replace existing child with same tag. Signature def test_subelement_found_one_replace_true(self): ... TestElementInject().test_subelement_found_replace_false Show source in test_adapter.py:1048 Inject after existing child(ren) with same tag. Signature def test_subelement_found_replace_false(self): ... TestElementInject().test_subelement_not_in_ordering_list Show source in test_adapter.py:1060 Subelement not in ordering list - should append. Signature def test_subelement_not_in_ordering_list(self): ... TestElementWrapper Show source in test_adapter.py:1113 Tests for the ElementWrapper class. Signature class TestElementWrapper(testtools.TestCase): ... TestElementWrapper().setUp Show source in test_adapter.py:1116 Signature def setUp(self): ... TestElementWrapper().test_equality Show source in test_adapter.py:1123 Validates that two elements loaded from the same data is equal. Signature def test_equality(self): ... TestElementWrapper().test_inequality_by_subelem_change Show source in test_adapter.py:1133 Signature def test_inequality_by_subelem_change(self): ...","title":"TestAdapter"},{"location":"pypowervm/tests/test_adapter/#testadapter","text":"Pypowervm Index / Pypowervm / Tests / TestAdapter Auto-generated documentation for pypowervm.tests.test_adapter module. TestAdapter TestAdapter TestAdapter().setUp TestAdapter().tearDown TestAdapter().test_auth_file_error TestAdapter().test_build_path TestAdapter().test_create TestAdapter().test_delete TestAdapter().test_element_iter TestAdapter().test_empty_init TestAdapter().test_event_listener TestAdapter().test_extend_path TestAdapter().test_extract_atom TestAdapter().test_headers TestAdapter().test_no_cache TestAdapter().test_read TestAdapter().test_read2 TestAdapter().test_read_by_href TestAdapter().test_sys_uuid TestAdapter().test_unauthorized_error TestAdapter().test_update TestAdapter().test_upload TestAdapter().test_upload_request_fh TestAdapter().test_upload_request_iter TestAdapterClasses TestAdapterClasses().setUp TestAdapterClasses().test_instantiation TestAdapterClasses().test_shutdown_adapter TestAdapterClasses().test_shutdown_session TestElement TestElement().setUp TestElement().test_cdata TestElement().test_tag_namespace TestElementInject TestElementInject().assert_expected_children TestElementInject().setUp TestElementInject().test_first_populated TestElementInject().test_first_sparse TestElementInject().test_last_populated TestElementInject().test_last_sparse TestElementInject().test_middle_populated TestElementInject().test_middle_sparse TestElementInject().test_no_children TestElementInject().test_subelement_found_mult_replace_true TestElementInject().test_subelement_found_one_replace_true TestElementInject().test_subelement_found_replace_false TestElementInject().test_subelement_not_in_ordering_list TestElementWrapper TestElementWrapper().setUp TestElementWrapper().test_equality TestElementWrapper().test_inequality_by_subelem_change","title":"TestAdapter"},{"location":"pypowervm/tests/test_adapter/#testadapter_1","text":"Show source in test_adapter.py:54 Test cases to test the adapter classes and methods.","title":"TestAdapter"},{"location":"pypowervm/tests/test_adapter/#signature","text":"class TestAdapter(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptersetup","text":"Show source in test_adapter.py:81","title":"TestAdapter().setUp"},{"location":"pypowervm/tests/test_adapter/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadapterteardown","text":"Show source in test_adapter.py:106 Tear down the Session instance.","title":"TestAdapter().tearDown"},{"location":"pypowervm/tests/test_adapter/#signature_2","text":"def tearDown(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_auth_file_error","text":"Show source in test_adapter.py:720","title":"TestAdapter().test_auth_file_error"},{"location":"pypowervm/tests/test_adapter/#signature_3","text":"@mock.patch.object(builtins, \"open\") def test_auth_file_error(self, mock_open_patch): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_build_path","text":"Show source in test_adapter.py:302 Validate build_path.","title":"TestAdapter().test_build_path"},{"location":"pypowervm/tests/test_adapter/#signature_4","text":"@mock.patch(\"pypowervm.adapter.Adapter.extend_path\") def test_build_path(self, mock_exp): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_create","text":"Show source in test_adapter.py:397 Test create() method found in the Adapter class.","title":"TestAdapter().test_create"},{"location":"pypowervm/tests/test_adapter/#signature_5","text":"@mock.patch(\"requests.Session\") def test_create(self, mock_session): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_delete","text":"Show source in test_adapter.py:694 Test delete() method found in the Adapter class.","title":"TestAdapter().test_delete"},{"location":"pypowervm/tests/test_adapter/#signature_6","text":"@mock.patch(\"requests.Session\") def test_delete(self, mock_session): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_element_iter","text":"Show source in test_adapter.py:757 Test the ETElement iter() method found in the Adapter class.","title":"TestAdapter().test_element_iter"},{"location":"pypowervm/tests/test_adapter/#signature_7","text":"def test_element_iter(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_empty_init","text":"Show source in test_adapter.py:224","title":"TestAdapter().test_empty_init"},{"location":"pypowervm/tests/test_adapter/#signature_8","text":"@mock.patch(\"pypowervm.adapter.Session\") def test_empty_init(self, mock_sess): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_event_listener","text":"Show source in test_adapter.py:111","title":"TestAdapter().test_event_listener"},{"location":"pypowervm/tests/test_adapter/#signature_9","text":"@mock.patch(\"pypowervm.wrappers.event.Event.wrap\") @mock.patch(\"time.sleep\") def test_event_listener(self, mock_sleep, mock_evt_wrap): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_extend_path","text":"Show source in test_adapter.py:533","title":"TestAdapter().test_extend_path"},{"location":"pypowervm/tests/test_adapter/#signature_10","text":"@mock.patch(\"requests.Session\") def test_extend_path(self, mock_session): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_extract_atom","text":"Show source in test_adapter.py:802","title":"TestAdapter().test_extract_atom"},{"location":"pypowervm/tests/test_adapter/#signature_11","text":"@mock.patch(\"pypowervm.entities.Feed.unmarshal_atom_feed\") @mock.patch(\"pypowervm.entities.Entry.unmarshal_atom_entry\") @mock.patch(\"lxml.etree.fromstring\") def test_extract_atom(self, mock_fromstring, mock_unm_ent, mock_unm_feed): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_headers","text":"Show source in test_adapter.py:339","title":"TestAdapter().test_headers"},{"location":"pypowervm/tests/test_adapter/#signature_12","text":"@mock.patch(\"pypowervm.adapter.Adapter._request\") def test_headers(self, mock_request): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_no_cache","text":"Show source in test_adapter.py:229","title":"TestAdapter().test_no_cache"},{"location":"pypowervm/tests/test_adapter/#signature_13","text":"def test_no_cache(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_read","text":"Show source in test_adapter.py:233 Test read() method found in the Adapter class.","title":"TestAdapter().test_read"},{"location":"pypowervm/tests/test_adapter/#signature_14","text":"@mock.patch(\"requests.Session\") def test_read(self, mock_session): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_read2","text":"Show source in test_adapter.py:264 Validate shallow flow & arg passing.","title":"TestAdapter().test_read2"},{"location":"pypowervm/tests/test_adapter/#signature_15","text":"@mock.patch(\"pypowervm.adapter.Adapter._validate\") @mock.patch(\"pypowervm.adapter.Adapter.build_path\") @mock.patch(\"pypowervm.adapter.Adapter.read_by_path\") def test_read2(self, mock_rbp, mock_bld, mock_val): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_read_by_href","text":"Show source in test_adapter.py:660 Ensure read_by_href correctly extends, preserves query strings.","title":"TestAdapter().test_read_by_href"},{"location":"pypowervm/tests/test_adapter/#signature_16","text":"@mock.patch(\"pypowervm.adapter.LOG\") @mock.patch(\"pypowervm.adapter.Adapter.read_by_path\") def test_read_by_href(self, mock_read_by_path, mock_log): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_sys_uuid","text":"Show source in test_adapter.py:845","title":"TestAdapter().test_sys_uuid"},{"location":"pypowervm/tests/test_adapter/#signature_17","text":"@mock.patch(\"pypowervm.adapter.Adapter.read\") def test_sys_uuid(self, mock_read): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_unauthorized_error","text":"Show source in test_adapter.py:732 401 (unauthorized) calling Adapter.create().","title":"TestAdapter().test_unauthorized_error"},{"location":"pypowervm/tests/test_adapter/#signature_18","text":"@mock.patch(\"pypowervm.adapter.LOG\") @mock.patch(\"requests.Session\") def test_unauthorized_error(self, mock_session, mock_log): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_update","text":"Show source in test_adapter.py:429 Test update() method found in the Adapter class.","title":"TestAdapter().test_update"},{"location":"pypowervm/tests/test_adapter/#signature_19","text":"@mock.patch(\"requests.Session\") def test_update(self, mock_session): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_upload","text":"Show source in test_adapter.py:457","title":"TestAdapter().test_upload"},{"location":"pypowervm/tests/test_adapter/#signature_20","text":"@mock.patch(\"requests.Session\") def test_upload(self, mock_session): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_upload_request_fh","text":"Show source in test_adapter.py:500 Test an upload request with a filehandle.","title":"TestAdapter().test_upload_request_fh"},{"location":"pypowervm/tests/test_adapter/#signature_21","text":"@mock.patch(\"requests.sessions.Session.request\") def test_upload_request_fh(self, mock_rq): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadaptertest_upload_request_iter","text":"Show source in test_adapter.py:494 Test an upload request with an iterable.","title":"TestAdapter().test_upload_request_iter"},{"location":"pypowervm/tests/test_adapter/#signature_22","text":"@mock.patch(\"requests.sessions.Session.request\") def test_upload_request_iter(self, mock_rq): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadapterclasses","text":"Show source in test_adapter.py:908","title":"TestAdapterClasses"},{"location":"pypowervm/tests/test_adapter/#signature_23","text":"class TestAdapterClasses(subunit.IsolatedTestCase, testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadapterclassessetup","text":"Show source in test_adapter.py:909","title":"TestAdapterClasses().setUp"},{"location":"pypowervm/tests/test_adapter/#signature_24","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadapterclassestest_instantiation","text":"Show source in test_adapter.py:920 Direct instantiation of EventListener is not allowed.","title":"TestAdapterClasses().test_instantiation"},{"location":"pypowervm/tests/test_adapter/#signature_25","text":"def test_instantiation(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadapterclassestest_shutdown_adapter","text":"Show source in test_adapter.py:957","title":"TestAdapterClasses().test_shutdown_adapter"},{"location":"pypowervm/tests/test_adapter/#signature_26","text":"def test_shutdown_adapter(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testadapterclassestest_shutdown_session","text":"Show source in test_adapter.py:932","title":"TestAdapterClasses().test_shutdown_session"},{"location":"pypowervm/tests/test_adapter/#signature_27","text":"def test_shutdown_session(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelement","text":"Show source in test_adapter.py:864","title":"TestElement"},{"location":"pypowervm/tests/test_adapter/#signature_28","text":"class TestElement(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementsetup","text":"Show source in test_adapter.py:865","title":"TestElement().setUp"},{"location":"pypowervm/tests/test_adapter/#signature_29","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementtest_cdata","text":"Show source in test_adapter.py:869","title":"TestElement().test_cdata"},{"location":"pypowervm/tests/test_adapter/#signature_30","text":"def test_cdata(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementtest_tag_namespace","text":"Show source in test_adapter.py:881","title":"TestElement().test_tag_namespace"},{"location":"pypowervm/tests/test_adapter/#signature_31","text":"def test_tag_namespace(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinject","text":"Show source in test_adapter.py:976","title":"TestElementInject"},{"location":"pypowervm/tests/test_adapter/#signature_32","text":"class TestElementInject(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjectassert_expected_children","text":"Show source in test_adapter.py:1002 Assert that *children are the children of parent, in that order.","title":"TestElementInject().assert_expected_children"},{"location":"pypowervm/tests/test_adapter/#arguments","text":"parent - Parent adapter.Element children - Child adapter.Elements","title":"Arguments"},{"location":"pypowervm/tests/test_adapter/#signature_33","text":"def assert_expected_children(self, parent, *expected_children): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjectsetup","text":"Show source in test_adapter.py:978","title":"TestElementInject().setUp"},{"location":"pypowervm/tests/test_adapter/#signature_34","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_first_populated","text":"Show source in test_adapter.py:1068 Inject the first child when children are otherwise populated.","title":"TestElementInject().test_first_populated"},{"location":"pypowervm/tests/test_adapter/#signature_35","text":"def test_first_populated(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_first_sparse","text":"Show source in test_adapter.py:1075 Inject the first child when children are sparsely populated.","title":"TestElementInject().test_first_sparse"},{"location":"pypowervm/tests/test_adapter/#signature_36","text":"def test_first_sparse(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_last_populated","text":"Show source in test_adapter.py:1083 Inject the last child when children are otherwise populated.","title":"TestElementInject().test_last_populated"},{"location":"pypowervm/tests/test_adapter/#signature_37","text":"def test_last_populated(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_last_sparse","text":"Show source in test_adapter.py:1090 Inject the last child when children are sparsely populated.","title":"TestElementInject().test_last_sparse"},{"location":"pypowervm/tests/test_adapter/#signature_38","text":"def test_last_sparse(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_middle_populated","text":"Show source in test_adapter.py:1098 Inject a middle child when children are otherwise populated.","title":"TestElementInject().test_middle_populated"},{"location":"pypowervm/tests/test_adapter/#signature_39","text":"def test_middle_populated(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_middle_sparse","text":"Show source in test_adapter.py:1105 Inject a middle child when children are sparsely populated.","title":"TestElementInject().test_middle_sparse"},{"location":"pypowervm/tests/test_adapter/#signature_40","text":"def test_middle_sparse(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_no_children","text":"Show source in test_adapter.py:1014 Inject when the element has no children - should \"append\".","title":"TestElementInject().test_no_children"},{"location":"pypowervm/tests/test_adapter/#signature_41","text":"def test_no_children(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_subelement_found_mult_replace_true","text":"Show source in test_adapter.py:1036 Replace existing child with same tag when >1 such children. Should replace the last such child.","title":"TestElementInject().test_subelement_found_mult_replace_true"},{"location":"pypowervm/tests/test_adapter/#signature_42","text":"def test_subelement_found_mult_replace_true(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_subelement_found_one_replace_true","text":"Show source in test_adapter.py:1024 Replace existing child with same tag.","title":"TestElementInject().test_subelement_found_one_replace_true"},{"location":"pypowervm/tests/test_adapter/#signature_43","text":"def test_subelement_found_one_replace_true(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_subelement_found_replace_false","text":"Show source in test_adapter.py:1048 Inject after existing child(ren) with same tag.","title":"TestElementInject().test_subelement_found_replace_false"},{"location":"pypowervm/tests/test_adapter/#signature_44","text":"def test_subelement_found_replace_false(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementinjecttest_subelement_not_in_ordering_list","text":"Show source in test_adapter.py:1060 Subelement not in ordering list - should append.","title":"TestElementInject().test_subelement_not_in_ordering_list"},{"location":"pypowervm/tests/test_adapter/#signature_45","text":"def test_subelement_not_in_ordering_list(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementwrapper","text":"Show source in test_adapter.py:1113 Tests for the ElementWrapper class.","title":"TestElementWrapper"},{"location":"pypowervm/tests/test_adapter/#signature_46","text":"class TestElementWrapper(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementwrappersetup","text":"Show source in test_adapter.py:1116","title":"TestElementWrapper().setUp"},{"location":"pypowervm/tests/test_adapter/#signature_47","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementwrappertest_equality","text":"Show source in test_adapter.py:1123 Validates that two elements loaded from the same data is equal.","title":"TestElementWrapper().test_equality"},{"location":"pypowervm/tests/test_adapter/#signature_48","text":"def test_equality(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_adapter/#testelementwrappertest_inequality_by_subelem_change","text":"Show source in test_adapter.py:1133","title":"TestElementWrapper().test_inequality_by_subelem_change"},{"location":"pypowervm/tests/test_adapter/#signature_49","text":"def test_inequality_by_subelem_change(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_exceptions/","text":"TestExceptions Pypowervm Index / Pypowervm / Tests / TestExceptions Auto-generated documentation for pypowervm.tests.test_exceptions module. TestExceptions TestExceptions TestExceptions().fmt_helper TestExceptions().raise_helper TestExceptions().test_Error TestExceptions().test_bogusformatparams TestExceptions().test_fmterrors TestExceptions Show source in test_exceptions.py:66 Test coverage for the pypowervm.exceptions module. Signature class TestExceptions(unittest.TestCase): ... TestExceptions().fmt_helper Show source in test_exceptions.py:72 Signature def fmt_helper(self, eclass, expected_message): ... TestExceptions().raise_helper Show source in test_exceptions.py:69 Signature def raise_helper(self, e): ... TestExceptions().test_Error Show source in test_exceptions.py:80 Signature def test_Error(self): ... TestExceptions().test_bogusformatparams Show source in test_exceptions.py:95 Signature def test_bogusformatparams(self): ... TestExceptions().test_fmterrors Show source in test_exceptions.py:88 Signature def test_fmterrors(self): ...","title":"TestExceptions"},{"location":"pypowervm/tests/test_exceptions/#testexceptions","text":"Pypowervm Index / Pypowervm / Tests / TestExceptions Auto-generated documentation for pypowervm.tests.test_exceptions module. TestExceptions TestExceptions TestExceptions().fmt_helper TestExceptions().raise_helper TestExceptions().test_Error TestExceptions().test_bogusformatparams TestExceptions().test_fmterrors","title":"TestExceptions"},{"location":"pypowervm/tests/test_exceptions/#testexceptions_1","text":"Show source in test_exceptions.py:66 Test coverage for the pypowervm.exceptions module.","title":"TestExceptions"},{"location":"pypowervm/tests/test_exceptions/#signature","text":"class TestExceptions(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_exceptions/#testexceptionsfmt_helper","text":"Show source in test_exceptions.py:72","title":"TestExceptions().fmt_helper"},{"location":"pypowervm/tests/test_exceptions/#signature_1","text":"def fmt_helper(self, eclass, expected_message): ...","title":"Signature"},{"location":"pypowervm/tests/test_exceptions/#testexceptionsraise_helper","text":"Show source in test_exceptions.py:69","title":"TestExceptions().raise_helper"},{"location":"pypowervm/tests/test_exceptions/#signature_2","text":"def raise_helper(self, e): ...","title":"Signature"},{"location":"pypowervm/tests/test_exceptions/#testexceptionstest_error","text":"Show source in test_exceptions.py:80","title":"TestExceptions().test_Error"},{"location":"pypowervm/tests/test_exceptions/#signature_3","text":"def test_Error(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_exceptions/#testexceptionstest_bogusformatparams","text":"Show source in test_exceptions.py:95","title":"TestExceptions().test_bogusformatparams"},{"location":"pypowervm/tests/test_exceptions/#signature_4","text":"def test_bogusformatparams(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_exceptions/#testexceptionstest_fmterrors","text":"Show source in test_exceptions.py:88","title":"TestExceptions().test_fmterrors"},{"location":"pypowervm/tests/test_exceptions/#signature_5","text":"def test_fmterrors(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/","text":"Test Fixtures Pypowervm Index / Pypowervm / Tests / Test Fixtures Auto-generated documentation for pypowervm.tests.test_fixtures module. Attributes SEM_ENTER - Thread locking primitives are located slightly differently in py2 vs py3: 'threading.%sSemaphore.__enter__' % '_' if six.PY2 else '' Test Fixtures AdapterFx AdapterFx().setUp AdapterFx().set_traits FeedTaskFx Init the fixture, but do not start it: An existing patcher can be modified: Or deleted: [New patchers can be added. They must be instances of SimplePatcher (or a](#new-patchers-can-be-added--they-must-be-instances-of-simplepatcher-(or-a) subclass). Add directly to 'patchers': --add-directly-to-'patchers':) ...or use add_patchers to add more than one: Finally, don't forget to start the fixture Mocks can be accessed via their patchers and queried during testing as usual: Logger Logger().get_log Logger().log Logger().reset_log LoggingFx LoggingPatcher SessionFx SessionFx().setUp SimplePatcher SimplePatcher().start SimplePatchingFx SimplePatchingFx().add_patchers SimplePatchingFx().setUp SleepFx SleepPatcher WrapperTaskFx Init the fixture, but do not start it: An existing patcher can be modified: Or deleted: [New patchers can be added. They must be instances of SimplePatcher (or a](#new-patchers-can-be-added--they-must-be-instances-of-simplepatcher-(or-a-1) subclass). Add directly to 'patchers': --add-directly-to-'patchers':-1) ...or use add_patchers to add more than one: Finally, don't forget to start the fixture Mocks can be accessed via their patchers and queried during testing as usual: AdapterFx Show source in test_fixtures.py:80 Patch pypowervm.adapter.Adapter. Signature class AdapterFx(fixtures.Fixture): def __init__(self, session=None, traits=None): ... AdapterFx().setUp Show source in test_fixtures.py:107 Signature def setUp(self): ... AdapterFx().set_traits Show source in test_fixtures.py:117 Signature def set_traits(self, traits): ... FeedTaskFx Show source in test_fixtures.py:373 Customizable mocking and pseudo-logging for FeedTask primitives. Provides LoggingPatchers for REST and locking primitives. By default, these patchers simply log their name and return a sensible value (see below). However, patchers can be added, changed, or removed by name from the fixture instance via its 'patchers' dict. In order to have effect on your test case, such modifications must be done between fixture initialization and useFixture. For example: Init the fixture, but do not start it: ftfx = FeedTaskFx(a_feed) An existing patcher can be modified: upd = ftfx.patchers['update'].side_effect = SomeException() Or deleted: del ftfx.patchers['refresh'] New patchers can be added. They must be instances of SimplePatcher (or a subclass). Add directly to 'patchers': ftfx.patchers['foo'] = LoggingPatcher(ftfx, 'frob', 'pypowervm.utils.frob') ...or use add_patchers to add more than one: ftfx.add_patchers(p1, p2, p3) Finally, don't forget to start the fixture self.useFixture(ftfx) Mocks can be accessed via their patchers and queried during testing as usual: ftfx.patchers['foo'].mock.assert_called_with('bar', 'baz') self.assertEqual(3, ftfx.patchers['update'].mock.call_count) See live examples in pypowervm.tests.utils.test_transaction.TestWrapperTask Default mocks: 'get': Mocks FeedGetter.get. Logs 'get'. Returns the feed with which the fixture was initialized. 'refresh': Mocks EntryWrapper.refresh. Logs 'refresh'. Returns the wrapper on which the refresh method was called. 'update': Mocks EntryWrapper.update. Logs 'update'. Returns the wrapper on which the update method was called. 'lock', 'unlock': Mocks semaphore locking (oslo_concurrency.lockutils.lock and @synchronized, ultimately threading.Semaphore) performed by the @entry_transaction decorator. Logs 'lock'/'unlock', respectively. Returns None. Signature class FeedTaskFx(SimplePatchingFx, Logger): def __init__(self, feed): ... See also Logger SimplePatchingFx Logger Show source in test_fixtures.py:219 Base class for mixins wanting simple 'log to a list' semantics. Signature class Logger(object): def __init__(self): ... Logger().get_log Show source in test_fixtures.py:226 Retrieve the event log. Returns The log, a list of strings in the order they were added. Signature def get_log(self): ... Logger().log Show source in test_fixtures.py:233 Add a message to the log. Arguments val - String value to append to the log. Signature def log(self, val): ... Logger().reset_log Show source in test_fixtures.py:240 Clear the log. Signature def reset_log(self): ... LoggingFx Show source in test_fixtures.py:450 Fixture for LOG.*, not to be confused with Logger/LoggingPatcher. Provides patches and mocks for LOG.x for x in ('info', 'warning', 'debug', 'error', 'exception') Signature class LoggingFx(SimplePatchingFx): def __init__(self): ... See also SimplePatchingFx LoggingPatcher Show source in test_fixtures.py:187 SimplePatcher whose mock logs its name and returns a value. Signature class LoggingPatcher(SimplePatcher): def __init__(self, fx, name, path, patch_object=False, return_value=None): ... See also SimplePatcher SessionFx Show source in test_fixtures.py:56 Patch pypowervm.adapter.Session. Signature class SessionFx(fixtures.Fixture): def __init__(self, traits=LocalPVMTraits): ... See also LocalPVMTraits SessionFx().setUp Show source in test_fixtures.py:72 Signature def setUp(self): ... SimplePatcher Show source in test_fixtures.py:123 Provide a basic mocking patcher on a test fixture. The main purpose of this class is to be used with SimplePatchingFx. That said, the following are equivalent: @mock.patch('path.to.method') def test_foo(self, mock_meth): mock_meth.return_value = 'abc' # ... def test_foo(self): mock_meth = SimplePatcher(self, 'whatever', 'path.to.method', return_value='abc').start() # ... Signature class SimplePatcher(object): def __init__( self, fx, name, path, patch_object=False, side_effect=None, return_value=None ): ... SimplePatcher().start Show source in test_fixtures.py:176 Start the patcher, creating the and setting up the mock. Signature def start(self): ... SimplePatchingFx Show source in test_fixtures.py:246 Fixture base class supporting SimplePatcher. Subclasses should invoke add_patchers from init after super(). init , but before useFixture. Signature class SimplePatchingFx(fixtures.Fixture): def __init__(self): ... SimplePatchingFx().add_patchers Show source in test_fixtures.py:257 Add some number of SimplePatcher instances to the fixture. Arguments patchers - Zero or more SimplePatcher instances to add. Signature def add_patchers(self, *patchers): ... SimplePatchingFx().setUp Show source in test_fixtures.py:265 Start the fixture and its member SimplePatchers. This is generally invoked via useFixture and should not be called directly. Signature def setUp(self): ... SleepFx Show source in test_fixtures.py:282 Fixture for time.sleep. Signature class SleepFx(SimplePatchingFx): def __init__(self, side_effect=None): ... See also SimplePatchingFx SleepPatcher Show source in test_fixtures.py:276 Signature class SleepPatcher(SimplePatcher): def __init__(self, fx, side_effect=None): ... See also SimplePatcher WrapperTaskFx Show source in test_fixtures.py:295 Customizable mocking and pseudo-logging for WrapperTask primitives. Provides LoggingPatchers for REST and locking primitives. By default, these patchers simply log their name and return a sensible value (see below). However, patchers can be added, changed, or removed by name from the fixture instance via its 'patchers' dict. In order to have effect on your test case, such modifications must be done between fixture initialization and useFixture. For example: Init the fixture, but do not start it: wtfx = WrapperTaskFx(a_wrapper) An existing patcher can be modified: upd = wtfx.patchers['update'].side_effect = SomeException() Or deleted: del wtfx.patchers['refresh'] New patchers can be added. They must be instances of SimplePatcher (or a subclass). Add directly to 'patchers': wtfx.patchers['foo'] = LoggingPatcher(wtfx, 'frob', 'pypowervm.utils.frob') ...or use add_patchers to add more than one: wtfx.add_patchers(p1, p2, p3) Finally, don't forget to start the fixture self.useFixture(wtfx) Mocks can be accessed via their patchers and queried during testing as usual: wtfx.patchers['foo'].mock.assert_called_with('bar', 'baz') self.assertEqual(3, wtfx.patchers['update'].mock.call_count) See live examples in pypowervm.tests.utils.test_transaction.TestWrapperTask Default mocks: 'get': Mocks EntyrWrapperGetter.get. Logs 'get'. Returns the wrapper with which the fixture was initialized. 'refresh': Mocks EntryWrapper.refresh. Logs 'refresh'. Returns the wrapper with which the fixture was initialized. 'update': Mocks EntryWrapper.update. Logs 'update'. Returns the wrapper with which the fixture was initialized. 'lock', 'unlock': Mocks semaphore locking (oslo_concurrency.lockutils.lock and @synchronized, ultimately threading.Semaphore) performed by the @entry_transaction decorator. Logs 'lock'/'unlock', respectively. Returns None. Signature class WrapperTaskFx(SimplePatchingFx, Logger): def __init__(self, wrapper): ... See also Logger SimplePatchingFx","title":"Test Fixtures"},{"location":"pypowervm/tests/test_fixtures/#test-fixtures","text":"Pypowervm Index / Pypowervm / Tests / Test Fixtures Auto-generated documentation for pypowervm.tests.test_fixtures module.","title":"Test Fixtures"},{"location":"pypowervm/tests/test_fixtures/#attributes","text":"SEM_ENTER - Thread locking primitives are located slightly differently in py2 vs py3: 'threading.%sSemaphore.__enter__' % '_' if six.PY2 else '' Test Fixtures AdapterFx AdapterFx().setUp AdapterFx().set_traits FeedTaskFx Init the fixture, but do not start it: An existing patcher can be modified: Or deleted: [New patchers can be added. They must be instances of SimplePatcher (or a](#new-patchers-can-be-added--they-must-be-instances-of-simplepatcher-(or-a) subclass). Add directly to 'patchers': --add-directly-to-'patchers':) ...or use add_patchers to add more than one: Finally, don't forget to start the fixture Mocks can be accessed via their patchers and queried during testing as usual: Logger Logger().get_log Logger().log Logger().reset_log LoggingFx LoggingPatcher SessionFx SessionFx().setUp SimplePatcher SimplePatcher().start SimplePatchingFx SimplePatchingFx().add_patchers SimplePatchingFx().setUp SleepFx SleepPatcher WrapperTaskFx Init the fixture, but do not start it: An existing patcher can be modified: Or deleted: [New patchers can be added. They must be instances of SimplePatcher (or a](#new-patchers-can-be-added--they-must-be-instances-of-simplepatcher-(or-a-1) subclass). Add directly to 'patchers': --add-directly-to-'patchers':-1) ...or use add_patchers to add more than one: Finally, don't forget to start the fixture Mocks can be accessed via their patchers and queried during testing as usual:","title":"Attributes"},{"location":"pypowervm/tests/test_fixtures/#adapterfx","text":"Show source in test_fixtures.py:80 Patch pypowervm.adapter.Adapter.","title":"AdapterFx"},{"location":"pypowervm/tests/test_fixtures/#signature","text":"class AdapterFx(fixtures.Fixture): def __init__(self, session=None, traits=None): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#adapterfxsetup","text":"Show source in test_fixtures.py:107","title":"AdapterFx().setUp"},{"location":"pypowervm/tests/test_fixtures/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#adapterfxset_traits","text":"Show source in test_fixtures.py:117","title":"AdapterFx().set_traits"},{"location":"pypowervm/tests/test_fixtures/#signature_2","text":"def set_traits(self, traits): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#feedtaskfx","text":"Show source in test_fixtures.py:373 Customizable mocking and pseudo-logging for FeedTask primitives. Provides LoggingPatchers for REST and locking primitives. By default, these patchers simply log their name and return a sensible value (see below). However, patchers can be added, changed, or removed by name from the fixture instance via its 'patchers' dict. In order to have effect on your test case, such modifications must be done between fixture initialization and useFixture. For example:","title":"FeedTaskFx"},{"location":"pypowervm/tests/test_fixtures/#init-the-fixture-but-do-not-start-it","text":"ftfx = FeedTaskFx(a_feed)","title":"Init the fixture, but do not start it:"},{"location":"pypowervm/tests/test_fixtures/#an-existing-patcher-can-be-modified","text":"upd = ftfx.patchers['update'].side_effect = SomeException()","title":"An existing patcher can be modified:"},{"location":"pypowervm/tests/test_fixtures/#or-deleted","text":"del ftfx.patchers['refresh']","title":"Or deleted:"},{"location":"pypowervm/tests/test_fixtures/#new-patchers-can-be-added-they-must-be-instances-of-simplepatcher-or-a","text":"","title":"New patchers can be added.  They must be instances of SimplePatcher (or a"},{"location":"pypowervm/tests/test_fixtures/#subclass-add-directly-to-patchers","text":"ftfx.patchers['foo'] = LoggingPatcher(ftfx, 'frob', 'pypowervm.utils.frob')","title":"subclass).  Add directly to 'patchers':"},{"location":"pypowervm/tests/test_fixtures/#or-use-add_patchers-to-add-more-than-one","text":"ftfx.add_patchers(p1, p2, p3)","title":"...or use add_patchers to add more than one:"},{"location":"pypowervm/tests/test_fixtures/#finally-dont-forget-to-start-the-fixture","text":"self.useFixture(ftfx)","title":"Finally, don't forget to start the fixture"},{"location":"pypowervm/tests/test_fixtures/#mocks-can-be-accessed-via-their-patchers-and-queried-during-testing-as","text":"","title":"Mocks can be accessed via their patchers and queried during testing as"},{"location":"pypowervm/tests/test_fixtures/#usual","text":"ftfx.patchers['foo'].mock.assert_called_with('bar', 'baz') self.assertEqual(3, ftfx.patchers['update'].mock.call_count) See live examples in pypowervm.tests.utils.test_transaction.TestWrapperTask Default mocks: 'get': Mocks FeedGetter.get. Logs 'get'. Returns the feed with which the fixture was initialized. 'refresh': Mocks EntryWrapper.refresh. Logs 'refresh'. Returns the wrapper on which the refresh method was called. 'update': Mocks EntryWrapper.update. Logs 'update'. Returns the wrapper on which the update method was called. 'lock', 'unlock': Mocks semaphore locking (oslo_concurrency.lockutils.lock and @synchronized, ultimately threading.Semaphore) performed by the @entry_transaction decorator. Logs 'lock'/'unlock', respectively. Returns None.","title":"usual:"},{"location":"pypowervm/tests/test_fixtures/#signature_3","text":"class FeedTaskFx(SimplePatchingFx, Logger): def __init__(self, feed): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#see-also","text":"Logger SimplePatchingFx","title":"See also"},{"location":"pypowervm/tests/test_fixtures/#logger","text":"Show source in test_fixtures.py:219 Base class for mixins wanting simple 'log to a list' semantics.","title":"Logger"},{"location":"pypowervm/tests/test_fixtures/#signature_4","text":"class Logger(object): def __init__(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#loggerget_log","text":"Show source in test_fixtures.py:226 Retrieve the event log.","title":"Logger().get_log"},{"location":"pypowervm/tests/test_fixtures/#returns","text":"The log, a list of strings in the order they were added.","title":"Returns"},{"location":"pypowervm/tests/test_fixtures/#signature_5","text":"def get_log(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#loggerlog","text":"Show source in test_fixtures.py:233 Add a message to the log.","title":"Logger().log"},{"location":"pypowervm/tests/test_fixtures/#arguments","text":"val - String value to append to the log.","title":"Arguments"},{"location":"pypowervm/tests/test_fixtures/#signature_6","text":"def log(self, val): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#loggerreset_log","text":"Show source in test_fixtures.py:240 Clear the log.","title":"Logger().reset_log"},{"location":"pypowervm/tests/test_fixtures/#signature_7","text":"def reset_log(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#loggingfx","text":"Show source in test_fixtures.py:450 Fixture for LOG.*, not to be confused with Logger/LoggingPatcher. Provides patches and mocks for LOG.x for x in ('info', 'warning', 'debug', 'error', 'exception')","title":"LoggingFx"},{"location":"pypowervm/tests/test_fixtures/#signature_8","text":"class LoggingFx(SimplePatchingFx): def __init__(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#see-also_1","text":"SimplePatchingFx","title":"See also"},{"location":"pypowervm/tests/test_fixtures/#loggingpatcher","text":"Show source in test_fixtures.py:187 SimplePatcher whose mock logs its name and returns a value.","title":"LoggingPatcher"},{"location":"pypowervm/tests/test_fixtures/#signature_9","text":"class LoggingPatcher(SimplePatcher): def __init__(self, fx, name, path, patch_object=False, return_value=None): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#see-also_2","text":"SimplePatcher","title":"See also"},{"location":"pypowervm/tests/test_fixtures/#sessionfx","text":"Show source in test_fixtures.py:56 Patch pypowervm.adapter.Session.","title":"SessionFx"},{"location":"pypowervm/tests/test_fixtures/#signature_10","text":"class SessionFx(fixtures.Fixture): def __init__(self, traits=LocalPVMTraits): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#see-also_3","text":"LocalPVMTraits","title":"See also"},{"location":"pypowervm/tests/test_fixtures/#sessionfxsetup","text":"Show source in test_fixtures.py:72","title":"SessionFx().setUp"},{"location":"pypowervm/tests/test_fixtures/#signature_11","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#simplepatcher","text":"Show source in test_fixtures.py:123 Provide a basic mocking patcher on a test fixture. The main purpose of this class is to be used with SimplePatchingFx. That said, the following are equivalent: @mock.patch('path.to.method') def test_foo(self, mock_meth): mock_meth.return_value = 'abc' # ... def test_foo(self): mock_meth = SimplePatcher(self, 'whatever', 'path.to.method', return_value='abc').start() # ...","title":"SimplePatcher"},{"location":"pypowervm/tests/test_fixtures/#signature_12","text":"class SimplePatcher(object): def __init__( self, fx, name, path, patch_object=False, side_effect=None, return_value=None ): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#simplepatcherstart","text":"Show source in test_fixtures.py:176 Start the patcher, creating the and setting up the mock.","title":"SimplePatcher().start"},{"location":"pypowervm/tests/test_fixtures/#signature_13","text":"def start(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#simplepatchingfx","text":"Show source in test_fixtures.py:246 Fixture base class supporting SimplePatcher. Subclasses should invoke add_patchers from init after super(). init , but before useFixture.","title":"SimplePatchingFx"},{"location":"pypowervm/tests/test_fixtures/#signature_14","text":"class SimplePatchingFx(fixtures.Fixture): def __init__(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#simplepatchingfxadd_patchers","text":"Show source in test_fixtures.py:257 Add some number of SimplePatcher instances to the fixture.","title":"SimplePatchingFx().add_patchers"},{"location":"pypowervm/tests/test_fixtures/#arguments_1","text":"patchers - Zero or more SimplePatcher instances to add.","title":"Arguments"},{"location":"pypowervm/tests/test_fixtures/#signature_15","text":"def add_patchers(self, *patchers): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#simplepatchingfxsetup","text":"Show source in test_fixtures.py:265 Start the fixture and its member SimplePatchers. This is generally invoked via useFixture and should not be called directly.","title":"SimplePatchingFx().setUp"},{"location":"pypowervm/tests/test_fixtures/#signature_16","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#sleepfx","text":"Show source in test_fixtures.py:282 Fixture for time.sleep.","title":"SleepFx"},{"location":"pypowervm/tests/test_fixtures/#signature_17","text":"class SleepFx(SimplePatchingFx): def __init__(self, side_effect=None): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#see-also_4","text":"SimplePatchingFx","title":"See also"},{"location":"pypowervm/tests/test_fixtures/#sleeppatcher","text":"Show source in test_fixtures.py:276","title":"SleepPatcher"},{"location":"pypowervm/tests/test_fixtures/#signature_18","text":"class SleepPatcher(SimplePatcher): def __init__(self, fx, side_effect=None): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#see-also_5","text":"SimplePatcher","title":"See also"},{"location":"pypowervm/tests/test_fixtures/#wrappertaskfx","text":"Show source in test_fixtures.py:295 Customizable mocking and pseudo-logging for WrapperTask primitives. Provides LoggingPatchers for REST and locking primitives. By default, these patchers simply log their name and return a sensible value (see below). However, patchers can be added, changed, or removed by name from the fixture instance via its 'patchers' dict. In order to have effect on your test case, such modifications must be done between fixture initialization and useFixture. For example:","title":"WrapperTaskFx"},{"location":"pypowervm/tests/test_fixtures/#init-the-fixture-but-do-not-start-it_1","text":"wtfx = WrapperTaskFx(a_wrapper)","title":"Init the fixture, but do not start it:"},{"location":"pypowervm/tests/test_fixtures/#an-existing-patcher-can-be-modified_1","text":"upd = wtfx.patchers['update'].side_effect = SomeException()","title":"An existing patcher can be modified:"},{"location":"pypowervm/tests/test_fixtures/#or-deleted_1","text":"del wtfx.patchers['refresh']","title":"Or deleted:"},{"location":"pypowervm/tests/test_fixtures/#new-patchers-can-be-added-they-must-be-instances-of-simplepatcher-or-a_1","text":"","title":"New patchers can be added.  They must be instances of SimplePatcher (or a"},{"location":"pypowervm/tests/test_fixtures/#subclass-add-directly-to-patchers_1","text":"wtfx.patchers['foo'] = LoggingPatcher(wtfx, 'frob', 'pypowervm.utils.frob')","title":"subclass).  Add directly to 'patchers':"},{"location":"pypowervm/tests/test_fixtures/#or-use-add_patchers-to-add-more-than-one_1","text":"wtfx.add_patchers(p1, p2, p3)","title":"...or use add_patchers to add more than one:"},{"location":"pypowervm/tests/test_fixtures/#finally-dont-forget-to-start-the-fixture_1","text":"self.useFixture(wtfx)","title":"Finally, don't forget to start the fixture"},{"location":"pypowervm/tests/test_fixtures/#mocks-can-be-accessed-via-their-patchers-and-queried-during-testing-as_1","text":"","title":"Mocks can be accessed via their patchers and queried during testing as"},{"location":"pypowervm/tests/test_fixtures/#usual_1","text":"wtfx.patchers['foo'].mock.assert_called_with('bar', 'baz') self.assertEqual(3, wtfx.patchers['update'].mock.call_count) See live examples in pypowervm.tests.utils.test_transaction.TestWrapperTask Default mocks: 'get': Mocks EntyrWrapperGetter.get. Logs 'get'. Returns the wrapper with which the fixture was initialized. 'refresh': Mocks EntryWrapper.refresh. Logs 'refresh'. Returns the wrapper with which the fixture was initialized. 'update': Mocks EntryWrapper.update. Logs 'update'. Returns the wrapper with which the fixture was initialized. 'lock', 'unlock': Mocks semaphore locking (oslo_concurrency.lockutils.lock and @synchronized, ultimately threading.Semaphore) performed by the @entry_transaction decorator. Logs 'lock'/'unlock', respectively. Returns None.","title":"usual:"},{"location":"pypowervm/tests/test_fixtures/#signature_19","text":"class WrapperTaskFx(SimplePatchingFx, Logger): def __init__(self, wrapper): ...","title":"Signature"},{"location":"pypowervm/tests/test_fixtures/#see-also_6","text":"Logger SimplePatchingFx","title":"See also"},{"location":"pypowervm/tests/test_helpers/","text":"TestHelpers Pypowervm Index / Pypowervm / Tests / TestHelpers Auto-generated documentation for pypowervm.tests.test_helpers module. TestHelpers TestHelpers TestHelpers().test_invalid_helper TestHelpers().test_multi_list TestHelpers().test_no_helpers TestHelpers().test_none TestHelpers().test_runs TestHelpers().test_single TestHelpers().test_single_list cat_string_helper TestHelpers Show source in test_helpers.py:31 Signature class TestHelpers(unittest.TestCase): ... TestHelpers().test_invalid_helper Show source in test_helpers.py:86 Signature @mock.patch(\"pypowervm.adapter.Session\") def test_invalid_helper(self, mock_sess): ... TestHelpers().test_multi_list Show source in test_helpers.py:49 Signature def test_multi_list(self): ... TestHelpers().test_no_helpers Show source in test_helpers.py:56 Signature @mock.patch(\"pypowervm.adapter.Session\") def test_no_helpers(self, mock_sess): ... TestHelpers().test_none Show source in test_helpers.py:32 Signature def test_none(self): ... TestHelpers().test_runs Show source in test_helpers.py:64 Signature @mock.patch(\"pypowervm.adapter.Session\") def test_runs(self, mock_sess): ... TestHelpers().test_single Show source in test_helpers.py:36 Signature def test_single(self): ... TestHelpers().test_single_list Show source in test_helpers.py:41 Signature def test_single_list(self): ... cat_string_helper Show source in test_helpers.py:25 Signature def cat_string_helper(func, string): ...","title":"TestHelpers"},{"location":"pypowervm/tests/test_helpers/#testhelpers","text":"Pypowervm Index / Pypowervm / Tests / TestHelpers Auto-generated documentation for pypowervm.tests.test_helpers module. TestHelpers TestHelpers TestHelpers().test_invalid_helper TestHelpers().test_multi_list TestHelpers().test_no_helpers TestHelpers().test_none TestHelpers().test_runs TestHelpers().test_single TestHelpers().test_single_list cat_string_helper","title":"TestHelpers"},{"location":"pypowervm/tests/test_helpers/#testhelpers_1","text":"Show source in test_helpers.py:31","title":"TestHelpers"},{"location":"pypowervm/tests/test_helpers/#signature","text":"class TestHelpers(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_helpers/#testhelperstest_invalid_helper","text":"Show source in test_helpers.py:86","title":"TestHelpers().test_invalid_helper"},{"location":"pypowervm/tests/test_helpers/#signature_1","text":"@mock.patch(\"pypowervm.adapter.Session\") def test_invalid_helper(self, mock_sess): ...","title":"Signature"},{"location":"pypowervm/tests/test_helpers/#testhelperstest_multi_list","text":"Show source in test_helpers.py:49","title":"TestHelpers().test_multi_list"},{"location":"pypowervm/tests/test_helpers/#signature_2","text":"def test_multi_list(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_helpers/#testhelperstest_no_helpers","text":"Show source in test_helpers.py:56","title":"TestHelpers().test_no_helpers"},{"location":"pypowervm/tests/test_helpers/#signature_3","text":"@mock.patch(\"pypowervm.adapter.Session\") def test_no_helpers(self, mock_sess): ...","title":"Signature"},{"location":"pypowervm/tests/test_helpers/#testhelperstest_none","text":"Show source in test_helpers.py:32","title":"TestHelpers().test_none"},{"location":"pypowervm/tests/test_helpers/#signature_4","text":"def test_none(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_helpers/#testhelperstest_runs","text":"Show source in test_helpers.py:64","title":"TestHelpers().test_runs"},{"location":"pypowervm/tests/test_helpers/#signature_5","text":"@mock.patch(\"pypowervm.adapter.Session\") def test_runs(self, mock_sess): ...","title":"Signature"},{"location":"pypowervm/tests/test_helpers/#testhelperstest_single","text":"Show source in test_helpers.py:36","title":"TestHelpers().test_single"},{"location":"pypowervm/tests/test_helpers/#signature_6","text":"def test_single(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_helpers/#testhelperstest_single_list","text":"Show source in test_helpers.py:41","title":"TestHelpers().test_single_list"},{"location":"pypowervm/tests/test_helpers/#signature_7","text":"def test_single_list(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_helpers/#cat_string_helper","text":"Show source in test_helpers.py:25","title":"cat_string_helper"},{"location":"pypowervm/tests/test_helpers/#signature_8","text":"def cat_string_helper(func, string): ...","title":"Signature"},{"location":"pypowervm/tests/test_i18n/","text":"Test I18n Pypowervm Index / Pypowervm / Tests / Test I18n Auto-generated documentation for pypowervm.tests.test_i18n module. Test I18n TranslationTests TranslationTests().test_translate TranslationTests Show source in test_i18n.py:24 Test internationalization library. Signature class TranslationTests(unittest.TestCase): ... TranslationTests().test_translate Show source in test_i18n.py:27 Signature @mock.patch.dict( os.environ, { \"PYPOWERVM_LOCALEDIR\": os.path.join( os.path.dirname(os.path.realpath(__file__)), \"locale\" ), \"LANG\": \"en_US\", }, ) def test_translate(self): ...","title":"Test I18n"},{"location":"pypowervm/tests/test_i18n/#test-i18n","text":"Pypowervm Index / Pypowervm / Tests / Test I18n Auto-generated documentation for pypowervm.tests.test_i18n module. Test I18n TranslationTests TranslationTests().test_translate","title":"Test I18n"},{"location":"pypowervm/tests/test_i18n/#translationtests","text":"Show source in test_i18n.py:24 Test internationalization library.","title":"TranslationTests"},{"location":"pypowervm/tests/test_i18n/#signature","text":"class TranslationTests(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_i18n/#translationteststest_translate","text":"Show source in test_i18n.py:27","title":"TranslationTests().test_translate"},{"location":"pypowervm/tests/test_i18n/#signature_1","text":"@mock.patch.dict( os.environ, { \"PYPOWERVM_LOCALEDIR\": os.path.join( os.path.dirname(os.path.realpath(__file__)), \"locale\" ), \"LANG\": \"en_US\", }, ) def test_translate(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_session/","text":"TestSession Pypowervm Index / Pypowervm / Tests / TestSession Auto-generated documentation for pypowervm.tests.test_session module. TestSession TestSession TestSession().test_Session TestSession().test_logon TestSession().test_session_clone TestSession().test_session_ext_cfg TestSession().test_session_init TestSession().test_session_init_remote_http TestSession Show source in test_session.py:36 Test cases to test the Session classes and methods. Signature class TestSession(subunit.IsolatedTestCase, testtools.TestCase): ... TestSession().test_Session Show source in test_session.py:39 Ensure Session can be instantiated, and test logon retries. Signature @mock.patch(\"time.sleep\") @mock.patch(\"lxml.etree.fromstring\", new=mock.Mock()) @mock.patch(\"pypowervm.adapter.Session._get_auth_tok_from_file\", new=mock.Mock()) def test_Session(self, mock_sleep): ... TestSession().test_logon Show source in test_session.py:163 Ensure a Session can be created and log on to PowerVM. Signature @mock.patch(\"pypowervm.util.validate_certificate\") @mock.patch(\"requests.Session\") def test_logon(self, mock_session, mock_validate_cert): ... TestSession().test_session_clone Show source in test_session.py:123 Signature @mock.patch.object(adp.Session, \"_logon\") @mock.patch.object(adp.Session, \"_logoff\") def test_session_clone(self, mock_logoff, mock_logon): ... TestSession().test_session_ext_cfg Show source in test_session.py:105 Test Session init with external config from env var. Signature @mock.patch(\"pypowervm.adapter.Session._logon\", new=mock.Mock()) @mock.patch(\"pypowervm.adapter._EventListener._get_events\") @mock.patch(\"imp.load_source\") def test_session_ext_cfg(self, mock_load, mock_get_evts): ... TestSession().test_session_init Show source in test_session.py:65 Ensure proper parameter handling in the Session initializer. Signature @mock.patch(\"pypowervm.adapter.Session._logon\", new=mock.Mock()) @mock.patch(\"pypowervm.adapter._EventListener._get_events\") def test_session_init(self, mock_get_evts): ... TestSession().test_session_init_remote_http Show source in test_session.py:116 Signature @mock.patch(\"pypowervm.adapter.Session._logon\") def test_session_init_remote_http(self, mock_logon): ...","title":"TestSession"},{"location":"pypowervm/tests/test_session/#testsession","text":"Pypowervm Index / Pypowervm / Tests / TestSession Auto-generated documentation for pypowervm.tests.test_session module. TestSession TestSession TestSession().test_Session TestSession().test_logon TestSession().test_session_clone TestSession().test_session_ext_cfg TestSession().test_session_init TestSession().test_session_init_remote_http","title":"TestSession"},{"location":"pypowervm/tests/test_session/#testsession_1","text":"Show source in test_session.py:36 Test cases to test the Session classes and methods.","title":"TestSession"},{"location":"pypowervm/tests/test_session/#signature","text":"class TestSession(subunit.IsolatedTestCase, testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_session/#testsessiontest_session","text":"Show source in test_session.py:39 Ensure Session can be instantiated, and test logon retries.","title":"TestSession().test_Session"},{"location":"pypowervm/tests/test_session/#signature_1","text":"@mock.patch(\"time.sleep\") @mock.patch(\"lxml.etree.fromstring\", new=mock.Mock()) @mock.patch(\"pypowervm.adapter.Session._get_auth_tok_from_file\", new=mock.Mock()) def test_Session(self, mock_sleep): ...","title":"Signature"},{"location":"pypowervm/tests/test_session/#testsessiontest_logon","text":"Show source in test_session.py:163 Ensure a Session can be created and log on to PowerVM.","title":"TestSession().test_logon"},{"location":"pypowervm/tests/test_session/#signature_2","text":"@mock.patch(\"pypowervm.util.validate_certificate\") @mock.patch(\"requests.Session\") def test_logon(self, mock_session, mock_validate_cert): ...","title":"Signature"},{"location":"pypowervm/tests/test_session/#testsessiontest_session_clone","text":"Show source in test_session.py:123","title":"TestSession().test_session_clone"},{"location":"pypowervm/tests/test_session/#signature_3","text":"@mock.patch.object(adp.Session, \"_logon\") @mock.patch.object(adp.Session, \"_logoff\") def test_session_clone(self, mock_logoff, mock_logon): ...","title":"Signature"},{"location":"pypowervm/tests/test_session/#testsessiontest_session_ext_cfg","text":"Show source in test_session.py:105 Test Session init with external config from env var.","title":"TestSession().test_session_ext_cfg"},{"location":"pypowervm/tests/test_session/#signature_4","text":"@mock.patch(\"pypowervm.adapter.Session._logon\", new=mock.Mock()) @mock.patch(\"pypowervm.adapter._EventListener._get_events\") @mock.patch(\"imp.load_source\") def test_session_ext_cfg(self, mock_load, mock_get_evts): ...","title":"Signature"},{"location":"pypowervm/tests/test_session/#testsessiontest_session_init","text":"Show source in test_session.py:65 Ensure proper parameter handling in the Session initializer.","title":"TestSession().test_session_init"},{"location":"pypowervm/tests/test_session/#signature_5","text":"@mock.patch(\"pypowervm.adapter.Session._logon\", new=mock.Mock()) @mock.patch(\"pypowervm.adapter._EventListener._get_events\") def test_session_init(self, mock_get_evts): ...","title":"Signature"},{"location":"pypowervm/tests/test_session/#testsessiontest_session_init_remote_http","text":"Show source in test_session.py:116","title":"TestSession().test_session_init_remote_http"},{"location":"pypowervm/tests/test_session/#signature_6","text":"@mock.patch(\"pypowervm.adapter.Session._logon\") def test_session_init_remote_http(self, mock_logon): ...","title":"Signature"},{"location":"pypowervm/tests/test_traits/","text":"TestTraits Pypowervm Index / Pypowervm / Tests / TestTraits Auto-generated documentation for pypowervm.tests.test_traits module. TestTraits TestTraits TestTraits().test_traits TestTraits().test_traits_into_wrappers TestTraits Show source in test_traits.py:38 Signature class TestTraits(unittest.TestCase): ... TestTraits().test_traits Show source in test_traits.py:40 Signature @mock.patch(\"pypowervm.adapter.Session\") def test_traits(self, mock_sess): ... TestTraits().test_traits_into_wrappers Show source in test_traits.py:81 Signature @mock.patch(\"requests.Session.request\") def test_traits_into_wrappers(self, mock_request): ...","title":"TestTraits"},{"location":"pypowervm/tests/test_traits/#testtraits","text":"Pypowervm Index / Pypowervm / Tests / TestTraits Auto-generated documentation for pypowervm.tests.test_traits module. TestTraits TestTraits TestTraits().test_traits TestTraits().test_traits_into_wrappers","title":"TestTraits"},{"location":"pypowervm/tests/test_traits/#testtraits_1","text":"Show source in test_traits.py:38","title":"TestTraits"},{"location":"pypowervm/tests/test_traits/#signature","text":"class TestTraits(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_traits/#testtraitstest_traits","text":"Show source in test_traits.py:40","title":"TestTraits().test_traits"},{"location":"pypowervm/tests/test_traits/#signature_1","text":"@mock.patch(\"pypowervm.adapter.Session\") def test_traits(self, mock_sess): ...","title":"Signature"},{"location":"pypowervm/tests/test_traits/#testtraitstest_traits_into_wrappers","text":"Show source in test_traits.py:81","title":"TestTraits().test_traits_into_wrappers"},{"location":"pypowervm/tests/test_traits/#signature_2","text":"@mock.patch(\"requests.Session.request\") def test_traits_into_wrappers(self, mock_request): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/","text":"TestUtil Pypowervm Index / Pypowervm / Tests / TestUtil Auto-generated documentation for pypowervm.tests.test_util module. TestUtil TestAllowedList TestAllowedList().test_all_none TestAllowedList().test_const_or_list TestAllowedList().test_marshal TestAllowedList().test_unmarshal TestUtil TestUtil().test_convert_bytes_to_gb TestUtil().test_dice_href TestUtil().test_extend_basepath TestUtil().test_find_wrapper TestUtil().test_get_req_path_uuid_and_is_instance_path TestUtil().test_my_partition_id TestUtil().test_parent_spec TestUtil().test_part_id_by_loc_code TestUtil().test_retry_io_command TestUtil().test_round_gb_size_up TestUtil().test_sanitize_bool_for_api TestUtil().test_sanitize_file_name_for_api TestUtil().test_sanitize_partition_name_for_api TestUtil().test_xag_attrs TestAllowedList Show source in test_util.py:337 Signature class TestAllowedList(unittest.TestCase): ... TestAllowedList().test_all_none Show source in test_util.py:338 Signature def test_all_none(self): ... TestAllowedList().test_const_or_list Show source in test_util.py:381 Signature def test_const_or_list(self): ... TestAllowedList().test_marshal Show source in test_util.py:361 Signature def test_marshal(self): ... TestAllowedList().test_unmarshal Show source in test_util.py:348 Signature def test_unmarshal(self): ... TestUtil Show source in test_util.py:34 Unit tests for pypowervm.util. Signature class TestUtil(unittest.TestCase): ... TestUtil().test_convert_bytes_to_gb Show source in test_util.py:37 Signature def test_convert_bytes_to_gb(self): ... TestUtil().test_dice_href Show source in test_util.py:84 Signature def test_dice_href(self): ... TestUtil().test_extend_basepath Show source in test_util.py:158 Signature def test_extend_basepath(self): ... TestUtil().test_find_wrapper Show source in test_util.py:73 Signature def test_find_wrapper(self): ... TestUtil().test_get_req_path_uuid_and_is_instance_path Show source in test_util.py:104 Signature def test_get_req_path_uuid_and_is_instance_path(self): ... TestUtil().test_my_partition_id Show source in test_util.py:271 Test my_partition_id. Signature @mock.patch.object(builtins, \"open\") def test_my_partition_id(self, m_open): ... TestUtil().test_parent_spec Show source in test_util.py:280 Test parent_spec. Signature def test_parent_spec(self): ... TestUtil().test_part_id_by_loc_code Show source in test_util.py:255 Signature def test_part_id_by_loc_code(self): ... TestUtil().test_retry_io_command Show source in test_util.py:302 Signature def test_retry_io_command(self): ... TestUtil().test_round_gb_size_up Show source in test_util.py:58 Signature def test_round_gb_size_up(self): ... TestUtil().test_sanitize_bool_for_api Show source in test_util.py:67 Signature def test_sanitize_bool_for_api(self): ... TestUtil().test_sanitize_file_name_for_api Show source in test_util.py:180 Signature def test_sanitize_file_name_for_api(self): ... TestUtil().test_sanitize_partition_name_for_api Show source in test_util.py:222 Signature def test_sanitize_partition_name_for_api(self): ... TestUtil().test_xag_attrs Show source in test_util.py:261 Signature def test_xag_attrs(self): ...","title":"TestUtil"},{"location":"pypowervm/tests/test_util/#testutil","text":"Pypowervm Index / Pypowervm / Tests / TestUtil Auto-generated documentation for pypowervm.tests.test_util module. TestUtil TestAllowedList TestAllowedList().test_all_none TestAllowedList().test_const_or_list TestAllowedList().test_marshal TestAllowedList().test_unmarshal TestUtil TestUtil().test_convert_bytes_to_gb TestUtil().test_dice_href TestUtil().test_extend_basepath TestUtil().test_find_wrapper TestUtil().test_get_req_path_uuid_and_is_instance_path TestUtil().test_my_partition_id TestUtil().test_parent_spec TestUtil().test_part_id_by_loc_code TestUtil().test_retry_io_command TestUtil().test_round_gb_size_up TestUtil().test_sanitize_bool_for_api TestUtil().test_sanitize_file_name_for_api TestUtil().test_sanitize_partition_name_for_api TestUtil().test_xag_attrs","title":"TestUtil"},{"location":"pypowervm/tests/test_util/#testallowedlist","text":"Show source in test_util.py:337","title":"TestAllowedList"},{"location":"pypowervm/tests/test_util/#signature","text":"class TestAllowedList(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testallowedlisttest_all_none","text":"Show source in test_util.py:338","title":"TestAllowedList().test_all_none"},{"location":"pypowervm/tests/test_util/#signature_1","text":"def test_all_none(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testallowedlisttest_const_or_list","text":"Show source in test_util.py:381","title":"TestAllowedList().test_const_or_list"},{"location":"pypowervm/tests/test_util/#signature_2","text":"def test_const_or_list(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testallowedlisttest_marshal","text":"Show source in test_util.py:361","title":"TestAllowedList().test_marshal"},{"location":"pypowervm/tests/test_util/#signature_3","text":"def test_marshal(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testallowedlisttest_unmarshal","text":"Show source in test_util.py:348","title":"TestAllowedList().test_unmarshal"},{"location":"pypowervm/tests/test_util/#signature_4","text":"def test_unmarshal(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutil_1","text":"Show source in test_util.py:34 Unit tests for pypowervm.util.","title":"TestUtil"},{"location":"pypowervm/tests/test_util/#signature_5","text":"class TestUtil(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_convert_bytes_to_gb","text":"Show source in test_util.py:37","title":"TestUtil().test_convert_bytes_to_gb"},{"location":"pypowervm/tests/test_util/#signature_6","text":"def test_convert_bytes_to_gb(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_dice_href","text":"Show source in test_util.py:84","title":"TestUtil().test_dice_href"},{"location":"pypowervm/tests/test_util/#signature_7","text":"def test_dice_href(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_extend_basepath","text":"Show source in test_util.py:158","title":"TestUtil().test_extend_basepath"},{"location":"pypowervm/tests/test_util/#signature_8","text":"def test_extend_basepath(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_find_wrapper","text":"Show source in test_util.py:73","title":"TestUtil().test_find_wrapper"},{"location":"pypowervm/tests/test_util/#signature_9","text":"def test_find_wrapper(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_get_req_path_uuid_and_is_instance_path","text":"Show source in test_util.py:104","title":"TestUtil().test_get_req_path_uuid_and_is_instance_path"},{"location":"pypowervm/tests/test_util/#signature_10","text":"def test_get_req_path_uuid_and_is_instance_path(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_my_partition_id","text":"Show source in test_util.py:271 Test my_partition_id.","title":"TestUtil().test_my_partition_id"},{"location":"pypowervm/tests/test_util/#signature_11","text":"@mock.patch.object(builtins, \"open\") def test_my_partition_id(self, m_open): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_parent_spec","text":"Show source in test_util.py:280 Test parent_spec.","title":"TestUtil().test_parent_spec"},{"location":"pypowervm/tests/test_util/#signature_12","text":"def test_parent_spec(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_part_id_by_loc_code","text":"Show source in test_util.py:255","title":"TestUtil().test_part_id_by_loc_code"},{"location":"pypowervm/tests/test_util/#signature_13","text":"def test_part_id_by_loc_code(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_retry_io_command","text":"Show source in test_util.py:302","title":"TestUtil().test_retry_io_command"},{"location":"pypowervm/tests/test_util/#signature_14","text":"def test_retry_io_command(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_round_gb_size_up","text":"Show source in test_util.py:58","title":"TestUtil().test_round_gb_size_up"},{"location":"pypowervm/tests/test_util/#signature_15","text":"def test_round_gb_size_up(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_sanitize_bool_for_api","text":"Show source in test_util.py:67","title":"TestUtil().test_sanitize_bool_for_api"},{"location":"pypowervm/tests/test_util/#signature_16","text":"def test_sanitize_bool_for_api(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_sanitize_file_name_for_api","text":"Show source in test_util.py:180","title":"TestUtil().test_sanitize_file_name_for_api"},{"location":"pypowervm/tests/test_util/#signature_17","text":"def test_sanitize_file_name_for_api(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_sanitize_partition_name_for_api","text":"Show source in test_util.py:222","title":"TestUtil().test_sanitize_partition_name_for_api"},{"location":"pypowervm/tests/test_util/#signature_18","text":"def test_sanitize_partition_name_for_api(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_util/#testutiltest_xag_attrs","text":"Show source in test_util.py:261","title":"TestUtil().test_xag_attrs"},{"location":"pypowervm/tests/test_util/#signature_19","text":"def test_xag_attrs(self): ...","title":"Signature"},{"location":"pypowervm/tests/helpers/","text":"Helpers Pypowervm Index / Pypowervm / Tests / Helpers Auto-generated documentation for pypowervm.tests.helpers module. Helpers Modules Modules TestLogHelper Test Sample Test Vios Busy","title":"Helpers"},{"location":"pypowervm/tests/helpers/#helpers","text":"Pypowervm Index / Pypowervm / Tests / Helpers Auto-generated documentation for pypowervm.tests.helpers module. Helpers Modules","title":"Helpers"},{"location":"pypowervm/tests/helpers/#modules","text":"TestLogHelper Test Sample Test Vios Busy","title":"Modules"},{"location":"pypowervm/tests/helpers/test_loghelper/","text":"TestLogHelper Pypowervm Index / Pypowervm / Tests / Helpers / TestLogHelper Auto-generated documentation for pypowervm.tests.helpers.test_loghelper module. TestLogHelper TestLogHelper TestLogHelper().setUp TestLogHelper().test_log_helper TestLogHelper Show source in test_loghelper.py:33 Signature class TestLogHelper(testtools.TestCase): ... TestLogHelper().setUp Show source in test_loghelper.py:35 Signature def setUp(self): ... TestLogHelper().test_log_helper Show source in test_loghelper.py:39 Signature @mock.patch(\"pypowervm.helpers.log_helper.LOG\") def test_log_helper(self, mock_log): ...","title":"TestLogHelper"},{"location":"pypowervm/tests/helpers/test_loghelper/#testloghelper","text":"Pypowervm Index / Pypowervm / Tests / Helpers / TestLogHelper Auto-generated documentation for pypowervm.tests.helpers.test_loghelper module. TestLogHelper TestLogHelper TestLogHelper().setUp TestLogHelper().test_log_helper","title":"TestLogHelper"},{"location":"pypowervm/tests/helpers/test_loghelper/#testloghelper_1","text":"Show source in test_loghelper.py:33","title":"TestLogHelper"},{"location":"pypowervm/tests/helpers/test_loghelper/#signature","text":"class TestLogHelper(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/helpers/test_loghelper/#testloghelpersetup","text":"Show source in test_loghelper.py:35","title":"TestLogHelper().setUp"},{"location":"pypowervm/tests/helpers/test_loghelper/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/helpers/test_loghelper/#testloghelpertest_log_helper","text":"Show source in test_loghelper.py:39","title":"TestLogHelper().test_log_helper"},{"location":"pypowervm/tests/helpers/test_loghelper/#signature_2","text":"@mock.patch(\"pypowervm.helpers.log_helper.LOG\") def test_log_helper(self, mock_log): ...","title":"Signature"},{"location":"pypowervm/tests/helpers/test_sample/","text":"Test Sample Pypowervm Index / Pypowervm / Tests / Helpers / Test Sample Auto-generated documentation for pypowervm.tests.helpers.test_sample module. Test Sample TestSampleHelper TestSampleHelper().setUp TestSampleHelper().test_sample_helper TestSampleHelper Show source in test_sample.py:28 Signature class TestSampleHelper(testtools.TestCase): ... TestSampleHelper().setUp Show source in test_sample.py:30 Signature def setUp(self): ... TestSampleHelper().test_sample_helper Show source in test_sample.py:34 Signature @mock.patch(\"time.sleep\") def test_sample_helper(self, mock_sleep): ...","title":"Test Sample"},{"location":"pypowervm/tests/helpers/test_sample/#test-sample","text":"Pypowervm Index / Pypowervm / Tests / Helpers / Test Sample Auto-generated documentation for pypowervm.tests.helpers.test_sample module. Test Sample TestSampleHelper TestSampleHelper().setUp TestSampleHelper().test_sample_helper","title":"Test Sample"},{"location":"pypowervm/tests/helpers/test_sample/#testsamplehelper","text":"Show source in test_sample.py:28","title":"TestSampleHelper"},{"location":"pypowervm/tests/helpers/test_sample/#signature","text":"class TestSampleHelper(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/helpers/test_sample/#testsamplehelpersetup","text":"Show source in test_sample.py:30","title":"TestSampleHelper().setUp"},{"location":"pypowervm/tests/helpers/test_sample/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/helpers/test_sample/#testsamplehelpertest_sample_helper","text":"Show source in test_sample.py:34","title":"TestSampleHelper().test_sample_helper"},{"location":"pypowervm/tests/helpers/test_sample/#signature_2","text":"@mock.patch(\"time.sleep\") def test_sample_helper(self, mock_sleep): ...","title":"Signature"},{"location":"pypowervm/tests/helpers/test_vios_busy/","text":"Test Vios Busy Pypowervm Index / Pypowervm / Tests / Helpers / Test Vios Busy Auto-generated documentation for pypowervm.tests.helpers.test_vios_busy module. Test Vios Busy TestVIOSBusyHelper TestVIOSBusyHelper().setUp TestVIOSBusyHelper().test_vios_busy_helper TestVIOSBusyHelper Show source in test_vios_busy.py:31 Signature class TestVIOSBusyHelper(unittest.TestCase): ... TestVIOSBusyHelper().setUp Show source in test_vios_busy.py:33 Signature def setUp(self): ... TestVIOSBusyHelper().test_vios_busy_helper Show source in test_vios_busy.py:39 Signature @mock.patch(\"pypowervm.adapter.Session\") @mock.patch(\"pypowervm.helpers.vios_busy.SLEEP\") def test_vios_busy_helper(self, mock_sleep, mock_sess): ...","title":"Test Vios Busy"},{"location":"pypowervm/tests/helpers/test_vios_busy/#test-vios-busy","text":"Pypowervm Index / Pypowervm / Tests / Helpers / Test Vios Busy Auto-generated documentation for pypowervm.tests.helpers.test_vios_busy module. Test Vios Busy TestVIOSBusyHelper TestVIOSBusyHelper().setUp TestVIOSBusyHelper().test_vios_busy_helper","title":"Test Vios Busy"},{"location":"pypowervm/tests/helpers/test_vios_busy/#testviosbusyhelper","text":"Show source in test_vios_busy.py:31","title":"TestVIOSBusyHelper"},{"location":"pypowervm/tests/helpers/test_vios_busy/#signature","text":"class TestVIOSBusyHelper(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/helpers/test_vios_busy/#testviosbusyhelpersetup","text":"Show source in test_vios_busy.py:33","title":"TestVIOSBusyHelper().setUp"},{"location":"pypowervm/tests/helpers/test_vios_busy/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/helpers/test_vios_busy/#testviosbusyhelpertest_vios_busy_helper","text":"Show source in test_vios_busy.py:39","title":"TestVIOSBusyHelper().test_vios_busy_helper"},{"location":"pypowervm/tests/helpers/test_vios_busy/#signature_2","text":"@mock.patch(\"pypowervm.adapter.Session\") @mock.patch(\"pypowervm.helpers.vios_busy.SLEEP\") def test_vios_busy_helper(self, mock_sleep, mock_sess): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/","text":"Tasks Pypowervm Index / Pypowervm / Tests / Tasks Auto-generated documentation for pypowervm.tests.tasks module. Tasks Modules Modules Create Cluster Hdisk Monitor TestClientStorage TestClusterSSP TestCNA TestIBMi TestMasterMode TestMemory Test Mgmtconsole TestMigration TestNetworkBridger TestPartition TestPower TestPowerOpts TestSCSIMapper Test Slot Map TestSriov Test Storage TestVFCMapper TestVOpt TestVterm Util","title":"Tasks"},{"location":"pypowervm/tests/tasks/#tasks","text":"Pypowervm Index / Pypowervm / Tests / Tasks Auto-generated documentation for pypowervm.tests.tasks module. Tasks Modules","title":"Tasks"},{"location":"pypowervm/tests/tasks/#modules","text":"Create Cluster Hdisk Monitor TestClientStorage TestClusterSSP TestCNA TestIBMi TestMasterMode TestMemory Test Mgmtconsole TestMigration TestNetworkBridger TestPartition TestPower TestPowerOpts TestSCSIMapper Test Slot Map TestSriov Test Storage TestVFCMapper TestVOpt TestVterm Util","title":"Modules"},{"location":"pypowervm/tests/tasks/create_cluster/","text":"Create Cluster Pypowervm Index / Pypowervm / Tests / Tasks / Create Cluster Auto-generated documentation for pypowervm.tests.tasks.create_cluster module. Attributes HOST - >>>Replace the following with real values>>>: '9.1.2.3' node1 - Option 1: MTMS, LPAR_ID, Hostname: clust.Node.bld(adap, hostname=NODE_HOSTNAME, mtms=NODE_MTMS, lpar_id=NODE_LPARID) node2 - Option 2: URI: clust.Node.bld(adap, vios_uri=NODE_URI) Create Cluster","title":"Create Cluster"},{"location":"pypowervm/tests/tasks/create_cluster/#create-cluster","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Create Cluster Auto-generated documentation for pypowervm.tests.tasks.create_cluster module.","title":"Create Cluster"},{"location":"pypowervm/tests/tasks/create_cluster/#attributes","text":"HOST - >>>Replace the following with real values>>>: '9.1.2.3' node1 - Option 1: MTMS, LPAR_ID, Hostname: clust.Node.bld(adap, hostname=NODE_HOSTNAME, mtms=NODE_MTMS, lpar_id=NODE_LPARID) node2 - Option 2: URI: clust.Node.bld(adap, vios_uri=NODE_URI) Create Cluster","title":"Attributes"},{"location":"pypowervm/tests/tasks/test_client_storage/","text":"TestClientStorage Pypowervm Index / Pypowervm / Tests / Tasks / TestClientStorage Auto-generated documentation for pypowervm.tests.tasks.test_client_storage module. TestClientStorage TestClientStorage TestClientStorage().test_c_wwpn_to_vfc TestClientStorage().test_udid2scsi TestClientStorage Show source in test_client_storage.py:22 Signature class TestClientStorage(twrap.TestWrapper): ... TestClientStorage().test_c_wwpn_to_vfc Show source in test_client_storage.py:48 Test c_wwpn_to_vfc_mapping. Signature def test_c_wwpn_to_vfc(self): ... TestClientStorage().test_udid2scsi Show source in test_client_storage.py:26 Test udid_to_scsi_mapping. Signature def test_udid2scsi(self): ...","title":"TestClientStorage"},{"location":"pypowervm/tests/tasks/test_client_storage/#testclientstorage","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestClientStorage Auto-generated documentation for pypowervm.tests.tasks.test_client_storage module. TestClientStorage TestClientStorage TestClientStorage().test_c_wwpn_to_vfc TestClientStorage().test_udid2scsi","title":"TestClientStorage"},{"location":"pypowervm/tests/tasks/test_client_storage/#testclientstorage_1","text":"Show source in test_client_storage.py:22","title":"TestClientStorage"},{"location":"pypowervm/tests/tasks/test_client_storage/#signature","text":"class TestClientStorage(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_client_storage/#testclientstoragetest_c_wwpn_to_vfc","text":"Show source in test_client_storage.py:48 Test c_wwpn_to_vfc_mapping.","title":"TestClientStorage().test_c_wwpn_to_vfc"},{"location":"pypowervm/tests/tasks/test_client_storage/#signature_1","text":"def test_c_wwpn_to_vfc(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_client_storage/#testclientstoragetest_udid2scsi","text":"Show source in test_client_storage.py:26 Test udid_to_scsi_mapping.","title":"TestClientStorage().test_udid2scsi"},{"location":"pypowervm/tests/tasks/test_client_storage/#signature_2","text":"def test_udid2scsi(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/","text":"TestClusterSSP Pypowervm Index / Pypowervm / Tests / Tasks / TestClusterSSP Auto-generated documentation for pypowervm.tests.tasks.test_cluster_ssp module. TestClusterSSP TestClusterSSP TestClusterSSP().test_crt_cluster_ssp TestGetOrUploadImageLU TestGetOrUploadImageLU().bld_lu TestGetOrUploadImageLU().crt_img_lu TestGetOrUploadImageLU().luent_search TestGetOrUploadImageLU().setUp TestGetOrUploadImageLU().setup_crt_lu_mock TestGetOrUploadImageLU().sleep_conflict_finishes TestGetOrUploadImageLU().test_already_exists TestGetOrUploadImageLU().test_conflict_I_lose TestGetOrUploadImageLU().test_conflict_I_win TestGetOrUploadImageLU().test_conflict_not_started TestGetOrUploadImageLU().test_conflict_started TestGetOrUploadImageLU().test_crt_img_lu_raises TestGetOrUploadImageLU().test_upload_no_conflict TestGetOrUploadImageLU().test_upload_raises TestGetOrUploadImageLU().upload_lu TestClusterSSP Show source in test_cluster_ssp.py:35 Signature class TestClusterSSP(unittest.TestCase): ... TestClusterSSP().test_crt_cluster_ssp Show source in test_cluster_ssp.py:37 Signature @mock.patch(\"pypowervm.wrappers.job.Job.delete_job\") @mock.patch(\"pypowervm.wrappers.job.Job._monitor_job\") @mock.patch(\"pypowervm.wrappers.job.Job.job_status\") @mock.patch(\"pypowervm.adapter.Adapter\") def test_crt_cluster_ssp(self, mock_adp, mock_status, mock_monitor_job, mock_del_job): ... TestGetOrUploadImageLU Show source in test_cluster_ssp.py:103 Signature class TestGetOrUploadImageLU(twrap.TestWrapper): ... TestGetOrUploadImageLU().bld_lu Show source in test_cluster_ssp.py:143 Signature def bld_lu(self, luname, gb_size): ... TestGetOrUploadImageLU().crt_img_lu Show source in test_cluster_ssp.py:192 Mock side effect for crt_lu of the image LU. Signature def crt_img_lu(self, tier, luname, lu_gb, typ=None): ... TestGetOrUploadImageLU().luent_search Show source in test_cluster_ssp.py:150 Mock side effect for LUEnt.search, validating arguments. Returns self.entries (the LUEnt feed) Signature def luent_search(self, adapter, parent=None, lu_type=None): ... TestGetOrUploadImageLU().setUp Show source in test_cluster_ssp.py:107 Signature def setUp(self): ... TestGetOrUploadImageLU().setup_crt_lu_mock Show source in test_cluster_ssp.py:160 Set up the mock side effect for crt_lu calls. The marker LU side always creates \"my\" marker LU. If a conflicting_mkr_lu is specified, also creates that marker LU (to simulate simultaneous attempts from separate hosts). The image LU side behaves as indicated by the crt_img_lu_se parameter. Arguments crt_img_lu_se - Side effect for crt_lu of the image LU. conflicting_mkr_lu - If specified, the resulting mock pretends that some other host created the specified marker LU at the same time we're creating ours. Returns A callable suitable for assigning to self.mock_crt_lu.side_effect. Signature def setup_crt_lu_mock(self, crt_img_lu_se, conflicting_mkr_lu=None): ... TestGetOrUploadImageLU().sleep_conflict_finishes Show source in test_cluster_ssp.py:208 Pretend the conflicting LU finishes while we sleep. Signature def sleep_conflict_finishes(self, sec): ... TestGetOrUploadImageLU().test_already_exists Show source in test_cluster_ssp.py:219 The image LU is already there. Signature def test_already_exists(self): ... TestGetOrUploadImageLU().test_conflict_I_lose Show source in test_cluster_ssp.py:306 We both bid at the same time; and I lose. Signature def test_conflict_I_lose(self): ... TestGetOrUploadImageLU().test_conflict_I_win Show source in test_cluster_ssp.py:331 We both bid at the same time; and I win. Signature def test_conflict_I_win(self): ... TestGetOrUploadImageLU().test_conflict_not_started Show source in test_cluster_ssp.py:262 Another upload is about to start when we get there. Signature def test_conflict_not_started(self): ... TestGetOrUploadImageLU().test_conflict_started Show source in test_cluster_ssp.py:285 Another upload is in progress when we get there. Signature def test_conflict_started(self): ... TestGetOrUploadImageLU().test_crt_img_lu_raises Show source in test_cluster_ssp.py:357 Exception during crt_lu of the image LU. Signature def test_crt_img_lu_raises(self): ... TestGetOrUploadImageLU().test_upload_no_conflict Show source in test_cluster_ssp.py:243 Upload a new LU - no conflict. Signature def test_upload_no_conflict(self): ... TestGetOrUploadImageLU().test_upload_raises Show source in test_cluster_ssp.py:380 I win; upload_lu raises after crt_lu of the image LU. Signature def test_upload_raises(self): ... TestGetOrUploadImageLU().upload_lu Show source in test_cluster_ssp.py:201 Signature def upload_lu(self, vios_uuid, new_lu, stream, b_size, upload_type=None): ...","title":"TestClusterSSP"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testclusterssp","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestClusterSSP Auto-generated documentation for pypowervm.tests.tasks.test_cluster_ssp module. TestClusterSSP TestClusterSSP TestClusterSSP().test_crt_cluster_ssp TestGetOrUploadImageLU TestGetOrUploadImageLU().bld_lu TestGetOrUploadImageLU().crt_img_lu TestGetOrUploadImageLU().luent_search TestGetOrUploadImageLU().setUp TestGetOrUploadImageLU().setup_crt_lu_mock TestGetOrUploadImageLU().sleep_conflict_finishes TestGetOrUploadImageLU().test_already_exists TestGetOrUploadImageLU().test_conflict_I_lose TestGetOrUploadImageLU().test_conflict_I_win TestGetOrUploadImageLU().test_conflict_not_started TestGetOrUploadImageLU().test_conflict_started TestGetOrUploadImageLU().test_crt_img_lu_raises TestGetOrUploadImageLU().test_upload_no_conflict TestGetOrUploadImageLU().test_upload_raises TestGetOrUploadImageLU().upload_lu","title":"TestClusterSSP"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testclusterssp_1","text":"Show source in test_cluster_ssp.py:35","title":"TestClusterSSP"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature","text":"class TestClusterSSP(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testclusterssptest_crt_cluster_ssp","text":"Show source in test_cluster_ssp.py:37","title":"TestClusterSSP().test_crt_cluster_ssp"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_1","text":"@mock.patch(\"pypowervm.wrappers.job.Job.delete_job\") @mock.patch(\"pypowervm.wrappers.job.Job._monitor_job\") @mock.patch(\"pypowervm.wrappers.job.Job.job_status\") @mock.patch(\"pypowervm.adapter.Adapter\") def test_crt_cluster_ssp(self, mock_adp, mock_status, mock_monitor_job, mock_del_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelu","text":"Show source in test_cluster_ssp.py:103","title":"TestGetOrUploadImageLU"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_2","text":"class TestGetOrUploadImageLU(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelubld_lu","text":"Show source in test_cluster_ssp.py:143","title":"TestGetOrUploadImageLU().bld_lu"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_3","text":"def bld_lu(self, luname, gb_size): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelucrt_img_lu","text":"Show source in test_cluster_ssp.py:192 Mock side effect for crt_lu of the image LU.","title":"TestGetOrUploadImageLU().crt_img_lu"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_4","text":"def crt_img_lu(self, tier, luname, lu_gb, typ=None): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimageluluent_search","text":"Show source in test_cluster_ssp.py:150 Mock side effect for LUEnt.search, validating arguments.","title":"TestGetOrUploadImageLU().luent_search"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#returns","text":"self.entries (the LUEnt feed)","title":"Returns"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_5","text":"def luent_search(self, adapter, parent=None, lu_type=None): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelusetup","text":"Show source in test_cluster_ssp.py:107","title":"TestGetOrUploadImageLU().setUp"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_6","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelusetup_crt_lu_mock","text":"Show source in test_cluster_ssp.py:160 Set up the mock side effect for crt_lu calls. The marker LU side always creates \"my\" marker LU. If a conflicting_mkr_lu is specified, also creates that marker LU (to simulate simultaneous attempts from separate hosts). The image LU side behaves as indicated by the crt_img_lu_se parameter.","title":"TestGetOrUploadImageLU().setup_crt_lu_mock"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#arguments","text":"crt_img_lu_se - Side effect for crt_lu of the image LU. conflicting_mkr_lu - If specified, the resulting mock pretends that some other host created the specified marker LU at the same time we're creating ours.","title":"Arguments"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#returns_1","text":"A callable suitable for assigning to self.mock_crt_lu.side_effect.","title":"Returns"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_7","text":"def setup_crt_lu_mock(self, crt_img_lu_se, conflicting_mkr_lu=None): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelusleep_conflict_finishes","text":"Show source in test_cluster_ssp.py:208 Pretend the conflicting LU finishes while we sleep.","title":"TestGetOrUploadImageLU().sleep_conflict_finishes"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_8","text":"def sleep_conflict_finishes(self, sec): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelutest_already_exists","text":"Show source in test_cluster_ssp.py:219 The image LU is already there.","title":"TestGetOrUploadImageLU().test_already_exists"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_9","text":"def test_already_exists(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelutest_conflict_i_lose","text":"Show source in test_cluster_ssp.py:306 We both bid at the same time; and I lose.","title":"TestGetOrUploadImageLU().test_conflict_I_lose"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_10","text":"def test_conflict_I_lose(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelutest_conflict_i_win","text":"Show source in test_cluster_ssp.py:331 We both bid at the same time; and I win.","title":"TestGetOrUploadImageLU().test_conflict_I_win"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_11","text":"def test_conflict_I_win(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelutest_conflict_not_started","text":"Show source in test_cluster_ssp.py:262 Another upload is about to start when we get there.","title":"TestGetOrUploadImageLU().test_conflict_not_started"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_12","text":"def test_conflict_not_started(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelutest_conflict_started","text":"Show source in test_cluster_ssp.py:285 Another upload is in progress when we get there.","title":"TestGetOrUploadImageLU().test_conflict_started"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_13","text":"def test_conflict_started(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelutest_crt_img_lu_raises","text":"Show source in test_cluster_ssp.py:357 Exception during crt_lu of the image LU.","title":"TestGetOrUploadImageLU().test_crt_img_lu_raises"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_14","text":"def test_crt_img_lu_raises(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelutest_upload_no_conflict","text":"Show source in test_cluster_ssp.py:243 Upload a new LU - no conflict.","title":"TestGetOrUploadImageLU().test_upload_no_conflict"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_15","text":"def test_upload_no_conflict(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimagelutest_upload_raises","text":"Show source in test_cluster_ssp.py:380 I win; upload_lu raises after crt_lu of the image LU.","title":"TestGetOrUploadImageLU().test_upload_raises"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_16","text":"def test_upload_raises(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#testgetoruploadimageluupload_lu","text":"Show source in test_cluster_ssp.py:201","title":"TestGetOrUploadImageLU().upload_lu"},{"location":"pypowervm/tests/tasks/test_cluster_ssp/#signature_17","text":"def upload_lu(self, vios_uuid, new_lu, stream, b_size, upload_type=None): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/","text":"TestCNA Pypowervm Index / Pypowervm / Tests / Tasks / TestCNA Auto-generated documentation for pypowervm.tests.tasks.test_cna module. TestCNA TestCNA TestCNA().test_crt_cna TestCNA().test_crt_cna_no_vnet_crt TestCNA().test_find_or_create_vswitch TestVNET TestVNET().test_assign_free_vlan TestVNET().test_crt_p2p_cna TestVNET().test_crt_p2p_cna_single TestVNET().test_crt_trunk_with_free_vlan TestVNET().test_find_all_trunks_on_lpar TestVNET().test_find_cna_wraps TestVNET().test_find_cnas_on_trunk TestVNET().test_find_free_vlan TestVNET().test_find_free_vlan_mocked TestVNET().test_find_or_create_vnet TestVNET().test_find_orphaned_trunks TestVNET().test_find_trunk_on_lpar TestVNET().test_find_trunks TestCNA Show source in test_cna.py:33 Unit Tests for creating Client Network Adapters. Signature class TestCNA(twrap.TestWrapper): ... TestCNA().test_crt_cna Show source in test_cna.py:39 Tests the creation of Client Network Adapters. Signature @mock.patch(\"pypowervm.tasks.cna._find_or_create_vnet\") def test_crt_cna(self, mock_vnet_find): ... TestCNA().test_crt_cna_no_vnet_crt Show source in test_cna.py:58 Tests the creation of Client Network Adapters. The virtual network creation shouldn't be done in this flow. Signature @mock.patch(\"pypowervm.tasks.cna._find_or_create_vnet\") def test_crt_cna_no_vnet_crt(self, mock_vnet_find): ... TestCNA().test_find_or_create_vswitch Show source in test_cna.py:84 Validates that a vswitch can be created. Signature def test_find_or_create_vswitch(self): ... TestVNET Show source in test_cna.py:112 Signature class TestVNET(twrap.TestWrapper): ... TestVNET().test_assign_free_vlan Show source in test_cna.py:187 Signature @mock.patch(\"pypowervm.tasks.cna._find_free_vlan\") def test_assign_free_vlan(self, mock_find_vlan): ... TestVNET().test_crt_p2p_cna Show source in test_cna.py:200 Tests the crt_p2p_cna. Signature @mock.patch(\"pypowervm.wrappers.network.CNA.bld\") @mock.patch(\"pypowervm.tasks.cna._find_free_vlan\") @mock.patch(\"pypowervm.tasks.cna._find_or_create_vswitch\") @mock.patch(\"pypowervm.tasks.partition.get_partitions\") def test_crt_p2p_cna( self, mock_get_partitions, mock_find_or_create_vswitch, mock_find_free_vlan, mock_cna_bld, ): ... TestVNET().test_crt_p2p_cna_single Show source in test_cna.py:249 Tests the crt_p2p_cna with the mgmt lpar and a dev_name. Signature @mock.patch(\"pypowervm.wrappers.network.CNA.bld\") @mock.patch(\"pypowervm.tasks.cna._find_free_vlan\") @mock.patch(\"pypowervm.tasks.cna._find_or_create_vswitch\") @mock.patch(\"pypowervm.tasks.partition.get_partitions\") def test_crt_p2p_cna_single( self, mock_get_partitions, mock_find_or_create_vswitch, mock_find_free_vlan, mock_cna_bld, ): ... TestVNET().test_crt_trunk_with_free_vlan Show source in test_cna.py:292 Tests the crt_trunk_with_free_vlan on mgmt based VIOS. Signature @mock.patch(\"pypowervm.wrappers.network.CNA.bld\") @mock.patch(\"pypowervm.tasks.cna._find_free_vlan\") @mock.patch(\"pypowervm.tasks.cna._find_or_create_vswitch\") @mock.patch(\"pypowervm.tasks.partition.get_partitions\") def test_crt_trunk_with_free_vlan( self, mock_get_partitions, mock_find_or_create_vswitch, mock_find_free_vlan, mock_cna_bld, ): ... TestVNET().test_find_all_trunks_on_lpar Show source in test_cna.py:374 Signature @mock.patch(\"pypowervm.wrappers.network.CNA.get\") def test_find_all_trunks_on_lpar(self, mock_cna_get): ... TestVNET().test_find_cna_wraps Show source in test_cna.py:395 Signature @mock.patch(\"pypowervm.wrappers.network.CNA.get\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") @mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.get\") def test_find_cna_wraps(self, mock_lpar_get, mock_vios_get, mock_cna_get): ... TestVNET().test_find_cnas_on_trunk Show source in test_cna.py:416 Signature @mock.patch(\"pypowervm.tasks.cna._find_cna_wraps\") def test_find_cnas_on_trunk(self, mock_find_wraps): ... TestVNET().test_find_free_vlan Show source in test_cna.py:143 Tests that a free VLAN can be found. Signature def test_find_free_vlan(self): ... TestVNET().test_find_free_vlan_mocked Show source in test_cna.py:157 Uses lots of mock data for a find vlan. Signature @mock.patch(\"pypowervm.wrappers.network.VNet.wrap\") def test_find_free_vlan_mocked(self, mock_vnet_wrap): ... TestVNET().test_find_or_create_vnet Show source in test_cna.py:117 Tests that the virtual network can be found/created. Signature def test_find_or_create_vnet(self): ... TestVNET().test_find_orphaned_trunks Show source in test_cna.py:433 Signature @mock.patch(\"pypowervm.tasks.cna._find_cna_wraps\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") @mock.patch(\"pypowervm.tasks.partition.get_mgmt_partition\") @mock.patch(\"pypowervm.tasks.cna._find_all_trunks_on_lpar\") @mock.patch(\"pypowervm.wrappers.network.VSwitch.search\") def test_find_orphaned_trunks( self, mock_vswitch, mock_trunks, mock_get_mgmt, mock_vios_get, mock_wraps ): ... TestVNET().test_find_trunk_on_lpar Show source in test_cna.py:329 Signature @mock.patch(\"pypowervm.wrappers.network.CNA.get\") def test_find_trunk_on_lpar(self, mock_cna_get): ... TestVNET().test_find_trunks Show source in test_cna.py:348 Signature @mock.patch(\"pypowervm.tasks.cna._find_trunk_on_lpar\") @mock.patch(\"pypowervm.tasks.partition.get_mgmt_partition\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") def test_find_trunks(self, mock_vios_get, mock_get_mgmt, mock_find_trunk): ...","title":"TestCNA"},{"location":"pypowervm/tests/tasks/test_cna/#testcna","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestCNA Auto-generated documentation for pypowervm.tests.tasks.test_cna module. TestCNA TestCNA TestCNA().test_crt_cna TestCNA().test_crt_cna_no_vnet_crt TestCNA().test_find_or_create_vswitch TestVNET TestVNET().test_assign_free_vlan TestVNET().test_crt_p2p_cna TestVNET().test_crt_p2p_cna_single TestVNET().test_crt_trunk_with_free_vlan TestVNET().test_find_all_trunks_on_lpar TestVNET().test_find_cna_wraps TestVNET().test_find_cnas_on_trunk TestVNET().test_find_free_vlan TestVNET().test_find_free_vlan_mocked TestVNET().test_find_or_create_vnet TestVNET().test_find_orphaned_trunks TestVNET().test_find_trunk_on_lpar TestVNET().test_find_trunks","title":"TestCNA"},{"location":"pypowervm/tests/tasks/test_cna/#testcna_1","text":"Show source in test_cna.py:33 Unit Tests for creating Client Network Adapters.","title":"TestCNA"},{"location":"pypowervm/tests/tasks/test_cna/#signature","text":"class TestCNA(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testcnatest_crt_cna","text":"Show source in test_cna.py:39 Tests the creation of Client Network Adapters.","title":"TestCNA().test_crt_cna"},{"location":"pypowervm/tests/tasks/test_cna/#signature_1","text":"@mock.patch(\"pypowervm.tasks.cna._find_or_create_vnet\") def test_crt_cna(self, mock_vnet_find): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testcnatest_crt_cna_no_vnet_crt","text":"Show source in test_cna.py:58 Tests the creation of Client Network Adapters. The virtual network creation shouldn't be done in this flow.","title":"TestCNA().test_crt_cna_no_vnet_crt"},{"location":"pypowervm/tests/tasks/test_cna/#signature_2","text":"@mock.patch(\"pypowervm.tasks.cna._find_or_create_vnet\") def test_crt_cna_no_vnet_crt(self, mock_vnet_find): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testcnatest_find_or_create_vswitch","text":"Show source in test_cna.py:84 Validates that a vswitch can be created.","title":"TestCNA().test_find_or_create_vswitch"},{"location":"pypowervm/tests/tasks/test_cna/#signature_3","text":"def test_find_or_create_vswitch(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnet","text":"Show source in test_cna.py:112","title":"TestVNET"},{"location":"pypowervm/tests/tasks/test_cna/#signature_4","text":"class TestVNET(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_assign_free_vlan","text":"Show source in test_cna.py:187","title":"TestVNET().test_assign_free_vlan"},{"location":"pypowervm/tests/tasks/test_cna/#signature_5","text":"@mock.patch(\"pypowervm.tasks.cna._find_free_vlan\") def test_assign_free_vlan(self, mock_find_vlan): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_crt_p2p_cna","text":"Show source in test_cna.py:200 Tests the crt_p2p_cna.","title":"TestVNET().test_crt_p2p_cna"},{"location":"pypowervm/tests/tasks/test_cna/#signature_6","text":"@mock.patch(\"pypowervm.wrappers.network.CNA.bld\") @mock.patch(\"pypowervm.tasks.cna._find_free_vlan\") @mock.patch(\"pypowervm.tasks.cna._find_or_create_vswitch\") @mock.patch(\"pypowervm.tasks.partition.get_partitions\") def test_crt_p2p_cna( self, mock_get_partitions, mock_find_or_create_vswitch, mock_find_free_vlan, mock_cna_bld, ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_crt_p2p_cna_single","text":"Show source in test_cna.py:249 Tests the crt_p2p_cna with the mgmt lpar and a dev_name.","title":"TestVNET().test_crt_p2p_cna_single"},{"location":"pypowervm/tests/tasks/test_cna/#signature_7","text":"@mock.patch(\"pypowervm.wrappers.network.CNA.bld\") @mock.patch(\"pypowervm.tasks.cna._find_free_vlan\") @mock.patch(\"pypowervm.tasks.cna._find_or_create_vswitch\") @mock.patch(\"pypowervm.tasks.partition.get_partitions\") def test_crt_p2p_cna_single( self, mock_get_partitions, mock_find_or_create_vswitch, mock_find_free_vlan, mock_cna_bld, ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_crt_trunk_with_free_vlan","text":"Show source in test_cna.py:292 Tests the crt_trunk_with_free_vlan on mgmt based VIOS.","title":"TestVNET().test_crt_trunk_with_free_vlan"},{"location":"pypowervm/tests/tasks/test_cna/#signature_8","text":"@mock.patch(\"pypowervm.wrappers.network.CNA.bld\") @mock.patch(\"pypowervm.tasks.cna._find_free_vlan\") @mock.patch(\"pypowervm.tasks.cna._find_or_create_vswitch\") @mock.patch(\"pypowervm.tasks.partition.get_partitions\") def test_crt_trunk_with_free_vlan( self, mock_get_partitions, mock_find_or_create_vswitch, mock_find_free_vlan, mock_cna_bld, ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_find_all_trunks_on_lpar","text":"Show source in test_cna.py:374","title":"TestVNET().test_find_all_trunks_on_lpar"},{"location":"pypowervm/tests/tasks/test_cna/#signature_9","text":"@mock.patch(\"pypowervm.wrappers.network.CNA.get\") def test_find_all_trunks_on_lpar(self, mock_cna_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_find_cna_wraps","text":"Show source in test_cna.py:395","title":"TestVNET().test_find_cna_wraps"},{"location":"pypowervm/tests/tasks/test_cna/#signature_10","text":"@mock.patch(\"pypowervm.wrappers.network.CNA.get\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") @mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.get\") def test_find_cna_wraps(self, mock_lpar_get, mock_vios_get, mock_cna_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_find_cnas_on_trunk","text":"Show source in test_cna.py:416","title":"TestVNET().test_find_cnas_on_trunk"},{"location":"pypowervm/tests/tasks/test_cna/#signature_11","text":"@mock.patch(\"pypowervm.tasks.cna._find_cna_wraps\") def test_find_cnas_on_trunk(self, mock_find_wraps): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_find_free_vlan","text":"Show source in test_cna.py:143 Tests that a free VLAN can be found.","title":"TestVNET().test_find_free_vlan"},{"location":"pypowervm/tests/tasks/test_cna/#signature_12","text":"def test_find_free_vlan(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_find_free_vlan_mocked","text":"Show source in test_cna.py:157 Uses lots of mock data for a find vlan.","title":"TestVNET().test_find_free_vlan_mocked"},{"location":"pypowervm/tests/tasks/test_cna/#signature_13","text":"@mock.patch(\"pypowervm.wrappers.network.VNet.wrap\") def test_find_free_vlan_mocked(self, mock_vnet_wrap): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_find_or_create_vnet","text":"Show source in test_cna.py:117 Tests that the virtual network can be found/created.","title":"TestVNET().test_find_or_create_vnet"},{"location":"pypowervm/tests/tasks/test_cna/#signature_14","text":"def test_find_or_create_vnet(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_find_orphaned_trunks","text":"Show source in test_cna.py:433","title":"TestVNET().test_find_orphaned_trunks"},{"location":"pypowervm/tests/tasks/test_cna/#signature_15","text":"@mock.patch(\"pypowervm.tasks.cna._find_cna_wraps\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") @mock.patch(\"pypowervm.tasks.partition.get_mgmt_partition\") @mock.patch(\"pypowervm.tasks.cna._find_all_trunks_on_lpar\") @mock.patch(\"pypowervm.wrappers.network.VSwitch.search\") def test_find_orphaned_trunks( self, mock_vswitch, mock_trunks, mock_get_mgmt, mock_vios_get, mock_wraps ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_find_trunk_on_lpar","text":"Show source in test_cna.py:329","title":"TestVNET().test_find_trunk_on_lpar"},{"location":"pypowervm/tests/tasks/test_cna/#signature_16","text":"@mock.patch(\"pypowervm.wrappers.network.CNA.get\") def test_find_trunk_on_lpar(self, mock_cna_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_cna/#testvnettest_find_trunks","text":"Show source in test_cna.py:348","title":"TestVNET().test_find_trunks"},{"location":"pypowervm/tests/tasks/test_cna/#signature_17","text":"@mock.patch(\"pypowervm.tasks.cna._find_trunk_on_lpar\") @mock.patch(\"pypowervm.tasks.partition.get_mgmt_partition\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") def test_find_trunks(self, mock_vios_get, mock_get_mgmt, mock_find_trunk): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/","text":"TestIBMi Pypowervm Index / Pypowervm / Tests / Tasks / TestIBMi Auto-generated documentation for pypowervm.tests.tasks.test_ibmi module. TestIBMi TestIBMi TestIBMi().setUp TestIBMiWithHMC TestIBMiWithHMC().setUp TestIBMiWithHMC().test_update_ibmi_settings TestIBMiWithPVM TestIBMiWithPVM().setUp TestIBMiWithPVM().test_update_ibmi_settings TestIBMiWithPVM().test_update_ibmi_settings_w_stale_adapters TestPanelFunction TestPanelFunction().mock_partition TestPanelFunction().setUp TestPanelFunction().test_exceptions TestPanelFunction().test_ops TestIBMi Show source in test_ibmi.py:32 Unit Tests for IBMi changes. Signature class TestIBMi(testtools.TestCase): ... TestIBMi().setUp Show source in test_ibmi.py:35 Signature def setUp(self, traits_type): ... TestIBMiWithHMC Show source in test_ibmi.py:84 Unit Tests for IBMi changes for HMC. Signature class TestIBMiWithHMC(TestIBMi): ... See also TestIBMi TestIBMiWithHMC().setUp Show source in test_ibmi.py:87 Signature def setUp(self): ... TestIBMiWithHMC().test_update_ibmi_settings Show source in test_ibmi.py:90 Signature @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.wrap\") def test_update_ibmi_settings(self, mock_viosw): ... TestIBMiWithPVM Show source in test_ibmi.py:95 Unit Tests for IBMi changes for PVM. Signature class TestIBMiWithPVM(TestIBMi): ... See also TestIBMi TestIBMiWithPVM().setUp Show source in test_ibmi.py:98 Signature def setUp(self): ... TestIBMiWithPVM().test_update_ibmi_settings Show source in test_ibmi.py:101 Signature @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.wrap\") def test_update_ibmi_settings(self, mock_viosw): ... TestIBMiWithPVM().test_update_ibmi_settings_w_stale_adapters Show source in test_ibmi.py:105 Signature @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.wrap\") @mock.patch( \"pypowervm.wrappers.virtual_io_server.VStorageMapping.client_adapter\", new_callable=mock.PropertyMock, return_value=None, ) def test_update_ibmi_settings_w_stale_adapters(self, mock_c_adap, mock_viosw): ... TestPanelFunction Show source in test_ibmi.py:118 Signature class TestPanelFunction(testtools.TestCase): ... TestPanelFunction().mock_partition Show source in test_ibmi.py:137 Returns a mocked partition with the specified properties. Signature def mock_partition(self, env=pvm_bp.LPARType.OS400, rmc_state=pvm_bp.RMCState.ACTIVE): ... TestPanelFunction().setUp Show source in test_ibmi.py:119 Signature def setUp(self): ... TestPanelFunction().test_exceptions Show source in test_ibmi.py:214 Signature def test_exceptions(self): ... TestPanelFunction().test_ops Show source in test_ibmi.py:142 Signature def test_ops(self): ...","title":"TestIBMi"},{"location":"pypowervm/tests/tasks/test_ibmi/#testibmi","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestIBMi Auto-generated documentation for pypowervm.tests.tasks.test_ibmi module. TestIBMi TestIBMi TestIBMi().setUp TestIBMiWithHMC TestIBMiWithHMC().setUp TestIBMiWithHMC().test_update_ibmi_settings TestIBMiWithPVM TestIBMiWithPVM().setUp TestIBMiWithPVM().test_update_ibmi_settings TestIBMiWithPVM().test_update_ibmi_settings_w_stale_adapters TestPanelFunction TestPanelFunction().mock_partition TestPanelFunction().setUp TestPanelFunction().test_exceptions TestPanelFunction().test_ops","title":"TestIBMi"},{"location":"pypowervm/tests/tasks/test_ibmi/#testibmi_1","text":"Show source in test_ibmi.py:32 Unit Tests for IBMi changes.","title":"TestIBMi"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature","text":"class TestIBMi(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testibmisetup","text":"Show source in test_ibmi.py:35","title":"TestIBMi().setUp"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_1","text":"def setUp(self, traits_type): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testibmiwithhmc","text":"Show source in test_ibmi.py:84 Unit Tests for IBMi changes for HMC.","title":"TestIBMiWithHMC"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_2","text":"class TestIBMiWithHMC(TestIBMi): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#see-also","text":"TestIBMi","title":"See also"},{"location":"pypowervm/tests/tasks/test_ibmi/#testibmiwithhmcsetup","text":"Show source in test_ibmi.py:87","title":"TestIBMiWithHMC().setUp"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_3","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testibmiwithhmctest_update_ibmi_settings","text":"Show source in test_ibmi.py:90","title":"TestIBMiWithHMC().test_update_ibmi_settings"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_4","text":"@mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.wrap\") def test_update_ibmi_settings(self, mock_viosw): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testibmiwithpvm","text":"Show source in test_ibmi.py:95 Unit Tests for IBMi changes for PVM.","title":"TestIBMiWithPVM"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_5","text":"class TestIBMiWithPVM(TestIBMi): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#see-also_1","text":"TestIBMi","title":"See also"},{"location":"pypowervm/tests/tasks/test_ibmi/#testibmiwithpvmsetup","text":"Show source in test_ibmi.py:98","title":"TestIBMiWithPVM().setUp"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_6","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testibmiwithpvmtest_update_ibmi_settings","text":"Show source in test_ibmi.py:101","title":"TestIBMiWithPVM().test_update_ibmi_settings"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_7","text":"@mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.wrap\") def test_update_ibmi_settings(self, mock_viosw): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testibmiwithpvmtest_update_ibmi_settings_w_stale_adapters","text":"Show source in test_ibmi.py:105","title":"TestIBMiWithPVM().test_update_ibmi_settings_w_stale_adapters"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_8","text":"@mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.wrap\") @mock.patch( \"pypowervm.wrappers.virtual_io_server.VStorageMapping.client_adapter\", new_callable=mock.PropertyMock, return_value=None, ) def test_update_ibmi_settings_w_stale_adapters(self, mock_c_adap, mock_viosw): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testpanelfunction","text":"Show source in test_ibmi.py:118","title":"TestPanelFunction"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_9","text":"class TestPanelFunction(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testpanelfunctionmock_partition","text":"Show source in test_ibmi.py:137 Returns a mocked partition with the specified properties.","title":"TestPanelFunction().mock_partition"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_10","text":"def mock_partition(self, env=pvm_bp.LPARType.OS400, rmc_state=pvm_bp.RMCState.ACTIVE): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testpanelfunctionsetup","text":"Show source in test_ibmi.py:119","title":"TestPanelFunction().setUp"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_11","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testpanelfunctiontest_exceptions","text":"Show source in test_ibmi.py:214","title":"TestPanelFunction().test_exceptions"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_12","text":"def test_exceptions(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_ibmi/#testpanelfunctiontest_ops","text":"Show source in test_ibmi.py:142","title":"TestPanelFunction().test_ops"},{"location":"pypowervm/tests/tasks/test_ibmi/#signature_13","text":"def test_ops(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_master_mode/","text":"TestMasterMode Pypowervm Index / Pypowervm / Tests / Tasks / TestMasterMode Auto-generated documentation for pypowervm.tests.tasks.test_master_mode module. TestMasterMode TestMasterMode TestMasterMode().setUp TestMasterMode().test_release_master TestMasterMode().test_request_master TestMasterMode Show source in test_master_mode.py:26 Unit Tests for master mode request and release. Signature class TestMasterMode(testtools.TestCase): ... TestMasterMode().setUp Show source in test_master_mode.py:29 Signature def setUp(self): ... TestMasterMode().test_release_master Show source in test_master_mode.py:61 Signature @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_release_master(self, mock_run_job): ... TestMasterMode().test_request_master Show source in test_master_mode.py:40 Signature @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_request_master(self, mock_run_job): ...","title":"TestMasterMode"},{"location":"pypowervm/tests/tasks/test_master_mode/#testmastermode","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestMasterMode Auto-generated documentation for pypowervm.tests.tasks.test_master_mode module. TestMasterMode TestMasterMode TestMasterMode().setUp TestMasterMode().test_release_master TestMasterMode().test_request_master","title":"TestMasterMode"},{"location":"pypowervm/tests/tasks/test_master_mode/#testmastermode_1","text":"Show source in test_master_mode.py:26 Unit Tests for master mode request and release.","title":"TestMasterMode"},{"location":"pypowervm/tests/tasks/test_master_mode/#signature","text":"class TestMasterMode(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_master_mode/#testmastermodesetup","text":"Show source in test_master_mode.py:29","title":"TestMasterMode().setUp"},{"location":"pypowervm/tests/tasks/test_master_mode/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_master_mode/#testmastermodetest_release_master","text":"Show source in test_master_mode.py:61","title":"TestMasterMode().test_release_master"},{"location":"pypowervm/tests/tasks/test_master_mode/#signature_2","text":"@mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_release_master(self, mock_run_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_master_mode/#testmastermodetest_request_master","text":"Show source in test_master_mode.py:40","title":"TestMasterMode().test_request_master"},{"location":"pypowervm/tests/tasks/test_master_mode/#signature_3","text":"@mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_request_master(self, mock_run_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_memory/","text":"TestMemory Pypowervm Index / Pypowervm / Tests / Tasks / TestMemory Auto-generated documentation for pypowervm.tests.tasks.test_memory module. TestMemory TestMemory TestMemory().setUp TestMemory().test_calculate_memory_overhead_on_host TestMemory Show source in test_memory.py:26 Unit Tests for Memory tasks. Signature class TestMemory(testtools.TestCase): ... TestMemory().setUp Show source in test_memory.py:29 Signature def setUp(self): ... TestMemory().test_calculate_memory_overhead_on_host Show source in test_memory.py:35 Performs a simple set of calculate_memory_overhead_on_host tests. Signature @mock.patch(\"pypowervm.wrappers.job.Job.wrap\") @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.wrappers.job.Job.create_job_parameter\") @mock.patch(\"pypowervm.wrappers.job.Job.get_job_results_as_dict\") def test_calculate_memory_overhead_on_host( self, mock_job_dict_res, mock_job_p, mock_run_job, mock_job_w ): ...","title":"TestMemory"},{"location":"pypowervm/tests/tasks/test_memory/#testmemory","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestMemory Auto-generated documentation for pypowervm.tests.tasks.test_memory module. TestMemory TestMemory TestMemory().setUp TestMemory().test_calculate_memory_overhead_on_host","title":"TestMemory"},{"location":"pypowervm/tests/tasks/test_memory/#testmemory_1","text":"Show source in test_memory.py:26 Unit Tests for Memory tasks.","title":"TestMemory"},{"location":"pypowervm/tests/tasks/test_memory/#signature","text":"class TestMemory(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_memory/#testmemorysetup","text":"Show source in test_memory.py:29","title":"TestMemory().setUp"},{"location":"pypowervm/tests/tasks/test_memory/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_memory/#testmemorytest_calculate_memory_overhead_on_host","text":"Show source in test_memory.py:35 Performs a simple set of calculate_memory_overhead_on_host tests.","title":"TestMemory().test_calculate_memory_overhead_on_host"},{"location":"pypowervm/tests/tasks/test_memory/#signature_2","text":"@mock.patch(\"pypowervm.wrappers.job.Job.wrap\") @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.wrappers.job.Job.create_job_parameter\") @mock.patch(\"pypowervm.wrappers.job.Job.get_job_results_as_dict\") def test_calculate_memory_overhead_on_host( self, mock_job_dict_res, mock_job_p, mock_run_job, mock_job_w ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/","text":"Test Mgmtconsole Pypowervm Index / Pypowervm / Tests / Tasks / Test Mgmtconsole Auto-generated documentation for pypowervm.tests.tasks.test_mgmtconsole module. Test Mgmtconsole TestMgmtCon TestMgmtCon().setUp TestMgmtCon().test_add_auth_key TestMgmtCon().test_get_auth_keys TestMgmtCon().test_get_public_key TestMgmtCon Show source in test_mgmtconsole.py:25 Unit Tests for ManagementConsole tasks. Signature class TestMgmtCon(testtools.TestCase): ... TestMgmtCon().setUp Show source in test_mgmtconsole.py:28 Signature def setUp(self): ... TestMgmtCon().test_add_auth_key Show source in test_mgmtconsole.py:44 Signature def test_add_auth_key(self): ... TestMgmtCon().test_get_auth_keys Show source in test_mgmtconsole.py:71 Signature def test_get_auth_keys(self): ... TestMgmtCon().test_get_public_key Show source in test_mgmtconsole.py:39 Signature def test_get_public_key(self): ...","title":"Test Mgmtconsole"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#test-mgmtconsole","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Test Mgmtconsole Auto-generated documentation for pypowervm.tests.tasks.test_mgmtconsole module. Test Mgmtconsole TestMgmtCon TestMgmtCon().setUp TestMgmtCon().test_add_auth_key TestMgmtCon().test_get_auth_keys TestMgmtCon().test_get_public_key","title":"Test Mgmtconsole"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#testmgmtcon","text":"Show source in test_mgmtconsole.py:25 Unit Tests for ManagementConsole tasks.","title":"TestMgmtCon"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#signature","text":"class TestMgmtCon(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#testmgmtconsetup","text":"Show source in test_mgmtconsole.py:28","title":"TestMgmtCon().setUp"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#testmgmtcontest_add_auth_key","text":"Show source in test_mgmtconsole.py:44","title":"TestMgmtCon().test_add_auth_key"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#signature_2","text":"def test_add_auth_key(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#testmgmtcontest_get_auth_keys","text":"Show source in test_mgmtconsole.py:71","title":"TestMgmtCon().test_get_auth_keys"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#signature_3","text":"def test_get_auth_keys(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#testmgmtcontest_get_public_key","text":"Show source in test_mgmtconsole.py:39","title":"TestMgmtCon().test_get_public_key"},{"location":"pypowervm/tests/tasks/test_mgmtconsole/#signature_4","text":"def test_get_public_key(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_migration/","text":"TestMigration Pypowervm Index / Pypowervm / Tests / Tasks / TestMigration Auto-generated documentation for pypowervm.tests.tasks.test_migration module. TestMigration TestMigration TestMigration().setUp TestMigration().test_migration TestMigration().test_migration_abort TestMigration().test_migration_recover TestMigration Show source in test_migration.py:26 Unit Tests for Migration. Signature class TestMigration(testtools.TestCase): ... TestMigration().setUp Show source in test_migration.py:29 Signature def setUp(self): ... TestMigration().test_migration Show source in test_migration.py:40 Signature @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_migration(self, mock_run_job): ... TestMigration().test_migration_abort Show source in test_migration.py:145 Signature @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_migration_abort(self, mock_run_job): ... TestMigration().test_migration_recover Show source in test_migration.py:124 Signature @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_migration_recover(self, mock_run_job): ...","title":"TestMigration"},{"location":"pypowervm/tests/tasks/test_migration/#testmigration","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestMigration Auto-generated documentation for pypowervm.tests.tasks.test_migration module. TestMigration TestMigration TestMigration().setUp TestMigration().test_migration TestMigration().test_migration_abort TestMigration().test_migration_recover","title":"TestMigration"},{"location":"pypowervm/tests/tasks/test_migration/#testmigration_1","text":"Show source in test_migration.py:26 Unit Tests for Migration.","title":"TestMigration"},{"location":"pypowervm/tests/tasks/test_migration/#signature","text":"class TestMigration(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_migration/#testmigrationsetup","text":"Show source in test_migration.py:29","title":"TestMigration().setUp"},{"location":"pypowervm/tests/tasks/test_migration/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_migration/#testmigrationtest_migration","text":"Show source in test_migration.py:40","title":"TestMigration().test_migration"},{"location":"pypowervm/tests/tasks/test_migration/#signature_2","text":"@mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_migration(self, mock_run_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_migration/#testmigrationtest_migration_abort","text":"Show source in test_migration.py:145","title":"TestMigration().test_migration_abort"},{"location":"pypowervm/tests/tasks/test_migration/#signature_3","text":"@mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_migration_abort(self, mock_run_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_migration/#testmigrationtest_migration_recover","text":"Show source in test_migration.py:124","title":"TestMigration().test_migration_recover"},{"location":"pypowervm/tests/tasks/test_migration/#signature_4","text":"@mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_migration_recover(self, mock_run_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/","text":"TestNetworkBridger Pypowervm Index / Pypowervm / Tests / Tasks / TestNetworkBridger Auto-generated documentation for pypowervm.tests.tasks.test_network_bridger module. TestNetworkBridger TestNetworkBridger TestNetworkBridger().setUp TestNetworkBridger().test_build_orphan_map TestNetworkBridger().test_ensure_vlan_on_nb TestNetworkBridger().test_ensure_vlan_on_nb_wrong_peer TestNetworkBridger().test_find_new_arbitrary_vid TestNetworkBridger().test_get_orphan_vlans TestNetworkBridger().test_is_arbitrary_vid TestNetworkBridger().test_remove_vlan_from_nb_bad_vid TestNetworkBridger().test_validate_orphan_on_ensure TestNetworkBridgerTA TestNetworkBridgerTA().setUp TestNetworkBridgerTA().test_ensure_vlan_on_nb_new_trunk TestNetworkBridgerTA().test_ensure_vlan_on_nb_new_vlan TestNetworkBridgerTA().test_ensure_vlan_on_nb_reassign TestNetworkBridgerTA().test_ensure_vlans_on_nb_new_vlan TestNetworkBridgerTA().test_find_available_min_trunk TestNetworkBridgerTA().test_find_available_trunks TestNetworkBridgerTA().test_find_available_trunks_1 TestNetworkBridgerTA().test_find_available_trunks_load_balance TestNetworkBridgerTA().test_find_peer_trunk TestNetworkBridgerTA().test_reassign_arbitrary_vid TestNetworkBridgerTA().test_remove_vlan_from_nb TestNetworkBridgerTA().test_remove_vlan_from_nb_arb_vid TestNetworkBridgerTA().test_remove_vlan_from_nb_lb TestNetworkBridgerVNet TestNetworkBridgerVNet().setUp TestNetworkBridgerVNet().test_ensure_vlan_on_nb_new_lg TestNetworkBridgerVNet().test_ensure_vlan_on_nb_new_vlan TestNetworkBridgerVNet().test_ensure_vlan_on_nb_reassign TestNetworkBridgerVNet().test_ensure_vlans_on_nb_new_vlan TestNetworkBridgerVNet().test_find_available_lg TestNetworkBridgerVNet().test_find_available_lg_load_balance TestNetworkBridgerVNet().test_find_available_min_lg TestNetworkBridgerVNet().test_find_or_create_vnet TestNetworkBridgerVNet().test_reassign_arbitrary_vid TestNetworkBridgerVNet().test_remove_vlan_from_nb TestNetworkBridgerVNet().test_remove_vlan_from_nb_lb TestNetworkBridger Show source in test_network_bridger.py:40 General tests for the Network Bridger superclass. Subclasses of Network Bridgers should extend this class. Signature class TestNetworkBridger(testtools.TestCase): ... TestNetworkBridger().setUp Show source in test_network_bridger.py:46 Signature def setUp(self): ... TestNetworkBridger().test_build_orphan_map Show source in test_network_bridger.py:149 Signature def test_build_orphan_map(self): ... TestNetworkBridger().test_ensure_vlan_on_nb Show source in test_network_bridger.py:69 This does a happy path test. Assumes VLAN on NB already. No subclass invocation. Signature def test_ensure_vlan_on_nb(self): ... TestNetworkBridger().test_ensure_vlan_on_nb_wrong_peer Show source in test_network_bridger.py:78 Test moving vlan from one peer to another. No subclass invocation. Signature @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._remove_vlan_from_nb_synch\") def test_ensure_vlan_on_nb_wrong_peer(self, mock_remove, mock_orphan): ... TestNetworkBridger().test_find_new_arbitrary_vid Show source in test_network_bridger.py:108 Signature def test_find_new_arbitrary_vid(self): ... TestNetworkBridger().test_get_orphan_vlans Show source in test_network_bridger.py:184 Tests the _get_orphan_vlans method. Signature def test_get_orphan_vlans(self): ... TestNetworkBridger().test_is_arbitrary_vid Show source in test_network_bridger.py:102 Signature def test_is_arbitrary_vid(self): ... TestNetworkBridger().test_remove_vlan_from_nb_bad_vid Show source in test_network_bridger.py:115 Attempt to remove a VID that can't be taken off NB. Signature def test_remove_vlan_from_nb_bad_vid(self): ... TestNetworkBridger().test_validate_orphan_on_ensure Show source in test_network_bridger.py:161 Tests the _validate_orphan_on_ensure method. Signature def test_validate_orphan_on_ensure(self): ... TestNetworkBridgerTA Show source in test_network_bridger.py:475 General tests for the network bridge super class and the VNet impl. Signature class TestNetworkBridgerTA(TestNetworkBridger): ... See also TestNetworkBridger TestNetworkBridgerTA().setUp Show source in test_network_bridger.py:478 Signature def setUp(self): ... TestNetworkBridgerTA().test_ensure_vlan_on_nb_new_trunk Show source in test_network_bridger.py:573 Validates new VLAN on new Load Group. Signature @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._get_orphan_vlans\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._find_available_trunks\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._is_arbitrary_vid\") def test_ensure_vlan_on_nb_new_trunk( self, mock_arb_vid, mock_avail_trunks, mock_orphan_validate, mock_orphan_vlans ): ... TestNetworkBridgerTA().test_ensure_vlan_on_nb_new_vlan Show source in test_network_bridger.py:512 Validates new VLAN on existing Trunk Adapter. Signature @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._is_arbitrary_vid\") def test_ensure_vlan_on_nb_new_vlan(self, mock_arb_vid, mock_orphan_validate): ... TestNetworkBridgerTA().test_ensure_vlan_on_nb_reassign Show source in test_network_bridger.py:482 Validates that after update, we support the VLAN. Signature @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._get_orphan_vlans\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._reassign_arbitrary_vid\") @mock.patch(\"pypowervm.wrappers.network.NetBridge.supports_vlan\") def test_ensure_vlan_on_nb_reassign( self, mock_support_vlan, mock_reassign, mock_orphan_validate, mock_orphan_vlans ): ... TestNetworkBridgerTA().test_ensure_vlans_on_nb_new_vlan Show source in test_network_bridger.py:544 Validates new VLAN on existing Load Group. Signature @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._is_arbitrary_vid\") def test_ensure_vlans_on_nb_new_vlan(self, mock_arb_vid, mock_orphan_validate): ... TestNetworkBridgerTA().test_find_available_min_trunk Show source in test_network_bridger.py:675 Signature @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._trunk_list\") def test_find_available_min_trunk(self, mock_trunk_list): ... TestNetworkBridgerTA().test_find_available_trunks Show source in test_network_bridger.py:645 Signature def test_find_available_trunks(self): ... TestNetworkBridgerTA().test_find_available_trunks_1 Show source in test_network_bridger.py:652 Signature def test_find_available_trunks_1(self): ... TestNetworkBridgerTA().test_find_available_trunks_load_balance Show source in test_network_bridger.py:662 Tests finding the trunk with load balancing enabled. Signature def test_find_available_trunks_load_balance(self): ... TestNetworkBridgerTA().test_find_peer_trunk Show source in test_network_bridger.py:697 Signature def test_find_peer_trunk(self): ... TestNetworkBridgerTA().test_reassign_arbitrary_vid Show source in test_network_bridger.py:609 Signature def test_reassign_arbitrary_vid(self): ... TestNetworkBridgerTA().test_remove_vlan_from_nb Show source in test_network_bridger.py:628 Happy path testing of the remove VLAN from NB. Signature def test_remove_vlan_from_nb(self): ... TestNetworkBridgerTA().test_remove_vlan_from_nb_arb_vid Show source in test_network_bridger.py:710 Attempt to remove an arbitrary VID off the network bridge. Signature @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._reassign_arbitrary_vid\") def test_remove_vlan_from_nb_arb_vid(self, mock_reassign): ... TestNetworkBridgerTA().test_remove_vlan_from_nb_lb Show source in test_network_bridger.py:724 Validates a load balance remove leaves an additional adpt. Signature def test_remove_vlan_from_nb_lb(self): ... TestNetworkBridgerVNet Show source in test_network_bridger.py:195 General tests for the network bridge super class and the VNet impl. Signature class TestNetworkBridgerVNet(TestNetworkBridger): ... See also TestNetworkBridger TestNetworkBridgerVNet().setUp Show source in test_network_bridger.py:198 Signature def setUp(self): ... TestNetworkBridgerVNet().test_ensure_vlan_on_nb_new_lg Show source in test_network_bridger.py:309 Validates new VLAN on new Load Group. Signature @mock.patch(\"oslo_concurrency.lockutils.lock\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._get_orphan_vlans\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_or_create_vnet\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_available_ld_grp\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._is_arbitrary_vid\") def test_ensure_vlan_on_nb_new_lg( self, mock_arb_vid, mock_avail_lg, mock_find_vnet, mock_orphan_validate, mock_orphan_vlans, mock_lock, ): ... TestNetworkBridgerVNet().test_ensure_vlan_on_nb_new_vlan Show source in test_network_bridger.py:234 Validates new VLAN on existing Load Group. Signature @mock.patch(\"oslo_concurrency.lockutils.lock\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_or_create_vnet\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._is_arbitrary_vid\") def test_ensure_vlan_on_nb_new_vlan( self, mock_arb_vid, mock_find_vnet, mock_orphan_validate, mock_lock ): ... TestNetworkBridgerVNet().test_ensure_vlan_on_nb_reassign Show source in test_network_bridger.py:202 Validates that after update, we support the VLAN. Signature @mock.patch(\"oslo_concurrency.lockutils.lock\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._get_orphan_vlans\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._reassign_arbitrary_vid\") @mock.patch(\"pypowervm.wrappers.network.NetBridge.supports_vlan\") def test_ensure_vlan_on_nb_reassign( self, mock_support_vlan, mock_reassign, mock_orphan_validate, mock_orphans, mock_lock ): ... TestNetworkBridgerVNet().test_ensure_vlans_on_nb_new_vlan Show source in test_network_bridger.py:273 Validates new VLAN on existing Load Group. Signature @mock.patch(\"oslo_concurrency.lockutils.lock\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_or_create_vnet\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._is_arbitrary_vid\") def test_ensure_vlans_on_nb_new_vlan( self, mock_arb_vid, mock_find_vnet, mock_orphan_validate, mock_lock ): ... TestNetworkBridgerVNet().test_find_available_lg Show source in test_network_bridger.py:442 Signature def test_find_available_lg(self): ... TestNetworkBridgerVNet().test_find_available_lg_load_balance Show source in test_network_bridger.py:448 Tests finding the Load Group with load balancing enabled. Signature def test_find_available_lg_load_balance(self): ... TestNetworkBridgerVNet().test_find_available_min_lg Show source in test_network_bridger.py:461 Signature def test_find_available_min_lg(self): ... TestNetworkBridgerVNet().test_find_or_create_vnet Show source in test_network_bridger.py:419 Validates that a vnet is created (and deleted) as part of find. Signature def test_find_or_create_vnet(self): ... TestNetworkBridgerVNet().test_reassign_arbitrary_vid Show source in test_network_bridger.py:356 Signature @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_or_create_vnet\") def test_reassign_arbitrary_vid(self, mock_find_vnet): ... TestNetworkBridgerVNet().test_remove_vlan_from_nb Show source in test_network_bridger.py:380 Happy path testing of the remove VLAN from NB. Signature @mock.patch(\"oslo_concurrency.lockutils.lock\") def test_remove_vlan_from_nb(self, mock_lock): ... TestNetworkBridgerVNet().test_remove_vlan_from_nb_lb Show source in test_network_bridger.py:399 Validates a load balance leaves two total LoadGroups. Signature @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_vnet_uri_from_lg\") def test_remove_vlan_from_nb_lb(self, mock_find_vnet): ...","title":"TestNetworkBridger"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridger","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestNetworkBridger Auto-generated documentation for pypowervm.tests.tasks.test_network_bridger module. TestNetworkBridger TestNetworkBridger TestNetworkBridger().setUp TestNetworkBridger().test_build_orphan_map TestNetworkBridger().test_ensure_vlan_on_nb TestNetworkBridger().test_ensure_vlan_on_nb_wrong_peer TestNetworkBridger().test_find_new_arbitrary_vid TestNetworkBridger().test_get_orphan_vlans TestNetworkBridger().test_is_arbitrary_vid TestNetworkBridger().test_remove_vlan_from_nb_bad_vid TestNetworkBridger().test_validate_orphan_on_ensure TestNetworkBridgerTA TestNetworkBridgerTA().setUp TestNetworkBridgerTA().test_ensure_vlan_on_nb_new_trunk TestNetworkBridgerTA().test_ensure_vlan_on_nb_new_vlan TestNetworkBridgerTA().test_ensure_vlan_on_nb_reassign TestNetworkBridgerTA().test_ensure_vlans_on_nb_new_vlan TestNetworkBridgerTA().test_find_available_min_trunk TestNetworkBridgerTA().test_find_available_trunks TestNetworkBridgerTA().test_find_available_trunks_1 TestNetworkBridgerTA().test_find_available_trunks_load_balance TestNetworkBridgerTA().test_find_peer_trunk TestNetworkBridgerTA().test_reassign_arbitrary_vid TestNetworkBridgerTA().test_remove_vlan_from_nb TestNetworkBridgerTA().test_remove_vlan_from_nb_arb_vid TestNetworkBridgerTA().test_remove_vlan_from_nb_lb TestNetworkBridgerVNet TestNetworkBridgerVNet().setUp TestNetworkBridgerVNet().test_ensure_vlan_on_nb_new_lg TestNetworkBridgerVNet().test_ensure_vlan_on_nb_new_vlan TestNetworkBridgerVNet().test_ensure_vlan_on_nb_reassign TestNetworkBridgerVNet().test_ensure_vlans_on_nb_new_vlan TestNetworkBridgerVNet().test_find_available_lg TestNetworkBridgerVNet().test_find_available_lg_load_balance TestNetworkBridgerVNet().test_find_available_min_lg TestNetworkBridgerVNet().test_find_or_create_vnet TestNetworkBridgerVNet().test_reassign_arbitrary_vid TestNetworkBridgerVNet().test_remove_vlan_from_nb TestNetworkBridgerVNet().test_remove_vlan_from_nb_lb","title":"TestNetworkBridger"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridger_1","text":"Show source in test_network_bridger.py:40 General tests for the Network Bridger superclass. Subclasses of Network Bridgers should extend this class.","title":"TestNetworkBridger"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature","text":"class TestNetworkBridger(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgersetup","text":"Show source in test_network_bridger.py:46","title":"TestNetworkBridger().setUp"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertest_build_orphan_map","text":"Show source in test_network_bridger.py:149","title":"TestNetworkBridger().test_build_orphan_map"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_2","text":"def test_build_orphan_map(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertest_ensure_vlan_on_nb","text":"Show source in test_network_bridger.py:69 This does a happy path test. Assumes VLAN on NB already. No subclass invocation.","title":"TestNetworkBridger().test_ensure_vlan_on_nb"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_3","text":"def test_ensure_vlan_on_nb(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertest_ensure_vlan_on_nb_wrong_peer","text":"Show source in test_network_bridger.py:78 Test moving vlan from one peer to another. No subclass invocation.","title":"TestNetworkBridger().test_ensure_vlan_on_nb_wrong_peer"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_4","text":"@mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._remove_vlan_from_nb_synch\") def test_ensure_vlan_on_nb_wrong_peer(self, mock_remove, mock_orphan): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertest_find_new_arbitrary_vid","text":"Show source in test_network_bridger.py:108","title":"TestNetworkBridger().test_find_new_arbitrary_vid"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_5","text":"def test_find_new_arbitrary_vid(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertest_get_orphan_vlans","text":"Show source in test_network_bridger.py:184 Tests the _get_orphan_vlans method.","title":"TestNetworkBridger().test_get_orphan_vlans"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_6","text":"def test_get_orphan_vlans(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertest_is_arbitrary_vid","text":"Show source in test_network_bridger.py:102","title":"TestNetworkBridger().test_is_arbitrary_vid"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_7","text":"def test_is_arbitrary_vid(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertest_remove_vlan_from_nb_bad_vid","text":"Show source in test_network_bridger.py:115 Attempt to remove a VID that can't be taken off NB.","title":"TestNetworkBridger().test_remove_vlan_from_nb_bad_vid"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_8","text":"def test_remove_vlan_from_nb_bad_vid(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertest_validate_orphan_on_ensure","text":"Show source in test_network_bridger.py:161 Tests the _validate_orphan_on_ensure method.","title":"TestNetworkBridger().test_validate_orphan_on_ensure"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_9","text":"def test_validate_orphan_on_ensure(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgerta","text":"Show source in test_network_bridger.py:475 General tests for the network bridge super class and the VNet impl.","title":"TestNetworkBridgerTA"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_10","text":"class TestNetworkBridgerTA(TestNetworkBridger): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#see-also","text":"TestNetworkBridger","title":"See also"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertasetup","text":"Show source in test_network_bridger.py:478","title":"TestNetworkBridgerTA().setUp"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_11","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_ensure_vlan_on_nb_new_trunk","text":"Show source in test_network_bridger.py:573 Validates new VLAN on new Load Group.","title":"TestNetworkBridgerTA().test_ensure_vlan_on_nb_new_trunk"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_12","text":"@mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._get_orphan_vlans\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._find_available_trunks\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._is_arbitrary_vid\") def test_ensure_vlan_on_nb_new_trunk( self, mock_arb_vid, mock_avail_trunks, mock_orphan_validate, mock_orphan_vlans ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_ensure_vlan_on_nb_new_vlan","text":"Show source in test_network_bridger.py:512 Validates new VLAN on existing Trunk Adapter.","title":"TestNetworkBridgerTA().test_ensure_vlan_on_nb_new_vlan"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_13","text":"@mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._is_arbitrary_vid\") def test_ensure_vlan_on_nb_new_vlan(self, mock_arb_vid, mock_orphan_validate): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_ensure_vlan_on_nb_reassign","text":"Show source in test_network_bridger.py:482 Validates that after update, we support the VLAN.","title":"TestNetworkBridgerTA().test_ensure_vlan_on_nb_reassign"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_14","text":"@mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._get_orphan_vlans\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._reassign_arbitrary_vid\") @mock.patch(\"pypowervm.wrappers.network.NetBridge.supports_vlan\") def test_ensure_vlan_on_nb_reassign( self, mock_support_vlan, mock_reassign, mock_orphan_validate, mock_orphan_vlans ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_ensure_vlans_on_nb_new_vlan","text":"Show source in test_network_bridger.py:544 Validates new VLAN on existing Load Group.","title":"TestNetworkBridgerTA().test_ensure_vlans_on_nb_new_vlan"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_15","text":"@mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._is_arbitrary_vid\") def test_ensure_vlans_on_nb_new_vlan(self, mock_arb_vid, mock_orphan_validate): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_find_available_min_trunk","text":"Show source in test_network_bridger.py:675","title":"TestNetworkBridgerTA().test_find_available_min_trunk"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_16","text":"@mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._trunk_list\") def test_find_available_min_trunk(self, mock_trunk_list): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_find_available_trunks","text":"Show source in test_network_bridger.py:645","title":"TestNetworkBridgerTA().test_find_available_trunks"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_17","text":"def test_find_available_trunks(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_find_available_trunks_1","text":"Show source in test_network_bridger.py:652","title":"TestNetworkBridgerTA().test_find_available_trunks_1"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_18","text":"def test_find_available_trunks_1(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_find_available_trunks_load_balance","text":"Show source in test_network_bridger.py:662 Tests finding the trunk with load balancing enabled.","title":"TestNetworkBridgerTA().test_find_available_trunks_load_balance"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_19","text":"def test_find_available_trunks_load_balance(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_find_peer_trunk","text":"Show source in test_network_bridger.py:697","title":"TestNetworkBridgerTA().test_find_peer_trunk"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_20","text":"def test_find_peer_trunk(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_reassign_arbitrary_vid","text":"Show source in test_network_bridger.py:609","title":"TestNetworkBridgerTA().test_reassign_arbitrary_vid"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_21","text":"def test_reassign_arbitrary_vid(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_remove_vlan_from_nb","text":"Show source in test_network_bridger.py:628 Happy path testing of the remove VLAN from NB.","title":"TestNetworkBridgerTA().test_remove_vlan_from_nb"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_22","text":"def test_remove_vlan_from_nb(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_remove_vlan_from_nb_arb_vid","text":"Show source in test_network_bridger.py:710 Attempt to remove an arbitrary VID off the network bridge.","title":"TestNetworkBridgerTA().test_remove_vlan_from_nb_arb_vid"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_23","text":"@mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerTA._reassign_arbitrary_vid\") def test_remove_vlan_from_nb_arb_vid(self, mock_reassign): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgertatest_remove_vlan_from_nb_lb","text":"Show source in test_network_bridger.py:724 Validates a load balance remove leaves an additional adpt.","title":"TestNetworkBridgerTA().test_remove_vlan_from_nb_lb"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_24","text":"def test_remove_vlan_from_nb_lb(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnet","text":"Show source in test_network_bridger.py:195 General tests for the network bridge super class and the VNet impl.","title":"TestNetworkBridgerVNet"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_25","text":"class TestNetworkBridgerVNet(TestNetworkBridger): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#see-also_1","text":"TestNetworkBridger","title":"See also"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnetsetup","text":"Show source in test_network_bridger.py:198","title":"TestNetworkBridgerVNet().setUp"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_26","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_ensure_vlan_on_nb_new_lg","text":"Show source in test_network_bridger.py:309 Validates new VLAN on new Load Group.","title":"TestNetworkBridgerVNet().test_ensure_vlan_on_nb_new_lg"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_27","text":"@mock.patch(\"oslo_concurrency.lockutils.lock\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._get_orphan_vlans\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_or_create_vnet\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_available_ld_grp\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._is_arbitrary_vid\") def test_ensure_vlan_on_nb_new_lg( self, mock_arb_vid, mock_avail_lg, mock_find_vnet, mock_orphan_validate, mock_orphan_vlans, mock_lock, ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_ensure_vlan_on_nb_new_vlan","text":"Show source in test_network_bridger.py:234 Validates new VLAN on existing Load Group.","title":"TestNetworkBridgerVNet().test_ensure_vlan_on_nb_new_vlan"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_28","text":"@mock.patch(\"oslo_concurrency.lockutils.lock\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_or_create_vnet\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._is_arbitrary_vid\") def test_ensure_vlan_on_nb_new_vlan( self, mock_arb_vid, mock_find_vnet, mock_orphan_validate, mock_lock ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_ensure_vlan_on_nb_reassign","text":"Show source in test_network_bridger.py:202 Validates that after update, we support the VLAN.","title":"TestNetworkBridgerVNet().test_ensure_vlan_on_nb_reassign"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_29","text":"@mock.patch(\"oslo_concurrency.lockutils.lock\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._get_orphan_vlans\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._reassign_arbitrary_vid\") @mock.patch(\"pypowervm.wrappers.network.NetBridge.supports_vlan\") def test_ensure_vlan_on_nb_reassign( self, mock_support_vlan, mock_reassign, mock_orphan_validate, mock_orphans, mock_lock ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_ensure_vlans_on_nb_new_vlan","text":"Show source in test_network_bridger.py:273 Validates new VLAN on existing Load Group.","title":"TestNetworkBridgerVNet().test_ensure_vlans_on_nb_new_vlan"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_30","text":"@mock.patch(\"oslo_concurrency.lockutils.lock\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridger._validate_orphan_on_ensure\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_or_create_vnet\") @mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._is_arbitrary_vid\") def test_ensure_vlans_on_nb_new_vlan( self, mock_arb_vid, mock_find_vnet, mock_orphan_validate, mock_lock ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_find_available_lg","text":"Show source in test_network_bridger.py:442","title":"TestNetworkBridgerVNet().test_find_available_lg"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_31","text":"def test_find_available_lg(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_find_available_lg_load_balance","text":"Show source in test_network_bridger.py:448 Tests finding the Load Group with load balancing enabled.","title":"TestNetworkBridgerVNet().test_find_available_lg_load_balance"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_32","text":"def test_find_available_lg_load_balance(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_find_available_min_lg","text":"Show source in test_network_bridger.py:461","title":"TestNetworkBridgerVNet().test_find_available_min_lg"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_33","text":"def test_find_available_min_lg(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_find_or_create_vnet","text":"Show source in test_network_bridger.py:419 Validates that a vnet is created (and deleted) as part of find.","title":"TestNetworkBridgerVNet().test_find_or_create_vnet"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_34","text":"def test_find_or_create_vnet(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_reassign_arbitrary_vid","text":"Show source in test_network_bridger.py:356","title":"TestNetworkBridgerVNet().test_reassign_arbitrary_vid"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_35","text":"@mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_or_create_vnet\") def test_reassign_arbitrary_vid(self, mock_find_vnet): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_remove_vlan_from_nb","text":"Show source in test_network_bridger.py:380 Happy path testing of the remove VLAN from NB.","title":"TestNetworkBridgerVNet().test_remove_vlan_from_nb"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_36","text":"@mock.patch(\"oslo_concurrency.lockutils.lock\") def test_remove_vlan_from_nb(self, mock_lock): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_network_bridger/#testnetworkbridgervnettest_remove_vlan_from_nb_lb","text":"Show source in test_network_bridger.py:399 Validates a load balance leaves two total LoadGroups.","title":"TestNetworkBridgerVNet().test_remove_vlan_from_nb_lb"},{"location":"pypowervm/tests/tasks/test_network_bridger/#signature_37","text":"@mock.patch(\"pypowervm.tasks.network_bridger.NetworkBridgerVNET._find_vnet_uri_from_lg\") def test_remove_vlan_from_nb_lb(self, mock_find_vnet): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/","text":"TestPartition Pypowervm Index / Pypowervm / Tests / Tasks / TestPartition Auto-generated documentation for pypowervm.tests.tasks.test_partition module. TestPartition TestPartition TestPartition().setUp TestPartition().test_get_me TestPartition().test_get_mgmt_lpar TestPartition().test_get_mgmt_none TestPartition().test_get_mgmt_vio TestPartition().test_has_physical_io TestVios TestVios().setUp TestVios().test_build_active_vio_feed_task TestVios().test_build_tx_feed_task_w_empty_feed TestVios().test_clone_uuid TestVios().test_exception_and_good_path TestVios().test_get_active_vioses TestVios().test_get_active_vioses_w_vios_wraps TestVios().test_get_partitions TestVios().test_get_physical_wwpns TestVios().test_max_wait_on_exception TestVios().test_no_vioses TestVios().test_rmc_down_vioses TestVios().test_timeout_short mock_vios TestPartition Show source in test_partition.py:47 Signature class TestPartition(testtools.TestCase): ... TestPartition().setUp Show source in test_partition.py:49 Signature def setUp(self): ... TestPartition().test_get_me Show source in test_partition.py:85 Test get_this_partition(). Signature @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.search\") @mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.search\") @mock.patch(\"pypowervm.util.my_partition_id\") def test_get_me(self, mock_my_id, mock_lp_search, mock_vio_search): ... TestPartition().test_get_mgmt_lpar Show source in test_partition.py:58 Happy path where the LPAR is the mgmt VM is a LPAR. Signature def test_get_mgmt_lpar(self): ... TestPartition().test_get_mgmt_none Show source in test_partition.py:78 Failure path with no mgmt VMs. Signature def test_get_mgmt_none(self): ... TestPartition().test_get_mgmt_vio Show source in test_partition.py:68 Happy path where the LPAR is the mgmt VM is a VIOS. Signature def test_get_mgmt_vio(self): ... TestPartition().test_has_physical_io Show source in test_partition.py:117 test partition has physical io. Signature def test_has_physical_io(self): ... TestVios Show source in test_partition.py:136 Signature class TestVios(twrap.TestWrapper): ... TestVios().setUp Show source in test_partition.py:140 Signature def setUp(self): ... TestVios().test_build_active_vio_feed_task Show source in test_partition.py:212 Signature @mock.patch(\"pypowervm.tasks.partition.get_active_vioses\") @mock.patch(\"pypowervm.utils.transaction.FeedTask\") def test_build_active_vio_feed_task(self, mock_feed_task, mock_get_active_vioses): ... TestVios().test_build_tx_feed_task_w_empty_feed Show source in test_partition.py:223 Signature @mock.patch(\"pypowervm.tasks.partition.get_active_vioses\") def test_build_tx_feed_task_w_empty_feed(self, mock_get_active_vioses): ... TestVios().test_clone_uuid Show source in test_partition.py:362 Signature @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_clone_uuid(self, mock_run_job): ... TestVios().test_exception_and_good_path Show source in test_partition.py:305 VIOS.get raises, then succeeds with some halfsies, then succeeds. Signature @mock.patch(\"pypowervm.tasks.partition.LOG.warning\") def test_exception_and_good_path(self, mock_warn): ... TestVios().test_get_active_vioses Show source in test_partition.py:149 Signature def test_get_active_vioses(self): ... TestVios().test_get_active_vioses_w_vios_wraps Show source in test_partition.py:173 Signature def test_get_active_vioses_w_vios_wraps(self): ... TestVios().test_get_partitions Show source in test_partition.py:322 Signature @mock.patch(\"pypowervm.tasks.partition.get_mgmt_partition\") @mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.get\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") def test_get_partitions(self, mock_vio_get, mock_lpar_get, mock_mgmt_get): ... TestVios().test_get_physical_wwpns Show source in test_partition.py:194 Signature def test_get_physical_wwpns(self): ... TestVios().test_max_wait_on_exception Show source in test_partition.py:297 VIOS.get raises repeatedly until max_wait_time is exceeded. Signature @mock.patch(\"pypowervm.tasks.partition.LOG.warning\") def test_max_wait_on_exception(self, mock_warn): ... TestVios().test_no_vioses Show source in test_partition.py:290 In the (highly unusual) case of no VIOSes, no warning, but raise. Signature @mock.patch(\"pypowervm.tasks.partition.LOG.warning\") def test_no_vioses(self, mock_warn): ... TestVios().test_rmc_down_vioses Show source in test_partition.py:272 Time out waiting for up/inactive partitions, but succeed. Signature @mock.patch(\"pypowervm.tasks.partition.LOG.warning\") def test_rmc_down_vioses(self, mock_warn): ... TestVios().test_timeout_short Show source in test_partition.py:257 Short timeout because relevant VIOSes have been up a while. Signature @mock.patch(\"pypowervm.tasks.partition.LOG.warning\") def test_timeout_short(self, mock_warn): ... mock_vios Show source in test_partition.py:40 Signature def mock_vios(name, state, rmc_state, is_mgmt=False, uptime=3601): ...","title":"TestPartition"},{"location":"pypowervm/tests/tasks/test_partition/#testpartition","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestPartition Auto-generated documentation for pypowervm.tests.tasks.test_partition module. TestPartition TestPartition TestPartition().setUp TestPartition().test_get_me TestPartition().test_get_mgmt_lpar TestPartition().test_get_mgmt_none TestPartition().test_get_mgmt_vio TestPartition().test_has_physical_io TestVios TestVios().setUp TestVios().test_build_active_vio_feed_task TestVios().test_build_tx_feed_task_w_empty_feed TestVios().test_clone_uuid TestVios().test_exception_and_good_path TestVios().test_get_active_vioses TestVios().test_get_active_vioses_w_vios_wraps TestVios().test_get_partitions TestVios().test_get_physical_wwpns TestVios().test_max_wait_on_exception TestVios().test_no_vioses TestVios().test_rmc_down_vioses TestVios().test_timeout_short mock_vios","title":"TestPartition"},{"location":"pypowervm/tests/tasks/test_partition/#testpartition_1","text":"Show source in test_partition.py:47","title":"TestPartition"},{"location":"pypowervm/tests/tasks/test_partition/#signature","text":"class TestPartition(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testpartitionsetup","text":"Show source in test_partition.py:49","title":"TestPartition().setUp"},{"location":"pypowervm/tests/tasks/test_partition/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testpartitiontest_get_me","text":"Show source in test_partition.py:85 Test get_this_partition().","title":"TestPartition().test_get_me"},{"location":"pypowervm/tests/tasks/test_partition/#signature_2","text":"@mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.search\") @mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.search\") @mock.patch(\"pypowervm.util.my_partition_id\") def test_get_me(self, mock_my_id, mock_lp_search, mock_vio_search): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testpartitiontest_get_mgmt_lpar","text":"Show source in test_partition.py:58 Happy path where the LPAR is the mgmt VM is a LPAR.","title":"TestPartition().test_get_mgmt_lpar"},{"location":"pypowervm/tests/tasks/test_partition/#signature_3","text":"def test_get_mgmt_lpar(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testpartitiontest_get_mgmt_none","text":"Show source in test_partition.py:78 Failure path with no mgmt VMs.","title":"TestPartition().test_get_mgmt_none"},{"location":"pypowervm/tests/tasks/test_partition/#signature_4","text":"def test_get_mgmt_none(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testpartitiontest_get_mgmt_vio","text":"Show source in test_partition.py:68 Happy path where the LPAR is the mgmt VM is a VIOS.","title":"TestPartition().test_get_mgmt_vio"},{"location":"pypowervm/tests/tasks/test_partition/#signature_5","text":"def test_get_mgmt_vio(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testpartitiontest_has_physical_io","text":"Show source in test_partition.py:117 test partition has physical io.","title":"TestPartition().test_has_physical_io"},{"location":"pypowervm/tests/tasks/test_partition/#signature_6","text":"def test_has_physical_io(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testvios","text":"Show source in test_partition.py:136","title":"TestVios"},{"location":"pypowervm/tests/tasks/test_partition/#signature_7","text":"class TestVios(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviossetup","text":"Show source in test_partition.py:140","title":"TestVios().setUp"},{"location":"pypowervm/tests/tasks/test_partition/#signature_8","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_build_active_vio_feed_task","text":"Show source in test_partition.py:212","title":"TestVios().test_build_active_vio_feed_task"},{"location":"pypowervm/tests/tasks/test_partition/#signature_9","text":"@mock.patch(\"pypowervm.tasks.partition.get_active_vioses\") @mock.patch(\"pypowervm.utils.transaction.FeedTask\") def test_build_active_vio_feed_task(self, mock_feed_task, mock_get_active_vioses): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_build_tx_feed_task_w_empty_feed","text":"Show source in test_partition.py:223","title":"TestVios().test_build_tx_feed_task_w_empty_feed"},{"location":"pypowervm/tests/tasks/test_partition/#signature_10","text":"@mock.patch(\"pypowervm.tasks.partition.get_active_vioses\") def test_build_tx_feed_task_w_empty_feed(self, mock_get_active_vioses): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_clone_uuid","text":"Show source in test_partition.py:362","title":"TestVios().test_clone_uuid"},{"location":"pypowervm/tests/tasks/test_partition/#signature_11","text":"@mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_clone_uuid(self, mock_run_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_exception_and_good_path","text":"Show source in test_partition.py:305 VIOS.get raises, then succeeds with some halfsies, then succeeds.","title":"TestVios().test_exception_and_good_path"},{"location":"pypowervm/tests/tasks/test_partition/#signature_12","text":"@mock.patch(\"pypowervm.tasks.partition.LOG.warning\") def test_exception_and_good_path(self, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_get_active_vioses","text":"Show source in test_partition.py:149","title":"TestVios().test_get_active_vioses"},{"location":"pypowervm/tests/tasks/test_partition/#signature_13","text":"def test_get_active_vioses(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_get_active_vioses_w_vios_wraps","text":"Show source in test_partition.py:173","title":"TestVios().test_get_active_vioses_w_vios_wraps"},{"location":"pypowervm/tests/tasks/test_partition/#signature_14","text":"def test_get_active_vioses_w_vios_wraps(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_get_partitions","text":"Show source in test_partition.py:322","title":"TestVios().test_get_partitions"},{"location":"pypowervm/tests/tasks/test_partition/#signature_15","text":"@mock.patch(\"pypowervm.tasks.partition.get_mgmt_partition\") @mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.get\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") def test_get_partitions(self, mock_vio_get, mock_lpar_get, mock_mgmt_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_get_physical_wwpns","text":"Show source in test_partition.py:194","title":"TestVios().test_get_physical_wwpns"},{"location":"pypowervm/tests/tasks/test_partition/#signature_16","text":"def test_get_physical_wwpns(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_max_wait_on_exception","text":"Show source in test_partition.py:297 VIOS.get raises repeatedly until max_wait_time is exceeded.","title":"TestVios().test_max_wait_on_exception"},{"location":"pypowervm/tests/tasks/test_partition/#signature_17","text":"@mock.patch(\"pypowervm.tasks.partition.LOG.warning\") def test_max_wait_on_exception(self, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_no_vioses","text":"Show source in test_partition.py:290 In the (highly unusual) case of no VIOSes, no warning, but raise.","title":"TestVios().test_no_vioses"},{"location":"pypowervm/tests/tasks/test_partition/#signature_18","text":"@mock.patch(\"pypowervm.tasks.partition.LOG.warning\") def test_no_vioses(self, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_rmc_down_vioses","text":"Show source in test_partition.py:272 Time out waiting for up/inactive partitions, but succeed.","title":"TestVios().test_rmc_down_vioses"},{"location":"pypowervm/tests/tasks/test_partition/#signature_19","text":"@mock.patch(\"pypowervm.tasks.partition.LOG.warning\") def test_rmc_down_vioses(self, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#testviostest_timeout_short","text":"Show source in test_partition.py:257 Short timeout because relevant VIOSes have been up a while.","title":"TestVios().test_timeout_short"},{"location":"pypowervm/tests/tasks/test_partition/#signature_20","text":"@mock.patch(\"pypowervm.tasks.partition.LOG.warning\") def test_timeout_short(self, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_partition/#mock_vios","text":"Show source in test_partition.py:40","title":"mock_vios"},{"location":"pypowervm/tests/tasks/test_partition/#signature_21","text":"def mock_vios(name, state, rmc_state, is_mgmt=False, uptime=3601): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/","text":"TestPower Pypowervm Index / Pypowervm / Tests / Tasks / TestPower Auto-generated documentation for pypowervm.tests.tasks.test_power module. TestPower TestPower TestPower.efail TestPower.etimeout TestPower().mock_partition TestPower().setUp TestPower().test_pwroff_already_off TestPower().test_pwroff_force_immed TestPower().test_pwroff_new_opts TestPower().test_pwroff_progressive TestPower().test_pwroff_soft_ibmi_norm TestPower().test_pwroff_soft_no_retry TestPower().test_pwroff_soft_standard_fail TestPower().test_pwroff_soft_standard_no_rmc_no_retry TestPower().test_pwroff_soft_standard_timeout TestPower().test_pwron TestPower().test_pwron_already_on TestPower().test_pwrop_start TestPower().test_pwrop_stop TestPower().test_pwrop_stop_no_rmc TestPower().validate_run TestPower Show source in test_power.py:29 Signature class TestPower(testtools.TestCase): ... TestPower.efail Show source in test_power.py:90 Returns a JobRequestFailed exception. Signature @staticmethod def efail(error=\"error\"): ... TestPower.etimeout Show source in test_power.py:85 Returns a JobRequestTimedOut exception. Signature @staticmethod def etimeout(): ... TestPower().mock_partition Show source in test_power.py:95 Returns a mocked partition with the specified properties. Signature def mock_partition( self, env=pvm_bp.LPARType.AIXLINUX, rmc_state=pvm_bp.RMCState.ACTIVE, mgmt=False ): ... TestPower().setUp Show source in test_power.py:30 Signature def setUp(self): ... TestPower().test_pwroff_already_off Show source in test_power.py:449 PowerOff when the system is already powered off. Signature def test_pwroff_already_off(self): ... TestPower().test_pwroff_force_immed Show source in test_power.py:255 Test power_off with force_immediate=Force.TRUE. Signature def test_pwroff_force_immed(self): ... TestPower().test_pwroff_new_opts Show source in test_power.py:473 Test power_off where add_parms is PowerOffOpts (not legacy). Signature def test_pwroff_new_opts(self): ... TestPower().test_pwroff_progressive Show source in test_power.py:506 Signature @mock.patch(\"pypowervm.tasks.power._power_off_progressive\") def test_pwroff_progressive(self, mock_prog_internal): ... TestPower().test_pwroff_soft_ibmi_norm Show source in test_power.py:295 Soft PowerOff flow, IBMi, normal (no immediate). Signature def test_pwroff_soft_ibmi_norm(self): ... TestPower().test_pwroff_soft_no_retry Show source in test_power.py:378 Soft PowerOff, no retry. Signature def test_pwroff_soft_no_retry(self): ... TestPower().test_pwroff_soft_standard_fail Show source in test_power.py:400 Soft PowerOff flow, non-IBMi, with Job failure. Signature def test_pwroff_soft_standard_fail(self): ... TestPower().test_pwroff_soft_standard_no_rmc_no_retry Show source in test_power.py:425 Non-IBMi soft PowerOff does VSP normal if RMC is down; no retry. Signature def test_pwroff_soft_standard_no_rmc_no_retry(self): ... TestPower().test_pwroff_soft_standard_timeout Show source in test_power.py:340 Soft PowerOff flow, non-IBMi, with timeout. Signature def test_pwroff_soft_standard_timeout(self): ... TestPower().test_pwron Show source in test_power.py:194 Test the power_on method. Signature def test_pwron(self): ... TestPower().test_pwron_already_on Show source in test_power.py:244 PowerOn when the system is already powered on. Signature def test_pwron_already_on(self): ... TestPower().test_pwrop_start Show source in test_power.py:101 Test PowerOp.start. Signature def test_pwrop_start(self): ... TestPower().test_pwrop_stop Show source in test_power.py:142 Test PowerOp.stop. Signature def test_pwrop_stop(self): ... TestPower().test_pwrop_stop_no_rmc Show source in test_power.py:187 Test PowerOp.stop with bad RMC state. Signature def test_pwrop_stop_no_rmc(self): ... TestPower().validate_run Show source in test_power.py:48 Return side effect method to validate Adapter.read and Job.run_job. Arguments part - (Mock) partition wrapper. ex_suff - Expected Job suffix - \"PowerOn\" or \"PowerOff\" ex_parms - Set of expected JobParameter 'name=value' strings. ex_timeout - Expected timeout (int, seconds). ex_synch - Expected value of the 'synchronous' flag. result - The desired result of the run_job call. May be None (the run_job call \"succeeded\") or an instance of an exception to be raised (either JobRequestTimedOut or JobRequestFailed). nxt - When chaining side effects, pass the method to be assigned to the run_job side effect after this side effect runs. Typically the return from another validate_run() call. Returns A method suitable for assigning to self.run_job.side_effect. Signature def validate_run( self, part, ex_suff=\"PowerOff\", ex_parms=None, ex_timeout=1800, ex_synch=True, result=\"\", nxt=None, ): ...","title":"TestPower"},{"location":"pypowervm/tests/tasks/test_power/#testpower","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestPower Auto-generated documentation for pypowervm.tests.tasks.test_power module. TestPower TestPower TestPower.efail TestPower.etimeout TestPower().mock_partition TestPower().setUp TestPower().test_pwroff_already_off TestPower().test_pwroff_force_immed TestPower().test_pwroff_new_opts TestPower().test_pwroff_progressive TestPower().test_pwroff_soft_ibmi_norm TestPower().test_pwroff_soft_no_retry TestPower().test_pwroff_soft_standard_fail TestPower().test_pwroff_soft_standard_no_rmc_no_retry TestPower().test_pwroff_soft_standard_timeout TestPower().test_pwron TestPower().test_pwron_already_on TestPower().test_pwrop_start TestPower().test_pwrop_stop TestPower().test_pwrop_stop_no_rmc TestPower().validate_run","title":"TestPower"},{"location":"pypowervm/tests/tasks/test_power/#testpower_1","text":"Show source in test_power.py:29","title":"TestPower"},{"location":"pypowervm/tests/tasks/test_power/#signature","text":"class TestPower(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowerefail","text":"Show source in test_power.py:90 Returns a JobRequestFailed exception.","title":"TestPower.efail"},{"location":"pypowervm/tests/tasks/test_power/#signature_1","text":"@staticmethod def efail(error=\"error\"): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpoweretimeout","text":"Show source in test_power.py:85 Returns a JobRequestTimedOut exception.","title":"TestPower.etimeout"},{"location":"pypowervm/tests/tasks/test_power/#signature_2","text":"@staticmethod def etimeout(): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowermock_partition","text":"Show source in test_power.py:95 Returns a mocked partition with the specified properties.","title":"TestPower().mock_partition"},{"location":"pypowervm/tests/tasks/test_power/#signature_3","text":"def mock_partition( self, env=pvm_bp.LPARType.AIXLINUX, rmc_state=pvm_bp.RMCState.ACTIVE, mgmt=False ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowersetup","text":"Show source in test_power.py:30","title":"TestPower().setUp"},{"location":"pypowervm/tests/tasks/test_power/#signature_4","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwroff_already_off","text":"Show source in test_power.py:449 PowerOff when the system is already powered off.","title":"TestPower().test_pwroff_already_off"},{"location":"pypowervm/tests/tasks/test_power/#signature_5","text":"def test_pwroff_already_off(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwroff_force_immed","text":"Show source in test_power.py:255 Test power_off with force_immediate=Force.TRUE.","title":"TestPower().test_pwroff_force_immed"},{"location":"pypowervm/tests/tasks/test_power/#signature_6","text":"def test_pwroff_force_immed(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwroff_new_opts","text":"Show source in test_power.py:473 Test power_off where add_parms is PowerOffOpts (not legacy).","title":"TestPower().test_pwroff_new_opts"},{"location":"pypowervm/tests/tasks/test_power/#signature_7","text":"def test_pwroff_new_opts(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwroff_progressive","text":"Show source in test_power.py:506","title":"TestPower().test_pwroff_progressive"},{"location":"pypowervm/tests/tasks/test_power/#signature_8","text":"@mock.patch(\"pypowervm.tasks.power._power_off_progressive\") def test_pwroff_progressive(self, mock_prog_internal): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwroff_soft_ibmi_norm","text":"Show source in test_power.py:295 Soft PowerOff flow, IBMi, normal (no immediate).","title":"TestPower().test_pwroff_soft_ibmi_norm"},{"location":"pypowervm/tests/tasks/test_power/#signature_9","text":"def test_pwroff_soft_ibmi_norm(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwroff_soft_no_retry","text":"Show source in test_power.py:378 Soft PowerOff, no retry.","title":"TestPower().test_pwroff_soft_no_retry"},{"location":"pypowervm/tests/tasks/test_power/#signature_10","text":"def test_pwroff_soft_no_retry(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwroff_soft_standard_fail","text":"Show source in test_power.py:400 Soft PowerOff flow, non-IBMi, with Job failure.","title":"TestPower().test_pwroff_soft_standard_fail"},{"location":"pypowervm/tests/tasks/test_power/#signature_11","text":"def test_pwroff_soft_standard_fail(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwroff_soft_standard_no_rmc_no_retry","text":"Show source in test_power.py:425 Non-IBMi soft PowerOff does VSP normal if RMC is down; no retry.","title":"TestPower().test_pwroff_soft_standard_no_rmc_no_retry"},{"location":"pypowervm/tests/tasks/test_power/#signature_12","text":"def test_pwroff_soft_standard_no_rmc_no_retry(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwroff_soft_standard_timeout","text":"Show source in test_power.py:340 Soft PowerOff flow, non-IBMi, with timeout.","title":"TestPower().test_pwroff_soft_standard_timeout"},{"location":"pypowervm/tests/tasks/test_power/#signature_13","text":"def test_pwroff_soft_standard_timeout(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwron","text":"Show source in test_power.py:194 Test the power_on method.","title":"TestPower().test_pwron"},{"location":"pypowervm/tests/tasks/test_power/#signature_14","text":"def test_pwron(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwron_already_on","text":"Show source in test_power.py:244 PowerOn when the system is already powered on.","title":"TestPower().test_pwron_already_on"},{"location":"pypowervm/tests/tasks/test_power/#signature_15","text":"def test_pwron_already_on(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwrop_start","text":"Show source in test_power.py:101 Test PowerOp.start.","title":"TestPower().test_pwrop_start"},{"location":"pypowervm/tests/tasks/test_power/#signature_16","text":"def test_pwrop_start(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwrop_stop","text":"Show source in test_power.py:142 Test PowerOp.stop.","title":"TestPower().test_pwrop_stop"},{"location":"pypowervm/tests/tasks/test_power/#signature_17","text":"def test_pwrop_stop(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowertest_pwrop_stop_no_rmc","text":"Show source in test_power.py:187 Test PowerOp.stop with bad RMC state.","title":"TestPower().test_pwrop_stop_no_rmc"},{"location":"pypowervm/tests/tasks/test_power/#signature_18","text":"def test_pwrop_stop_no_rmc(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power/#testpowervalidate_run","text":"Show source in test_power.py:48 Return side effect method to validate Adapter.read and Job.run_job.","title":"TestPower().validate_run"},{"location":"pypowervm/tests/tasks/test_power/#arguments","text":"part - (Mock) partition wrapper. ex_suff - Expected Job suffix - \"PowerOn\" or \"PowerOff\" ex_parms - Set of expected JobParameter 'name=value' strings. ex_timeout - Expected timeout (int, seconds). ex_synch - Expected value of the 'synchronous' flag. result - The desired result of the run_job call. May be None (the run_job call \"succeeded\") or an instance of an exception to be raised (either JobRequestTimedOut or JobRequestFailed). nxt - When chaining side effects, pass the method to be assigned to the run_job side effect after this side effect runs. Typically the return from another validate_run() call.","title":"Arguments"},{"location":"pypowervm/tests/tasks/test_power/#returns","text":"A method suitable for assigning to self.run_job.side_effect.","title":"Returns"},{"location":"pypowervm/tests/tasks/test_power/#signature_19","text":"def validate_run( self, part, ex_suff=\"PowerOff\", ex_parms=None, ex_timeout=1800, ex_synch=True, result=\"\", nxt=None, ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power_opts/","text":"TestPowerOpts Pypowervm Index / Pypowervm / Tests / Tasks / TestPowerOpts Auto-generated documentation for pypowervm.tests.tasks.test_power_opts module. TestPowerOpts TestPowerOpts TestPowerOpts().test_enums TestPowerOpts().test_power_off_opts TestPowerOpts().test_power_on_opts TestPowerOpts().test_remove_optical TestPowerOpts Show source in test_power_opts.py:25 Signature class TestPowerOpts(testtools.TestCase): ... TestPowerOpts().test_enums Show source in test_power_opts.py:44 Signature def test_enums(self): ... TestPowerOpts().test_power_off_opts Show source in test_power_opts.py:137 Signature def test_power_off_opts(self): ... TestPowerOpts().test_power_on_opts Show source in test_power_opts.py:61 Signature def test_power_on_opts(self): ... TestPowerOpts().test_remove_optical Show source in test_power_opts.py:51 Signature def test_remove_optical(self): ...","title":"TestPowerOpts"},{"location":"pypowervm/tests/tasks/test_power_opts/#testpoweropts","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestPowerOpts Auto-generated documentation for pypowervm.tests.tasks.test_power_opts module. TestPowerOpts TestPowerOpts TestPowerOpts().test_enums TestPowerOpts().test_power_off_opts TestPowerOpts().test_power_on_opts TestPowerOpts().test_remove_optical","title":"TestPowerOpts"},{"location":"pypowervm/tests/tasks/test_power_opts/#testpoweropts_1","text":"Show source in test_power_opts.py:25","title":"TestPowerOpts"},{"location":"pypowervm/tests/tasks/test_power_opts/#signature","text":"class TestPowerOpts(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power_opts/#testpoweroptstest_enums","text":"Show source in test_power_opts.py:44","title":"TestPowerOpts().test_enums"},{"location":"pypowervm/tests/tasks/test_power_opts/#signature_1","text":"def test_enums(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power_opts/#testpoweroptstest_power_off_opts","text":"Show source in test_power_opts.py:137","title":"TestPowerOpts().test_power_off_opts"},{"location":"pypowervm/tests/tasks/test_power_opts/#signature_2","text":"def test_power_off_opts(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power_opts/#testpoweroptstest_power_on_opts","text":"Show source in test_power_opts.py:61","title":"TestPowerOpts().test_power_on_opts"},{"location":"pypowervm/tests/tasks/test_power_opts/#signature_3","text":"def test_power_on_opts(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_power_opts/#testpoweroptstest_remove_optical","text":"Show source in test_power_opts.py:51","title":"TestPowerOpts().test_remove_optical"},{"location":"pypowervm/tests/tasks/test_power_opts/#signature_4","text":"def test_remove_optical(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/","text":"TestSCSIMapper Pypowervm Index / Pypowervm / Tests / Tasks / TestSCSIMapper Auto-generated documentation for pypowervm.tests.tasks.test_scsi_mapper module. TestSCSIMapper TestSCSIMapper TestSCSIMapper().setUp TestSCSIMapper().test_add_map TestSCSIMapper().test_add_vscsi_mapping_root_uri TestSCSIMapper().test_detach_storage TestSCSIMapper().test_find_maps TestSCSIMapper().test_gen_match_func TestSCSIMapper().test_index_mappings TestSCSIMapper().test_mapping TestSCSIMapper().test_mapping_new_mapping TestSCSIMapper().test_mapping_retry TestSCSIMapper().test_remap_storage_vopt TestSCSIMapper().test_remove_pv_mapping_name TestSCSIMapper().test_remove_pv_mapping_udid TestSCSIMapper().test_remove_storage_lu_all TestSCSIMapper().test_remove_storage_lu_udid TestSCSIMapper().test_remove_storage_vdisk_name TestSCSIMapper().test_remove_storage_vdisk_udid TestSCSIMapper().test_remove_storage_vopt TestSCSIMapper().test_remove_storage_vopt_no_name_specified TestSCSIMapper().test_remove_storage_vopt_retry TestSCSIMapper().test_separate_mappings TestSCSIMapper Show source in test_scsi_mapper.py:33 Signature class TestSCSIMapper(testtools.TestCase): ... TestSCSIMapper().setUp Show source in test_scsi_mapper.py:35 Signature def setUp(self): ... TestSCSIMapper().test_add_map Show source in test_scsi_mapper.py:198 Tests the add_map method. Signature def test_add_map(self): ... TestSCSIMapper().test_add_vscsi_mapping_root_uri Show source in test_scsi_mapper.py:173 Signature def test_add_vscsi_mapping_root_uri(self): ... TestSCSIMapper().test_detach_storage Show source in test_scsi_mapper.py:497 Detach storage from some mappings. Signature def test_detach_storage(self): ... TestSCSIMapper().test_find_maps Show source in test_scsi_mapper.py:542 find_maps() tests not covered elsewhere. Signature def test_find_maps(self): ... TestSCSIMapper().test_gen_match_func Show source in test_scsi_mapper.py:672 Tests for gen_match_func. Signature def test_gen_match_func(self): ... TestSCSIMapper().test_index_mappings Show source in test_scsi_mapper.py:626 Signature def test_index_mappings(self): ... TestSCSIMapper().test_mapping Show source in test_scsi_mapper.py:62 Signature def test_mapping(self): ... TestSCSIMapper().test_mapping_new_mapping Show source in test_scsi_mapper.py:137 Fuse limit, slot number, LUA via add_vscsi_mapping. Signature def test_mapping_new_mapping(self): ... TestSCSIMapper().test_mapping_retry Show source in test_scsi_mapper.py:99 Tests that a mapping function will be retried. Signature def test_mapping_retry(self): ... TestSCSIMapper().test_remap_storage_vopt Show source in test_scsi_mapper.py:230 Signature def test_remap_storage_vopt(self): ... TestSCSIMapper().test_remove_pv_mapping_name Show source in test_scsi_mapper.py:488 Signature def test_remove_pv_mapping_name(self): ... TestSCSIMapper().test_remove_pv_mapping_udid Show source in test_scsi_mapper.py:491 Signature def test_remove_pv_mapping_udid(self): ... TestSCSIMapper().test_remove_storage_lu_all Show source in test_scsi_mapper.py:458 Signature def test_remove_storage_lu_all(self): ... TestSCSIMapper().test_remove_storage_lu_udid Show source in test_scsi_mapper.py:461 Signature def test_remove_storage_lu_udid(self): ... TestSCSIMapper().test_remove_storage_vdisk_name Show source in test_scsi_mapper.py:428 Signature def test_remove_storage_vdisk_name(self): ... TestSCSIMapper().test_remove_storage_vdisk_udid Show source in test_scsi_mapper.py:432 Signature def test_remove_storage_vdisk_udid(self): ... TestSCSIMapper().test_remove_storage_vopt Show source in test_scsi_mapper.py:304 Signature def test_remove_storage_vopt(self): ... TestSCSIMapper().test_remove_storage_vopt_no_name_specified Show source in test_scsi_mapper.py:345 Signature def test_remove_storage_vopt_no_name_specified(self): ... TestSCSIMapper().test_remove_storage_vopt_retry Show source in test_scsi_mapper.py:367 Tests removing the storage vOpt with multiple retries. Signature def test_remove_storage_vopt_retry(self): ... TestSCSIMapper().test_separate_mappings Show source in test_scsi_mapper.py:602 Signature def test_separate_mappings(self): ...","title":"TestSCSIMapper"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimapper","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestSCSIMapper Auto-generated documentation for pypowervm.tests.tasks.test_scsi_mapper module. TestSCSIMapper TestSCSIMapper TestSCSIMapper().setUp TestSCSIMapper().test_add_map TestSCSIMapper().test_add_vscsi_mapping_root_uri TestSCSIMapper().test_detach_storage TestSCSIMapper().test_find_maps TestSCSIMapper().test_gen_match_func TestSCSIMapper().test_index_mappings TestSCSIMapper().test_mapping TestSCSIMapper().test_mapping_new_mapping TestSCSIMapper().test_mapping_retry TestSCSIMapper().test_remap_storage_vopt TestSCSIMapper().test_remove_pv_mapping_name TestSCSIMapper().test_remove_pv_mapping_udid TestSCSIMapper().test_remove_storage_lu_all TestSCSIMapper().test_remove_storage_lu_udid TestSCSIMapper().test_remove_storage_vdisk_name TestSCSIMapper().test_remove_storage_vdisk_udid TestSCSIMapper().test_remove_storage_vopt TestSCSIMapper().test_remove_storage_vopt_no_name_specified TestSCSIMapper().test_remove_storage_vopt_retry TestSCSIMapper().test_separate_mappings","title":"TestSCSIMapper"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimapper_1","text":"Show source in test_scsi_mapper.py:33","title":"TestSCSIMapper"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature","text":"class TestSCSIMapper(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappersetup","text":"Show source in test_scsi_mapper.py:35","title":"TestSCSIMapper().setUp"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_add_map","text":"Show source in test_scsi_mapper.py:198 Tests the add_map method.","title":"TestSCSIMapper().test_add_map"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_2","text":"def test_add_map(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_add_vscsi_mapping_root_uri","text":"Show source in test_scsi_mapper.py:173","title":"TestSCSIMapper().test_add_vscsi_mapping_root_uri"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_3","text":"def test_add_vscsi_mapping_root_uri(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_detach_storage","text":"Show source in test_scsi_mapper.py:497 Detach storage from some mappings.","title":"TestSCSIMapper().test_detach_storage"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_4","text":"def test_detach_storage(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_find_maps","text":"Show source in test_scsi_mapper.py:542 find_maps() tests not covered elsewhere.","title":"TestSCSIMapper().test_find_maps"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_5","text":"def test_find_maps(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_gen_match_func","text":"Show source in test_scsi_mapper.py:672 Tests for gen_match_func.","title":"TestSCSIMapper().test_gen_match_func"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_6","text":"def test_gen_match_func(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_index_mappings","text":"Show source in test_scsi_mapper.py:626","title":"TestSCSIMapper().test_index_mappings"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_7","text":"def test_index_mappings(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_mapping","text":"Show source in test_scsi_mapper.py:62","title":"TestSCSIMapper().test_mapping"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_8","text":"def test_mapping(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_mapping_new_mapping","text":"Show source in test_scsi_mapper.py:137 Fuse limit, slot number, LUA via add_vscsi_mapping.","title":"TestSCSIMapper().test_mapping_new_mapping"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_9","text":"def test_mapping_new_mapping(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_mapping_retry","text":"Show source in test_scsi_mapper.py:99 Tests that a mapping function will be retried.","title":"TestSCSIMapper().test_mapping_retry"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_10","text":"def test_mapping_retry(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_remap_storage_vopt","text":"Show source in test_scsi_mapper.py:230","title":"TestSCSIMapper().test_remap_storage_vopt"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_11","text":"def test_remap_storage_vopt(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_remove_pv_mapping_name","text":"Show source in test_scsi_mapper.py:488","title":"TestSCSIMapper().test_remove_pv_mapping_name"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_12","text":"def test_remove_pv_mapping_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_remove_pv_mapping_udid","text":"Show source in test_scsi_mapper.py:491","title":"TestSCSIMapper().test_remove_pv_mapping_udid"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_13","text":"def test_remove_pv_mapping_udid(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_remove_storage_lu_all","text":"Show source in test_scsi_mapper.py:458","title":"TestSCSIMapper().test_remove_storage_lu_all"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_14","text":"def test_remove_storage_lu_all(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_remove_storage_lu_udid","text":"Show source in test_scsi_mapper.py:461","title":"TestSCSIMapper().test_remove_storage_lu_udid"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_15","text":"def test_remove_storage_lu_udid(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_remove_storage_vdisk_name","text":"Show source in test_scsi_mapper.py:428","title":"TestSCSIMapper().test_remove_storage_vdisk_name"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_16","text":"def test_remove_storage_vdisk_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_remove_storage_vdisk_udid","text":"Show source in test_scsi_mapper.py:432","title":"TestSCSIMapper().test_remove_storage_vdisk_udid"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_17","text":"def test_remove_storage_vdisk_udid(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_remove_storage_vopt","text":"Show source in test_scsi_mapper.py:304","title":"TestSCSIMapper().test_remove_storage_vopt"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_18","text":"def test_remove_storage_vopt(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_remove_storage_vopt_no_name_specified","text":"Show source in test_scsi_mapper.py:345","title":"TestSCSIMapper().test_remove_storage_vopt_no_name_specified"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_19","text":"def test_remove_storage_vopt_no_name_specified(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_remove_storage_vopt_retry","text":"Show source in test_scsi_mapper.py:367 Tests removing the storage vOpt with multiple retries.","title":"TestSCSIMapper().test_remove_storage_vopt_retry"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_20","text":"def test_remove_storage_vopt_retry(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#testscsimappertest_separate_mappings","text":"Show source in test_scsi_mapper.py:602","title":"TestSCSIMapper().test_separate_mappings"},{"location":"pypowervm/tests/tasks/test_scsi_mapper/#signature_21","text":"def test_separate_mappings(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/","text":"Test Slot Map Pypowervm Index / Pypowervm / Tests / Tasks / Test Slot Map Auto-generated documentation for pypowervm.tests.tasks.test_slot_map module. Attributes vio1 - Load data files just once, since the wrappers will be read-only: loadf(vios.VIOS, 'fake_vios_ssp_npiv.txt') Test Slot Map SlotMapTestImpl SlotMapTestImplLegacy SlotMapTestImplLegacy().delete SlotMapTestImplLegacy().load SlotMapTestImplLegacy().save TestRebuildSlotMap TestRebuildSlotMapLegacy TestRebuildSlotMapLegacy().setUp TestRebuildSlotMapLegacy().test_get_mgmt_vea_slot TestRebuildSlotMapLegacy().test_lu_vscsi_build_out_1 TestRebuildSlotMapLegacy().test_max_vslots TestRebuildSlotMapLegacy().test_mix_vscsi_build_out_1 TestRebuildSlotMapLegacy().test_more_pv_udids_than_dest_vioses_fails TestRebuildSlotMapLegacy().test_npiv_build_out TestRebuildSlotMapLegacy().test_pv_udid_not_found_on_dest TestRebuildSlotMapLegacy().test_pv_vscsi_build_out_1 TestRebuildSlotMapLegacy().test_rebuild_fails_w_vopt TestRebuildSlotMapLegacy().test_rebuild_w_vdisk TestRebuildSlotMapLegacy().test_vea_build_out TestRebuildSlotMapLegacy().test_vnic_build_out TestRebuildSlotMapLegacy().test_vscsi_build_out_arbitrary_dest_vioses TestRebuildSlotMapLegacy().test_vscsi_build_out_full_coverage TestSlotMapStore TestSlotMapStore().test_delete TestSlotMapStore().test_init_calls_load TestSlotMapStore().test_save_when_needed TestSlotMapStoreLegacy TestSlotMapStoreLegacy().test_drop_cna TestSlotMapStoreLegacy().test_drop_vfc_mapping TestSlotMapStoreLegacy().test_drop_vnet TestSlotMapStoreLegacy().test_drop_vnet_exception TestSlotMapStoreLegacy().test_drop_vscsi_mappings TestSlotMapStoreLegacy().test_init_calls_load TestSlotMapStoreLegacy().test_init_deserialize TestSlotMapStoreLegacy().test_ioclass_consts TestSlotMapStoreLegacy().test_max_vslots TestSlotMapStoreLegacy().test_register_cna TestSlotMapStoreLegacy().test_register_vfc_mapping TestSlotMapStoreLegacy().test_register_vnet TestSlotMapStoreLegacy().test_register_vnet_exception TestSlotMapStoreLegacy().test_register_vscsi_mappings TestSlotMapStoreLegacy().test_serialize_unserialize TestSlotMapStoreLegacy().test_serialized TestSlotMapStoreLegacy().test_vswitch_id2name loadf SlotMapTestImpl Show source in test_slot_map.py:61 New-style subclass overriding _load/_save/_delete. Signature class SlotMapTestImpl(slot_map.SlotMapStore): def __init__(self, inst_key, load=True, load_ret=None): ... SlotMapTestImplLegacy Show source in test_slot_map.py:45 Legacy subclass overriding load/save/delete directly. Signature class SlotMapTestImplLegacy(slot_map.SlotMapStore): def __init__(self, inst_key, load=True, load_ret=None): ... SlotMapTestImplLegacy().delete Show source in test_slot_map.py:57 Signature def delete(self): ... SlotMapTestImplLegacy().load Show source in test_slot_map.py:51 Signature def load(self): ... SlotMapTestImplLegacy().save Show source in test_slot_map.py:54 Signature def save(self): ... TestRebuildSlotMap Show source in test_slot_map.py:995 Test for RebuildSlotMap class with new-style SlotMapStore subclass. Tests BuildSlotMap class's get methods as well. Signature class TestRebuildSlotMap(TestRebuildSlotMapLegacy): def __init__(self, *args, **kwargs): ... See also TestRebuildSlotMapLegacy TestRebuildSlotMapLegacy Show source in test_slot_map.py:602 Test for RebuildSlotMap class with legacy SlotMapStore subclass. Tests BuildSlotMap class's get methods as well. Signature class TestRebuildSlotMapLegacy(testtools.TestCase): def __init__(self, *args, **kwargs): ... TestRebuildSlotMapLegacy().setUp Show source in test_slot_map.py:613 Signature def setUp(self): ... TestRebuildSlotMapLegacy().test_get_mgmt_vea_slot Show source in test_slot_map.py:618 Signature def test_get_mgmt_vea_slot(self): ... TestRebuildSlotMapLegacy().test_lu_vscsi_build_out_1 Show source in test_slot_map.py:752 Test RebuildSlotMap deterministic. Signature def test_lu_vscsi_build_out_1(self): ... TestRebuildSlotMapLegacy().test_max_vslots Show source in test_slot_map.py:686 Ensure max_vslots returns the set value, or 10 + highest slot. Signature def test_max_vslots(self): ... TestRebuildSlotMapLegacy().test_mix_vscsi_build_out_1 Show source in test_slot_map.py:812 Test RebuildSlotMap deterministic. Signature def test_mix_vscsi_build_out_1(self): ... TestRebuildSlotMapLegacy().test_more_pv_udids_than_dest_vioses_fails Show source in test_slot_map.py:920 Test RebuildSlotMap fails when there's not enough VIOSes. Signature def test_more_pv_udids_than_dest_vioses_fails(self): ... TestRebuildSlotMapLegacy().test_npiv_build_out Show source in test_slot_map.py:929 Test _npiv_build_out. Signature def test_npiv_build_out(self): ... TestRebuildSlotMapLegacy().test_pv_udid_not_found_on_dest Show source in test_slot_map.py:911 Test RebuildSlotMap fails when UDID not found on dest. Signature def test_pv_udid_not_found_on_dest(self): ... TestRebuildSlotMapLegacy().test_pv_vscsi_build_out_1 Show source in test_slot_map.py:780 Test RebuildSlotMap deterministic. Signature def test_pv_vscsi_build_out_1(self): ... TestRebuildSlotMapLegacy().test_rebuild_fails_w_vopt Show source in test_slot_map.py:716 Test RebuildSlotMap fails when a Vopt exists in topology. Signature def test_rebuild_fails_w_vopt(self): ... TestRebuildSlotMapLegacy().test_rebuild_w_vdisk Show source in test_slot_map.py:725 Test RebuildSlotMap deterministic. Signature def test_rebuild_w_vdisk(self): ... TestRebuildSlotMapLegacy().test_vea_build_out Show source in test_slot_map.py:644 Test _vea_build_out. Signature def test_vea_build_out(self): ... TestRebuildSlotMapLegacy().test_vnic_build_out Show source in test_slot_map.py:667 Test _vnic_build_out. Signature def test_vnic_build_out(self): ... TestRebuildSlotMapLegacy().test_vscsi_build_out_arbitrary_dest_vioses Show source in test_slot_map.py:839 Test RebuildSlotMap with multiple candidate dest VIOSes. Signature def test_vscsi_build_out_arbitrary_dest_vioses(self): ... TestRebuildSlotMapLegacy().test_vscsi_build_out_full_coverage Show source in test_slot_map.py:872 Test rebuild with 2 slots per udid and 2 candidate VIOSes. Signature def test_vscsi_build_out_full_coverage(self): ... TestSlotMapStore Show source in test_slot_map.py:539 Test slot_map.SlotMapStore with a new-style impl. Signature class TestSlotMapStore(TestSlotMapStoreLegacy): def __init__(self, *args, **kwargs): ... See also TestSlotMapStoreLegacy TestSlotMapStore().test_delete Show source in test_slot_map.py:594 Overridden _delete is called properly when delete is invoked. Signature def test_delete(self): ... TestSlotMapStore().test_init_calls_load Show source in test_slot_map.py:548 Ensure SlotMapStore. init calls load or not based on the parm. This overrides the legacy test of the same name to ensure that _load gets invoked properly. Signature def test_init_calls_load(self): ... TestSlotMapStore().test_save_when_needed Show source in test_slot_map.py:564 Overridden _save call invoked only when needed. Signature @mock.patch( \"pypowervm.tasks.slot_map.SlotMapStore.serialized\", new_callable=mock.PropertyMock ) def test_save_when_needed(self, mock_ser): ... TestSlotMapStoreLegacy Show source in test_slot_map.py:77 Test slot_map.SlotMapStore with a legacy impl. Signature class TestSlotMapStoreLegacy(testtools.TestCase): def __init__(self, *args, **kwargs): ... TestSlotMapStoreLegacy().test_drop_cna Show source in test_slot_map.py:173 Test deprecated drop_cna. Signature @mock.patch(\"warnings.warn\") def test_drop_cna(self, mock_warn): ... TestSlotMapStoreLegacy().test_drop_vfc_mapping Show source in test_slot_map.py:298 Test drop_vfc_mapping. Signature def test_drop_vfc_mapping(self): ... TestSlotMapStoreLegacy().test_drop_vnet Show source in test_slot_map.py:220 Test drop_vnet. Signature def test_drop_vnet(self): ... TestSlotMapStoreLegacy().test_drop_vnet_exception Show source in test_slot_map.py:248 Test drop_vnet raises exception without CNA or VNIC. Signature def test_drop_vnet_exception(self): ... TestSlotMapStoreLegacy().test_drop_vscsi_mappings Show source in test_slot_map.py:361 Test drop_vscsi_mappings. Signature def test_drop_vscsi_mappings(self): ... TestSlotMapStoreLegacy().test_init_calls_load Show source in test_slot_map.py:91 Ensure SlotMapStore. init calls load or not based on the parm. Signature def test_init_calls_load(self): ... TestSlotMapStoreLegacy().test_init_deserialize Show source in test_slot_map.py:103 Ensure init deserializes or not based on what's loaded. Signature @mock.patch(\"pickle.loads\") def test_init_deserialize(self, mock_unpickle): ... TestSlotMapStoreLegacy().test_ioclass_consts Show source in test_slot_map.py:85 Make sure the IOCLASS constants are disparate. Signature def test_ioclass_consts(self): ... TestSlotMapStoreLegacy().test_max_vslots Show source in test_slot_map.py:482 Test setting/getting the max_vslots. Signature def test_max_vslots(self): ... TestSlotMapStoreLegacy().test_register_cna Show source in test_slot_map.py:152 Test deprecated register_cna. Signature @mock.patch(\"pypowervm.wrappers.managed_system.System.get\") @mock.patch(\"pypowervm.wrappers.network.VSwitch.get\") @mock.patch(\"warnings.warn\") def test_register_cna(self, mock_warn, mock_vsw_get, mock_sys_get): ... TestSlotMapStoreLegacy().test_register_vfc_mapping Show source in test_slot_map.py:254 Test register_vfc_mapping. Signature def test_register_vfc_mapping(self): ... TestSlotMapStoreLegacy().test_register_vnet Show source in test_slot_map.py:192 Test register_vnet. Signature @mock.patch(\"pypowervm.wrappers.managed_system.System.get\") @mock.patch(\"pypowervm.wrappers.network.VSwitch.get\") def test_register_vnet(self, mock_vsw_get, mock_sys_get): ... TestSlotMapStoreLegacy().test_register_vnet_exception Show source in test_slot_map.py:214 Test register_vnet raises exception without CNA or VNIC. Signature def test_register_vnet_exception(self): ... TestSlotMapStoreLegacy().test_register_vscsi_mappings Show source in test_slot_map.py:324 Test register_vscsi_mappings. Signature def test_register_vscsi_mappings(self): ... TestSlotMapStoreLegacy().test_serialize_unserialize Show source in test_slot_map.py:457 Ensure that saving/loading doesn't corrupt the data. Signature @mock.patch(\"pypowervm.wrappers.managed_system.System.get\") @mock.patch(\"pypowervm.wrappers.network.VSwitch.get\") def test_serialize_unserialize(self, mock_vsw_get, mock_sys_get): ... TestSlotMapStoreLegacy().test_serialized Show source in test_slot_map.py:115 Validate the serialized property. Signature @mock.patch(\"pickle.dumps\") @mock.patch( \"pypowervm.tasks.slot_map.SlotMapStore.topology\", new_callable=mock.PropertyMock ) def test_serialized(self, mock_topo, mock_pickle): ... TestSlotMapStoreLegacy().test_vswitch_id2name Show source in test_slot_map.py:126 Ensure _vswitch_id2name caches, and gets the right content. Signature @mock.patch(\"pypowervm.wrappers.managed_system.System.get\") @mock.patch(\"pypowervm.wrappers.network.VSwitch.get\") def test_vswitch_id2name(self, mock_vsw_get, mock_sys_get): ... loadf Show source in test_slot_map.py:33 Signature def loadf(wcls, fname): ...","title":"Test Slot Map"},{"location":"pypowervm/tests/tasks/test_slot_map/#test-slot-map","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Test Slot Map Auto-generated documentation for pypowervm.tests.tasks.test_slot_map module.","title":"Test Slot Map"},{"location":"pypowervm/tests/tasks/test_slot_map/#attributes","text":"vio1 - Load data files just once, since the wrappers will be read-only: loadf(vios.VIOS, 'fake_vios_ssp_npiv.txt') Test Slot Map SlotMapTestImpl SlotMapTestImplLegacy SlotMapTestImplLegacy().delete SlotMapTestImplLegacy().load SlotMapTestImplLegacy().save TestRebuildSlotMap TestRebuildSlotMapLegacy TestRebuildSlotMapLegacy().setUp TestRebuildSlotMapLegacy().test_get_mgmt_vea_slot TestRebuildSlotMapLegacy().test_lu_vscsi_build_out_1 TestRebuildSlotMapLegacy().test_max_vslots TestRebuildSlotMapLegacy().test_mix_vscsi_build_out_1 TestRebuildSlotMapLegacy().test_more_pv_udids_than_dest_vioses_fails TestRebuildSlotMapLegacy().test_npiv_build_out TestRebuildSlotMapLegacy().test_pv_udid_not_found_on_dest TestRebuildSlotMapLegacy().test_pv_vscsi_build_out_1 TestRebuildSlotMapLegacy().test_rebuild_fails_w_vopt TestRebuildSlotMapLegacy().test_rebuild_w_vdisk TestRebuildSlotMapLegacy().test_vea_build_out TestRebuildSlotMapLegacy().test_vnic_build_out TestRebuildSlotMapLegacy().test_vscsi_build_out_arbitrary_dest_vioses TestRebuildSlotMapLegacy().test_vscsi_build_out_full_coverage TestSlotMapStore TestSlotMapStore().test_delete TestSlotMapStore().test_init_calls_load TestSlotMapStore().test_save_when_needed TestSlotMapStoreLegacy TestSlotMapStoreLegacy().test_drop_cna TestSlotMapStoreLegacy().test_drop_vfc_mapping TestSlotMapStoreLegacy().test_drop_vnet TestSlotMapStoreLegacy().test_drop_vnet_exception TestSlotMapStoreLegacy().test_drop_vscsi_mappings TestSlotMapStoreLegacy().test_init_calls_load TestSlotMapStoreLegacy().test_init_deserialize TestSlotMapStoreLegacy().test_ioclass_consts TestSlotMapStoreLegacy().test_max_vslots TestSlotMapStoreLegacy().test_register_cna TestSlotMapStoreLegacy().test_register_vfc_mapping TestSlotMapStoreLegacy().test_register_vnet TestSlotMapStoreLegacy().test_register_vnet_exception TestSlotMapStoreLegacy().test_register_vscsi_mappings TestSlotMapStoreLegacy().test_serialize_unserialize TestSlotMapStoreLegacy().test_serialized TestSlotMapStoreLegacy().test_vswitch_id2name loadf","title":"Attributes"},{"location":"pypowervm/tests/tasks/test_slot_map/#slotmaptestimpl","text":"Show source in test_slot_map.py:61 New-style subclass overriding _load/_save/_delete.","title":"SlotMapTestImpl"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature","text":"class SlotMapTestImpl(slot_map.SlotMapStore): def __init__(self, inst_key, load=True, load_ret=None): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#slotmaptestimpllegacy","text":"Show source in test_slot_map.py:45 Legacy subclass overriding load/save/delete directly.","title":"SlotMapTestImplLegacy"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_1","text":"class SlotMapTestImplLegacy(slot_map.SlotMapStore): def __init__(self, inst_key, load=True, load_ret=None): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#slotmaptestimpllegacydelete","text":"Show source in test_slot_map.py:57","title":"SlotMapTestImplLegacy().delete"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_2","text":"def delete(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#slotmaptestimpllegacyload","text":"Show source in test_slot_map.py:51","title":"SlotMapTestImplLegacy().load"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_3","text":"def load(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#slotmaptestimpllegacysave","text":"Show source in test_slot_map.py:54","title":"SlotMapTestImplLegacy().save"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_4","text":"def save(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmap","text":"Show source in test_slot_map.py:995 Test for RebuildSlotMap class with new-style SlotMapStore subclass. Tests BuildSlotMap class's get methods as well.","title":"TestRebuildSlotMap"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_5","text":"class TestRebuildSlotMap(TestRebuildSlotMapLegacy): def __init__(self, *args, **kwargs): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#see-also","text":"TestRebuildSlotMapLegacy","title":"See also"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacy","text":"Show source in test_slot_map.py:602 Test for RebuildSlotMap class with legacy SlotMapStore subclass. Tests BuildSlotMap class's get methods as well.","title":"TestRebuildSlotMapLegacy"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_6","text":"class TestRebuildSlotMapLegacy(testtools.TestCase): def __init__(self, *args, **kwargs): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacysetup","text":"Show source in test_slot_map.py:613","title":"TestRebuildSlotMapLegacy().setUp"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_7","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_get_mgmt_vea_slot","text":"Show source in test_slot_map.py:618","title":"TestRebuildSlotMapLegacy().test_get_mgmt_vea_slot"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_8","text":"def test_get_mgmt_vea_slot(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_lu_vscsi_build_out_1","text":"Show source in test_slot_map.py:752 Test RebuildSlotMap deterministic.","title":"TestRebuildSlotMapLegacy().test_lu_vscsi_build_out_1"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_9","text":"def test_lu_vscsi_build_out_1(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_max_vslots","text":"Show source in test_slot_map.py:686 Ensure max_vslots returns the set value, or 10 + highest slot.","title":"TestRebuildSlotMapLegacy().test_max_vslots"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_10","text":"def test_max_vslots(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_mix_vscsi_build_out_1","text":"Show source in test_slot_map.py:812 Test RebuildSlotMap deterministic.","title":"TestRebuildSlotMapLegacy().test_mix_vscsi_build_out_1"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_11","text":"def test_mix_vscsi_build_out_1(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_more_pv_udids_than_dest_vioses_fails","text":"Show source in test_slot_map.py:920 Test RebuildSlotMap fails when there's not enough VIOSes.","title":"TestRebuildSlotMapLegacy().test_more_pv_udids_than_dest_vioses_fails"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_12","text":"def test_more_pv_udids_than_dest_vioses_fails(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_npiv_build_out","text":"Show source in test_slot_map.py:929 Test _npiv_build_out.","title":"TestRebuildSlotMapLegacy().test_npiv_build_out"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_13","text":"def test_npiv_build_out(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_pv_udid_not_found_on_dest","text":"Show source in test_slot_map.py:911 Test RebuildSlotMap fails when UDID not found on dest.","title":"TestRebuildSlotMapLegacy().test_pv_udid_not_found_on_dest"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_14","text":"def test_pv_udid_not_found_on_dest(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_pv_vscsi_build_out_1","text":"Show source in test_slot_map.py:780 Test RebuildSlotMap deterministic.","title":"TestRebuildSlotMapLegacy().test_pv_vscsi_build_out_1"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_15","text":"def test_pv_vscsi_build_out_1(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_rebuild_fails_w_vopt","text":"Show source in test_slot_map.py:716 Test RebuildSlotMap fails when a Vopt exists in topology.","title":"TestRebuildSlotMapLegacy().test_rebuild_fails_w_vopt"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_16","text":"def test_rebuild_fails_w_vopt(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_rebuild_w_vdisk","text":"Show source in test_slot_map.py:725 Test RebuildSlotMap deterministic.","title":"TestRebuildSlotMapLegacy().test_rebuild_w_vdisk"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_17","text":"def test_rebuild_w_vdisk(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_vea_build_out","text":"Show source in test_slot_map.py:644 Test _vea_build_out.","title":"TestRebuildSlotMapLegacy().test_vea_build_out"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_18","text":"def test_vea_build_out(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_vnic_build_out","text":"Show source in test_slot_map.py:667 Test _vnic_build_out.","title":"TestRebuildSlotMapLegacy().test_vnic_build_out"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_19","text":"def test_vnic_build_out(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_vscsi_build_out_arbitrary_dest_vioses","text":"Show source in test_slot_map.py:839 Test RebuildSlotMap with multiple candidate dest VIOSes.","title":"TestRebuildSlotMapLegacy().test_vscsi_build_out_arbitrary_dest_vioses"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_20","text":"def test_vscsi_build_out_arbitrary_dest_vioses(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testrebuildslotmaplegacytest_vscsi_build_out_full_coverage","text":"Show source in test_slot_map.py:872 Test rebuild with 2 slots per udid and 2 candidate VIOSes.","title":"TestRebuildSlotMapLegacy().test_vscsi_build_out_full_coverage"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_21","text":"def test_vscsi_build_out_full_coverage(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstore","text":"Show source in test_slot_map.py:539 Test slot_map.SlotMapStore with a new-style impl.","title":"TestSlotMapStore"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_22","text":"class TestSlotMapStore(TestSlotMapStoreLegacy): def __init__(self, *args, **kwargs): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#see-also_1","text":"TestSlotMapStoreLegacy","title":"See also"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstoretest_delete","text":"Show source in test_slot_map.py:594 Overridden _delete is called properly when delete is invoked.","title":"TestSlotMapStore().test_delete"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_23","text":"def test_delete(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstoretest_init_calls_load","text":"Show source in test_slot_map.py:548 Ensure SlotMapStore. init calls load or not based on the parm. This overrides the legacy test of the same name to ensure that _load gets invoked properly.","title":"TestSlotMapStore().test_init_calls_load"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_24","text":"def test_init_calls_load(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstoretest_save_when_needed","text":"Show source in test_slot_map.py:564 Overridden _save call invoked only when needed.","title":"TestSlotMapStore().test_save_when_needed"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_25","text":"@mock.patch( \"pypowervm.tasks.slot_map.SlotMapStore.serialized\", new_callable=mock.PropertyMock ) def test_save_when_needed(self, mock_ser): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacy","text":"Show source in test_slot_map.py:77 Test slot_map.SlotMapStore with a legacy impl.","title":"TestSlotMapStoreLegacy"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_26","text":"class TestSlotMapStoreLegacy(testtools.TestCase): def __init__(self, *args, **kwargs): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_drop_cna","text":"Show source in test_slot_map.py:173 Test deprecated drop_cna.","title":"TestSlotMapStoreLegacy().test_drop_cna"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_27","text":"@mock.patch(\"warnings.warn\") def test_drop_cna(self, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_drop_vfc_mapping","text":"Show source in test_slot_map.py:298 Test drop_vfc_mapping.","title":"TestSlotMapStoreLegacy().test_drop_vfc_mapping"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_28","text":"def test_drop_vfc_mapping(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_drop_vnet","text":"Show source in test_slot_map.py:220 Test drop_vnet.","title":"TestSlotMapStoreLegacy().test_drop_vnet"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_29","text":"def test_drop_vnet(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_drop_vnet_exception","text":"Show source in test_slot_map.py:248 Test drop_vnet raises exception without CNA or VNIC.","title":"TestSlotMapStoreLegacy().test_drop_vnet_exception"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_30","text":"def test_drop_vnet_exception(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_drop_vscsi_mappings","text":"Show source in test_slot_map.py:361 Test drop_vscsi_mappings.","title":"TestSlotMapStoreLegacy().test_drop_vscsi_mappings"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_31","text":"def test_drop_vscsi_mappings(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_init_calls_load","text":"Show source in test_slot_map.py:91 Ensure SlotMapStore. init calls load or not based on the parm.","title":"TestSlotMapStoreLegacy().test_init_calls_load"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_32","text":"def test_init_calls_load(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_init_deserialize","text":"Show source in test_slot_map.py:103 Ensure init deserializes or not based on what's loaded.","title":"TestSlotMapStoreLegacy().test_init_deserialize"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_33","text":"@mock.patch(\"pickle.loads\") def test_init_deserialize(self, mock_unpickle): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_ioclass_consts","text":"Show source in test_slot_map.py:85 Make sure the IOCLASS constants are disparate.","title":"TestSlotMapStoreLegacy().test_ioclass_consts"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_34","text":"def test_ioclass_consts(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_max_vslots","text":"Show source in test_slot_map.py:482 Test setting/getting the max_vslots.","title":"TestSlotMapStoreLegacy().test_max_vslots"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_35","text":"def test_max_vslots(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_register_cna","text":"Show source in test_slot_map.py:152 Test deprecated register_cna.","title":"TestSlotMapStoreLegacy().test_register_cna"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_36","text":"@mock.patch(\"pypowervm.wrappers.managed_system.System.get\") @mock.patch(\"pypowervm.wrappers.network.VSwitch.get\") @mock.patch(\"warnings.warn\") def test_register_cna(self, mock_warn, mock_vsw_get, mock_sys_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_register_vfc_mapping","text":"Show source in test_slot_map.py:254 Test register_vfc_mapping.","title":"TestSlotMapStoreLegacy().test_register_vfc_mapping"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_37","text":"def test_register_vfc_mapping(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_register_vnet","text":"Show source in test_slot_map.py:192 Test register_vnet.","title":"TestSlotMapStoreLegacy().test_register_vnet"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_38","text":"@mock.patch(\"pypowervm.wrappers.managed_system.System.get\") @mock.patch(\"pypowervm.wrappers.network.VSwitch.get\") def test_register_vnet(self, mock_vsw_get, mock_sys_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_register_vnet_exception","text":"Show source in test_slot_map.py:214 Test register_vnet raises exception without CNA or VNIC.","title":"TestSlotMapStoreLegacy().test_register_vnet_exception"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_39","text":"def test_register_vnet_exception(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_register_vscsi_mappings","text":"Show source in test_slot_map.py:324 Test register_vscsi_mappings.","title":"TestSlotMapStoreLegacy().test_register_vscsi_mappings"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_40","text":"def test_register_vscsi_mappings(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_serialize_unserialize","text":"Show source in test_slot_map.py:457 Ensure that saving/loading doesn't corrupt the data.","title":"TestSlotMapStoreLegacy().test_serialize_unserialize"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_41","text":"@mock.patch(\"pypowervm.wrappers.managed_system.System.get\") @mock.patch(\"pypowervm.wrappers.network.VSwitch.get\") def test_serialize_unserialize(self, mock_vsw_get, mock_sys_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_serialized","text":"Show source in test_slot_map.py:115 Validate the serialized property.","title":"TestSlotMapStoreLegacy().test_serialized"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_42","text":"@mock.patch(\"pickle.dumps\") @mock.patch( \"pypowervm.tasks.slot_map.SlotMapStore.topology\", new_callable=mock.PropertyMock ) def test_serialized(self, mock_topo, mock_pickle): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#testslotmapstorelegacytest_vswitch_id2name","text":"Show source in test_slot_map.py:126 Ensure _vswitch_id2name caches, and gets the right content.","title":"TestSlotMapStoreLegacy().test_vswitch_id2name"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_43","text":"@mock.patch(\"pypowervm.wrappers.managed_system.System.get\") @mock.patch(\"pypowervm.wrappers.network.VSwitch.get\") def test_vswitch_id2name(self, mock_vsw_get, mock_sys_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_slot_map/#loadf","text":"Show source in test_slot_map.py:33","title":"loadf"},{"location":"pypowervm/tests/tasks/test_slot_map/#signature_44","text":"def loadf(wcls, fname): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/","text":"TestSriov Pypowervm Index / Pypowervm / Tests / Tasks / TestSriov Auto-generated documentation for pypowervm.tests.tasks.test_sriov module. TestSriov TestMisc TestMisc().test_find_pport TestSafeUpdatePPort TestSafeUpdatePPort().test_get_lpar_vnics TestSafeUpdatePPort().test_safe_update_pports TestSafeUpdatePPort().test_vet_port_usage TestSafeUpdatePPort().test_vnics_using_pport TestSriov TestSriov().setUp TestSriov().test_check_and_filter_vioses TestSriov().test_check_sys_vnic_capabilities TestSriov().test_find_pports_for_portlabel TestSriov().test_find_pports_for_portlabel_blank TestSriov().test_get_good_pport_list TestSriov().test_get_good_sriovs TestSriov().test_set_vnic_back_devs TestSriov().test_set_vnic_back_devs_max_capacity_invoked TestSriov().test_set_vnic_back_devs_max_greaterthan_100 TestSriov().test_set_vnic_back_devs_max_less_than_capacity fake_pport fake_sriov good_sriov sys_wrapper TestMisc Show source in test_sriov.py:525 Signature class TestMisc(twrap.TestWrapper): ... TestMisc().test_find_pport Show source in test_sriov.py:529 Signature def test_find_pport(self): ... TestSafeUpdatePPort Show source in test_sriov.py:378 Signature class TestSafeUpdatePPort(testtools.TestCase): ... TestSafeUpdatePPort().test_get_lpar_vnics Show source in test_sriov.py:380 Signature @mock.patch(\"pypowervm.tasks.partition.get_partitions\") @mock.patch(\"pypowervm.wrappers.iocard.VNIC.get\") def test_get_lpar_vnics(self, mock_vnics, mock_get_pars): ... TestSafeUpdatePPort().test_safe_update_pports Show source in test_sriov.py:477 Signature @mock.patch(\"pypowervm.tasks.sriov._vet_port_usage\") @mock.patch(\"pypowervm.tasks.sriov.LOG.warning\") @mock.patch(\"fasteners.lock.ReaderWriterLock.write_lock\") @mock.patch(\"pypowervm.wrappers.managed_system.System.getter\") def test_safe_update_pports(self, mock_getter, mock_lock, mock_warn, mock_vpu): ... TestSafeUpdatePPort().test_vet_port_usage Show source in test_sriov.py:440 Signature @mock.patch(\"pypowervm.tasks.sriov.get_lpar_vnics\") @mock.patch(\"pypowervm.tasks.sriov._vnics_using_pport\") def test_vet_port_usage(self, mock_vup, mock_glv): ... TestSafeUpdatePPort().test_vnics_using_pport Show source in test_sriov.py:392 Signature def test_vnics_using_pport(self): ... TestSriov Show source in test_sriov.py:69 Signature class TestSriov(testtools.TestCase): ... TestSriov().setUp Show source in test_sriov.py:71 Signature def setUp(self): ... TestSriov().test_check_and_filter_vioses Show source in test_sriov.py:184 Signature @mock.patch(\"pypowervm.tasks.partition.get_active_vioses\") def test_check_and_filter_vioses(self, mock_vioget): ... TestSriov().test_check_sys_vnic_capabilities Show source in test_sriov.py:143 Signature @mock.patch(\"pypowervm.wrappers.managed_system.System.get\") def test_check_sys_vnic_capabilities(self, mock_sys_get): ... TestSriov().test_find_pports_for_portlabel Show source in test_sriov.py:345 Signature @mock.patch(\"pypowervm.wrappers.managed_system.System.get\") def test_find_pports_for_portlabel(self, mock_sys_get): ... TestSriov().test_find_pports_for_portlabel_blank Show source in test_sriov.py:361 Signature @mock.patch(\"pypowervm.wrappers.managed_system.System.get\") def test_find_pports_for_portlabel_blank(self, mock_sys_get): ... TestSriov().test_get_good_pport_list Show source in test_sriov.py:100 Test _get_good_pport_list helper. Signature def test_get_good_pport_list(self): ... TestSriov().test_get_good_sriovs Show source in test_sriov.py:89 Test _get_good_sriovs helper. Signature def test_get_good_sriovs(self): ... TestSriov().test_set_vnic_back_devs Show source in test_sriov.py:249 Test set_vnic_back_devs. Signature @mock.patch(\"pypowervm.tasks.sriov._check_and_filter_vioses\") @mock.patch(\"random.shuffle\") def test_set_vnic_back_devs(self, mock_shuffle, mock_vioget): ... TestSriov().test_set_vnic_back_devs_max_capacity_invoked Show source in test_sriov.py:330 Signature @mock.patch(\"pypowervm.tasks.sriov._check_and_filter_vioses\") def test_set_vnic_back_devs_max_capacity_invoked(self, mock_vioget): ... TestSriov().test_set_vnic_back_devs_max_greaterthan_100 Show source in test_sriov.py:235 Test set_vnic_back_devs with max capacity greater than 1 Signature @mock.patch(\"pypowervm.tasks.sriov._check_and_filter_vioses\") def test_set_vnic_back_devs_max_greaterthan_100(self, mock_vioget): ... TestSriov().test_set_vnic_back_devs_max_less_than_capacity Show source in test_sriov.py:221 Test set_vnic_back_devs with max capacity less than min capacity Signature @mock.patch(\"pypowervm.tasks.sriov._check_and_filter_vioses\") def test_set_vnic_back_devs_max_less_than_capacity(self, mock_vioget): ... fake_pport Show source in test_sriov.py:36 Signature def fake_pport(sriov_adap_id, port_id, cfg_lps, alloc_cap): ... fake_sriov Show source in test_sriov.py:30 Signature def fake_sriov(mode, state, sriov_adap_id, phys_ports): ... good_sriov Show source in test_sriov.py:46 Signature def good_sriov(sriov_adap_id, pports): ... sys_wrapper Show source in test_sriov.py:56 Signature def sys_wrapper(sriovs, vnic_capable=True, vnic_failover_capable=True): ...","title":"TestSriov"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriov","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestSriov Auto-generated documentation for pypowervm.tests.tasks.test_sriov module. TestSriov TestMisc TestMisc().test_find_pport TestSafeUpdatePPort TestSafeUpdatePPort().test_get_lpar_vnics TestSafeUpdatePPort().test_safe_update_pports TestSafeUpdatePPort().test_vet_port_usage TestSafeUpdatePPort().test_vnics_using_pport TestSriov TestSriov().setUp TestSriov().test_check_and_filter_vioses TestSriov().test_check_sys_vnic_capabilities TestSriov().test_find_pports_for_portlabel TestSriov().test_find_pports_for_portlabel_blank TestSriov().test_get_good_pport_list TestSriov().test_get_good_sriovs TestSriov().test_set_vnic_back_devs TestSriov().test_set_vnic_back_devs_max_capacity_invoked TestSriov().test_set_vnic_back_devs_max_greaterthan_100 TestSriov().test_set_vnic_back_devs_max_less_than_capacity fake_pport fake_sriov good_sriov sys_wrapper","title":"TestSriov"},{"location":"pypowervm/tests/tasks/test_sriov/#testmisc","text":"Show source in test_sriov.py:525","title":"TestMisc"},{"location":"pypowervm/tests/tasks/test_sriov/#signature","text":"class TestMisc(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testmisctest_find_pport","text":"Show source in test_sriov.py:529","title":"TestMisc().test_find_pport"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_1","text":"def test_find_pport(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsafeupdatepport","text":"Show source in test_sriov.py:378","title":"TestSafeUpdatePPort"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_2","text":"class TestSafeUpdatePPort(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsafeupdatepporttest_get_lpar_vnics","text":"Show source in test_sriov.py:380","title":"TestSafeUpdatePPort().test_get_lpar_vnics"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_3","text":"@mock.patch(\"pypowervm.tasks.partition.get_partitions\") @mock.patch(\"pypowervm.wrappers.iocard.VNIC.get\") def test_get_lpar_vnics(self, mock_vnics, mock_get_pars): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsafeupdatepporttest_safe_update_pports","text":"Show source in test_sriov.py:477","title":"TestSafeUpdatePPort().test_safe_update_pports"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_4","text":"@mock.patch(\"pypowervm.tasks.sriov._vet_port_usage\") @mock.patch(\"pypowervm.tasks.sriov.LOG.warning\") @mock.patch(\"fasteners.lock.ReaderWriterLock.write_lock\") @mock.patch(\"pypowervm.wrappers.managed_system.System.getter\") def test_safe_update_pports(self, mock_getter, mock_lock, mock_warn, mock_vpu): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsafeupdatepporttest_vet_port_usage","text":"Show source in test_sriov.py:440","title":"TestSafeUpdatePPort().test_vet_port_usage"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_5","text":"@mock.patch(\"pypowervm.tasks.sriov.get_lpar_vnics\") @mock.patch(\"pypowervm.tasks.sriov._vnics_using_pport\") def test_vet_port_usage(self, mock_vup, mock_glv): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsafeupdatepporttest_vnics_using_pport","text":"Show source in test_sriov.py:392","title":"TestSafeUpdatePPort().test_vnics_using_pport"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_6","text":"def test_vnics_using_pport(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriov_1","text":"Show source in test_sriov.py:69","title":"TestSriov"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_7","text":"class TestSriov(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovsetup","text":"Show source in test_sriov.py:71","title":"TestSriov().setUp"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_8","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovtest_check_and_filter_vioses","text":"Show source in test_sriov.py:184","title":"TestSriov().test_check_and_filter_vioses"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_9","text":"@mock.patch(\"pypowervm.tasks.partition.get_active_vioses\") def test_check_and_filter_vioses(self, mock_vioget): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovtest_check_sys_vnic_capabilities","text":"Show source in test_sriov.py:143","title":"TestSriov().test_check_sys_vnic_capabilities"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_10","text":"@mock.patch(\"pypowervm.wrappers.managed_system.System.get\") def test_check_sys_vnic_capabilities(self, mock_sys_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovtest_find_pports_for_portlabel","text":"Show source in test_sriov.py:345","title":"TestSriov().test_find_pports_for_portlabel"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_11","text":"@mock.patch(\"pypowervm.wrappers.managed_system.System.get\") def test_find_pports_for_portlabel(self, mock_sys_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovtest_find_pports_for_portlabel_blank","text":"Show source in test_sriov.py:361","title":"TestSriov().test_find_pports_for_portlabel_blank"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_12","text":"@mock.patch(\"pypowervm.wrappers.managed_system.System.get\") def test_find_pports_for_portlabel_blank(self, mock_sys_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovtest_get_good_pport_list","text":"Show source in test_sriov.py:100 Test _get_good_pport_list helper.","title":"TestSriov().test_get_good_pport_list"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_13","text":"def test_get_good_pport_list(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovtest_get_good_sriovs","text":"Show source in test_sriov.py:89 Test _get_good_sriovs helper.","title":"TestSriov().test_get_good_sriovs"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_14","text":"def test_get_good_sriovs(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovtest_set_vnic_back_devs","text":"Show source in test_sriov.py:249 Test set_vnic_back_devs.","title":"TestSriov().test_set_vnic_back_devs"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_15","text":"@mock.patch(\"pypowervm.tasks.sriov._check_and_filter_vioses\") @mock.patch(\"random.shuffle\") def test_set_vnic_back_devs(self, mock_shuffle, mock_vioget): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovtest_set_vnic_back_devs_max_capacity_invoked","text":"Show source in test_sriov.py:330","title":"TestSriov().test_set_vnic_back_devs_max_capacity_invoked"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_16","text":"@mock.patch(\"pypowervm.tasks.sriov._check_and_filter_vioses\") def test_set_vnic_back_devs_max_capacity_invoked(self, mock_vioget): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovtest_set_vnic_back_devs_max_greaterthan_100","text":"Show source in test_sriov.py:235 Test set_vnic_back_devs with max capacity greater than 1","title":"TestSriov().test_set_vnic_back_devs_max_greaterthan_100"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_17","text":"@mock.patch(\"pypowervm.tasks.sriov._check_and_filter_vioses\") def test_set_vnic_back_devs_max_greaterthan_100(self, mock_vioget): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#testsriovtest_set_vnic_back_devs_max_less_than_capacity","text":"Show source in test_sriov.py:221 Test set_vnic_back_devs with max capacity less than min capacity","title":"TestSriov().test_set_vnic_back_devs_max_less_than_capacity"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_18","text":"@mock.patch(\"pypowervm.tasks.sriov._check_and_filter_vioses\") def test_set_vnic_back_devs_max_less_than_capacity(self, mock_vioget): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#fake_pport","text":"Show source in test_sriov.py:36","title":"fake_pport"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_19","text":"def fake_pport(sriov_adap_id, port_id, cfg_lps, alloc_cap): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#fake_sriov","text":"Show source in test_sriov.py:30","title":"fake_sriov"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_20","text":"def fake_sriov(mode, state, sriov_adap_id, phys_ports): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#good_sriov","text":"Show source in test_sriov.py:46","title":"good_sriov"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_21","text":"def good_sriov(sriov_adap_id, pports): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_sriov/#sys_wrapper","text":"Show source in test_sriov.py:56","title":"sys_wrapper"},{"location":"pypowervm/tests/tasks/test_sriov/#signature_22","text":"def sys_wrapper(sriovs, vnic_capable=True, vnic_failover_capable=True): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/","text":"Test Storage Pypowervm Index / Pypowervm / Tests / Tasks / Test Storage Auto-generated documentation for pypowervm.tests.tasks.test_storage module. Test Storage TestLU TestLU().setUp TestLU().test_crt_lu TestLU().test_rm_lu_by_lu TestLUEnt TestLUEnt().setUp TestLUEnt().test_rm_tier_storage1 TestLUEnt().test_rm_tier_storage_errors TestLUEnt().test_rm_tier_storage_feed_get TestLULinkedClone TestLULinkedClone().setUp TestLULinkedClone().test_crt_lu_linked_clone TestLULinkedClone().test_image_lu_for_clone TestLULinkedClone().test_image_lu_in_use TestLULinkedClone().test_rm_ssp_storage TestRMStorage TestRMStorage().setUp TestRMStorage().test_rm_dev_by_udid TestRMStorage().test_rm_vdisks TestRMStorage().test_rm_vopts TestScrub TestScrub().setUp TestScrub().test_matches_warn TestScrub().test_multiple_removals TestScrub().test_no_matches TestScrub2 TestScrub2().setUp TestScrub2().test_find_stale_lpars TestScrub2().test_lu_vopt_vdisk TestScrub2().test_no_remove_storage TestScrub3 TestScrub3.count_maps_for_lpar TestScrub3().setUp TestScrub3().test_comprehensive_scrub TestScrub3().test_orphan TestScrub3().test_orphans_by_lpar_id TestScrub3().test_remove_portless_vfc_maps1 TestScrub3().test_remove_portless_vfc_maps2 TestScrub4 TestScrub4().setUp TestScrub4().test_add_lpar_storage_scrub_tasks TestScrub4().test_find_stale_lpars_combined TestScrub4().test_find_stale_lpars_vios_only TestScrub4().test_orphan_scrub TestTier TestTier().test_default_tier_for_ssp TestUploadLV TestUploadLV().setUp TestUploadLV().test_create_file TestUploadLV().test_crt_copy_vdisk TestUploadLV().test_rest_api_pipe TestUploadLV().test_upload_lu_func_remote TestUploadLV().test_upload_new_lu TestUploadLV().test_upload_new_lu_calls TestUploadLV().test_upload_new_lu_calls_via_func TestUploadLV().test_upload_new_vdisk TestUploadLV().test_upload_new_vdisk_failed TestUploadLV().test_upload_new_vdisk_failure TestUploadLV().test_upload_new_vdisk_func_remote TestUploadLV().test_upload_new_vopt TestUploadLV().test_upload_new_vopt_w_fail TestUploadLV().test_upload_stream_api_func TestUploadLV().test_upload_stream_via_stream_bld TestUploadLV().test_upload_vopt_by_filepath TestVDisk TestVDisk().setUp TestVDisk().test_crt_vdisk TestVDisk().test_rescan_vstor TestVG TestVG().setUp TestVG().test_find_vg_all_vioses TestVG().test_find_vg_no_vios TestVG().test_find_vg_not_found TestVG().test_find_vg_specified_vios TestLU Show source in test_storage.py:815 Signature class TestLU(testtools.TestCase): ... TestLU().setUp Show source in test_storage.py:816 Signature def setUp(self): ... TestLU().test_crt_lu Show source in test_storage.py:830 Signature @mock.patch(\"pypowervm.wrappers.storage.LUEnt.bld\") @mock.patch(\"pypowervm.wrappers.storage.Tier.search\") def test_crt_lu(self, mock_tier_srch, mock_lu_bld): ... TestLU().test_rm_lu_by_lu Show source in test_storage.py:879 Signature def test_rm_lu_by_lu(self): ... TestLUEnt Show source in test_storage.py:741 Signature class TestLUEnt(twrap.TestWrapper): ... TestLUEnt().setUp Show source in test_storage.py:745 Signature def setUp(self): ... TestLUEnt().test_rm_tier_storage1 Show source in test_storage.py:795 Verify rm_tier_storage removes what it oughtta. Signature def test_rm_tier_storage1(self): ... TestLUEnt().test_rm_tier_storage_errors Show source in test_storage.py:763 Test rm_tier_storage ValueErrors. Signature def test_rm_tier_storage_errors(self): ... TestLUEnt().test_rm_tier_storage_feed_get Show source in test_storage.py:774 Verify rm_tier_storage does a feed GET if lufeed not provided. Signature @mock.patch(\"pypowervm.tasks.storage._rm_lus\") def test_rm_tier_storage_feed_get(self, mock_rm_lus): ... TestLULinkedClone Show source in test_storage.py:887 Signature class TestLULinkedClone(testtools.TestCase): ... TestLULinkedClone().setUp Show source in test_storage.py:889 Signature def setUp(self): ... TestLULinkedClone().test_crt_lu_linked_clone Show source in test_storage.py:931 Signature @mock.patch(\"warnings.warn\") @mock.patch(\"pypowervm.tasks.storage.crt_lu\") def test_crt_lu_linked_clone(self, mock_crt_lu, mock_warn): ... TestLULinkedClone().test_image_lu_for_clone Show source in test_storage.py:953 Signature def test_image_lu_for_clone(self): ... TestLULinkedClone().test_image_lu_in_use Show source in test_storage.py:944 Signature def test_image_lu_in_use(self): ... TestLULinkedClone().test_rm_ssp_storage Show source in test_storage.py:961 Signature def test_rm_ssp_storage(self): ... TestRMStorage Show source in test_storage.py:624 Signature class TestRMStorage(testtools.TestCase): ... TestRMStorage().setUp Show source in test_storage.py:625 Signature def setUp(self): ... TestRMStorage().test_rm_dev_by_udid Show source in test_storage.py:633 Signature def test_rm_dev_by_udid(self): ... TestRMStorage().test_rm_vdisks Show source in test_storage.py:666 Signature @mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") def test_rm_vdisks(self, mock_update): ... TestRMStorage().test_rm_vopts Show source in test_storage.py:698 Signature @mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") def test_rm_vopts(self, mock_update): ... TestScrub Show source in test_storage.py:989 Two VIOSes in feed; no VFC mappings; no storage in VSCSI mappings. Signature class TestScrub(testtools.TestCase): ... TestScrub().setUp Show source in test_storage.py:991 Signature def setUp(self): ... TestScrub().test_matches_warn Show source in test_storage.py:1014 When removals hit, log warnings including the removal count. Signature @mock.patch(\"pypowervm.tasks.vfc_mapper.remove_maps\") def test_matches_warn(self, mock_rm_vfc_maps): ... TestScrub().test_multiple_removals Show source in test_storage.py:1037 Signature @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.wrap\") def test_multiple_removals(self, mock_wrap): ... TestScrub().test_no_matches Show source in test_storage.py:999 When removals have no hits, log debug messages, but no warnings. Signature @mock.patch(\"pypowervm.tasks.storage._RemoveStorage.execute\") def test_no_matches(self, mock_rm_stg): ... TestScrub2 Show source in test_storage.py:1084 One VIOS in feed; VFC mappings; interesting VSCSI mappings. Signature class TestScrub2(testtools.TestCase): ... TestScrub2().setUp Show source in test_storage.py:1086 Signature def setUp(self): ... TestScrub2().test_find_stale_lpars Show source in test_storage.py:1151 Signature @mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.get\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") def test_find_stale_lpars(self, mock_vios, mock_lpar): ... TestScrub2().test_lu_vopt_vdisk Show source in test_storage.py:1095 Signature @mock.patch(\"pypowervm.tasks.storage._rm_vdisks\") @mock.patch(\"pypowervm.tasks.storage._rm_vopts\") @mock.patch(\"pypowervm.tasks.storage._rm_lus\") def test_lu_vopt_vdisk(self, mock_rm_lu, mock_rm_vopt, mock_rm_vd): ... TestScrub2().test_no_remove_storage Show source in test_storage.py:1140 Signature @mock.patch(\"pypowervm.tasks.storage._rm_vdisks\") @mock.patch(\"pypowervm.tasks.storage._rm_vopts\") @mock.patch(\"pypowervm.tasks.storage._rm_lus\") def test_no_remove_storage(self, mock_rm_lu, mock_rm_vopt, mock_rm_vd): ... TestScrub3 Show source in test_storage.py:1160 One VIOS; lots of orphan VSCSI and VFC mappings. Signature class TestScrub3(testtools.TestCase): ... TestScrub3.count_maps_for_lpar Show source in test_storage.py:1238 Count the mappings whose client side is the specified LPAR ID. Arguments mappings - List of VFC or VSCSI mappings to search. lpar_id - The client LPAR ID to search for. Returns Integer - the number of mappings whose server_adapter.lpar_id matches the specified lpar_id. Signature @staticmethod def count_maps_for_lpar(mappings, lpar_id): ... TestScrub3().setUp Show source in test_storage.py:1162 Signature def setUp(self): ... TestScrub3().test_comprehensive_scrub Show source in test_storage.py:1212 Signature @mock.patch(\"pypowervm.tasks.storage._rm_vdisks\") @mock.patch(\"pypowervm.tasks.storage._rm_vopts\") @mock.patch(\"pypowervm.tasks.storage.find_stale_lpars\") @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.wrap\") def test_comprehensive_scrub( self, mock_wrap, mock_stale_lids, mock_rm_vopts, mock_rm_vdisks ): ... TestScrub3().test_orphan Show source in test_storage.py:1170 Scrub orphan VSCSI and VFC mappings. Signature @mock.patch(\"pypowervm.tasks.storage._rm_vopts\") def test_orphan(self, mock_rm_vopts): ... TestScrub3().test_orphans_by_lpar_id Show source in test_storage.py:1283 Signature @mock.patch(\"pypowervm.tasks.storage._rm_vopts\") @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.wrap\") def test_orphans_by_lpar_id(self, mock_wrap, mock_rm_vopts): ... TestScrub3().test_remove_portless_vfc_maps1 Show source in test_storage.py:1250 Test _remove_portless_vfc_maps with no LPAR ID. Signature def test_remove_portless_vfc_maps1(self): ... TestScrub3().test_remove_portless_vfc_maps2 Show source in test_storage.py:1268 Test _remove_portless_vfc_maps specifying an LPAR ID. Signature def test_remove_portless_vfc_maps2(self): ... TestScrub4 Show source in test_storage.py:1303 Novalink partition hosting storage for another VIOS partition Signature class TestScrub4(testtools.TestCase): ... TestScrub4().setUp Show source in test_storage.py:1305 Signature def setUp(self): ... TestScrub4().test_add_lpar_storage_scrub_tasks Show source in test_storage.py:1353 Signature @mock.patch(\"pypowervm.tasks.storage._remove_lpar_maps\") def test_add_lpar_storage_scrub_tasks(self, mock_rm_lpar): ... TestScrub4().test_find_stale_lpars_combined Show source in test_storage.py:1325 Signature def test_find_stale_lpars_combined(self): ... TestScrub4().test_find_stale_lpars_vios_only Show source in test_storage.py:1321 Signature def test_find_stale_lpars_vios_only(self): ... TestScrub4().test_orphan_scrub Show source in test_storage.py:1328 Signature @mock.patch(\"pypowervm.tasks.storage._remove_lpar_maps\") def test_orphan_scrub(self, mock_rm_lpar): ... TestTier Show source in test_storage.py:729 Signature class TestTier(testtools.TestCase): ... TestTier().test_default_tier_for_ssp Show source in test_storage.py:730 Signature @mock.patch(\"pypowervm.wrappers.storage.Tier.search\") def test_default_tier_for_ssp(self, mock_srch): ... TestUploadLV Show source in test_storage.py:65 Unit Tests for Instance uploads. Signature class TestUploadLV(testtools.TestCase): ... TestUploadLV().setUp Show source in test_storage.py:68 Signature def setUp(self): ... TestUploadLV().test_create_file Show source in test_storage.py:451 Validates that the _create_file builds the Element properly. Signature def test_create_file(self): ... TestUploadLV().test_crt_copy_vdisk Show source in test_storage.py:245 Tests the uploads of the virtual disks. Signature @mock.patch(\"pypowervm.tasks.storage.crt_vdisk\") def test_crt_copy_vdisk(self, mock_crt_vdisk): ... TestUploadLV().test_rest_api_pipe Show source in test_storage.py:75 Signature @mock.patch(\"tempfile.mkdtemp\") @mock.patch(\"pypowervm.tasks.storage.os\") @mock.patch(\"pypowervm.util.retry_io_command\") @mock.patch(\"pypowervm.tasks.storage.open\") def test_rest_api_pipe(self, mock_open, mock_retry, mock_os, mock_mkdtemp): ... TestUploadLV().test_upload_lu_func_remote Show source in test_storage.py:418 With FUNC and non-local, upload_lu uses REST API upload. Signature @mock.patch(\"pypowervm.tasks.storage._create_file\") @mock.patch(\"pypowervm.tasks.storage._upload_stream_api\") def test_upload_lu_func_remote(self, mock_usa, mock_crt_file): ... TestUploadLV().test_upload_new_lu Show source in test_storage.py:339 Tests create/upload of SSP LU. Signature @mock.patch(\"pypowervm.tasks.storage._create_file\") @mock.patch(\"pypowervm.tasks.storage.crt_lu\") def test_upload_new_lu(self, mock_crt_lu, mock_create_file): ... TestUploadLV().test_upload_new_lu_calls Show source in test_storage.py:371 Various permutations of how to call upload_new_lu. Signature @mock.patch(\"pypowervm.util.convert_bytes_to_gb\") @mock.patch(\"pypowervm.tasks.storage.crt_lu\") @mock.patch(\"pypowervm.tasks.storage.upload_lu\") def test_upload_new_lu_calls(self, mock_upl, mock_crt, mock_b2g): ... TestUploadLV().test_upload_new_lu_calls_via_func Show source in test_storage.py:431 Various permutations of how to call upload_new_lu. Signature @mock.patch(\"pypowervm.util.convert_bytes_to_gb\") @mock.patch(\"pypowervm.tasks.storage.crt_lu\") @mock.patch(\"pypowervm.tasks.storage.upload_lu\") def test_upload_new_lu_calls_via_func(self, mock_upl, mock_crt, mock_b2g): ... TestUploadLV().test_upload_new_vdisk Show source in test_storage.py:213 Tests the uploads of the virtual disks. Signature @mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_new_vdisk(self, mock_create_file): ... TestUploadLV().test_upload_new_vdisk_failed Show source in test_storage.py:188 Tests the uploads of the virtual disks. Signature @mock.patch(\"pypowervm.tasks.storage.rm_vg_storage\") @mock.patch(\"pypowervm.wrappers.storage.VG.get\") @mock.patch(\"pypowervm.tasks.storage._upload_stream\") @mock.patch(\"pypowervm.tasks.storage._create_file\") @mock.patch(\"pypowervm.tasks.storage.crt_vdisk\") def test_upload_new_vdisk_failed( self, mock_create_vdisk, mock_create_file, mock_upload_stream, mock_vg_get, mock_rm ): ... TestUploadLV().test_upload_new_vdisk_failure Show source in test_storage.py:314 Tests the failure path for uploading of the virtual disks. Signature @mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_new_vdisk_failure(self, mock_create_file): ... TestUploadLV().test_upload_new_vdisk_func_remote Show source in test_storage.py:265 With FUNC and non-local, upload_new_vdisk uses REST API upload. Signature @mock.patch(\"pypowervm.tasks.storage.crt_vdisk\") @mock.patch(\"pypowervm.tasks.storage._create_file\") @mock.patch(\"pypowervm.tasks.storage._upload_stream_api\") def test_upload_new_vdisk_func_remote(self, mock_usa, mock_crt_file, mock_crt_vdisk): ... TestUploadLV().test_upload_new_vopt Show source in test_storage.py:106 Tests the uploads of the virtual disks. Signature @mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_new_vopt(self, mock_create_file): ... TestUploadLV().test_upload_new_vopt_w_fail Show source in test_storage.py:179 Tests the uploads of the virtual disks with an upload fail. Signature @mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_new_vopt_w_fail(self, mock_create_file): ... TestUploadLV().test_upload_stream_api_func Show source in test_storage.py:95 With FUNC, _upload_stream_api uses _rest_api_pipe properly. Signature @mock.patch(\"pypowervm.tasks.storage._rest_api_pipe\") def test_upload_stream_api_func(self, mock_rap): ... TestUploadLV().test_upload_stream_via_stream_bld Show source in test_storage.py:291 Tests the uploads of a vDisk - via UploadType.IO_STREAM_BUILDER. Signature @mock.patch(\"pypowervm.tasks.storage._upload_stream_api\") @mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_stream_via_stream_bld(self, mock_create_file, mock_upload_st): ... TestUploadLV().test_upload_vopt_by_filepath Show source in test_storage.py:146 Tests the uploads of the virtual disks with an upload retry. Signature @mock.patch.object(ts.LOG, \"warning\") @mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_vopt_by_filepath(self, mock_create_file, mock_log_warn): ... TestVDisk Show source in test_storage.py:539 Signature class TestVDisk(testtools.TestCase): ... TestVDisk().setUp Show source in test_storage.py:540 Signature def setUp(self): ... TestVDisk().test_crt_vdisk Show source in test_storage.py:548 Signature @mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") @mock.patch(\"pypowervm.adapter.Adapter.read\") def test_crt_vdisk(self, mock_read, mock_update): ... TestVDisk().test_rescan_vstor Show source in test_storage.py:585 Signature @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.adapter.Adapter.read\") def test_rescan_vstor(self, mock_adpt_read, mock_run_job): ... TestVG Show source in test_storage.py:480 Signature class TestVG(twrap.TestWrapper): ... TestVG().setUp Show source in test_storage.py:484 Signature def setUp(self): ... TestVG().test_find_vg_all_vioses Show source in test_storage.py:500 Signature def test_find_vg_all_vioses(self): ... TestVG().test_find_vg_no_vios Show source in test_storage.py:521 Signature def test_find_vg_no_vios(self): ... TestVG().test_find_vg_not_found Show source in test_storage.py:530 Signature def test_find_vg_not_found(self): ... TestVG().test_find_vg_specified_vios Show source in test_storage.py:509 Signature def test_find_vg_specified_vios(self): ...","title":"Test Storage"},{"location":"pypowervm/tests/tasks/test_storage/#test-storage","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Test Storage Auto-generated documentation for pypowervm.tests.tasks.test_storage module. Test Storage TestLU TestLU().setUp TestLU().test_crt_lu TestLU().test_rm_lu_by_lu TestLUEnt TestLUEnt().setUp TestLUEnt().test_rm_tier_storage1 TestLUEnt().test_rm_tier_storage_errors TestLUEnt().test_rm_tier_storage_feed_get TestLULinkedClone TestLULinkedClone().setUp TestLULinkedClone().test_crt_lu_linked_clone TestLULinkedClone().test_image_lu_for_clone TestLULinkedClone().test_image_lu_in_use TestLULinkedClone().test_rm_ssp_storage TestRMStorage TestRMStorage().setUp TestRMStorage().test_rm_dev_by_udid TestRMStorage().test_rm_vdisks TestRMStorage().test_rm_vopts TestScrub TestScrub().setUp TestScrub().test_matches_warn TestScrub().test_multiple_removals TestScrub().test_no_matches TestScrub2 TestScrub2().setUp TestScrub2().test_find_stale_lpars TestScrub2().test_lu_vopt_vdisk TestScrub2().test_no_remove_storage TestScrub3 TestScrub3.count_maps_for_lpar TestScrub3().setUp TestScrub3().test_comprehensive_scrub TestScrub3().test_orphan TestScrub3().test_orphans_by_lpar_id TestScrub3().test_remove_portless_vfc_maps1 TestScrub3().test_remove_portless_vfc_maps2 TestScrub4 TestScrub4().setUp TestScrub4().test_add_lpar_storage_scrub_tasks TestScrub4().test_find_stale_lpars_combined TestScrub4().test_find_stale_lpars_vios_only TestScrub4().test_orphan_scrub TestTier TestTier().test_default_tier_for_ssp TestUploadLV TestUploadLV().setUp TestUploadLV().test_create_file TestUploadLV().test_crt_copy_vdisk TestUploadLV().test_rest_api_pipe TestUploadLV().test_upload_lu_func_remote TestUploadLV().test_upload_new_lu TestUploadLV().test_upload_new_lu_calls TestUploadLV().test_upload_new_lu_calls_via_func TestUploadLV().test_upload_new_vdisk TestUploadLV().test_upload_new_vdisk_failed TestUploadLV().test_upload_new_vdisk_failure TestUploadLV().test_upload_new_vdisk_func_remote TestUploadLV().test_upload_new_vopt TestUploadLV().test_upload_new_vopt_w_fail TestUploadLV().test_upload_stream_api_func TestUploadLV().test_upload_stream_via_stream_bld TestUploadLV().test_upload_vopt_by_filepath TestVDisk TestVDisk().setUp TestVDisk().test_crt_vdisk TestVDisk().test_rescan_vstor TestVG TestVG().setUp TestVG().test_find_vg_all_vioses TestVG().test_find_vg_no_vios TestVG().test_find_vg_not_found TestVG().test_find_vg_specified_vios","title":"Test Storage"},{"location":"pypowervm/tests/tasks/test_storage/#testlu","text":"Show source in test_storage.py:815","title":"TestLU"},{"location":"pypowervm/tests/tasks/test_storage/#signature","text":"class TestLU(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testlusetup","text":"Show source in test_storage.py:816","title":"TestLU().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testlutest_crt_lu","text":"Show source in test_storage.py:830","title":"TestLU().test_crt_lu"},{"location":"pypowervm/tests/tasks/test_storage/#signature_2","text":"@mock.patch(\"pypowervm.wrappers.storage.LUEnt.bld\") @mock.patch(\"pypowervm.wrappers.storage.Tier.search\") def test_crt_lu(self, mock_tier_srch, mock_lu_bld): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testlutest_rm_lu_by_lu","text":"Show source in test_storage.py:879","title":"TestLU().test_rm_lu_by_lu"},{"location":"pypowervm/tests/tasks/test_storage/#signature_3","text":"def test_rm_lu_by_lu(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testluent","text":"Show source in test_storage.py:741","title":"TestLUEnt"},{"location":"pypowervm/tests/tasks/test_storage/#signature_4","text":"class TestLUEnt(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testluentsetup","text":"Show source in test_storage.py:745","title":"TestLUEnt().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_5","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testluenttest_rm_tier_storage1","text":"Show source in test_storage.py:795 Verify rm_tier_storage removes what it oughtta.","title":"TestLUEnt().test_rm_tier_storage1"},{"location":"pypowervm/tests/tasks/test_storage/#signature_6","text":"def test_rm_tier_storage1(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testluenttest_rm_tier_storage_errors","text":"Show source in test_storage.py:763 Test rm_tier_storage ValueErrors.","title":"TestLUEnt().test_rm_tier_storage_errors"},{"location":"pypowervm/tests/tasks/test_storage/#signature_7","text":"def test_rm_tier_storage_errors(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testluenttest_rm_tier_storage_feed_get","text":"Show source in test_storage.py:774 Verify rm_tier_storage does a feed GET if lufeed not provided.","title":"TestLUEnt().test_rm_tier_storage_feed_get"},{"location":"pypowervm/tests/tasks/test_storage/#signature_8","text":"@mock.patch(\"pypowervm.tasks.storage._rm_lus\") def test_rm_tier_storage_feed_get(self, mock_rm_lus): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testlulinkedclone","text":"Show source in test_storage.py:887","title":"TestLULinkedClone"},{"location":"pypowervm/tests/tasks/test_storage/#signature_9","text":"class TestLULinkedClone(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testlulinkedclonesetup","text":"Show source in test_storage.py:889","title":"TestLULinkedClone().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_10","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testlulinkedclonetest_crt_lu_linked_clone","text":"Show source in test_storage.py:931","title":"TestLULinkedClone().test_crt_lu_linked_clone"},{"location":"pypowervm/tests/tasks/test_storage/#signature_11","text":"@mock.patch(\"warnings.warn\") @mock.patch(\"pypowervm.tasks.storage.crt_lu\") def test_crt_lu_linked_clone(self, mock_crt_lu, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testlulinkedclonetest_image_lu_for_clone","text":"Show source in test_storage.py:953","title":"TestLULinkedClone().test_image_lu_for_clone"},{"location":"pypowervm/tests/tasks/test_storage/#signature_12","text":"def test_image_lu_for_clone(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testlulinkedclonetest_image_lu_in_use","text":"Show source in test_storage.py:944","title":"TestLULinkedClone().test_image_lu_in_use"},{"location":"pypowervm/tests/tasks/test_storage/#signature_13","text":"def test_image_lu_in_use(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testlulinkedclonetest_rm_ssp_storage","text":"Show source in test_storage.py:961","title":"TestLULinkedClone().test_rm_ssp_storage"},{"location":"pypowervm/tests/tasks/test_storage/#signature_14","text":"def test_rm_ssp_storage(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testrmstorage","text":"Show source in test_storage.py:624","title":"TestRMStorage"},{"location":"pypowervm/tests/tasks/test_storage/#signature_15","text":"class TestRMStorage(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testrmstoragesetup","text":"Show source in test_storage.py:625","title":"TestRMStorage().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_16","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testrmstoragetest_rm_dev_by_udid","text":"Show source in test_storage.py:633","title":"TestRMStorage().test_rm_dev_by_udid"},{"location":"pypowervm/tests/tasks/test_storage/#signature_17","text":"def test_rm_dev_by_udid(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testrmstoragetest_rm_vdisks","text":"Show source in test_storage.py:666","title":"TestRMStorage().test_rm_vdisks"},{"location":"pypowervm/tests/tasks/test_storage/#signature_18","text":"@mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") def test_rm_vdisks(self, mock_update): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testrmstoragetest_rm_vopts","text":"Show source in test_storage.py:698","title":"TestRMStorage().test_rm_vopts"},{"location":"pypowervm/tests/tasks/test_storage/#signature_19","text":"@mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") def test_rm_vopts(self, mock_update): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub","text":"Show source in test_storage.py:989 Two VIOSes in feed; no VFC mappings; no storage in VSCSI mappings.","title":"TestScrub"},{"location":"pypowervm/tests/tasks/test_storage/#signature_20","text":"class TestScrub(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrubsetup","text":"Show source in test_storage.py:991","title":"TestScrub().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_21","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrubtest_matches_warn","text":"Show source in test_storage.py:1014 When removals hit, log warnings including the removal count.","title":"TestScrub().test_matches_warn"},{"location":"pypowervm/tests/tasks/test_storage/#signature_22","text":"@mock.patch(\"pypowervm.tasks.vfc_mapper.remove_maps\") def test_matches_warn(self, mock_rm_vfc_maps): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrubtest_multiple_removals","text":"Show source in test_storage.py:1037","title":"TestScrub().test_multiple_removals"},{"location":"pypowervm/tests/tasks/test_storage/#signature_23","text":"@mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.wrap\") def test_multiple_removals(self, mock_wrap): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrubtest_no_matches","text":"Show source in test_storage.py:999 When removals have no hits, log debug messages, but no warnings.","title":"TestScrub().test_no_matches"},{"location":"pypowervm/tests/tasks/test_storage/#signature_24","text":"@mock.patch(\"pypowervm.tasks.storage._RemoveStorage.execute\") def test_no_matches(self, mock_rm_stg): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub2","text":"Show source in test_storage.py:1084 One VIOS in feed; VFC mappings; interesting VSCSI mappings.","title":"TestScrub2"},{"location":"pypowervm/tests/tasks/test_storage/#signature_25","text":"class TestScrub2(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub2setup","text":"Show source in test_storage.py:1086","title":"TestScrub2().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_26","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub2test_find_stale_lpars","text":"Show source in test_storage.py:1151","title":"TestScrub2().test_find_stale_lpars"},{"location":"pypowervm/tests/tasks/test_storage/#signature_27","text":"@mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.get\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") def test_find_stale_lpars(self, mock_vios, mock_lpar): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub2test_lu_vopt_vdisk","text":"Show source in test_storage.py:1095","title":"TestScrub2().test_lu_vopt_vdisk"},{"location":"pypowervm/tests/tasks/test_storage/#signature_28","text":"@mock.patch(\"pypowervm.tasks.storage._rm_vdisks\") @mock.patch(\"pypowervm.tasks.storage._rm_vopts\") @mock.patch(\"pypowervm.tasks.storage._rm_lus\") def test_lu_vopt_vdisk(self, mock_rm_lu, mock_rm_vopt, mock_rm_vd): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub2test_no_remove_storage","text":"Show source in test_storage.py:1140","title":"TestScrub2().test_no_remove_storage"},{"location":"pypowervm/tests/tasks/test_storage/#signature_29","text":"@mock.patch(\"pypowervm.tasks.storage._rm_vdisks\") @mock.patch(\"pypowervm.tasks.storage._rm_vopts\") @mock.patch(\"pypowervm.tasks.storage._rm_lus\") def test_no_remove_storage(self, mock_rm_lu, mock_rm_vopt, mock_rm_vd): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub3","text":"Show source in test_storage.py:1160 One VIOS; lots of orphan VSCSI and VFC mappings.","title":"TestScrub3"},{"location":"pypowervm/tests/tasks/test_storage/#signature_30","text":"class TestScrub3(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub3count_maps_for_lpar","text":"Show source in test_storage.py:1238 Count the mappings whose client side is the specified LPAR ID.","title":"TestScrub3.count_maps_for_lpar"},{"location":"pypowervm/tests/tasks/test_storage/#arguments","text":"mappings - List of VFC or VSCSI mappings to search. lpar_id - The client LPAR ID to search for.","title":"Arguments"},{"location":"pypowervm/tests/tasks/test_storage/#returns","text":"Integer - the number of mappings whose server_adapter.lpar_id matches the specified lpar_id.","title":"Returns"},{"location":"pypowervm/tests/tasks/test_storage/#signature_31","text":"@staticmethod def count_maps_for_lpar(mappings, lpar_id): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub3setup","text":"Show source in test_storage.py:1162","title":"TestScrub3().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_32","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub3test_comprehensive_scrub","text":"Show source in test_storage.py:1212","title":"TestScrub3().test_comprehensive_scrub"},{"location":"pypowervm/tests/tasks/test_storage/#signature_33","text":"@mock.patch(\"pypowervm.tasks.storage._rm_vdisks\") @mock.patch(\"pypowervm.tasks.storage._rm_vopts\") @mock.patch(\"pypowervm.tasks.storage.find_stale_lpars\") @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.wrap\") def test_comprehensive_scrub( self, mock_wrap, mock_stale_lids, mock_rm_vopts, mock_rm_vdisks ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub3test_orphan","text":"Show source in test_storage.py:1170 Scrub orphan VSCSI and VFC mappings.","title":"TestScrub3().test_orphan"},{"location":"pypowervm/tests/tasks/test_storage/#signature_34","text":"@mock.patch(\"pypowervm.tasks.storage._rm_vopts\") def test_orphan(self, mock_rm_vopts): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub3test_orphans_by_lpar_id","text":"Show source in test_storage.py:1283","title":"TestScrub3().test_orphans_by_lpar_id"},{"location":"pypowervm/tests/tasks/test_storage/#signature_35","text":"@mock.patch(\"pypowervm.tasks.storage._rm_vopts\") @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.wrap\") def test_orphans_by_lpar_id(self, mock_wrap, mock_rm_vopts): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub3test_remove_portless_vfc_maps1","text":"Show source in test_storage.py:1250 Test _remove_portless_vfc_maps with no LPAR ID.","title":"TestScrub3().test_remove_portless_vfc_maps1"},{"location":"pypowervm/tests/tasks/test_storage/#signature_36","text":"def test_remove_portless_vfc_maps1(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub3test_remove_portless_vfc_maps2","text":"Show source in test_storage.py:1268 Test _remove_portless_vfc_maps specifying an LPAR ID.","title":"TestScrub3().test_remove_portless_vfc_maps2"},{"location":"pypowervm/tests/tasks/test_storage/#signature_37","text":"def test_remove_portless_vfc_maps2(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub4","text":"Show source in test_storage.py:1303 Novalink partition hosting storage for another VIOS partition","title":"TestScrub4"},{"location":"pypowervm/tests/tasks/test_storage/#signature_38","text":"class TestScrub4(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub4setup","text":"Show source in test_storage.py:1305","title":"TestScrub4().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_39","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub4test_add_lpar_storage_scrub_tasks","text":"Show source in test_storage.py:1353","title":"TestScrub4().test_add_lpar_storage_scrub_tasks"},{"location":"pypowervm/tests/tasks/test_storage/#signature_40","text":"@mock.patch(\"pypowervm.tasks.storage._remove_lpar_maps\") def test_add_lpar_storage_scrub_tasks(self, mock_rm_lpar): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub4test_find_stale_lpars_combined","text":"Show source in test_storage.py:1325","title":"TestScrub4().test_find_stale_lpars_combined"},{"location":"pypowervm/tests/tasks/test_storage/#signature_41","text":"def test_find_stale_lpars_combined(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub4test_find_stale_lpars_vios_only","text":"Show source in test_storage.py:1321","title":"TestScrub4().test_find_stale_lpars_vios_only"},{"location":"pypowervm/tests/tasks/test_storage/#signature_42","text":"def test_find_stale_lpars_vios_only(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testscrub4test_orphan_scrub","text":"Show source in test_storage.py:1328","title":"TestScrub4().test_orphan_scrub"},{"location":"pypowervm/tests/tasks/test_storage/#signature_43","text":"@mock.patch(\"pypowervm.tasks.storage._remove_lpar_maps\") def test_orphan_scrub(self, mock_rm_lpar): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testtier","text":"Show source in test_storage.py:729","title":"TestTier"},{"location":"pypowervm/tests/tasks/test_storage/#signature_44","text":"class TestTier(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testtiertest_default_tier_for_ssp","text":"Show source in test_storage.py:730","title":"TestTier().test_default_tier_for_ssp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_45","text":"@mock.patch(\"pypowervm.wrappers.storage.Tier.search\") def test_default_tier_for_ssp(self, mock_srch): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlv","text":"Show source in test_storage.py:65 Unit Tests for Instance uploads.","title":"TestUploadLV"},{"location":"pypowervm/tests/tasks/test_storage/#signature_46","text":"class TestUploadLV(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvsetup","text":"Show source in test_storage.py:68","title":"TestUploadLV().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_47","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_create_file","text":"Show source in test_storage.py:451 Validates that the _create_file builds the Element properly.","title":"TestUploadLV().test_create_file"},{"location":"pypowervm/tests/tasks/test_storage/#signature_48","text":"def test_create_file(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_crt_copy_vdisk","text":"Show source in test_storage.py:245 Tests the uploads of the virtual disks.","title":"TestUploadLV().test_crt_copy_vdisk"},{"location":"pypowervm/tests/tasks/test_storage/#signature_49","text":"@mock.patch(\"pypowervm.tasks.storage.crt_vdisk\") def test_crt_copy_vdisk(self, mock_crt_vdisk): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_rest_api_pipe","text":"Show source in test_storage.py:75","title":"TestUploadLV().test_rest_api_pipe"},{"location":"pypowervm/tests/tasks/test_storage/#signature_50","text":"@mock.patch(\"tempfile.mkdtemp\") @mock.patch(\"pypowervm.tasks.storage.os\") @mock.patch(\"pypowervm.util.retry_io_command\") @mock.patch(\"pypowervm.tasks.storage.open\") def test_rest_api_pipe(self, mock_open, mock_retry, mock_os, mock_mkdtemp): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_lu_func_remote","text":"Show source in test_storage.py:418 With FUNC and non-local, upload_lu uses REST API upload.","title":"TestUploadLV().test_upload_lu_func_remote"},{"location":"pypowervm/tests/tasks/test_storage/#signature_51","text":"@mock.patch(\"pypowervm.tasks.storage._create_file\") @mock.patch(\"pypowervm.tasks.storage._upload_stream_api\") def test_upload_lu_func_remote(self, mock_usa, mock_crt_file): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_new_lu","text":"Show source in test_storage.py:339 Tests create/upload of SSP LU.","title":"TestUploadLV().test_upload_new_lu"},{"location":"pypowervm/tests/tasks/test_storage/#signature_52","text":"@mock.patch(\"pypowervm.tasks.storage._create_file\") @mock.patch(\"pypowervm.tasks.storage.crt_lu\") def test_upload_new_lu(self, mock_crt_lu, mock_create_file): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_new_lu_calls","text":"Show source in test_storage.py:371 Various permutations of how to call upload_new_lu.","title":"TestUploadLV().test_upload_new_lu_calls"},{"location":"pypowervm/tests/tasks/test_storage/#signature_53","text":"@mock.patch(\"pypowervm.util.convert_bytes_to_gb\") @mock.patch(\"pypowervm.tasks.storage.crt_lu\") @mock.patch(\"pypowervm.tasks.storage.upload_lu\") def test_upload_new_lu_calls(self, mock_upl, mock_crt, mock_b2g): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_new_lu_calls_via_func","text":"Show source in test_storage.py:431 Various permutations of how to call upload_new_lu.","title":"TestUploadLV().test_upload_new_lu_calls_via_func"},{"location":"pypowervm/tests/tasks/test_storage/#signature_54","text":"@mock.patch(\"pypowervm.util.convert_bytes_to_gb\") @mock.patch(\"pypowervm.tasks.storage.crt_lu\") @mock.patch(\"pypowervm.tasks.storage.upload_lu\") def test_upload_new_lu_calls_via_func(self, mock_upl, mock_crt, mock_b2g): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_new_vdisk","text":"Show source in test_storage.py:213 Tests the uploads of the virtual disks.","title":"TestUploadLV().test_upload_new_vdisk"},{"location":"pypowervm/tests/tasks/test_storage/#signature_55","text":"@mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_new_vdisk(self, mock_create_file): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_new_vdisk_failed","text":"Show source in test_storage.py:188 Tests the uploads of the virtual disks.","title":"TestUploadLV().test_upload_new_vdisk_failed"},{"location":"pypowervm/tests/tasks/test_storage/#signature_56","text":"@mock.patch(\"pypowervm.tasks.storage.rm_vg_storage\") @mock.patch(\"pypowervm.wrappers.storage.VG.get\") @mock.patch(\"pypowervm.tasks.storage._upload_stream\") @mock.patch(\"pypowervm.tasks.storage._create_file\") @mock.patch(\"pypowervm.tasks.storage.crt_vdisk\") def test_upload_new_vdisk_failed( self, mock_create_vdisk, mock_create_file, mock_upload_stream, mock_vg_get, mock_rm ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_new_vdisk_failure","text":"Show source in test_storage.py:314 Tests the failure path for uploading of the virtual disks.","title":"TestUploadLV().test_upload_new_vdisk_failure"},{"location":"pypowervm/tests/tasks/test_storage/#signature_57","text":"@mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_new_vdisk_failure(self, mock_create_file): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_new_vdisk_func_remote","text":"Show source in test_storage.py:265 With FUNC and non-local, upload_new_vdisk uses REST API upload.","title":"TestUploadLV().test_upload_new_vdisk_func_remote"},{"location":"pypowervm/tests/tasks/test_storage/#signature_58","text":"@mock.patch(\"pypowervm.tasks.storage.crt_vdisk\") @mock.patch(\"pypowervm.tasks.storage._create_file\") @mock.patch(\"pypowervm.tasks.storage._upload_stream_api\") def test_upload_new_vdisk_func_remote(self, mock_usa, mock_crt_file, mock_crt_vdisk): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_new_vopt","text":"Show source in test_storage.py:106 Tests the uploads of the virtual disks.","title":"TestUploadLV().test_upload_new_vopt"},{"location":"pypowervm/tests/tasks/test_storage/#signature_59","text":"@mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_new_vopt(self, mock_create_file): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_new_vopt_w_fail","text":"Show source in test_storage.py:179 Tests the uploads of the virtual disks with an upload fail.","title":"TestUploadLV().test_upload_new_vopt_w_fail"},{"location":"pypowervm/tests/tasks/test_storage/#signature_60","text":"@mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_new_vopt_w_fail(self, mock_create_file): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_stream_api_func","text":"Show source in test_storage.py:95 With FUNC, _upload_stream_api uses _rest_api_pipe properly.","title":"TestUploadLV().test_upload_stream_api_func"},{"location":"pypowervm/tests/tasks/test_storage/#signature_61","text":"@mock.patch(\"pypowervm.tasks.storage._rest_api_pipe\") def test_upload_stream_api_func(self, mock_rap): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_stream_via_stream_bld","text":"Show source in test_storage.py:291 Tests the uploads of a vDisk - via UploadType.IO_STREAM_BUILDER.","title":"TestUploadLV().test_upload_stream_via_stream_bld"},{"location":"pypowervm/tests/tasks/test_storage/#signature_62","text":"@mock.patch(\"pypowervm.tasks.storage._upload_stream_api\") @mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_stream_via_stream_bld(self, mock_create_file, mock_upload_st): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testuploadlvtest_upload_vopt_by_filepath","text":"Show source in test_storage.py:146 Tests the uploads of the virtual disks with an upload retry.","title":"TestUploadLV().test_upload_vopt_by_filepath"},{"location":"pypowervm/tests/tasks/test_storage/#signature_63","text":"@mock.patch.object(ts.LOG, \"warning\") @mock.patch(\"pypowervm.tasks.storage._create_file\") def test_upload_vopt_by_filepath(self, mock_create_file, mock_log_warn): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testvdisk","text":"Show source in test_storage.py:539","title":"TestVDisk"},{"location":"pypowervm/tests/tasks/test_storage/#signature_64","text":"class TestVDisk(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testvdisksetup","text":"Show source in test_storage.py:540","title":"TestVDisk().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_65","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testvdisktest_crt_vdisk","text":"Show source in test_storage.py:548","title":"TestVDisk().test_crt_vdisk"},{"location":"pypowervm/tests/tasks/test_storage/#signature_66","text":"@mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") @mock.patch(\"pypowervm.adapter.Adapter.read\") def test_crt_vdisk(self, mock_read, mock_update): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testvdisktest_rescan_vstor","text":"Show source in test_storage.py:585","title":"TestVDisk().test_rescan_vstor"},{"location":"pypowervm/tests/tasks/test_storage/#signature_67","text":"@mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.adapter.Adapter.read\") def test_rescan_vstor(self, mock_adpt_read, mock_run_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testvg","text":"Show source in test_storage.py:480","title":"TestVG"},{"location":"pypowervm/tests/tasks/test_storage/#signature_68","text":"class TestVG(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testvgsetup","text":"Show source in test_storage.py:484","title":"TestVG().setUp"},{"location":"pypowervm/tests/tasks/test_storage/#signature_69","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testvgtest_find_vg_all_vioses","text":"Show source in test_storage.py:500","title":"TestVG().test_find_vg_all_vioses"},{"location":"pypowervm/tests/tasks/test_storage/#signature_70","text":"def test_find_vg_all_vioses(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testvgtest_find_vg_no_vios","text":"Show source in test_storage.py:521","title":"TestVG().test_find_vg_no_vios"},{"location":"pypowervm/tests/tasks/test_storage/#signature_71","text":"def test_find_vg_no_vios(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testvgtest_find_vg_not_found","text":"Show source in test_storage.py:530","title":"TestVG().test_find_vg_not_found"},{"location":"pypowervm/tests/tasks/test_storage/#signature_72","text":"def test_find_vg_not_found(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_storage/#testvgtest_find_vg_specified_vios","text":"Show source in test_storage.py:509","title":"TestVG().test_find_vg_specified_vios"},{"location":"pypowervm/tests/tasks/test_storage/#signature_73","text":"def test_find_vg_specified_vios(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/","text":"TestVFCMapper Pypowervm Index / Pypowervm / Tests / Tasks / TestVFCMapper Auto-generated documentation for pypowervm.tests.tasks.test_vfc_mapper module. TestVFCMapper TestAddRemoveMap TestAddRemoveMap().setUp TestAddRemoveMap().test_add_map TestAddRemoveMap().test_add_remove_map_any_wwpn TestPortMappings TestPortMappings().ensure_does_not_have_wwpns TestPortMappings().ensure_has_wwpns TestPortMappings().setUp TestPortMappings().test_add_port_bad_pfc TestPortMappings().test_find_maps TestPortMappings().test_find_pfc_wwpn_by_name TestPortMappings().test_find_vios_for_port_map TestPortMappings().test_find_vios_for_vfc_wwpns TestPortMappings().test_has_client_wwpns TestPortMappings().test_remove_maps TestPortMappings().test_remove_maps_client_adpt TestVFCMapper TestVFCMapper().test_build_migration_mappings TestVFCMapper().test_build_migration_mappings_for_fabric TestVFCMapper().test_build_migration_mappings_for_fabric_invalid_physical_port TestVFCMapper().test_build_wwpn_pair TestVFCMapper().test_derive_base_npiv_map TestVFCMapper().test_derive_npiv_map TestVFCMapper().test_derive_npiv_map_existing_no_bp TestVFCMapper().test_derive_npiv_map_existing_no_preserve TestVFCMapper().test_derive_npiv_map_existing_preserve TestVFCMapper().test_derive_npiv_map_failure TestVFCMapper().test_derive_npiv_map_multi_vio TestVFCMapper().test_find_map_port TestVFCMapper().test_find_vios_for_wwpn TestVFCMapper().test_fuse_vfc_ports TestVFCMapper().test_intersect_wwpns TestAddRemoveMap Show source in test_vfc_mapper.py:574 Signature class TestAddRemoveMap(twrap.TestWrapper): ... TestAddRemoveMap().setUp Show source in test_vfc_mapper.py:579 Signature def setUp(self): ... TestAddRemoveMap().test_add_map Show source in test_vfc_mapper.py:618 Validates the add_map method. Signature def test_add_map(self): ... TestAddRemoveMap().test_add_remove_map_any_wwpn Show source in test_vfc_mapper.py:593 Tests a loop of add map/remove map when using _ANY_WWPN. Signature def test_add_remove_map_any_wwpn(self): ... TestPortMappings Show source in test_vfc_mapper.py:351 Signature class TestPortMappings(twrap.TestWrapper): ... TestPortMappings().ensure_does_not_have_wwpns Show source in test_vfc_mapper.py:471 Signature def ensure_does_not_have_wwpns(self, vios_w, wwpns): ... TestPortMappings().ensure_has_wwpns Show source in test_vfc_mapper.py:479 Signature def ensure_has_wwpns(self, vios_w, wwpns): ... TestPortMappings().setUp Show source in test_vfc_mapper.py:356 Signature def setUp(self): ... TestPortMappings().test_add_port_bad_pfc Show source in test_vfc_mapper.py:457 Validates that an error will be thrown with a bad pfc port. Signature @mock.patch(\"lxml.etree.tostring\") def test_add_port_bad_pfc(self, mock_tostring): ... TestPortMappings().test_find_maps Show source in test_vfc_mapper.py:492 Signature def test_find_maps(self): ... TestPortMappings().test_find_pfc_wwpn_by_name Show source in test_vfc_mapper.py:451 Signature def test_find_pfc_wwpn_by_name(self): ... TestPortMappings().test_find_vios_for_port_map Show source in test_vfc_mapper.py:365 Tests the find_vios_for_port_map method. Signature def test_find_vios_for_port_map(self): ... TestPortMappings().test_find_vios_for_vfc_wwpns Show source in test_vfc_mapper.py:386 Tests the find_vios_for_vfc_wwpns method. Signature def test_find_vios_for_vfc_wwpns(self): ... TestPortMappings().test_has_client_wwpns Show source in test_vfc_mapper.py:553 Signature def test_has_client_wwpns(self): ... TestPortMappings().test_remove_maps Show source in test_vfc_mapper.py:514 Signature def test_remove_maps(self): ... TestPortMappings().test_remove_maps_client_adpt Show source in test_vfc_mapper.py:532 Tests the remove_maps method, with the client_adpt input. Signature def test_remove_maps_client_adpt(self): ... TestVFCMapper Show source in test_vfc_mapper.py:35 Signature class TestVFCMapper(unittest.TestCase): ... TestVFCMapper().test_build_migration_mappings Show source in test_vfc_mapper.py:311 Signature def test_build_migration_mappings(self): ... TestVFCMapper().test_build_migration_mappings_for_fabric Show source in test_vfc_mapper.py:277 Signature @mock.patch(\"pypowervm.tasks.vfc_mapper.derive_base_npiv_map\") def test_build_migration_mappings_for_fabric(self, mock_derive): ... TestVFCMapper().test_build_migration_mappings_for_fabric_invalid_physical_port Show source in test_vfc_mapper.py:298 Signature def test_build_migration_mappings_for_fabric_invalid_physical_port(self): ... TestVFCMapper().test_build_wwpn_pair Show source in test_vfc_mapper.py:37 Signature @mock.patch(\"pypowervm.wrappers.job.Job\") def test_build_wwpn_pair(self, mock_job): ... TestVFCMapper().test_derive_base_npiv_map Show source in test_vfc_mapper.py:184 Signature def test_derive_base_npiv_map(self): ... TestVFCMapper().test_derive_npiv_map Show source in test_vfc_mapper.py:97 Signature def test_derive_npiv_map(self): ... TestVFCMapper().test_derive_npiv_map_existing_no_bp Show source in test_vfc_mapper.py:171 Signature @mock.patch( \"pypowervm.wrappers.virtual_io_server.VFCMapping.backing_port\", new_callable=mock.PropertyMock, return_value=None, ) def test_derive_npiv_map_existing_no_bp(self, mock_bp): ... TestVFCMapper().test_derive_npiv_map_existing_no_preserve Show source in test_vfc_mapper.py:144 Signature def test_derive_npiv_map_existing_no_preserve(self): ... TestVFCMapper().test_derive_npiv_map_existing_preserve Show source in test_vfc_mapper.py:116 Signature def test_derive_npiv_map_existing_preserve(self): ... TestVFCMapper().test_derive_npiv_map_failure Show source in test_vfc_mapper.py:223 Make sure we get a failure in the event of no candidates. Signature def test_derive_npiv_map_failure(self): ... TestVFCMapper().test_derive_npiv_map_multi_vio Show source in test_vfc_mapper.py:205 Signature def test_derive_npiv_map_multi_vio(self): ... TestVFCMapper().test_find_map_port Show source in test_vfc_mapper.py:239 Signature def test_find_map_port(self): ... TestVFCMapper().test_find_vios_for_wwpn Show source in test_vfc_mapper.py:59 Signature def test_find_vios_for_wwpn(self): ... TestVFCMapper().test_fuse_vfc_ports Show source in test_vfc_mapper.py:271 Signature def test_fuse_vfc_ports(self): ... TestVFCMapper().test_intersect_wwpns Show source in test_vfc_mapper.py:81 Signature def test_intersect_wwpns(self): ...","title":"TestVFCMapper"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmapper","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestVFCMapper Auto-generated documentation for pypowervm.tests.tasks.test_vfc_mapper module. TestVFCMapper TestAddRemoveMap TestAddRemoveMap().setUp TestAddRemoveMap().test_add_map TestAddRemoveMap().test_add_remove_map_any_wwpn TestPortMappings TestPortMappings().ensure_does_not_have_wwpns TestPortMappings().ensure_has_wwpns TestPortMappings().setUp TestPortMappings().test_add_port_bad_pfc TestPortMappings().test_find_maps TestPortMappings().test_find_pfc_wwpn_by_name TestPortMappings().test_find_vios_for_port_map TestPortMappings().test_find_vios_for_vfc_wwpns TestPortMappings().test_has_client_wwpns TestPortMappings().test_remove_maps TestPortMappings().test_remove_maps_client_adpt TestVFCMapper TestVFCMapper().test_build_migration_mappings TestVFCMapper().test_build_migration_mappings_for_fabric TestVFCMapper().test_build_migration_mappings_for_fabric_invalid_physical_port TestVFCMapper().test_build_wwpn_pair TestVFCMapper().test_derive_base_npiv_map TestVFCMapper().test_derive_npiv_map TestVFCMapper().test_derive_npiv_map_existing_no_bp TestVFCMapper().test_derive_npiv_map_existing_no_preserve TestVFCMapper().test_derive_npiv_map_existing_preserve TestVFCMapper().test_derive_npiv_map_failure TestVFCMapper().test_derive_npiv_map_multi_vio TestVFCMapper().test_find_map_port TestVFCMapper().test_find_vios_for_wwpn TestVFCMapper().test_fuse_vfc_ports TestVFCMapper().test_intersect_wwpns","title":"TestVFCMapper"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testaddremovemap","text":"Show source in test_vfc_mapper.py:574","title":"TestAddRemoveMap"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature","text":"class TestAddRemoveMap(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testaddremovemapsetup","text":"Show source in test_vfc_mapper.py:579","title":"TestAddRemoveMap().setUp"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testaddremovemaptest_add_map","text":"Show source in test_vfc_mapper.py:618 Validates the add_map method.","title":"TestAddRemoveMap().test_add_map"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_2","text":"def test_add_map(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testaddremovemaptest_add_remove_map_any_wwpn","text":"Show source in test_vfc_mapper.py:593 Tests a loop of add map/remove map when using _ANY_WWPN.","title":"TestAddRemoveMap().test_add_remove_map_any_wwpn"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_3","text":"def test_add_remove_map_any_wwpn(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappings","text":"Show source in test_vfc_mapper.py:351","title":"TestPortMappings"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_4","text":"class TestPortMappings(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingsensure_does_not_have_wwpns","text":"Show source in test_vfc_mapper.py:471","title":"TestPortMappings().ensure_does_not_have_wwpns"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_5","text":"def ensure_does_not_have_wwpns(self, vios_w, wwpns): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingsensure_has_wwpns","text":"Show source in test_vfc_mapper.py:479","title":"TestPortMappings().ensure_has_wwpns"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_6","text":"def ensure_has_wwpns(self, vios_w, wwpns): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingssetup","text":"Show source in test_vfc_mapper.py:356","title":"TestPortMappings().setUp"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_7","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingstest_add_port_bad_pfc","text":"Show source in test_vfc_mapper.py:457 Validates that an error will be thrown with a bad pfc port.","title":"TestPortMappings().test_add_port_bad_pfc"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_8","text":"@mock.patch(\"lxml.etree.tostring\") def test_add_port_bad_pfc(self, mock_tostring): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingstest_find_maps","text":"Show source in test_vfc_mapper.py:492","title":"TestPortMappings().test_find_maps"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_9","text":"def test_find_maps(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingstest_find_pfc_wwpn_by_name","text":"Show source in test_vfc_mapper.py:451","title":"TestPortMappings().test_find_pfc_wwpn_by_name"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_10","text":"def test_find_pfc_wwpn_by_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingstest_find_vios_for_port_map","text":"Show source in test_vfc_mapper.py:365 Tests the find_vios_for_port_map method.","title":"TestPortMappings().test_find_vios_for_port_map"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_11","text":"def test_find_vios_for_port_map(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingstest_find_vios_for_vfc_wwpns","text":"Show source in test_vfc_mapper.py:386 Tests the find_vios_for_vfc_wwpns method.","title":"TestPortMappings().test_find_vios_for_vfc_wwpns"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_12","text":"def test_find_vios_for_vfc_wwpns(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingstest_has_client_wwpns","text":"Show source in test_vfc_mapper.py:553","title":"TestPortMappings().test_has_client_wwpns"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_13","text":"def test_has_client_wwpns(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingstest_remove_maps","text":"Show source in test_vfc_mapper.py:514","title":"TestPortMappings().test_remove_maps"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_14","text":"def test_remove_maps(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testportmappingstest_remove_maps_client_adpt","text":"Show source in test_vfc_mapper.py:532 Tests the remove_maps method, with the client_adpt input.","title":"TestPortMappings().test_remove_maps_client_adpt"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_15","text":"def test_remove_maps_client_adpt(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmapper_1","text":"Show source in test_vfc_mapper.py:35","title":"TestVFCMapper"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_16","text":"class TestVFCMapper(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_build_migration_mappings","text":"Show source in test_vfc_mapper.py:311","title":"TestVFCMapper().test_build_migration_mappings"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_17","text":"def test_build_migration_mappings(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_build_migration_mappings_for_fabric","text":"Show source in test_vfc_mapper.py:277","title":"TestVFCMapper().test_build_migration_mappings_for_fabric"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_18","text":"@mock.patch(\"pypowervm.tasks.vfc_mapper.derive_base_npiv_map\") def test_build_migration_mappings_for_fabric(self, mock_derive): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_build_migration_mappings_for_fabric_invalid_physical_port","text":"Show source in test_vfc_mapper.py:298","title":"TestVFCMapper().test_build_migration_mappings_for_fabric_invalid_physical_port"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_19","text":"def test_build_migration_mappings_for_fabric_invalid_physical_port(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_build_wwpn_pair","text":"Show source in test_vfc_mapper.py:37","title":"TestVFCMapper().test_build_wwpn_pair"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_20","text":"@mock.patch(\"pypowervm.wrappers.job.Job\") def test_build_wwpn_pair(self, mock_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_derive_base_npiv_map","text":"Show source in test_vfc_mapper.py:184","title":"TestVFCMapper().test_derive_base_npiv_map"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_21","text":"def test_derive_base_npiv_map(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_derive_npiv_map","text":"Show source in test_vfc_mapper.py:97","title":"TestVFCMapper().test_derive_npiv_map"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_22","text":"def test_derive_npiv_map(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_derive_npiv_map_existing_no_bp","text":"Show source in test_vfc_mapper.py:171","title":"TestVFCMapper().test_derive_npiv_map_existing_no_bp"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_23","text":"@mock.patch( \"pypowervm.wrappers.virtual_io_server.VFCMapping.backing_port\", new_callable=mock.PropertyMock, return_value=None, ) def test_derive_npiv_map_existing_no_bp(self, mock_bp): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_derive_npiv_map_existing_no_preserve","text":"Show source in test_vfc_mapper.py:144","title":"TestVFCMapper().test_derive_npiv_map_existing_no_preserve"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_24","text":"def test_derive_npiv_map_existing_no_preserve(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_derive_npiv_map_existing_preserve","text":"Show source in test_vfc_mapper.py:116","title":"TestVFCMapper().test_derive_npiv_map_existing_preserve"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_25","text":"def test_derive_npiv_map_existing_preserve(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_derive_npiv_map_failure","text":"Show source in test_vfc_mapper.py:223 Make sure we get a failure in the event of no candidates.","title":"TestVFCMapper().test_derive_npiv_map_failure"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_26","text":"def test_derive_npiv_map_failure(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_derive_npiv_map_multi_vio","text":"Show source in test_vfc_mapper.py:205","title":"TestVFCMapper().test_derive_npiv_map_multi_vio"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_27","text":"def test_derive_npiv_map_multi_vio(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_find_map_port","text":"Show source in test_vfc_mapper.py:239","title":"TestVFCMapper().test_find_map_port"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_28","text":"def test_find_map_port(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_find_vios_for_wwpn","text":"Show source in test_vfc_mapper.py:59","title":"TestVFCMapper().test_find_vios_for_wwpn"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_29","text":"def test_find_vios_for_wwpn(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_fuse_vfc_ports","text":"Show source in test_vfc_mapper.py:271","title":"TestVFCMapper().test_fuse_vfc_ports"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_30","text":"def test_fuse_vfc_ports(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#testvfcmappertest_intersect_wwpns","text":"Show source in test_vfc_mapper.py:81","title":"TestVFCMapper().test_intersect_wwpns"},{"location":"pypowervm/tests/tasks/test_vfc_mapper/#signature_31","text":"def test_intersect_wwpns(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vopt/","text":"TestVOpt Pypowervm Index / Pypowervm / Tests / Tasks / TestVOpt Auto-generated documentation for pypowervm.tests.tasks.test_vopt module. TestVOpt TestVOpt TestVOpt().setUp TestVOpt().test_validate_vopt_vg1 TestVOpt().test_validate_vopt_vg2 TestVOpt Show source in test_vopt.py:25 Tests the vopt file. Signature class TestVOpt(testtools.TestCase): ... TestVOpt().setUp Show source in test_vopt.py:28 Signature def setUp(self): ... TestVOpt().test_validate_vopt_vg1 Show source in test_vopt.py:37 One VIOS, rootvg found; locals are set. Signature @mock.patch(\"pypowervm.wrappers.storage.VG.get\") @mock.patch(\"pypowervm.tasks.partition.get_active_vioses\") def test_validate_vopt_vg1(self, mock_vios_get, mock_vg_get): ... TestVOpt().test_validate_vopt_vg2 Show source in test_vopt.py:62 Dual VIOS, multiple VGs, repos on non-rootvg. Signature @mock.patch(\"pypowervm.tasks.partition.get_active_vioses\") @mock.patch(\"pypowervm.wrappers.storage.VG.get\") @mock.patch(\"pypowervm.wrappers.storage.VMediaRepos.bld\") def test_validate_vopt_vg2(self, mock_vmr_bld, mock_vg_get, mock_vios_get): ...","title":"TestVOpt"},{"location":"pypowervm/tests/tasks/test_vopt/#testvopt","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestVOpt Auto-generated documentation for pypowervm.tests.tasks.test_vopt module. TestVOpt TestVOpt TestVOpt().setUp TestVOpt().test_validate_vopt_vg1 TestVOpt().test_validate_vopt_vg2","title":"TestVOpt"},{"location":"pypowervm/tests/tasks/test_vopt/#testvopt_1","text":"Show source in test_vopt.py:25 Tests the vopt file.","title":"TestVOpt"},{"location":"pypowervm/tests/tasks/test_vopt/#signature","text":"class TestVOpt(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vopt/#testvoptsetup","text":"Show source in test_vopt.py:28","title":"TestVOpt().setUp"},{"location":"pypowervm/tests/tasks/test_vopt/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vopt/#testvopttest_validate_vopt_vg1","text":"Show source in test_vopt.py:37 One VIOS, rootvg found; locals are set.","title":"TestVOpt().test_validate_vopt_vg1"},{"location":"pypowervm/tests/tasks/test_vopt/#signature_2","text":"@mock.patch(\"pypowervm.wrappers.storage.VG.get\") @mock.patch(\"pypowervm.tasks.partition.get_active_vioses\") def test_validate_vopt_vg1(self, mock_vios_get, mock_vg_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vopt/#testvopttest_validate_vopt_vg2","text":"Show source in test_vopt.py:62 Dual VIOS, multiple VGs, repos on non-rootvg.","title":"TestVOpt().test_validate_vopt_vg2"},{"location":"pypowervm/tests/tasks/test_vopt/#signature_3","text":"@mock.patch(\"pypowervm.tasks.partition.get_active_vioses\") @mock.patch(\"pypowervm.wrappers.storage.VG.get\") @mock.patch(\"pypowervm.wrappers.storage.VMediaRepos.bld\") def test_validate_vopt_vg2(self, mock_vmr_bld, mock_vg_get, mock_vios_get): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/","text":"TestVterm Pypowervm Index / Pypowervm / Tests / Tasks / TestVterm Auto-generated documentation for pypowervm.tests.tasks.test_vterm module. TestVterm TestVNCSocketListener TestVNCSocketListener().setUp TestVNCSocketListener().tearDown TestVNCSocketListener().test_check_http_connect TestVNCSocketListener().test_close_client TestVNCSocketListener().test_enable_x509_authentication TestVNCSocketListener().test_enable_x509_authentication_bad_auth_subtype TestVNCSocketListener().test_enable_x509_authentication_bad_auth_type TestVNCSocketListener().test_enable_x509_authentication_bad_auth_version TestVNCSocketListener().test_new_client TestVNCSocketListener().test_new_client_6 TestVNCSocketListener().test_new_client_bad_ip TestVNCSocketListener().test_new_client_bad_ip6 TestVNCSocketListener().test_new_client_no_verify TestVNCSocketListener().test_new_client_validation_checks TestVNCSocketListener().test_run_new_client TestVNCSocketListener().test_stop TestVterm TestVterm().setUp TestVterm().test_close_vterm_local TestVterm().test_close_vterm_non_local TestVterm().test_open_vnc_vterm TestVterm().test_open_vnc_vterm_existing TestVterm().test_open_vnc_vterm_force_bad_error TestVterm().test_open_vnc_vterm_ibmi TestVterm().test_open_vnc_vterm_non_ibmi TestVterm().test_open_vnc_vterm_nonascii TestVterm().test_open_vnc_vterm_nonvnc_force TestVterm().test_open_vnc_vterm_nonvnc_noforce TestVNCSocketListener Show source in test_vterm.py:212 Unit Tests for _VNCSocketListener vterm. Signature class TestVNCSocketListener(testtools.TestCase): ... TestVNCSocketListener().setUp Show source in test_vterm.py:215 Signature def setUp(self): ... TestVNCSocketListener().tearDown Show source in test_vterm.py:234 Tear down the Session instance. Signature def tearDown(self): ... TestVNCSocketListener().test_check_http_connect Show source in test_vterm.py:302 Signature def test_check_http_connect(self): ... TestVNCSocketListener().test_close_client Show source in test_vterm.py:361 Signature @mock.patch(\"pypowervm.tasks.vterm._close_vterm_local\") def test_close_client(self, mock_close): ... TestVNCSocketListener().test_enable_x509_authentication Show source in test_vterm.py:418 Signature @mock.patch(\"select.select\") @mock.patch(\"ssl.wrap_socket\", mock.Mock()) def test_enable_x509_authentication(self, mock_select): ... TestVNCSocketListener().test_enable_x509_authentication_bad_auth_subtype Show source in test_vterm.py:470 Signature @mock.patch(\"select.select\") def test_enable_x509_authentication_bad_auth_subtype(self, mock_select): ... TestVNCSocketListener().test_enable_x509_authentication_bad_auth_type Show source in test_vterm.py:438 Signature @mock.patch(\"select.select\") def test_enable_x509_authentication_bad_auth_type(self, mock_select): ... TestVNCSocketListener().test_enable_x509_authentication_bad_auth_version Show source in test_vterm.py:454 Signature @mock.patch(\"select.select\") def test_enable_x509_authentication_bad_auth_version(self, mock_select): ... TestVNCSocketListener().test_new_client Show source in test_vterm.py:265 Signature @mock.patch(\"select.select\") @mock.patch(\"socket.socket\") def test_new_client(self, mock_sock, mock_select): ... TestVNCSocketListener().test_new_client_6 Show source in test_vterm.py:284 Signature @mock.patch(\"select.select\") @mock.patch(\"socket.socket\") def test_new_client_6(self, mock_sock, mock_select): ... TestVNCSocketListener().test_new_client_bad_ip Show source in test_vterm.py:316 Tests that a new client will be rejected if a bad IP. Signature def test_new_client_bad_ip(self): ... TestVNCSocketListener().test_new_client_bad_ip6 Show source in test_vterm.py:327 Signature def test_new_client_bad_ip6(self): ... TestVNCSocketListener().test_new_client_no_verify Show source in test_vterm.py:250 Signature @mock.patch(\"socket.socket\") def test_new_client_no_verify(self, mock_sock): ... TestVNCSocketListener().test_new_client_validation_checks Show source in test_vterm.py:337 Signature @mock.patch(\"select.select\") def test_new_client_validation_checks(self, mock_select): ... TestVNCSocketListener().test_run_new_client Show source in test_vterm.py:376 Signature @mock.patch(\"pypowervm.tasks.vterm._VNCSocketListener._new_client\") @mock.patch(\"select.select\") @mock.patch(\"socket.socket\") def test_run_new_client(self, mock_socket, mock_select, mock_new_client): ... TestVNCSocketListener().test_stop Show source in test_vterm.py:245 Signature def test_stop(self): ... TestVterm Show source in test_vterm.py:27 Unit Tests for LPAR vterm. Signature class TestVterm(testtools.TestCase): ... TestVterm().setUp Show source in test_vterm.py:30 Signature def setUp(self): ... TestVterm().test_close_vterm_local Show source in test_vterm.py:204 Signature @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_close_vterm_local(self, mock_run_proc, mock_get_lpar_id): ... TestVterm().test_close_vterm_non_local Show source in test_vterm.py:35 Performs a close LPAR vterm test. Signature @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_close_vterm_non_local(self, mock_run_job): ... TestVterm().test_open_vnc_vterm Show source in test_vterm.py:52 Validates the output from the mkvterm if a vterm is not active. Signature @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm(self, mock_run_proc, mock_get_lpar_id): ... TestVterm().test_open_vnc_vterm_existing Show source in test_vterm.py:107 Validates the output from the mkvterm if a VNC vterm is active. Signature @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_existing(self, mock_run_proc, mock_get_lpar_id): ... TestVterm().test_open_vnc_vterm_force_bad_error Show source in test_vterm.py:183 Validates the output from mkvterm if force but unexpected error. Signature @mock.patch(\"pypowervm.tasks.vterm.close_vterm\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_force_bad_error( self, mock_run_proc, mock_get_lpar_id, mock_close ): ... TestVterm().test_open_vnc_vterm_ibmi Show source in test_vterm.py:68 Validates the mkvterm command for ibmi console. Signature @mock.patch(\"pypowervm.tasks.vterm._get_lpar_type\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_ibmi(self, mock_run_proc, mock_get_lpar_id, mock_get_lpar_type): ... TestVterm().test_open_vnc_vterm_non_ibmi Show source in test_vterm.py:88 Validates the mkvterm command for non ibmi console. Signature @mock.patch(\"pypowervm.tasks.vterm._get_lpar_type\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_non_ibmi( self, mock_run_proc, mock_get_lpar_id, mock_get_lpar_type ): ... TestVterm().test_open_vnc_vterm_nonascii Show source in test_vterm.py:123 Validates errors in non-ascii encodings are handled properly Signature @mock.patch(\"subprocess.Popen\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") def test_open_vnc_vterm_nonascii(self, mock_get_lpar_id, mock_popen): ... TestVterm().test_open_vnc_vterm_nonvnc_force Show source in test_vterm.py:135 Validates the output from mkvterm if non-vnc active and force. Signature @mock.patch(\"pypowervm.tasks.vterm.close_vterm\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_nonvnc_force(self, mock_run_proc, mock_get_lpar_id, mock_close): ... TestVterm().test_open_vnc_vterm_nonvnc_noforce Show source in test_vterm.py:161 Validates the output from mkvterm if non-vnc active and no force. Signature @mock.patch(\"pypowervm.tasks.vterm.close_vterm\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_nonvnc_noforce( self, mock_run_proc, mock_get_lpar_id, mock_close ): ...","title":"TestVterm"},{"location":"pypowervm/tests/tasks/test_vterm/#testvterm","text":"Pypowervm Index / Pypowervm / Tests / Tasks / TestVterm Auto-generated documentation for pypowervm.tests.tasks.test_vterm module. TestVterm TestVNCSocketListener TestVNCSocketListener().setUp TestVNCSocketListener().tearDown TestVNCSocketListener().test_check_http_connect TestVNCSocketListener().test_close_client TestVNCSocketListener().test_enable_x509_authentication TestVNCSocketListener().test_enable_x509_authentication_bad_auth_subtype TestVNCSocketListener().test_enable_x509_authentication_bad_auth_type TestVNCSocketListener().test_enable_x509_authentication_bad_auth_version TestVNCSocketListener().test_new_client TestVNCSocketListener().test_new_client_6 TestVNCSocketListener().test_new_client_bad_ip TestVNCSocketListener().test_new_client_bad_ip6 TestVNCSocketListener().test_new_client_no_verify TestVNCSocketListener().test_new_client_validation_checks TestVNCSocketListener().test_run_new_client TestVNCSocketListener().test_stop TestVterm TestVterm().setUp TestVterm().test_close_vterm_local TestVterm().test_close_vterm_non_local TestVterm().test_open_vnc_vterm TestVterm().test_open_vnc_vterm_existing TestVterm().test_open_vnc_vterm_force_bad_error TestVterm().test_open_vnc_vterm_ibmi TestVterm().test_open_vnc_vterm_non_ibmi TestVterm().test_open_vnc_vterm_nonascii TestVterm().test_open_vnc_vterm_nonvnc_force TestVterm().test_open_vnc_vterm_nonvnc_noforce","title":"TestVterm"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistener","text":"Show source in test_vterm.py:212 Unit Tests for _VNCSocketListener vterm.","title":"TestVNCSocketListener"},{"location":"pypowervm/tests/tasks/test_vterm/#signature","text":"class TestVNCSocketListener(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenersetup","text":"Show source in test_vterm.py:215","title":"TestVNCSocketListener().setUp"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenerteardown","text":"Show source in test_vterm.py:234 Tear down the Session instance.","title":"TestVNCSocketListener().tearDown"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_2","text":"def tearDown(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_check_http_connect","text":"Show source in test_vterm.py:302","title":"TestVNCSocketListener().test_check_http_connect"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_3","text":"def test_check_http_connect(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_close_client","text":"Show source in test_vterm.py:361","title":"TestVNCSocketListener().test_close_client"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_4","text":"@mock.patch(\"pypowervm.tasks.vterm._close_vterm_local\") def test_close_client(self, mock_close): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_enable_x509_authentication","text":"Show source in test_vterm.py:418","title":"TestVNCSocketListener().test_enable_x509_authentication"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_5","text":"@mock.patch(\"select.select\") @mock.patch(\"ssl.wrap_socket\", mock.Mock()) def test_enable_x509_authentication(self, mock_select): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_enable_x509_authentication_bad_auth_subtype","text":"Show source in test_vterm.py:470","title":"TestVNCSocketListener().test_enable_x509_authentication_bad_auth_subtype"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_6","text":"@mock.patch(\"select.select\") def test_enable_x509_authentication_bad_auth_subtype(self, mock_select): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_enable_x509_authentication_bad_auth_type","text":"Show source in test_vterm.py:438","title":"TestVNCSocketListener().test_enable_x509_authentication_bad_auth_type"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_7","text":"@mock.patch(\"select.select\") def test_enable_x509_authentication_bad_auth_type(self, mock_select): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_enable_x509_authentication_bad_auth_version","text":"Show source in test_vterm.py:454","title":"TestVNCSocketListener().test_enable_x509_authentication_bad_auth_version"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_8","text":"@mock.patch(\"select.select\") def test_enable_x509_authentication_bad_auth_version(self, mock_select): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_new_client","text":"Show source in test_vterm.py:265","title":"TestVNCSocketListener().test_new_client"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_9","text":"@mock.patch(\"select.select\") @mock.patch(\"socket.socket\") def test_new_client(self, mock_sock, mock_select): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_new_client_6","text":"Show source in test_vterm.py:284","title":"TestVNCSocketListener().test_new_client_6"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_10","text":"@mock.patch(\"select.select\") @mock.patch(\"socket.socket\") def test_new_client_6(self, mock_sock, mock_select): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_new_client_bad_ip","text":"Show source in test_vterm.py:316 Tests that a new client will be rejected if a bad IP.","title":"TestVNCSocketListener().test_new_client_bad_ip"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_11","text":"def test_new_client_bad_ip(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_new_client_bad_ip6","text":"Show source in test_vterm.py:327","title":"TestVNCSocketListener().test_new_client_bad_ip6"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_12","text":"def test_new_client_bad_ip6(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_new_client_no_verify","text":"Show source in test_vterm.py:250","title":"TestVNCSocketListener().test_new_client_no_verify"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_13","text":"@mock.patch(\"socket.socket\") def test_new_client_no_verify(self, mock_sock): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_new_client_validation_checks","text":"Show source in test_vterm.py:337","title":"TestVNCSocketListener().test_new_client_validation_checks"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_14","text":"@mock.patch(\"select.select\") def test_new_client_validation_checks(self, mock_select): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_run_new_client","text":"Show source in test_vterm.py:376","title":"TestVNCSocketListener().test_run_new_client"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_15","text":"@mock.patch(\"pypowervm.tasks.vterm._VNCSocketListener._new_client\") @mock.patch(\"select.select\") @mock.patch(\"socket.socket\") def test_run_new_client(self, mock_socket, mock_select, mock_new_client): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvncsocketlistenertest_stop","text":"Show source in test_vterm.py:245","title":"TestVNCSocketListener().test_stop"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_16","text":"def test_stop(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvterm_1","text":"Show source in test_vterm.py:27 Unit Tests for LPAR vterm.","title":"TestVterm"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_17","text":"class TestVterm(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermsetup","text":"Show source in test_vterm.py:30","title":"TestVterm().setUp"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_18","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermtest_close_vterm_local","text":"Show source in test_vterm.py:204","title":"TestVterm().test_close_vterm_local"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_19","text":"@mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_close_vterm_local(self, mock_run_proc, mock_get_lpar_id): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermtest_close_vterm_non_local","text":"Show source in test_vterm.py:35 Performs a close LPAR vterm test.","title":"TestVterm().test_close_vterm_non_local"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_20","text":"@mock.patch(\"pypowervm.wrappers.job.Job.run_job\") def test_close_vterm_non_local(self, mock_run_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermtest_open_vnc_vterm","text":"Show source in test_vterm.py:52 Validates the output from the mkvterm if a vterm is not active.","title":"TestVterm().test_open_vnc_vterm"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_21","text":"@mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm(self, mock_run_proc, mock_get_lpar_id): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermtest_open_vnc_vterm_existing","text":"Show source in test_vterm.py:107 Validates the output from the mkvterm if a VNC vterm is active.","title":"TestVterm().test_open_vnc_vterm_existing"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_22","text":"@mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_existing(self, mock_run_proc, mock_get_lpar_id): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermtest_open_vnc_vterm_force_bad_error","text":"Show source in test_vterm.py:183 Validates the output from mkvterm if force but unexpected error.","title":"TestVterm().test_open_vnc_vterm_force_bad_error"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_23","text":"@mock.patch(\"pypowervm.tasks.vterm.close_vterm\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_force_bad_error( self, mock_run_proc, mock_get_lpar_id, mock_close ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermtest_open_vnc_vterm_ibmi","text":"Show source in test_vterm.py:68 Validates the mkvterm command for ibmi console.","title":"TestVterm().test_open_vnc_vterm_ibmi"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_24","text":"@mock.patch(\"pypowervm.tasks.vterm._get_lpar_type\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_ibmi(self, mock_run_proc, mock_get_lpar_id, mock_get_lpar_type): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermtest_open_vnc_vterm_non_ibmi","text":"Show source in test_vterm.py:88 Validates the mkvterm command for non ibmi console.","title":"TestVterm().test_open_vnc_vterm_non_ibmi"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_25","text":"@mock.patch(\"pypowervm.tasks.vterm._get_lpar_type\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_non_ibmi( self, mock_run_proc, mock_get_lpar_id, mock_get_lpar_type ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermtest_open_vnc_vterm_nonascii","text":"Show source in test_vterm.py:123 Validates errors in non-ascii encodings are handled properly","title":"TestVterm().test_open_vnc_vterm_nonascii"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_26","text":"@mock.patch(\"subprocess.Popen\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") def test_open_vnc_vterm_nonascii(self, mock_get_lpar_id, mock_popen): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermtest_open_vnc_vterm_nonvnc_force","text":"Show source in test_vterm.py:135 Validates the output from mkvterm if non-vnc active and force.","title":"TestVterm().test_open_vnc_vterm_nonvnc_force"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_27","text":"@mock.patch(\"pypowervm.tasks.vterm.close_vterm\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_nonvnc_force(self, mock_run_proc, mock_get_lpar_id, mock_close): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/test_vterm/#testvtermtest_open_vnc_vterm_nonvnc_noforce","text":"Show source in test_vterm.py:161 Validates the output from mkvterm if non-vnc active and no force.","title":"TestVterm().test_open_vnc_vterm_nonvnc_noforce"},{"location":"pypowervm/tests/tasks/test_vterm/#signature_28","text":"@mock.patch(\"pypowervm.tasks.vterm.close_vterm\") @mock.patch(\"pypowervm.tasks.vterm._get_lpar_id\") @mock.patch(\"pypowervm.tasks.vterm._run_proc\") def test_open_vnc_vterm_nonvnc_noforce( self, mock_run_proc, mock_get_lpar_id, mock_close ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/util/","text":"Util Pypowervm Index / Pypowervm / Tests / Tasks / Util Auto-generated documentation for pypowervm.tests.tasks.util module. Util get_parm_checker load_file raiseRetryException get_parm_checker Show source in util.py:37 Signature def get_parm_checker( test_obj, exp_uuid, exp_job_parms, exp_job_mappings=[], exp_timeout=None ): ... load_file Show source in util.py:24 Helper method to load the responses from a given location. Signature def load_file(file_name, adapter=None): ... raiseRetryException Show source in util.py:29 Used for other tests wishing to raise an exception to a force retry. Signature def raiseRetryException(): ...","title":"Util"},{"location":"pypowervm/tests/tasks/util/#util","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Util Auto-generated documentation for pypowervm.tests.tasks.util module. Util get_parm_checker load_file raiseRetryException","title":"Util"},{"location":"pypowervm/tests/tasks/util/#get_parm_checker","text":"Show source in util.py:37","title":"get_parm_checker"},{"location":"pypowervm/tests/tasks/util/#signature","text":"def get_parm_checker( test_obj, exp_uuid, exp_job_parms, exp_job_mappings=[], exp_timeout=None ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/util/#load_file","text":"Show source in util.py:24 Helper method to load the responses from a given location.","title":"load_file"},{"location":"pypowervm/tests/tasks/util/#signature_1","text":"def load_file(file_name, adapter=None): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/util/#raiseretryexception","text":"Show source in util.py:29 Used for other tests wishing to raise an exception to a force retry.","title":"raiseRetryException"},{"location":"pypowervm/tests/tasks/util/#signature_2","text":"def raiseRetryException(): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/","text":"Hdisk Pypowervm Index / Pypowervm / Tests / Tasks / Hdisk Auto-generated documentation for pypowervm.tests.tasks.hdisk module. Hdisk Modules Modules TestFC TestIscsi TestRbd","title":"Hdisk"},{"location":"pypowervm/tests/tasks/hdisk/#hdisk","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Hdisk Auto-generated documentation for pypowervm.tests.tasks.hdisk module. Hdisk Modules","title":"Hdisk"},{"location":"pypowervm/tests/tasks/hdisk/#modules","text":"TestFC TestIscsi TestRbd","title":"Modules"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/","text":"TestFC Pypowervm Index / Pypowervm / Tests / Tasks / Hdisk / TestFC Auto-generated documentation for pypowervm.tests.tasks.hdisk.test_fc module. TestFC TestFC TestFC().setUp TestFC().test_build_itls TestFC().test_discover_hdisk TestFC().test_itl TestFC().test_lua_recovery TestFC().test_lua_recovery_dupe_itls TestFC().test_lua_recovery_xml TestFC().test_normalize_lun TestFC().test_process_lua_result TestFC().test_process_lua_result_no_resp TestFC().test_process_lua_result_terse_resp TestFC().test_remove_hdisk_classic TestFC().test_remove_hdisk_job TestFC().test_validate_lua_status TestFC Show source in test_fc.py:27 Signature class TestFC(unittest.TestCase): ... TestFC().setUp Show source in test_fc.py:29 Signature def setUp(self): ... TestFC().test_build_itls Show source in test_fc.py:43 Tests that the ITL combinations can be built out. Signature def test_build_itls(self): ... TestFC().test_discover_hdisk Show source in test_fc.py:187 Signature @mock.patch(\"pypowervm.tasks.hdisk._fc.lua_recovery\") @mock.patch(\"pypowervm.utils.transaction.FeedTask\") @mock.patch(\"pypowervm.tasks.storage.add_lpar_storage_scrub_tasks\") @mock.patch(\"pypowervm.tasks.storage.find_stale_lpars\") @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.get\", new=mock.Mock()) def test_discover_hdisk(self, mock_fsl, mock_alsst, mock_ftsk, mock_luar): ... TestFC().test_itl Show source in test_fc.py:32 Tests the ITL class. Signature def test_itl(self): ... TestFC().test_lua_recovery Show source in test_fc.py:142 Signature @mock.patch(\"pypowervm.tasks.hdisk._fc._process_lua_result\") @mock.patch(\"pypowervm.wrappers.job.Job\", new=mock.Mock()) @mock.patch(\"pypowervm.adapter.Adapter\") def test_lua_recovery(self, mock_adapter, mock_lua_result): ... TestFC().test_lua_recovery_dupe_itls Show source in test_fc.py:162 Signature @mock.patch(\"pypowervm.tasks.hdisk._fc._lua_recovery_xml\") @mock.patch(\"pypowervm.tasks.hdisk._fc._process_lua_result\") @mock.patch(\"pypowervm.wrappers.job.Job\", new=mock.Mock()) @mock.patch(\"pypowervm.adapter.Adapter\") def test_lua_recovery_dupe_itls(self, mock_adapter, mock_lua_result, mock_lua_xml): ... TestFC().test_lua_recovery_xml Show source in test_fc.py:59 Validates that the LUA recovery XML is build properly. Signature def test_lua_recovery_xml(self): ... TestFC().test_normalize_lun Show source in test_fc.py:296 Signature def test_normalize_lun(self): ... TestFC().test_process_lua_result Show source in test_fc.py:103 Signature def test_process_lua_result(self): ... TestFC().test_process_lua_result_no_resp Show source in test_fc.py:86 Signature def test_process_lua_result_no_resp(self): ... TestFC().test_process_lua_result_terse_resp Show source in test_fc.py:93 Tests where valid XML is returned, but no device. Signature def test_process_lua_result_terse_resp(self): ... TestFC().test_remove_hdisk_classic Show source in test_fc.py:260 Signature @mock.patch(\"pypowervm.wrappers.job.Job.job_status\", new=mock.Mock()) @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.adapter.Adapter\") def test_remove_hdisk_classic(self, mock_adapter, mock_run_job): ... TestFC().test_remove_hdisk_job Show source in test_fc.py:273 Signature @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.adapter.Adapter\") def test_remove_hdisk_job(self, mock_adapter, mock_run_job): ... TestFC().test_validate_lua_status Show source in test_fc.py:122 This tests the branches of validate_lua_status. Signature @mock.patch(\"pypowervm.tasks.hdisk._fc.LOG\") def test_validate_lua_status(self, mock_log): ...","title":"TestFC"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfc","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Hdisk / TestFC Auto-generated documentation for pypowervm.tests.tasks.hdisk.test_fc module. TestFC TestFC TestFC().setUp TestFC().test_build_itls TestFC().test_discover_hdisk TestFC().test_itl TestFC().test_lua_recovery TestFC().test_lua_recovery_dupe_itls TestFC().test_lua_recovery_xml TestFC().test_normalize_lun TestFC().test_process_lua_result TestFC().test_process_lua_result_no_resp TestFC().test_process_lua_result_terse_resp TestFC().test_remove_hdisk_classic TestFC().test_remove_hdisk_job TestFC().test_validate_lua_status","title":"TestFC"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfc_1","text":"Show source in test_fc.py:27","title":"TestFC"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature","text":"class TestFC(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfcsetup","text":"Show source in test_fc.py:29","title":"TestFC().setUp"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_build_itls","text":"Show source in test_fc.py:43 Tests that the ITL combinations can be built out.","title":"TestFC().test_build_itls"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_2","text":"def test_build_itls(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_discover_hdisk","text":"Show source in test_fc.py:187","title":"TestFC().test_discover_hdisk"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_3","text":"@mock.patch(\"pypowervm.tasks.hdisk._fc.lua_recovery\") @mock.patch(\"pypowervm.utils.transaction.FeedTask\") @mock.patch(\"pypowervm.tasks.storage.add_lpar_storage_scrub_tasks\") @mock.patch(\"pypowervm.tasks.storage.find_stale_lpars\") @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.get\", new=mock.Mock()) def test_discover_hdisk(self, mock_fsl, mock_alsst, mock_ftsk, mock_luar): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_itl","text":"Show source in test_fc.py:32 Tests the ITL class.","title":"TestFC().test_itl"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_4","text":"def test_itl(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_lua_recovery","text":"Show source in test_fc.py:142","title":"TestFC().test_lua_recovery"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_5","text":"@mock.patch(\"pypowervm.tasks.hdisk._fc._process_lua_result\") @mock.patch(\"pypowervm.wrappers.job.Job\", new=mock.Mock()) @mock.patch(\"pypowervm.adapter.Adapter\") def test_lua_recovery(self, mock_adapter, mock_lua_result): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_lua_recovery_dupe_itls","text":"Show source in test_fc.py:162","title":"TestFC().test_lua_recovery_dupe_itls"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_6","text":"@mock.patch(\"pypowervm.tasks.hdisk._fc._lua_recovery_xml\") @mock.patch(\"pypowervm.tasks.hdisk._fc._process_lua_result\") @mock.patch(\"pypowervm.wrappers.job.Job\", new=mock.Mock()) @mock.patch(\"pypowervm.adapter.Adapter\") def test_lua_recovery_dupe_itls(self, mock_adapter, mock_lua_result, mock_lua_xml): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_lua_recovery_xml","text":"Show source in test_fc.py:59 Validates that the LUA recovery XML is build properly.","title":"TestFC().test_lua_recovery_xml"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_7","text":"def test_lua_recovery_xml(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_normalize_lun","text":"Show source in test_fc.py:296","title":"TestFC().test_normalize_lun"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_8","text":"def test_normalize_lun(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_process_lua_result","text":"Show source in test_fc.py:103","title":"TestFC().test_process_lua_result"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_9","text":"def test_process_lua_result(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_process_lua_result_no_resp","text":"Show source in test_fc.py:86","title":"TestFC().test_process_lua_result_no_resp"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_10","text":"def test_process_lua_result_no_resp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_process_lua_result_terse_resp","text":"Show source in test_fc.py:93 Tests where valid XML is returned, but no device.","title":"TestFC().test_process_lua_result_terse_resp"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_11","text":"def test_process_lua_result_terse_resp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_remove_hdisk_classic","text":"Show source in test_fc.py:260","title":"TestFC().test_remove_hdisk_classic"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_12","text":"@mock.patch(\"pypowervm.wrappers.job.Job.job_status\", new=mock.Mock()) @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.adapter.Adapter\") def test_remove_hdisk_classic(self, mock_adapter, mock_run_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_remove_hdisk_job","text":"Show source in test_fc.py:273","title":"TestFC().test_remove_hdisk_job"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_13","text":"@mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.adapter.Adapter\") def test_remove_hdisk_job(self, mock_adapter, mock_run_job): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#testfctest_validate_lua_status","text":"Show source in test_fc.py:122 This tests the branches of validate_lua_status.","title":"TestFC().test_validate_lua_status"},{"location":"pypowervm/tests/tasks/hdisk/test_fc/#signature_14","text":"@mock.patch(\"pypowervm.tasks.hdisk._fc.LOG\") def test_validate_lua_status(self, mock_log): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/","text":"TestIscsi Pypowervm Index / Pypowervm / Tests / Tasks / Hdisk / TestIscsi Auto-generated documentation for pypowervm.tests.tasks.hdisk.test_iscsi module. TestIscsi TestIscsi TestIscsi().setUp TestIscsi().test_add_parameter TestIscsi().test_discover_initiator TestIscsi().test_discover_iscsi TestIscsi().test_discover_iscsi_scrub TestIscsi().test_log_iscsi_status TestIscsi().test_remove_iscsi TestIscsi Show source in test_iscsi.py:27 Signature class TestIscsi(testtools.TestCase): ... TestIscsi().setUp Show source in test_iscsi.py:29 Signature def setUp(self): ... TestIscsi().test_add_parameter Show source in test_iscsi.py:35 Signature @mock.patch(\"pypowervm.wrappers.job.Job.create_job_parameter\") def test_add_parameter(self, mock_create): ... TestIscsi().test_discover_initiator Show source in test_iscsi.py:189 Signature @mock.patch(\"pypowervm.wrappers.job.Job.wrap\") @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.wrappers.job.Job.get_job_results_as_dict\") def test_discover_initiator(self, mock_job_res, mock_run_job, mock_job_w): ... TestIscsi().test_discover_iscsi Show source in test_iscsi.py:56 Signature @mock.patch(\"pypowervm.wrappers.job.Job.wrap\") @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.wrappers.job.Job.create_job_parameter\") @mock.patch(\"pypowervm.wrappers.job.Job.get_job_results_as_dict\") def test_discover_iscsi(self, mock_job_res, mock_job_p, mock_run_job, mock_job_w): ... TestIscsi().test_discover_iscsi_scrub Show source in test_iscsi.py:127 Signature @mock.patch(\"pypowervm.tasks.hdisk._iscsi.remove_iscsi\") @mock.patch(\"pypowervm.tasks.hdisk._iscsi._discover_iscsi\") @mock.patch(\"pypowervm.utils.transaction.FeedTask\") @mock.patch(\"pypowervm.tasks.storage.add_lpar_storage_scrub_tasks\") @mock.patch(\"pypowervm.tasks.storage.find_stale_lpars\") @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.get\", new=mock.Mock()) def test_discover_iscsi_scrub( self, mock_fsl, mock_alsst, mock_ftsk, mock_discover, mock_remove ): ... TestIscsi().test_log_iscsi_status Show source in test_iscsi.py:252 This tests the branches of log_iscsi_status. Signature @mock.patch(\"pypowervm.tasks.hdisk._iscsi.LOG\") def test_log_iscsi_status(self, mock_log): ... TestIscsi().test_remove_iscsi Show source in test_iscsi.py:209 Signature @mock.patch(\"pypowervm.wrappers.job.Job.create_job_parameter\") @mock.patch(\"pypowervm.wrappers.job.Job.wrap\") @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.wrappers.job.Job.get_job_results_as_dict\") def test_remove_iscsi(self, mock_job_res, mock_run_job, mock_job_w, mock_job_p): ...","title":"TestIscsi"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#testiscsi","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Hdisk / TestIscsi Auto-generated documentation for pypowervm.tests.tasks.hdisk.test_iscsi module. TestIscsi TestIscsi TestIscsi().setUp TestIscsi().test_add_parameter TestIscsi().test_discover_initiator TestIscsi().test_discover_iscsi TestIscsi().test_discover_iscsi_scrub TestIscsi().test_log_iscsi_status TestIscsi().test_remove_iscsi","title":"TestIscsi"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#testiscsi_1","text":"Show source in test_iscsi.py:27","title":"TestIscsi"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#signature","text":"class TestIscsi(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#testiscsisetup","text":"Show source in test_iscsi.py:29","title":"TestIscsi().setUp"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#testiscsitest_add_parameter","text":"Show source in test_iscsi.py:35","title":"TestIscsi().test_add_parameter"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#signature_2","text":"@mock.patch(\"pypowervm.wrappers.job.Job.create_job_parameter\") def test_add_parameter(self, mock_create): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#testiscsitest_discover_initiator","text":"Show source in test_iscsi.py:189","title":"TestIscsi().test_discover_initiator"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#signature_3","text":"@mock.patch(\"pypowervm.wrappers.job.Job.wrap\") @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.wrappers.job.Job.get_job_results_as_dict\") def test_discover_initiator(self, mock_job_res, mock_run_job, mock_job_w): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#testiscsitest_discover_iscsi","text":"Show source in test_iscsi.py:56","title":"TestIscsi().test_discover_iscsi"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#signature_4","text":"@mock.patch(\"pypowervm.wrappers.job.Job.wrap\") @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.wrappers.job.Job.create_job_parameter\") @mock.patch(\"pypowervm.wrappers.job.Job.get_job_results_as_dict\") def test_discover_iscsi(self, mock_job_res, mock_job_p, mock_run_job, mock_job_w): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#testiscsitest_discover_iscsi_scrub","text":"Show source in test_iscsi.py:127","title":"TestIscsi().test_discover_iscsi_scrub"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#signature_5","text":"@mock.patch(\"pypowervm.tasks.hdisk._iscsi.remove_iscsi\") @mock.patch(\"pypowervm.tasks.hdisk._iscsi._discover_iscsi\") @mock.patch(\"pypowervm.utils.transaction.FeedTask\") @mock.patch(\"pypowervm.tasks.storage.add_lpar_storage_scrub_tasks\") @mock.patch(\"pypowervm.tasks.storage.find_stale_lpars\") @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.get\", new=mock.Mock()) def test_discover_iscsi_scrub( self, mock_fsl, mock_alsst, mock_ftsk, mock_discover, mock_remove ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#testiscsitest_log_iscsi_status","text":"Show source in test_iscsi.py:252 This tests the branches of log_iscsi_status.","title":"TestIscsi().test_log_iscsi_status"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#signature_6","text":"@mock.patch(\"pypowervm.tasks.hdisk._iscsi.LOG\") def test_log_iscsi_status(self, mock_log): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#testiscsitest_remove_iscsi","text":"Show source in test_iscsi.py:209","title":"TestIscsi().test_remove_iscsi"},{"location":"pypowervm/tests/tasks/hdisk/test_iscsi/#signature_7","text":"@mock.patch(\"pypowervm.wrappers.job.Job.create_job_parameter\") @mock.patch(\"pypowervm.wrappers.job.Job.wrap\") @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.wrappers.job.Job.get_job_results_as_dict\") def test_remove_iscsi(self, mock_job_res, mock_run_job, mock_job_w, mock_job_p): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_rbd/","text":"TestRbd Pypowervm Index / Pypowervm / Tests / Tasks / Hdisk / TestRbd Auto-generated documentation for pypowervm.tests.tasks.hdisk.test_rbd module. TestRbd TestRbd TestRbd().setUp TestRbd().test_rbd_exists TestRbd Show source in test_rbd.py:26 Signature class TestRbd(testtools.TestCase): ... TestRbd().setUp Show source in test_rbd.py:28 Signature def setUp(self): ... TestRbd().test_rbd_exists Show source in test_rbd.py:34 Signature @mock.patch(\"pypowervm.wrappers.job.Job.create_job_parameter\") @mock.patch(\"pypowervm.wrappers.job.Job.wrap\") @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.wrappers.job.Job.get_job_results_as_dict\") def test_rbd_exists(self, mock_job_res, mock_run_job, mock_job_w, mock_job_p): ...","title":"TestRbd"},{"location":"pypowervm/tests/tasks/hdisk/test_rbd/#testrbd","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Hdisk / TestRbd Auto-generated documentation for pypowervm.tests.tasks.hdisk.test_rbd module. TestRbd TestRbd TestRbd().setUp TestRbd().test_rbd_exists","title":"TestRbd"},{"location":"pypowervm/tests/tasks/hdisk/test_rbd/#testrbd_1","text":"Show source in test_rbd.py:26","title":"TestRbd"},{"location":"pypowervm/tests/tasks/hdisk/test_rbd/#signature","text":"class TestRbd(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_rbd/#testrbdsetup","text":"Show source in test_rbd.py:28","title":"TestRbd().setUp"},{"location":"pypowervm/tests/tasks/hdisk/test_rbd/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/hdisk/test_rbd/#testrbdtest_rbd_exists","text":"Show source in test_rbd.py:34","title":"TestRbd().test_rbd_exists"},{"location":"pypowervm/tests/tasks/hdisk/test_rbd/#signature_2","text":"@mock.patch(\"pypowervm.wrappers.job.Job.create_job_parameter\") @mock.patch(\"pypowervm.wrappers.job.Job.wrap\") @mock.patch(\"pypowervm.wrappers.job.Job.run_job\") @mock.patch(\"pypowervm.wrappers.job.Job.get_job_results_as_dict\") def test_rbd_exists(self, mock_job_res, mock_run_job, mock_job_w, mock_job_p): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/","text":"Monitor Pypowervm Index / Pypowervm / Tests / Tasks / Monitor Auto-generated documentation for pypowervm.tests.tasks.monitor module. Monitor Modules Modules Test Host Cpu Test Monitor","title":"Monitor"},{"location":"pypowervm/tests/tasks/monitor/#monitor","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Monitor Auto-generated documentation for pypowervm.tests.tasks.monitor module. Monitor Modules","title":"Monitor"},{"location":"pypowervm/tests/tasks/monitor/#modules","text":"Test Host Cpu Test Monitor","title":"Modules"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/","text":"Test Host Cpu Pypowervm Index / Pypowervm / Tests / Tasks / Monitor / Test Host Cpu Auto-generated documentation for pypowervm.tests.tasks.monitor.test_host_cpu module. Test Host Cpu TestHostCPUBase TestHostCPUBase().setUp TestHostCPUFreq TestHostCPUFreq().test_get_cpu_freq TestHostCPUMetricCache TestHostCPUMetricCache().setUp TestHostCPUMetricCache().test_delta_proc_cycles TestHostCPUMetricCache().test_delta_user_cycles TestHostCPUMetricCache().test_find_prev_sample TestHostCPUMetricCache().test_gather_user_cycles_delta TestHostCPUMetricCache().test_get_firmware_cycles TestHostCPUMetricCache().test_get_total_cycles TestHostCPUMetricCache().test_get_total_cycles_diff_cores TestHostCPUMetricCache().test_refresh TestHostCPUMetricCache().test_update_internal_metric TestHostCPUMetricCache().test_update_internal_metric_bad_total TestHostCPUBase Show source in test_host_cpu.py:27 Signature class TestHostCPUBase(testtools.TestCase): ... TestHostCPUBase().setUp Show source in test_host_cpu.py:29 Signature def setUp(self): ... TestHostCPUFreq Show source in test_host_cpu.py:44 Signature class TestHostCPUFreq(TestHostCPUBase): ... See also TestHostCPUBase TestHostCPUFreq().test_get_cpu_freq Show source in test_host_cpu.py:46 Signature def test_get_cpu_freq(self): ... TestHostCPUMetricCache Show source in test_host_cpu.py:57 Signature class TestHostCPUMetricCache(TestHostCPUBase): ... See also TestHostCPUBase TestHostCPUMetricCache().setUp Show source in test_host_cpu.py:59 Signature def setUp(self): ... TestHostCPUMetricCache().test_delta_proc_cycles Show source in test_host_cpu.py:188 Signature def test_delta_proc_cycles(self): ... TestHostCPUMetricCache().test_delta_user_cycles Show source in test_host_cpu.py:217 Signature def test_delta_user_cycles(self): ... TestHostCPUMetricCache().test_find_prev_sample Show source in test_host_cpu.py:241 Signature def test_find_prev_sample(self): ... TestHostCPUMetricCache().test_gather_user_cycles_delta Show source in test_host_cpu.py:164 Signature @mock.patch(\"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._delta_proc_cycles\") def test_gather_user_cycles_delta(self, mock_cycles): ... TestHostCPUMetricCache().test_get_firmware_cycles Show source in test_host_cpu.py:308 Signature def test_get_firmware_cycles(self): ... TestHostCPUMetricCache().test_get_total_cycles Show source in test_host_cpu.py:275 Signature def test_get_total_cycles(self): ... TestHostCPUMetricCache().test_get_total_cycles_diff_cores Show source in test_host_cpu.py:288 Signature def test_get_total_cycles_diff_cores(self): ... TestHostCPUMetricCache().test_refresh Show source in test_host_cpu.py:72 Signature def test_refresh(self): ... TestHostCPUMetricCache().test_update_internal_metric Show source in test_host_cpu.py:78 Signature @mock.patch(\"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._get_fw_cycles_delta\") @mock.patch( \"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._get_total_cycles_delta\" ) @mock.patch( \"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._gather_user_cycles_delta\" ) def test_update_internal_metric( self, mock_user_cycles, mock_total_cycles, mock_fw_cycles ): ... TestHostCPUMetricCache().test_update_internal_metric_bad_total Show source in test_host_cpu.py:132 Validates that if the total cycles are off, we handle. Signature @mock.patch(\"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._get_fw_cycles_delta\") @mock.patch( \"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._get_total_cycles_delta\" ) @mock.patch( \"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._gather_user_cycles_delta\" ) def test_update_internal_metric_bad_total( self, mock_user_cycles, mock_tot_cycles, mock_fw_cycles ): ...","title":"Test Host Cpu"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#test-host-cpu","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Monitor / Test Host Cpu Auto-generated documentation for pypowervm.tests.tasks.monitor.test_host_cpu module. Test Host Cpu TestHostCPUBase TestHostCPUBase().setUp TestHostCPUFreq TestHostCPUFreq().test_get_cpu_freq TestHostCPUMetricCache TestHostCPUMetricCache().setUp TestHostCPUMetricCache().test_delta_proc_cycles TestHostCPUMetricCache().test_delta_user_cycles TestHostCPUMetricCache().test_find_prev_sample TestHostCPUMetricCache().test_gather_user_cycles_delta TestHostCPUMetricCache().test_get_firmware_cycles TestHostCPUMetricCache().test_get_total_cycles TestHostCPUMetricCache().test_get_total_cycles_diff_cores TestHostCPUMetricCache().test_refresh TestHostCPUMetricCache().test_update_internal_metric TestHostCPUMetricCache().test_update_internal_metric_bad_total","title":"Test Host Cpu"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpubase","text":"Show source in test_host_cpu.py:27","title":"TestHostCPUBase"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature","text":"class TestHostCPUBase(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpubasesetup","text":"Show source in test_host_cpu.py:29","title":"TestHostCPUBase().setUp"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpufreq","text":"Show source in test_host_cpu.py:44","title":"TestHostCPUFreq"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_2","text":"class TestHostCPUFreq(TestHostCPUBase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#see-also","text":"TestHostCPUBase","title":"See also"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpufreqtest_get_cpu_freq","text":"Show source in test_host_cpu.py:46","title":"TestHostCPUFreq().test_get_cpu_freq"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_3","text":"def test_get_cpu_freq(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccache","text":"Show source in test_host_cpu.py:57","title":"TestHostCPUMetricCache"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_4","text":"class TestHostCPUMetricCache(TestHostCPUBase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#see-also_1","text":"TestHostCPUBase","title":"See also"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachesetup","text":"Show source in test_host_cpu.py:59","title":"TestHostCPUMetricCache().setUp"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_5","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachetest_delta_proc_cycles","text":"Show source in test_host_cpu.py:188","title":"TestHostCPUMetricCache().test_delta_proc_cycles"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_6","text":"def test_delta_proc_cycles(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachetest_delta_user_cycles","text":"Show source in test_host_cpu.py:217","title":"TestHostCPUMetricCache().test_delta_user_cycles"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_7","text":"def test_delta_user_cycles(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachetest_find_prev_sample","text":"Show source in test_host_cpu.py:241","title":"TestHostCPUMetricCache().test_find_prev_sample"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_8","text":"def test_find_prev_sample(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachetest_gather_user_cycles_delta","text":"Show source in test_host_cpu.py:164","title":"TestHostCPUMetricCache().test_gather_user_cycles_delta"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_9","text":"@mock.patch(\"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._delta_proc_cycles\") def test_gather_user_cycles_delta(self, mock_cycles): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachetest_get_firmware_cycles","text":"Show source in test_host_cpu.py:308","title":"TestHostCPUMetricCache().test_get_firmware_cycles"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_10","text":"def test_get_firmware_cycles(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachetest_get_total_cycles","text":"Show source in test_host_cpu.py:275","title":"TestHostCPUMetricCache().test_get_total_cycles"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_11","text":"def test_get_total_cycles(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachetest_get_total_cycles_diff_cores","text":"Show source in test_host_cpu.py:288","title":"TestHostCPUMetricCache().test_get_total_cycles_diff_cores"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_12","text":"def test_get_total_cycles_diff_cores(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachetest_refresh","text":"Show source in test_host_cpu.py:72","title":"TestHostCPUMetricCache().test_refresh"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_13","text":"def test_refresh(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachetest_update_internal_metric","text":"Show source in test_host_cpu.py:78","title":"TestHostCPUMetricCache().test_update_internal_metric"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_14","text":"@mock.patch(\"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._get_fw_cycles_delta\") @mock.patch( \"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._get_total_cycles_delta\" ) @mock.patch( \"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._gather_user_cycles_delta\" ) def test_update_internal_metric( self, mock_user_cycles, mock_total_cycles, mock_fw_cycles ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#testhostcpumetriccachetest_update_internal_metric_bad_total","text":"Show source in test_host_cpu.py:132 Validates that if the total cycles are off, we handle.","title":"TestHostCPUMetricCache().test_update_internal_metric_bad_total"},{"location":"pypowervm/tests/tasks/monitor/test_host_cpu/#signature_15","text":"@mock.patch(\"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._get_fw_cycles_delta\") @mock.patch( \"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._get_total_cycles_delta\" ) @mock.patch( \"pypowervm.tasks.monitor.host_cpu.HostCPUMetricCache._gather_user_cycles_delta\" ) def test_update_internal_metric_bad_total( self, mock_user_cycles, mock_tot_cycles, mock_fw_cycles ): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/","text":"Test Monitor Pypowervm Index / Pypowervm / Tests / Tasks / Monitor / Test Monitor Auto-generated documentation for pypowervm.tests.tasks.monitor.test_monitor module. Test Monitor TestMetricsCache TestMetricsCache().setUp TestMetricsCache().test_refresh TestMonitors TestMonitors().setUp TestMonitors().test_ensure_ltm_monitors TestMonitors().test_ensure_ltm_monitors_non_default TestMonitors().test_latest_stats TestMonitors().test_latest_stats_no_data TestMonitors().test_parse_to_vm_metrics TestMonitors().test_query_ltm_feed TestMonitors().test_vm_metrics_no_phyp_data TestMetricsCache Show source in test_monitor.py:343 Validates the LparMetricCache. Signature class TestMetricsCache(testtools.TestCase): ... TestMetricsCache().setUp Show source in test_monitor.py:346 Signature def setUp(self): ... TestMetricsCache().test_refresh Show source in test_monitor.py:352 Signature @mock.patch(\"pypowervm.tasks.monitor.util.vm_metrics\") @mock.patch(\"pypowervm.tasks.monitor.util.latest_stats\") @mock.patch(\"pypowervm.tasks.monitor.util.ensure_ltm_monitors\") def test_refresh(self, mock_ensure_monitor, mock_stats, mock_vm_metrics): ... TestMonitors Show source in test_monitor.py:41 Signature class TestMonitors(testtools.TestCase): ... TestMonitors().setUp Show source in test_monitor.py:43 Signature def setUp(self): ... TestMonitors().test_ensure_ltm_monitors Show source in test_monitor.py:63 Verifies that the LTM monitors can be turned on. Signature def test_ensure_ltm_monitors(self): ... TestMonitors().test_ensure_ltm_monitors_non_default Show source in test_monitor.py:92 Verifies that the LTM monitors with different default inputs Signature def test_ensure_ltm_monitors_non_default(self): ... TestMonitors().test_latest_stats Show source in test_monitor.py:227 Signature @mock.patch(\"pypowervm.tasks.monitor.util.query_ltm_feed\") def test_latest_stats(self, mock_ltm_feed): ... TestMonitors().test_latest_stats_no_data Show source in test_monitor.py:322 Signature @mock.patch(\"pypowervm.tasks.monitor.util.vm_metrics\") @mock.patch(\"pypowervm.tasks.monitor.util.query_ltm_feed\") def test_latest_stats_no_data(self, mock_ltm_feed, mock_vm_metrics): ... TestMonitors().test_parse_to_vm_metrics Show source in test_monitor.py:125 Verifies the parsing to LPAR metrics. Signature def test_parse_to_vm_metrics(self): ... TestMonitors().test_query_ltm_feed Show source in test_monitor.py:49 Signature def test_query_ltm_feed(self): ... TestMonitors().test_vm_metrics_no_phyp_data Show source in test_monitor.py:224 Signature def test_vm_metrics_no_phyp_data(self): ...","title":"Test Monitor"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#test-monitor","text":"Pypowervm Index / Pypowervm / Tests / Tasks / Monitor / Test Monitor Auto-generated documentation for pypowervm.tests.tasks.monitor.test_monitor module. Test Monitor TestMetricsCache TestMetricsCache().setUp TestMetricsCache().test_refresh TestMonitors TestMonitors().setUp TestMonitors().test_ensure_ltm_monitors TestMonitors().test_ensure_ltm_monitors_non_default TestMonitors().test_latest_stats TestMonitors().test_latest_stats_no_data TestMonitors().test_parse_to_vm_metrics TestMonitors().test_query_ltm_feed TestMonitors().test_vm_metrics_no_phyp_data","title":"Test Monitor"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmetricscache","text":"Show source in test_monitor.py:343 Validates the LparMetricCache.","title":"TestMetricsCache"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature","text":"class TestMetricsCache(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmetricscachesetup","text":"Show source in test_monitor.py:346","title":"TestMetricsCache().setUp"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmetricscachetest_refresh","text":"Show source in test_monitor.py:352","title":"TestMetricsCache().test_refresh"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_2","text":"@mock.patch(\"pypowervm.tasks.monitor.util.vm_metrics\") @mock.patch(\"pypowervm.tasks.monitor.util.latest_stats\") @mock.patch(\"pypowervm.tasks.monitor.util.ensure_ltm_monitors\") def test_refresh(self, mock_ensure_monitor, mock_stats, mock_vm_metrics): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmonitors","text":"Show source in test_monitor.py:41","title":"TestMonitors"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_3","text":"class TestMonitors(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmonitorssetup","text":"Show source in test_monitor.py:43","title":"TestMonitors().setUp"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_4","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmonitorstest_ensure_ltm_monitors","text":"Show source in test_monitor.py:63 Verifies that the LTM monitors can be turned on.","title":"TestMonitors().test_ensure_ltm_monitors"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_5","text":"def test_ensure_ltm_monitors(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmonitorstest_ensure_ltm_monitors_non_default","text":"Show source in test_monitor.py:92 Verifies that the LTM monitors with different default inputs","title":"TestMonitors().test_ensure_ltm_monitors_non_default"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_6","text":"def test_ensure_ltm_monitors_non_default(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmonitorstest_latest_stats","text":"Show source in test_monitor.py:227","title":"TestMonitors().test_latest_stats"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_7","text":"@mock.patch(\"pypowervm.tasks.monitor.util.query_ltm_feed\") def test_latest_stats(self, mock_ltm_feed): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmonitorstest_latest_stats_no_data","text":"Show source in test_monitor.py:322","title":"TestMonitors().test_latest_stats_no_data"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_8","text":"@mock.patch(\"pypowervm.tasks.monitor.util.vm_metrics\") @mock.patch(\"pypowervm.tasks.monitor.util.query_ltm_feed\") def test_latest_stats_no_data(self, mock_ltm_feed, mock_vm_metrics): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmonitorstest_parse_to_vm_metrics","text":"Show source in test_monitor.py:125 Verifies the parsing to LPAR metrics.","title":"TestMonitors().test_parse_to_vm_metrics"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_9","text":"def test_parse_to_vm_metrics(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmonitorstest_query_ltm_feed","text":"Show source in test_monitor.py:49","title":"TestMonitors().test_query_ltm_feed"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_10","text":"def test_query_ltm_feed(self): ...","title":"Signature"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#testmonitorstest_vm_metrics_no_phyp_data","text":"Show source in test_monitor.py:224","title":"TestMonitors().test_vm_metrics_no_phyp_data"},{"location":"pypowervm/tests/tasks/monitor/test_monitor/#signature_11","text":"def test_vm_metrics_no_phyp_data(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/","text":"Test Utils Pypowervm Index / Pypowervm / Tests / Test Utils Auto-generated documentation for pypowervm.tests.test_utils module. Test Utils Modules Modules Create Httpresp Pvmhttp Refresh Httpresp Test Wrapper Abc Xml Sections","title":"Test Utils"},{"location":"pypowervm/tests/test_utils/#test-utils","text":"Pypowervm Index / Pypowervm / Tests / Test Utils Auto-generated documentation for pypowervm.tests.test_utils module. Test Utils Modules","title":"Test Utils"},{"location":"pypowervm/tests/test_utils/#modules","text":"Create Httpresp Pvmhttp Refresh Httpresp Test Wrapper Abc Xml Sections","title":"Modules"},{"location":"pypowervm/tests/test_utils/create_httpresp/","text":"Create Httpresp Pypowervm Index / Pypowervm / Tests / Test Utils / Create Httpresp Auto-generated documentation for pypowervm.tests.test_utils.create_httpresp module. Create Httpresp main refresh_response usage main Show source in create_httpresp.py:52 Signature def main(argv): ... refresh_response Show source in create_httpresp.py:24 Reload the file and redo the query. Signature def refresh_response(file_to_refresh): ... usage Show source in create_httpresp.py:37 Signature def usage(): ...","title":"Create Httpresp"},{"location":"pypowervm/tests/test_utils/create_httpresp/#create-httpresp","text":"Pypowervm Index / Pypowervm / Tests / Test Utils / Create Httpresp Auto-generated documentation for pypowervm.tests.test_utils.create_httpresp module. Create Httpresp main refresh_response usage","title":"Create Httpresp"},{"location":"pypowervm/tests/test_utils/create_httpresp/#main","text":"Show source in create_httpresp.py:52","title":"main"},{"location":"pypowervm/tests/test_utils/create_httpresp/#signature","text":"def main(argv): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/create_httpresp/#refresh_response","text":"Show source in create_httpresp.py:24 Reload the file and redo the query.","title":"refresh_response"},{"location":"pypowervm/tests/test_utils/create_httpresp/#signature_1","text":"def refresh_response(file_to_refresh): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/create_httpresp/#usage","text":"Show source in create_httpresp.py:37","title":"usage"},{"location":"pypowervm/tests/test_utils/create_httpresp/#signature_2","text":"def usage(): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/pvmhttp/","text":"Pvmhttp Pypowervm Index / Pypowervm / Tests / Test Utils / Pvmhttp Auto-generated documentation for pypowervm.tests.test_utils.pvmhttp module. Pvmhttp PVMFile PVMFile().load_file PVMResp PVMResp().get_response PVMResp().refresh PVMResp().save load_pvm_resp PVMFile Show source in pvmhttp.py:31 Signature class PVMFile(object): def __init__(self, file_name=None): ... PVMFile().load_file Show source in pvmhttp.py:43 Load a REST response file. Signature def load_file(self, file_name): ... PVMResp Show source in pvmhttp.py:94 Class to encapsulate the text serialization of a response. Signature class PVMResp(PVMFile): def __init__(self, file_name=None, pvmfile=None, adapter=None): ... See also PVMFile PVMResp().get_response Show source in pvmhttp.py:132 Signature def get_response(self): ... PVMResp().refresh Show source in pvmhttp.py:135 Do the query and get the response. Signature def refresh(self): ... PVMResp().save Show source in pvmhttp.py:146 Signature def save(self, file_name): ... load_pvm_resp Show source in pvmhttp.py:189 Signature def load_pvm_resp(file_name, adapter=None): ...","title":"Pvmhttp"},{"location":"pypowervm/tests/test_utils/pvmhttp/#pvmhttp","text":"Pypowervm Index / Pypowervm / Tests / Test Utils / Pvmhttp Auto-generated documentation for pypowervm.tests.test_utils.pvmhttp module. Pvmhttp PVMFile PVMFile().load_file PVMResp PVMResp().get_response PVMResp().refresh PVMResp().save load_pvm_resp","title":"Pvmhttp"},{"location":"pypowervm/tests/test_utils/pvmhttp/#pvmfile","text":"Show source in pvmhttp.py:31","title":"PVMFile"},{"location":"pypowervm/tests/test_utils/pvmhttp/#signature","text":"class PVMFile(object): def __init__(self, file_name=None): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/pvmhttp/#pvmfileload_file","text":"Show source in pvmhttp.py:43 Load a REST response file.","title":"PVMFile().load_file"},{"location":"pypowervm/tests/test_utils/pvmhttp/#signature_1","text":"def load_file(self, file_name): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/pvmhttp/#pvmresp","text":"Show source in pvmhttp.py:94 Class to encapsulate the text serialization of a response.","title":"PVMResp"},{"location":"pypowervm/tests/test_utils/pvmhttp/#signature_2","text":"class PVMResp(PVMFile): def __init__(self, file_name=None, pvmfile=None, adapter=None): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/pvmhttp/#see-also","text":"PVMFile","title":"See also"},{"location":"pypowervm/tests/test_utils/pvmhttp/#pvmrespget_response","text":"Show source in pvmhttp.py:132","title":"PVMResp().get_response"},{"location":"pypowervm/tests/test_utils/pvmhttp/#signature_3","text":"def get_response(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/pvmhttp/#pvmresprefresh","text":"Show source in pvmhttp.py:135 Do the query and get the response.","title":"PVMResp().refresh"},{"location":"pypowervm/tests/test_utils/pvmhttp/#signature_4","text":"def refresh(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/pvmhttp/#pvmrespsave","text":"Show source in pvmhttp.py:146","title":"PVMResp().save"},{"location":"pypowervm/tests/test_utils/pvmhttp/#signature_5","text":"def save(self, file_name): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/pvmhttp/#load_pvm_resp","text":"Show source in pvmhttp.py:189","title":"load_pvm_resp"},{"location":"pypowervm/tests/test_utils/pvmhttp/#signature_6","text":"def load_pvm_resp(file_name, adapter=None): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/refresh_httpresp/","text":"Refresh Httpresp Pypowervm Index / Pypowervm / Tests / Test Utils / Refresh Httpresp Auto-generated documentation for pypowervm.tests.test_utils.refresh_httpresp module. Refresh Httpresp get_default_selection get_txt_file save_default_selection get_default_selection Show source in refresh_httpresp.py:33 Retrieve the last response file updated. Signature def get_default_selection(): ... get_txt_file Show source in refresh_httpresp.py:58 Signature def get_txt_file(): ... save_default_selection Show source in refresh_httpresp.py:48 Save the selection so it can be set as the default next time. Signature def save_default_selection(default_line): ...","title":"Refresh Httpresp"},{"location":"pypowervm/tests/test_utils/refresh_httpresp/#refresh-httpresp","text":"Pypowervm Index / Pypowervm / Tests / Test Utils / Refresh Httpresp Auto-generated documentation for pypowervm.tests.test_utils.refresh_httpresp module. Refresh Httpresp get_default_selection get_txt_file save_default_selection","title":"Refresh Httpresp"},{"location":"pypowervm/tests/test_utils/refresh_httpresp/#get_default_selection","text":"Show source in refresh_httpresp.py:33 Retrieve the last response file updated.","title":"get_default_selection"},{"location":"pypowervm/tests/test_utils/refresh_httpresp/#signature","text":"def get_default_selection(): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/refresh_httpresp/#get_txt_file","text":"Show source in refresh_httpresp.py:58","title":"get_txt_file"},{"location":"pypowervm/tests/test_utils/refresh_httpresp/#signature_1","text":"def get_txt_file(): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/refresh_httpresp/#save_default_selection","text":"Show source in refresh_httpresp.py:48 Save the selection so it can be set as the default next time.","title":"save_default_selection"},{"location":"pypowervm/tests/test_utils/refresh_httpresp/#signature_2","text":"def save_default_selection(default_line): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/","text":"Test Wrapper Abc Pypowervm Index / Pypowervm / Tests / Test Utils / Test Wrapper Abc Auto-generated documentation for pypowervm.tests.test_utils.test_wrapper_abc module. Test Wrapper Abc TestWrapper TestWrapper().file TestWrapper().setUp TestWrapper().wrapper_class_to_test TestWrapper Show source in test_wrapper_abc.py:27 Attributes mock_adapter_fx_args - Arguments to test_fixtures.AdapterFx(), used to create a mock adapter. Must be represented as a dict. For example: mock_adapter_fx_args = {} or: mock_adapter_fx_args = dict(session=mock_session, traits=test_fixtures.LocalPVMTraits): None Superclass for wrapper test cases; provides loading of data files. A single subclass tests a single wrapper class on a single file. Usage: - Subclass this class. - Provide the name of the data file to load, e.g. file = 'ssp.txt' - Indicate the wrapper class to be tested, e.g. wrapper_class_to_test = clust.SSP - If your tests will make use of traits, you must provide mock_adapter_fx_args, resulting in AdapterFx being constructed with those args and used via useFixture. Your tests may access the adapter via self.adpt and the fixture itself via self.adptfx. - No init or setUp is necessary. - In your test cases, make use of the following variables: - self.resp: The raw Response object from load_pvm_resp().get_response(). May represent an entry or a feed. - self.dwrap: A single instance of the wrapper_class_to_test extracted from self.resp. If self.resp was a feed, this is the first entry. - self.entries: The result of wrap(response) of the wrapper class. May be a single wrapper instance, in which case it's (nearly*) equivalent to self.dwrap, or a list of such wrappers. * Note that wrap(response) injects each entry's etag into the wrapper instance. Signature class TestWrapper(testtools.TestCase): ... TestWrapper().file Show source in test_wrapper_abc.py:58 Data file name, relative to pypowervm/tests/wrappers/data/. Signature @abc.abstractproperty def file(self): ... TestWrapper().setUp Show source in test_wrapper_abc.py:76 Signature def setUp(self): ... TestWrapper().wrapper_class_to_test Show source in test_wrapper_abc.py:63 Indicates the type (Wrapper subclass) produced by self.dwrap. Signature @abc.abstractproperty def wrapper_class_to_test(self): ...","title":"Test Wrapper Abc"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/#test-wrapper-abc","text":"Pypowervm Index / Pypowervm / Tests / Test Utils / Test Wrapper Abc Auto-generated documentation for pypowervm.tests.test_utils.test_wrapper_abc module. Test Wrapper Abc TestWrapper TestWrapper().file TestWrapper().setUp TestWrapper().wrapper_class_to_test","title":"Test Wrapper Abc"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/#testwrapper","text":"Show source in test_wrapper_abc.py:27","title":"TestWrapper"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/#attributes","text":"mock_adapter_fx_args - Arguments to test_fixtures.AdapterFx(), used to create a mock adapter. Must be represented as a dict. For example: mock_adapter_fx_args = {} or: mock_adapter_fx_args = dict(session=mock_session, traits=test_fixtures.LocalPVMTraits): None Superclass for wrapper test cases; provides loading of data files. A single subclass tests a single wrapper class on a single file. Usage: - Subclass this class. - Provide the name of the data file to load, e.g. file = 'ssp.txt' - Indicate the wrapper class to be tested, e.g. wrapper_class_to_test = clust.SSP - If your tests will make use of traits, you must provide mock_adapter_fx_args, resulting in AdapterFx being constructed with those args and used via useFixture. Your tests may access the adapter via self.adpt and the fixture itself via self.adptfx. - No init or setUp is necessary. - In your test cases, make use of the following variables: - self.resp: The raw Response object from load_pvm_resp().get_response(). May represent an entry or a feed. - self.dwrap: A single instance of the wrapper_class_to_test extracted from self.resp. If self.resp was a feed, this is the first entry. - self.entries: The result of wrap(response) of the wrapper class. May be a single wrapper instance, in which case it's (nearly*) equivalent to self.dwrap, or a list of such wrappers. * Note that wrap(response) injects each entry's etag into the wrapper instance.","title":"Attributes"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/#signature","text":"class TestWrapper(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/#testwrapperfile","text":"Show source in test_wrapper_abc.py:58 Data file name, relative to pypowervm/tests/wrappers/data/.","title":"TestWrapper().file"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/#signature_1","text":"@abc.abstractproperty def file(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/#testwrappersetup","text":"Show source in test_wrapper_abc.py:76","title":"TestWrapper().setUp"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/#signature_2","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/#testwrapperwrapper_class_to_test","text":"Show source in test_wrapper_abc.py:63 Indicates the type (Wrapper subclass) produced by self.dwrap.","title":"TestWrapper().wrapper_class_to_test"},{"location":"pypowervm/tests/test_utils/test_wrapper_abc/#signature_3","text":"@abc.abstractproperty def wrapper_class_to_test(self): ...","title":"Signature"},{"location":"pypowervm/tests/test_utils/xml_sections/","text":"Xml Sections Pypowervm Index / Pypowervm / Tests / Test Utils / Xml Sections Auto-generated documentation for pypowervm.tests.test_utils.xml_sections module. Xml Sections load_xml_sections load_xml_sections Show source in xml_sections.py:24 Loads a file that contains xml sections This method takes a file that contains xml sections and returns a dict of them. It's useful for testing the generation of the sections. See ../data/lpar_sections.txt for an example of the file contents. Arguments file_name - The name of the file to load. Signature def load_xml_sections(file_name): ...","title":"Xml Sections"},{"location":"pypowervm/tests/test_utils/xml_sections/#xml-sections","text":"Pypowervm Index / Pypowervm / Tests / Test Utils / Xml Sections Auto-generated documentation for pypowervm.tests.test_utils.xml_sections module. Xml Sections load_xml_sections","title":"Xml Sections"},{"location":"pypowervm/tests/test_utils/xml_sections/#load_xml_sections","text":"Show source in xml_sections.py:24 Loads a file that contains xml sections This method takes a file that contains xml sections and returns a dict of them. It's useful for testing the generation of the sections. See ../data/lpar_sections.txt for an example of the file contents.","title":"load_xml_sections"},{"location":"pypowervm/tests/test_utils/xml_sections/#arguments","text":"file_name - The name of the file to load.","title":"Arguments"},{"location":"pypowervm/tests/test_utils/xml_sections/#signature","text":"def load_xml_sections(file_name): ...","title":"Signature"},{"location":"pypowervm/tests/utils/","text":"Utils Pypowervm Index / Pypowervm / Tests / Utils Auto-generated documentation for pypowervm.tests.utils module. Utils Modules Modules Test Lpar Bldr TestRetry Test Transaction TestUUID Test Validation","title":"Utils"},{"location":"pypowervm/tests/utils/#utils","text":"Pypowervm Index / Pypowervm / Tests / Utils Auto-generated documentation for pypowervm.tests.utils module. Utils Modules","title":"Utils"},{"location":"pypowervm/tests/utils/#modules","text":"Test Lpar Bldr TestRetry Test Transaction TestUUID Test Validation","title":"Modules"},{"location":"pypowervm/tests/utils/test_lpar_bldr/","text":"Test Lpar Bldr Pypowervm Index / Pypowervm / Tests / Utils / Test Lpar Bldr Auto-generated documentation for pypowervm.tests.utils.test_lpar_bldr module. Test Lpar Bldr TestLPARBuilder TestLPARBuilder().assert_xml TestLPARBuilder().setUp TestLPARBuilder().test_IBMi TestLPARBuilder().test_builder TestLPARBuilder().test_io_slots TestLPARBuilder().test_proc_modes TestLPARBuilder Show source in test_lpar_bldr.py:33 Unit tests for the lpar builder. Signature class TestLPARBuilder(testtools.TestCase): ... TestLPARBuilder().assert_xml Show source in test_lpar_bldr.py:88 Signature def assert_xml(self, entry, string): ... TestLPARBuilder().setUp Show source in test_lpar_bldr.py:36 Signature def setUp(self): ... TestLPARBuilder().test_IBMi Show source in test_lpar_bldr.py:510 Signature def test_IBMi(self): ... TestLPARBuilder().test_builder Show source in test_lpar_bldr.py:137 Signature def test_builder(self): ... TestLPARBuilder().test_io_slots Show source in test_lpar_bldr.py:537 Signature def test_io_slots(self): ... TestLPARBuilder().test_proc_modes Show source in test_lpar_bldr.py:92 Signature def test_proc_modes(self): ...","title":"Test Lpar Bldr"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#test-lpar-bldr","text":"Pypowervm Index / Pypowervm / Tests / Utils / Test Lpar Bldr Auto-generated documentation for pypowervm.tests.utils.test_lpar_bldr module. Test Lpar Bldr TestLPARBuilder TestLPARBuilder().assert_xml TestLPARBuilder().setUp TestLPARBuilder().test_IBMi TestLPARBuilder().test_builder TestLPARBuilder().test_io_slots TestLPARBuilder().test_proc_modes","title":"Test Lpar Bldr"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#testlparbuilder","text":"Show source in test_lpar_bldr.py:33 Unit tests for the lpar builder.","title":"TestLPARBuilder"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#signature","text":"class TestLPARBuilder(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#testlparbuilderassert_xml","text":"Show source in test_lpar_bldr.py:88","title":"TestLPARBuilder().assert_xml"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#signature_1","text":"def assert_xml(self, entry, string): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#testlparbuildersetup","text":"Show source in test_lpar_bldr.py:36","title":"TestLPARBuilder().setUp"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#signature_2","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#testlparbuildertest_ibmi","text":"Show source in test_lpar_bldr.py:510","title":"TestLPARBuilder().test_IBMi"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#signature_3","text":"def test_IBMi(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#testlparbuildertest_builder","text":"Show source in test_lpar_bldr.py:137","title":"TestLPARBuilder().test_builder"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#signature_4","text":"def test_builder(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#testlparbuildertest_io_slots","text":"Show source in test_lpar_bldr.py:537","title":"TestLPARBuilder().test_io_slots"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#signature_5","text":"def test_io_slots(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#testlparbuildertest_proc_modes","text":"Show source in test_lpar_bldr.py:92","title":"TestLPARBuilder().test_proc_modes"},{"location":"pypowervm/tests/utils/test_lpar_bldr/#signature_6","text":"def test_proc_modes(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_retry/","text":"TestRetry Pypowervm Index / Pypowervm / Tests / Utils / TestRetry Auto-generated documentation for pypowervm.tests.utils.test_retry module. TestRetry TestRetry TestRetry().test_random_delay TestRetry().test_retry TestRetry().test_retry_argmod TestRetry().test_retry_example TestRetry().test_retry_refresh_wrapper TestRetry().test_stepped_delay TestRetry().test_stepped_random_delay TestRetry().test_stepped_random_delay_large TestRetry().test_stepped_random_delay_small TestRetry Show source in test_retry.py:29 Unit tests for pypowervm.util. Signature class TestRetry(testtools.TestCase): ... TestRetry().test_random_delay Show source in test_retry.py:242 Test gen_random_delay. Signature @mock.patch(\"time.sleep\") def test_random_delay(self, mock_sleep): ... TestRetry().test_retry Show source in test_retry.py:32 Signature def test_retry(self): ... TestRetry().test_retry_argmod Show source in test_retry.py:167 Signature def test_retry_argmod(self): ... TestRetry().test_retry_example Show source in test_retry.py:128 Signature def test_retry_example(self): ... TestRetry().test_retry_refresh_wrapper Show source in test_retry.py:202 Test @retry with the 'refresh_wrapper' argmod_func. Signature def test_retry_refresh_wrapper(self): ... TestRetry().test_stepped_delay Show source in test_retry.py:233 Signature @mock.patch(\"time.sleep\") def test_stepped_delay(self, mock_sleep): ... TestRetry().test_stepped_random_delay Show source in test_retry.py:287 Test STEPPED_RANDOM_DELAY. Signature @mock.patch(\"time.sleep\") def test_stepped_random_delay(self, mock_sleep): ... TestRetry().test_stepped_random_delay_large Show source in test_retry.py:302 Test STEPPED_RANDOM_DELAY with a very large range. Signature @mock.patch(\"time.sleep\") def test_stepped_random_delay_large(self, mock_sleep): ... TestRetry().test_stepped_random_delay_small Show source in test_retry.py:328 Test STEPPED_RANDOM_DELAY with a very small range. Uses a 'max_attempts' whose range is less than the size of RANDOM_DELAY_STEPS Signature @mock.patch(\"time.sleep\") def test_stepped_random_delay_small(self, mock_sleep): ...","title":"TestRetry"},{"location":"pypowervm/tests/utils/test_retry/#testretry","text":"Pypowervm Index / Pypowervm / Tests / Utils / TestRetry Auto-generated documentation for pypowervm.tests.utils.test_retry module. TestRetry TestRetry TestRetry().test_random_delay TestRetry().test_retry TestRetry().test_retry_argmod TestRetry().test_retry_example TestRetry().test_retry_refresh_wrapper TestRetry().test_stepped_delay TestRetry().test_stepped_random_delay TestRetry().test_stepped_random_delay_large TestRetry().test_stepped_random_delay_small","title":"TestRetry"},{"location":"pypowervm/tests/utils/test_retry/#testretry_1","text":"Show source in test_retry.py:29 Unit tests for pypowervm.util.","title":"TestRetry"},{"location":"pypowervm/tests/utils/test_retry/#signature","text":"class TestRetry(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_retry/#testretrytest_random_delay","text":"Show source in test_retry.py:242 Test gen_random_delay.","title":"TestRetry().test_random_delay"},{"location":"pypowervm/tests/utils/test_retry/#signature_1","text":"@mock.patch(\"time.sleep\") def test_random_delay(self, mock_sleep): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_retry/#testretrytest_retry","text":"Show source in test_retry.py:32","title":"TestRetry().test_retry"},{"location":"pypowervm/tests/utils/test_retry/#signature_2","text":"def test_retry(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_retry/#testretrytest_retry_argmod","text":"Show source in test_retry.py:167","title":"TestRetry().test_retry_argmod"},{"location":"pypowervm/tests/utils/test_retry/#signature_3","text":"def test_retry_argmod(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_retry/#testretrytest_retry_example","text":"Show source in test_retry.py:128","title":"TestRetry().test_retry_example"},{"location":"pypowervm/tests/utils/test_retry/#signature_4","text":"def test_retry_example(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_retry/#testretrytest_retry_refresh_wrapper","text":"Show source in test_retry.py:202 Test @retry with the 'refresh_wrapper' argmod_func.","title":"TestRetry().test_retry_refresh_wrapper"},{"location":"pypowervm/tests/utils/test_retry/#signature_5","text":"def test_retry_refresh_wrapper(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_retry/#testretrytest_stepped_delay","text":"Show source in test_retry.py:233","title":"TestRetry().test_stepped_delay"},{"location":"pypowervm/tests/utils/test_retry/#signature_6","text":"@mock.patch(\"time.sleep\") def test_stepped_delay(self, mock_sleep): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_retry/#testretrytest_stepped_random_delay","text":"Show source in test_retry.py:287 Test STEPPED_RANDOM_DELAY.","title":"TestRetry().test_stepped_random_delay"},{"location":"pypowervm/tests/utils/test_retry/#signature_7","text":"@mock.patch(\"time.sleep\") def test_stepped_random_delay(self, mock_sleep): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_retry/#testretrytest_stepped_random_delay_large","text":"Show source in test_retry.py:302 Test STEPPED_RANDOM_DELAY with a very large range.","title":"TestRetry().test_stepped_random_delay_large"},{"location":"pypowervm/tests/utils/test_retry/#signature_8","text":"@mock.patch(\"time.sleep\") def test_stepped_random_delay_large(self, mock_sleep): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_retry/#testretrytest_stepped_random_delay_small","text":"Show source in test_retry.py:328 Test STEPPED_RANDOM_DELAY with a very small range. Uses a 'max_attempts' whose range is less than the size of RANDOM_DELAY_STEPS","title":"TestRetry().test_stepped_random_delay_small"},{"location":"pypowervm/tests/utils/test_retry/#signature_9","text":"@mock.patch(\"time.sleep\") def test_stepped_random_delay_small(self, mock_sleep): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/","text":"Test Transaction Pypowervm Index / Pypowervm / Tests / Utils / Test Transaction Auto-generated documentation for pypowervm.tests.utils.test_transaction module. Test Transaction TestExceptions TestExceptions().test_exceptions TestFeedTask TestFeedTask().setUp TestFeedTask().test_deferred_feed_get TestFeedTask().test_empty_feed TestFeedTask().test_execute TestFeedTask().test_invalid_feed_or_getter TestFeedTask().test_no_subtasks TestFeedTask().test_post_exec TestFeedTask().test_rebuild_feed TestFeedTask().test_subtask_thread_local TestFeedTask().test_wrapper_task_adds_and_replication TestFeedTask().test_wrapper_task_rets TestWrapperTask TestWrapperTask().execute TestWrapperTask.retry_twice TestWrapperTask().setUp TestWrapperTask().test_flag_update TestWrapperTask().test_logspec TestWrapperTask().test_retry_args TestWrapperTask().test_sequence TestWrapperTask().test_subtask_provides TestWrapperTask().test_synchronized_called_with_uuid TestWrapperTask().test_wrapper_task1 TestWrapperTask().test_wrapper_task2 TestWrapperTask().test_wrapper_task_allow_empty TestWrapperTask().test_wrapper_task_subtask TestWrapperTask().test_wrapper_task_subtask_returns TestWrapperTask.tx_subtask_invoke TestExceptions Show source in test_transaction.py:824 Signature class TestExceptions(unittest.TestCase): ... TestExceptions().test_exceptions Show source in test_transaction.py:825 Signature def test_exceptions(self): ... TestFeedTask Show source in test_transaction.py:460 Signature class TestFeedTask(twrap.TestWrapper): ... TestFeedTask().setUp Show source in test_transaction.py:464 Signature def setUp(self): ... TestFeedTask().test_deferred_feed_get Show source in test_transaction.py:588 Test deferred and unique GET of the internal feed. Signature def test_deferred_feed_get(self): ... TestFeedTask().test_empty_feed Show source in test_transaction.py:481 Signature @mock.patch(\"pypowervm.wrappers.entry_wrapper.FeedGetter.get\") def test_empty_feed(self, mock_get): ... TestFeedTask().test_execute Show source in test_transaction.py:646 Execute a 'real' FeedTask. Signature def test_execute(self): ... TestFeedTask().test_invalid_feed_or_getter Show source in test_transaction.py:471 Various evil inputs to FeedTask. init 's feed_or_getter. Signature def test_invalid_feed_or_getter(self): ... TestFeedTask().test_no_subtasks Show source in test_transaction.py:680 Ensure that a FeedTask with no Subtasks is a no-op. Signature @mock.patch(\"taskflow.patterns.unordered_flow.Flow.__init__\") def test_no_subtasks(self, mock_flow): ... TestFeedTask().test_post_exec Show source in test_transaction.py:688 Signature def test_post_exec(self): ... TestFeedTask().test_rebuild_feed Show source in test_transaction.py:612 Feed gets rebuilt when transactions exist and an etag mismatches. Signature def test_rebuild_feed(self): ... TestFeedTask().test_subtask_thread_local Show source in test_transaction.py:786 Security context and locks, if set, propagates to WrapperTasks. Signature def test_subtask_thread_local(self): ... TestFeedTask().test_wrapper_task_adds_and_replication Show source in test_transaction.py:491 Deferred replication of individual WrapperTasks with adds. Covers: - wrapper_tasks - get_wrapper - add_subtask - add_functor_subtask Signature def test_wrapper_task_adds_and_replication(self): ... TestFeedTask().test_wrapper_task_rets Show source in test_transaction.py:720 Signature def test_wrapper_task_rets(self): ... TestWrapperTask Show source in test_transaction.py:39 Signature class TestWrapperTask(twrap.TestWrapper, tx.Subtask): ... TestWrapperTask().execute Show source in test_transaction.py:53 Modify an LPAR's name and desired memory. Arguments lpar_wrapper - The LPAR EntryWrapper to update. new_name - The new name to give the LPAR. des_mem - (Optional) The new desired memory value, an int. logger - (Optional) If specified, \"log\" the class name for test inspection purposes. Returns The (possibly modified) lpar_wrapper. Signature def execute(self, lpar_wrapper, new_name, des_mem=None, logger=None): ... TestWrapperTask.retry_twice Show source in test_transaction.py:77 Signature @staticmethod def retry_twice(wrapper, tracker, logger): ... TestWrapperTask().setUp Show source in test_transaction.py:43 Signature def setUp(self): ... TestWrapperTask().test_flag_update Show source in test_transaction.py:332 flag_update=False avoids update even if Subtask returns True. Signature def test_flag_update(self): ... TestWrapperTask().test_logspec Show source in test_transaction.py:295 Signature def test_logspec(self): ... TestWrapperTask().test_retry_args Show source in test_transaction.py:141 Ensure the correct arguments are passed to @retry. Signature @mock.patch(\"pypowervm.utils.retry.retry\") def test_retry_args(self, mock_retry): ... TestWrapperTask().test_sequence Show source in test_transaction.py:111 Prove the sequence of events on a transaction-decorated method. We expect it to look like: lock get the wrapper if necessary invoke the method while the method raises etag error, refresh the wrapper and re-invoke unlock Signature def test_sequence(self): ... TestWrapperTask().test_subtask_provides Show source in test_transaction.py:381 Signature def test_subtask_provides(self): ... TestWrapperTask().test_synchronized_called_with_uuid Show source in test_transaction.py:86 Ensure the synchronizer is locking with the first arg's .uuid. Signature @mock.patch(\"oslo_concurrency.lockutils.Semaphores.get\") def test_synchronized_called_with_uuid(self, mock_semget): ... TestWrapperTask().test_wrapper_task1 Show source in test_transaction.py:214 Signature def test_wrapper_task1(self): ... TestWrapperTask().test_wrapper_task2 Show source in test_transaction.py:345 Signature def test_wrapper_task2(self): ... TestWrapperTask().test_wrapper_task_allow_empty Show source in test_transaction.py:207 Test the allow_empty=True condition. Signature def test_wrapper_task_allow_empty(self): ... TestWrapperTask().test_wrapper_task_subtask Show source in test_transaction.py:163 Tests around Subtask. Signature def test_wrapper_task_subtask(self): ... TestWrapperTask().test_wrapper_task_subtask_returns Show source in test_transaction.py:186 Test that execute methods' return values are processed properly. Signature def test_wrapper_task_subtask_returns(self): ... TestWrapperTask.tx_subtask_invoke Show source in test_transaction.py:153 Simulates how Subtasks are invoked by WrapperTask. Arguments tst - A Subtask wrapper - The wrapper with which to invoke execute() Returns The value returned by execute() Signature @staticmethod def tx_subtask_invoke(tst, wrapper): ...","title":"Test Transaction"},{"location":"pypowervm/tests/utils/test_transaction/#test-transaction","text":"Pypowervm Index / Pypowervm / Tests / Utils / Test Transaction Auto-generated documentation for pypowervm.tests.utils.test_transaction module. Test Transaction TestExceptions TestExceptions().test_exceptions TestFeedTask TestFeedTask().setUp TestFeedTask().test_deferred_feed_get TestFeedTask().test_empty_feed TestFeedTask().test_execute TestFeedTask().test_invalid_feed_or_getter TestFeedTask().test_no_subtasks TestFeedTask().test_post_exec TestFeedTask().test_rebuild_feed TestFeedTask().test_subtask_thread_local TestFeedTask().test_wrapper_task_adds_and_replication TestFeedTask().test_wrapper_task_rets TestWrapperTask TestWrapperTask().execute TestWrapperTask.retry_twice TestWrapperTask().setUp TestWrapperTask().test_flag_update TestWrapperTask().test_logspec TestWrapperTask().test_retry_args TestWrapperTask().test_sequence TestWrapperTask().test_subtask_provides TestWrapperTask().test_synchronized_called_with_uuid TestWrapperTask().test_wrapper_task1 TestWrapperTask().test_wrapper_task2 TestWrapperTask().test_wrapper_task_allow_empty TestWrapperTask().test_wrapper_task_subtask TestWrapperTask().test_wrapper_task_subtask_returns TestWrapperTask.tx_subtask_invoke","title":"Test Transaction"},{"location":"pypowervm/tests/utils/test_transaction/#testexceptions","text":"Show source in test_transaction.py:824","title":"TestExceptions"},{"location":"pypowervm/tests/utils/test_transaction/#signature","text":"class TestExceptions(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testexceptionstest_exceptions","text":"Show source in test_transaction.py:825","title":"TestExceptions().test_exceptions"},{"location":"pypowervm/tests/utils/test_transaction/#signature_1","text":"def test_exceptions(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtask","text":"Show source in test_transaction.py:460","title":"TestFeedTask"},{"location":"pypowervm/tests/utils/test_transaction/#signature_2","text":"class TestFeedTask(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasksetup","text":"Show source in test_transaction.py:464","title":"TestFeedTask().setUp"},{"location":"pypowervm/tests/utils/test_transaction/#signature_3","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasktest_deferred_feed_get","text":"Show source in test_transaction.py:588 Test deferred and unique GET of the internal feed.","title":"TestFeedTask().test_deferred_feed_get"},{"location":"pypowervm/tests/utils/test_transaction/#signature_4","text":"def test_deferred_feed_get(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasktest_empty_feed","text":"Show source in test_transaction.py:481","title":"TestFeedTask().test_empty_feed"},{"location":"pypowervm/tests/utils/test_transaction/#signature_5","text":"@mock.patch(\"pypowervm.wrappers.entry_wrapper.FeedGetter.get\") def test_empty_feed(self, mock_get): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasktest_execute","text":"Show source in test_transaction.py:646 Execute a 'real' FeedTask.","title":"TestFeedTask().test_execute"},{"location":"pypowervm/tests/utils/test_transaction/#signature_6","text":"def test_execute(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasktest_invalid_feed_or_getter","text":"Show source in test_transaction.py:471 Various evil inputs to FeedTask. init 's feed_or_getter.","title":"TestFeedTask().test_invalid_feed_or_getter"},{"location":"pypowervm/tests/utils/test_transaction/#signature_7","text":"def test_invalid_feed_or_getter(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasktest_no_subtasks","text":"Show source in test_transaction.py:680 Ensure that a FeedTask with no Subtasks is a no-op.","title":"TestFeedTask().test_no_subtasks"},{"location":"pypowervm/tests/utils/test_transaction/#signature_8","text":"@mock.patch(\"taskflow.patterns.unordered_flow.Flow.__init__\") def test_no_subtasks(self, mock_flow): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasktest_post_exec","text":"Show source in test_transaction.py:688","title":"TestFeedTask().test_post_exec"},{"location":"pypowervm/tests/utils/test_transaction/#signature_9","text":"def test_post_exec(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasktest_rebuild_feed","text":"Show source in test_transaction.py:612 Feed gets rebuilt when transactions exist and an etag mismatches.","title":"TestFeedTask().test_rebuild_feed"},{"location":"pypowervm/tests/utils/test_transaction/#signature_10","text":"def test_rebuild_feed(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasktest_subtask_thread_local","text":"Show source in test_transaction.py:786 Security context and locks, if set, propagates to WrapperTasks.","title":"TestFeedTask().test_subtask_thread_local"},{"location":"pypowervm/tests/utils/test_transaction/#signature_11","text":"def test_subtask_thread_local(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasktest_wrapper_task_adds_and_replication","text":"Show source in test_transaction.py:491 Deferred replication of individual WrapperTasks with adds. Covers: - wrapper_tasks - get_wrapper - add_subtask - add_functor_subtask","title":"TestFeedTask().test_wrapper_task_adds_and_replication"},{"location":"pypowervm/tests/utils/test_transaction/#signature_12","text":"def test_wrapper_task_adds_and_replication(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testfeedtasktest_wrapper_task_rets","text":"Show source in test_transaction.py:720","title":"TestFeedTask().test_wrapper_task_rets"},{"location":"pypowervm/tests/utils/test_transaction/#signature_13","text":"def test_wrapper_task_rets(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertask","text":"Show source in test_transaction.py:39","title":"TestWrapperTask"},{"location":"pypowervm/tests/utils/test_transaction/#signature_14","text":"class TestWrapperTask(twrap.TestWrapper, tx.Subtask): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertaskexecute","text":"Show source in test_transaction.py:53 Modify an LPAR's name and desired memory.","title":"TestWrapperTask().execute"},{"location":"pypowervm/tests/utils/test_transaction/#arguments","text":"lpar_wrapper - The LPAR EntryWrapper to update. new_name - The new name to give the LPAR. des_mem - (Optional) The new desired memory value, an int. logger - (Optional) If specified, \"log\" the class name for test inspection purposes.","title":"Arguments"},{"location":"pypowervm/tests/utils/test_transaction/#returns","text":"The (possibly modified) lpar_wrapper.","title":"Returns"},{"location":"pypowervm/tests/utils/test_transaction/#signature_15","text":"def execute(self, lpar_wrapper, new_name, des_mem=None, logger=None): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertaskretry_twice","text":"Show source in test_transaction.py:77","title":"TestWrapperTask.retry_twice"},{"location":"pypowervm/tests/utils/test_transaction/#signature_16","text":"@staticmethod def retry_twice(wrapper, tracker, logger): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasksetup","text":"Show source in test_transaction.py:43","title":"TestWrapperTask().setUp"},{"location":"pypowervm/tests/utils/test_transaction/#signature_17","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_flag_update","text":"Show source in test_transaction.py:332 flag_update=False avoids update even if Subtask returns True.","title":"TestWrapperTask().test_flag_update"},{"location":"pypowervm/tests/utils/test_transaction/#signature_18","text":"def test_flag_update(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_logspec","text":"Show source in test_transaction.py:295","title":"TestWrapperTask().test_logspec"},{"location":"pypowervm/tests/utils/test_transaction/#signature_19","text":"def test_logspec(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_retry_args","text":"Show source in test_transaction.py:141 Ensure the correct arguments are passed to @retry.","title":"TestWrapperTask().test_retry_args"},{"location":"pypowervm/tests/utils/test_transaction/#signature_20","text":"@mock.patch(\"pypowervm.utils.retry.retry\") def test_retry_args(self, mock_retry): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_sequence","text":"Show source in test_transaction.py:111 Prove the sequence of events on a transaction-decorated method. We expect it to look like: lock get the wrapper if necessary invoke the method while the method raises etag error, refresh the wrapper and re-invoke unlock","title":"TestWrapperTask().test_sequence"},{"location":"pypowervm/tests/utils/test_transaction/#signature_21","text":"def test_sequence(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_subtask_provides","text":"Show source in test_transaction.py:381","title":"TestWrapperTask().test_subtask_provides"},{"location":"pypowervm/tests/utils/test_transaction/#signature_22","text":"def test_subtask_provides(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_synchronized_called_with_uuid","text":"Show source in test_transaction.py:86 Ensure the synchronizer is locking with the first arg's .uuid.","title":"TestWrapperTask().test_synchronized_called_with_uuid"},{"location":"pypowervm/tests/utils/test_transaction/#signature_23","text":"@mock.patch(\"oslo_concurrency.lockutils.Semaphores.get\") def test_synchronized_called_with_uuid(self, mock_semget): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_wrapper_task1","text":"Show source in test_transaction.py:214","title":"TestWrapperTask().test_wrapper_task1"},{"location":"pypowervm/tests/utils/test_transaction/#signature_24","text":"def test_wrapper_task1(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_wrapper_task2","text":"Show source in test_transaction.py:345","title":"TestWrapperTask().test_wrapper_task2"},{"location":"pypowervm/tests/utils/test_transaction/#signature_25","text":"def test_wrapper_task2(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_wrapper_task_allow_empty","text":"Show source in test_transaction.py:207 Test the allow_empty=True condition.","title":"TestWrapperTask().test_wrapper_task_allow_empty"},{"location":"pypowervm/tests/utils/test_transaction/#signature_26","text":"def test_wrapper_task_allow_empty(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_wrapper_task_subtask","text":"Show source in test_transaction.py:163 Tests around Subtask.","title":"TestWrapperTask().test_wrapper_task_subtask"},{"location":"pypowervm/tests/utils/test_transaction/#signature_27","text":"def test_wrapper_task_subtask(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktest_wrapper_task_subtask_returns","text":"Show source in test_transaction.py:186 Test that execute methods' return values are processed properly.","title":"TestWrapperTask().test_wrapper_task_subtask_returns"},{"location":"pypowervm/tests/utils/test_transaction/#signature_28","text":"def test_wrapper_task_subtask_returns(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_transaction/#testwrappertasktx_subtask_invoke","text":"Show source in test_transaction.py:153 Simulates how Subtasks are invoked by WrapperTask.","title":"TestWrapperTask.tx_subtask_invoke"},{"location":"pypowervm/tests/utils/test_transaction/#arguments_1","text":"tst - A Subtask wrapper - The wrapper with which to invoke execute()","title":"Arguments"},{"location":"pypowervm/tests/utils/test_transaction/#returns_1","text":"The value returned by execute()","title":"Returns"},{"location":"pypowervm/tests/utils/test_transaction/#signature_29","text":"@staticmethod def tx_subtask_invoke(tst, wrapper): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_uuid/","text":"TestUUID Pypowervm Index / Pypowervm / Tests / Utils / TestUUID Auto-generated documentation for pypowervm.tests.utils.test_uuid module. TestUUID TestUUID TestUUID().test_id_or_uuid TestUUID().test_uuid_conversion TestUUID Show source in test_uuid.py:25 Unit tests for the uuid. Signature class TestUUID(unittest.TestCase): ... TestUUID().test_id_or_uuid Show source in test_uuid.py:41 Signature def test_id_or_uuid(self): ... TestUUID().test_uuid_conversion Show source in test_uuid.py:28 Signature def test_uuid_conversion(self): ...","title":"TestUUID"},{"location":"pypowervm/tests/utils/test_uuid/#testuuid","text":"Pypowervm Index / Pypowervm / Tests / Utils / TestUUID Auto-generated documentation for pypowervm.tests.utils.test_uuid module. TestUUID TestUUID TestUUID().test_id_or_uuid TestUUID().test_uuid_conversion","title":"TestUUID"},{"location":"pypowervm/tests/utils/test_uuid/#testuuid_1","text":"Show source in test_uuid.py:25 Unit tests for the uuid.","title":"TestUUID"},{"location":"pypowervm/tests/utils/test_uuid/#signature","text":"class TestUUID(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_uuid/#testuuidtest_id_or_uuid","text":"Show source in test_uuid.py:41","title":"TestUUID().test_id_or_uuid"},{"location":"pypowervm/tests/utils/test_uuid/#signature_1","text":"def test_id_or_uuid(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_uuid/#testuuidtest_uuid_conversion","text":"Show source in test_uuid.py:28","title":"TestUUID().test_uuid_conversion"},{"location":"pypowervm/tests/utils/test_uuid/#signature_2","text":"def test_uuid_conversion(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_validation/","text":"Test Validation Pypowervm Index / Pypowervm / Tests / Utils / Test Validation Auto-generated documentation for pypowervm.tests.utils.test_validation module. Test Validation TestValidator TestValidator().setUp TestValidator().test_validator TestValidator().test_validator_check_dlpar TestValidator Show source in test_validation.py:26 Unit tests for validation. Signature class TestValidator(testtools.TestCase): ... TestValidator().setUp Show source in test_validation.py:29 Signature def setUp(self): ... TestValidator().test_validator Show source in test_validation.py:171 Signature def test_validator(self): ... TestValidator().test_validator_check_dlpar Show source in test_validation.py:386 Signature @mock.patch(\"pypowervm.utils.validation.ProcValidator.validate\") @mock.patch(\"pypowervm.utils.validation.MemValidator.validate\") def test_validator_check_dlpar(self, mem_val_validate, proc_val_validate): ...","title":"Test Validation"},{"location":"pypowervm/tests/utils/test_validation/#test-validation","text":"Pypowervm Index / Pypowervm / Tests / Utils / Test Validation Auto-generated documentation for pypowervm.tests.utils.test_validation module. Test Validation TestValidator TestValidator().setUp TestValidator().test_validator TestValidator().test_validator_check_dlpar","title":"Test Validation"},{"location":"pypowervm/tests/utils/test_validation/#testvalidator","text":"Show source in test_validation.py:26 Unit tests for validation.","title":"TestValidator"},{"location":"pypowervm/tests/utils/test_validation/#signature","text":"class TestValidator(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_validation/#testvalidatorsetup","text":"Show source in test_validation.py:29","title":"TestValidator().setUp"},{"location":"pypowervm/tests/utils/test_validation/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_validation/#testvalidatortest_validator","text":"Show source in test_validation.py:171","title":"TestValidator().test_validator"},{"location":"pypowervm/tests/utils/test_validation/#signature_2","text":"def test_validator(self): ...","title":"Signature"},{"location":"pypowervm/tests/utils/test_validation/#testvalidatortest_validator_check_dlpar","text":"Show source in test_validation.py:386","title":"TestValidator().test_validator_check_dlpar"},{"location":"pypowervm/tests/utils/test_validation/#signature_3","text":"@mock.patch(\"pypowervm.utils.validation.ProcValidator.validate\") @mock.patch(\"pypowervm.utils.validation.MemValidator.validate\") def test_validator_check_dlpar(self, mem_val_validate, proc_val_validate): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/","text":"Wrappers Pypowervm Index / Pypowervm / Tests / Wrappers Auto-generated documentation for pypowervm.tests.wrappers module. Wrappers Modules Modules Pcm TestCDATA TestCluster Test Enterprise Pool Test Entry TestEvent TestHttpError Test Iocard Test Job TestLogicalPartition Test Managed System Test Mgmt Console Test Monitor TestNetwork TestSearch Test Shared Proc Pool Test Storage TestVIOSFile Test Virtual Io Server Test Wrapper Properties","title":"Wrappers"},{"location":"pypowervm/tests/wrappers/#wrappers","text":"Pypowervm Index / Pypowervm / Tests / Wrappers Auto-generated documentation for pypowervm.tests.wrappers module. Wrappers Modules","title":"Wrappers"},{"location":"pypowervm/tests/wrappers/#modules","text":"Pcm TestCDATA TestCluster Test Enterprise Pool Test Entry TestEvent TestHttpError Test Iocard Test Job TestLogicalPartition Test Managed System Test Mgmt Console Test Monitor TestNetwork TestSearch Test Shared Proc Pool Test Storage TestVIOSFile Test Virtual Io Server Test Wrapper Properties","title":"Modules"},{"location":"pypowervm/tests/wrappers/test_cdata/","text":"TestCDATA Pypowervm Index / Pypowervm / Tests / Wrappers / TestCDATA Auto-generated documentation for pypowervm.tests.wrappers.test_cdata module. TestCDATA TestCDATA TestCDATA().test_cdata_request TestCDATA().test_cdata_results TestCDATA Show source in test_cdata.py:43 Signature class TestCDATA(twrap.TestWrapper): ... TestCDATA().test_cdata_request Show source in test_cdata.py:49 Signature def test_cdata_request(self): ... TestCDATA().test_cdata_results Show source in test_cdata.py:56 Signature def test_cdata_results(self): ...","title":"TestCDATA"},{"location":"pypowervm/tests/wrappers/test_cdata/#testcdata","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / TestCDATA Auto-generated documentation for pypowervm.tests.wrappers.test_cdata module. TestCDATA TestCDATA TestCDATA().test_cdata_request TestCDATA().test_cdata_results","title":"TestCDATA"},{"location":"pypowervm/tests/wrappers/test_cdata/#testcdata_1","text":"Show source in test_cdata.py:43","title":"TestCDATA"},{"location":"pypowervm/tests/wrappers/test_cdata/#signature","text":"class TestCDATA(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cdata/#testcdatatest_cdata_request","text":"Show source in test_cdata.py:49","title":"TestCDATA().test_cdata_request"},{"location":"pypowervm/tests/wrappers/test_cdata/#signature_1","text":"def test_cdata_request(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cdata/#testcdatatest_cdata_results","text":"Show source in test_cdata.py:56","title":"TestCDATA().test_cdata_results"},{"location":"pypowervm/tests/wrappers/test_cdata/#signature_2","text":"def test_cdata_results(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cluster/","text":"TestCluster Pypowervm Index / Pypowervm / Tests / Wrappers / TestCluster Auto-generated documentation for pypowervm.tests.wrappers.test_cluster module. TestCluster TestCluster TestCluster().test_bld_cluster TestCluster().test_cluster_ordering TestCluster().test_id TestCluster().test_name TestCluster().test_nodes TestCluster().test_repos_pv TestCluster().test_ssp_uri TestCluster().test_ssp_uuid TestCluster().test_wrapper_classes TestCluster Show source in test_cluster.py:41 Signature class TestCluster(twrap.TestWrapper): ... TestCluster().test_bld_cluster Show source in test_cluster.py:143 Signature def test_bld_cluster(self): ... TestCluster().test_cluster_ordering Show source in test_cluster.py:170 Signature def test_cluster_ordering(self): ... TestCluster().test_id Show source in test_cluster.py:49 Signature def test_id(self): ... TestCluster().test_name Show source in test_cluster.py:46 Signature def test_name(self): ... TestCluster().test_nodes Show source in test_cluster.py:81 Tests the Node and MTMS wrappers as well. Signature def test_nodes(self): ... TestCluster().test_repos_pv Show source in test_cluster.py:61 Signature def test_repos_pv(self): ... TestCluster().test_ssp_uri Show source in test_cluster.py:52 Signature def test_ssp_uri(self): ... TestCluster().test_ssp_uuid Show source in test_cluster.py:57 Signature def test_ssp_uuid(self): ... TestCluster().test_wrapper_classes Show source in test_cluster.py:131 Signature def test_wrapper_classes(self): ...","title":"TestCluster"},{"location":"pypowervm/tests/wrappers/test_cluster/#testcluster","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / TestCluster Auto-generated documentation for pypowervm.tests.wrappers.test_cluster module. TestCluster TestCluster TestCluster().test_bld_cluster TestCluster().test_cluster_ordering TestCluster().test_id TestCluster().test_name TestCluster().test_nodes TestCluster().test_repos_pv TestCluster().test_ssp_uri TestCluster().test_ssp_uuid TestCluster().test_wrapper_classes","title":"TestCluster"},{"location":"pypowervm/tests/wrappers/test_cluster/#testcluster_1","text":"Show source in test_cluster.py:41","title":"TestCluster"},{"location":"pypowervm/tests/wrappers/test_cluster/#signature","text":"class TestCluster(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cluster/#testclustertest_bld_cluster","text":"Show source in test_cluster.py:143","title":"TestCluster().test_bld_cluster"},{"location":"pypowervm/tests/wrappers/test_cluster/#signature_1","text":"def test_bld_cluster(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cluster/#testclustertest_cluster_ordering","text":"Show source in test_cluster.py:170","title":"TestCluster().test_cluster_ordering"},{"location":"pypowervm/tests/wrappers/test_cluster/#signature_2","text":"def test_cluster_ordering(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cluster/#testclustertest_id","text":"Show source in test_cluster.py:49","title":"TestCluster().test_id"},{"location":"pypowervm/tests/wrappers/test_cluster/#signature_3","text":"def test_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cluster/#testclustertest_name","text":"Show source in test_cluster.py:46","title":"TestCluster().test_name"},{"location":"pypowervm/tests/wrappers/test_cluster/#signature_4","text":"def test_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cluster/#testclustertest_nodes","text":"Show source in test_cluster.py:81 Tests the Node and MTMS wrappers as well.","title":"TestCluster().test_nodes"},{"location":"pypowervm/tests/wrappers/test_cluster/#signature_5","text":"def test_nodes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cluster/#testclustertest_repos_pv","text":"Show source in test_cluster.py:61","title":"TestCluster().test_repos_pv"},{"location":"pypowervm/tests/wrappers/test_cluster/#signature_6","text":"def test_repos_pv(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cluster/#testclustertest_ssp_uri","text":"Show source in test_cluster.py:52","title":"TestCluster().test_ssp_uri"},{"location":"pypowervm/tests/wrappers/test_cluster/#signature_7","text":"def test_ssp_uri(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cluster/#testclustertest_ssp_uuid","text":"Show source in test_cluster.py:57","title":"TestCluster().test_ssp_uuid"},{"location":"pypowervm/tests/wrappers/test_cluster/#signature_8","text":"def test_ssp_uuid(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_cluster/#testclustertest_wrapper_classes","text":"Show source in test_cluster.py:131","title":"TestCluster().test_wrapper_classes"},{"location":"pypowervm/tests/wrappers/test_cluster/#signature_9","text":"def test_wrapper_classes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/","text":"Test Enterprise Pool Pypowervm Index / Pypowervm / Tests / Wrappers / Test Enterprise Pool Auto-generated documentation for pypowervm.tests.wrappers.test_enterprise_pool module. Test Enterprise Pool TestPoolFile TestPoolFile().test_avail_mobile_mem TestPoolFile().test_avail_mobile_procs TestPoolFile().test_compliance_hours_left TestPoolFile().test_compliance_state TestPoolFile().test_entries TestPoolFile().test_id TestPoolFile().test_master_console_mtms TestPoolFile().test_mgmt_consoles TestPoolFile().test_name TestPoolFile().test_total_mobile_mem TestPoolFile().test_total_mobile_procs TestPoolFile().test_type TestPoolFile().test_unret_mobile_mem TestPoolFile().test_unret_mobile_procs TestPoolMemberFile TestPoolMemberFile().test_entries TestPoolMemberFile().test_inactive_mem TestPoolMemberFile().test_inactive_procs TestPoolMemberFile().test_mem_compliance_hours_left TestPoolMemberFile().test_mgmt_consoles TestPoolMemberFile().test_mobile_mem TestPoolMemberFile().test_mobile_procs TestPoolMemberFile().test_proc_compliance_hours_left TestPoolMemberFile().test_set_mobile_mem TestPoolMemberFile().test_set_mobile_procs TestPoolMemberFile().test_sys_installed_mem TestPoolMemberFile().test_sys_installed_procs TestPoolMemberFile().test_sys_mtms TestPoolMemberFile().test_sys_name TestPoolMemberFile().test_sys_state TestPoolMemberFile().test_type TestPoolMemberFile().test_unret_mobile_mem TestPoolMemberFile().test_unret_mobile_procs TestPoolFile Show source in test_enterprise_pool.py:22 Signature class TestPoolFile(test_wrapper_abc.TestWrapper): ... TestPoolFile().test_avail_mobile_mem Show source in test_enterprise_pool.py:55 Signature def test_avail_mobile_mem(self): ... TestPoolFile().test_avail_mobile_procs Show source in test_enterprise_pool.py:52 Signature def test_avail_mobile_procs(self): ... TestPoolFile().test_compliance_hours_left Show source in test_enterprise_pool.py:43 Signature def test_compliance_hours_left(self): ... TestPoolFile().test_compliance_state Show source in test_enterprise_pool.py:39 Signature def test_compliance_state(self): ... TestPoolFile().test_entries Show source in test_enterprise_pool.py:27 Signature def test_entries(self): ... TestPoolFile().test_id Show source in test_enterprise_pool.py:33 Signature def test_id(self): ... TestPoolFile().test_master_console_mtms Show source in test_enterprise_pool.py:75 Signature def test_master_console_mtms(self): ... TestPoolFile().test_mgmt_consoles Show source in test_enterprise_pool.py:64 Signature def test_mgmt_consoles(self): ... TestPoolFile().test_name Show source in test_enterprise_pool.py:36 Signature def test_name(self): ... TestPoolFile().test_total_mobile_mem Show source in test_enterprise_pool.py:49 Signature def test_total_mobile_mem(self): ... TestPoolFile().test_total_mobile_procs Show source in test_enterprise_pool.py:46 Signature def test_total_mobile_procs(self): ... TestPoolFile().test_type Show source in test_enterprise_pool.py:30 Signature def test_type(self): ... TestPoolFile().test_unret_mobile_mem Show source in test_enterprise_pool.py:61 Signature def test_unret_mobile_mem(self): ... TestPoolFile().test_unret_mobile_procs Show source in test_enterprise_pool.py:58 Signature def test_unret_mobile_procs(self): ... TestPoolMemberFile Show source in test_enterprise_pool.py:80 Signature class TestPoolMemberFile(test_wrapper_abc.TestWrapper): ... TestPoolMemberFile().test_entries Show source in test_enterprise_pool.py:85 Signature def test_entries(self): ... TestPoolMemberFile().test_inactive_mem Show source in test_enterprise_pool.py:113 Signature def test_inactive_mem(self): ... TestPoolMemberFile().test_inactive_procs Show source in test_enterprise_pool.py:110 Signature def test_inactive_procs(self): ... TestPoolMemberFile().test_mem_compliance_hours_left Show source in test_enterprise_pool.py:125 Signature def test_mem_compliance_hours_left(self): ... TestPoolMemberFile().test_mgmt_consoles Show source in test_enterprise_pool.py:143 Signature def test_mgmt_consoles(self): ... TestPoolMemberFile().test_mobile_mem Show source in test_enterprise_pool.py:95 Signature def test_mobile_mem(self): ... TestPoolMemberFile().test_mobile_procs Show source in test_enterprise_pool.py:92 Signature def test_mobile_procs(self): ... TestPoolMemberFile().test_proc_compliance_hours_left Show source in test_enterprise_pool.py:122 Signature def test_proc_compliance_hours_left(self): ... TestPoolMemberFile().test_set_mobile_mem Show source in test_enterprise_pool.py:104 Signature def test_set_mobile_mem(self): ... TestPoolMemberFile().test_set_mobile_procs Show source in test_enterprise_pool.py:98 Signature def test_set_mobile_procs(self): ... TestPoolMemberFile().test_sys_installed_mem Show source in test_enterprise_pool.py:134 Signature def test_sys_installed_mem(self): ... TestPoolMemberFile().test_sys_installed_procs Show source in test_enterprise_pool.py:131 Signature def test_sys_installed_procs(self): ... TestPoolMemberFile().test_sys_mtms Show source in test_enterprise_pool.py:137 Signature def test_sys_mtms(self): ... TestPoolMemberFile().test_sys_name Show source in test_enterprise_pool.py:128 Signature def test_sys_name(self): ... TestPoolMemberFile().test_sys_state Show source in test_enterprise_pool.py:140 Signature def test_sys_state(self): ... TestPoolMemberFile().test_type Show source in test_enterprise_pool.py:88 Signature def test_type(self): ... TestPoolMemberFile().test_unret_mobile_mem Show source in test_enterprise_pool.py:119 Signature def test_unret_mobile_mem(self): ... TestPoolMemberFile().test_unret_mobile_procs Show source in test_enterprise_pool.py:116 Signature def test_unret_mobile_procs(self): ...","title":"Test Enterprise Pool"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#test-enterprise-pool","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Enterprise Pool Auto-generated documentation for pypowervm.tests.wrappers.test_enterprise_pool module. Test Enterprise Pool TestPoolFile TestPoolFile().test_avail_mobile_mem TestPoolFile().test_avail_mobile_procs TestPoolFile().test_compliance_hours_left TestPoolFile().test_compliance_state TestPoolFile().test_entries TestPoolFile().test_id TestPoolFile().test_master_console_mtms TestPoolFile().test_mgmt_consoles TestPoolFile().test_name TestPoolFile().test_total_mobile_mem TestPoolFile().test_total_mobile_procs TestPoolFile().test_type TestPoolFile().test_unret_mobile_mem TestPoolFile().test_unret_mobile_procs TestPoolMemberFile TestPoolMemberFile().test_entries TestPoolMemberFile().test_inactive_mem TestPoolMemberFile().test_inactive_procs TestPoolMemberFile().test_mem_compliance_hours_left TestPoolMemberFile().test_mgmt_consoles TestPoolMemberFile().test_mobile_mem TestPoolMemberFile().test_mobile_procs TestPoolMemberFile().test_proc_compliance_hours_left TestPoolMemberFile().test_set_mobile_mem TestPoolMemberFile().test_set_mobile_procs TestPoolMemberFile().test_sys_installed_mem TestPoolMemberFile().test_sys_installed_procs TestPoolMemberFile().test_sys_mtms TestPoolMemberFile().test_sys_name TestPoolMemberFile().test_sys_state TestPoolMemberFile().test_type TestPoolMemberFile().test_unret_mobile_mem TestPoolMemberFile().test_unret_mobile_procs","title":"Test Enterprise Pool"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfile","text":"Show source in test_enterprise_pool.py:22","title":"TestPoolFile"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature","text":"class TestPoolFile(test_wrapper_abc.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_avail_mobile_mem","text":"Show source in test_enterprise_pool.py:55","title":"TestPoolFile().test_avail_mobile_mem"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_1","text":"def test_avail_mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_avail_mobile_procs","text":"Show source in test_enterprise_pool.py:52","title":"TestPoolFile().test_avail_mobile_procs"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_2","text":"def test_avail_mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_compliance_hours_left","text":"Show source in test_enterprise_pool.py:43","title":"TestPoolFile().test_compliance_hours_left"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_3","text":"def test_compliance_hours_left(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_compliance_state","text":"Show source in test_enterprise_pool.py:39","title":"TestPoolFile().test_compliance_state"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_4","text":"def test_compliance_state(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_entries","text":"Show source in test_enterprise_pool.py:27","title":"TestPoolFile().test_entries"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_5","text":"def test_entries(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_id","text":"Show source in test_enterprise_pool.py:33","title":"TestPoolFile().test_id"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_6","text":"def test_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_master_console_mtms","text":"Show source in test_enterprise_pool.py:75","title":"TestPoolFile().test_master_console_mtms"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_7","text":"def test_master_console_mtms(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_mgmt_consoles","text":"Show source in test_enterprise_pool.py:64","title":"TestPoolFile().test_mgmt_consoles"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_8","text":"def test_mgmt_consoles(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_name","text":"Show source in test_enterprise_pool.py:36","title":"TestPoolFile().test_name"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_9","text":"def test_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_total_mobile_mem","text":"Show source in test_enterprise_pool.py:49","title":"TestPoolFile().test_total_mobile_mem"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_10","text":"def test_total_mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_total_mobile_procs","text":"Show source in test_enterprise_pool.py:46","title":"TestPoolFile().test_total_mobile_procs"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_11","text":"def test_total_mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_type","text":"Show source in test_enterprise_pool.py:30","title":"TestPoolFile().test_type"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_12","text":"def test_type(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_unret_mobile_mem","text":"Show source in test_enterprise_pool.py:61","title":"TestPoolFile().test_unret_mobile_mem"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_13","text":"def test_unret_mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolfiletest_unret_mobile_procs","text":"Show source in test_enterprise_pool.py:58","title":"TestPoolFile().test_unret_mobile_procs"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_14","text":"def test_unret_mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfile","text":"Show source in test_enterprise_pool.py:80","title":"TestPoolMemberFile"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_15","text":"class TestPoolMemberFile(test_wrapper_abc.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_entries","text":"Show source in test_enterprise_pool.py:85","title":"TestPoolMemberFile().test_entries"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_16","text":"def test_entries(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_inactive_mem","text":"Show source in test_enterprise_pool.py:113","title":"TestPoolMemberFile().test_inactive_mem"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_17","text":"def test_inactive_mem(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_inactive_procs","text":"Show source in test_enterprise_pool.py:110","title":"TestPoolMemberFile().test_inactive_procs"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_18","text":"def test_inactive_procs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_mem_compliance_hours_left","text":"Show source in test_enterprise_pool.py:125","title":"TestPoolMemberFile().test_mem_compliance_hours_left"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_19","text":"def test_mem_compliance_hours_left(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_mgmt_consoles","text":"Show source in test_enterprise_pool.py:143","title":"TestPoolMemberFile().test_mgmt_consoles"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_20","text":"def test_mgmt_consoles(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_mobile_mem","text":"Show source in test_enterprise_pool.py:95","title":"TestPoolMemberFile().test_mobile_mem"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_21","text":"def test_mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_mobile_procs","text":"Show source in test_enterprise_pool.py:92","title":"TestPoolMemberFile().test_mobile_procs"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_22","text":"def test_mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_proc_compliance_hours_left","text":"Show source in test_enterprise_pool.py:122","title":"TestPoolMemberFile().test_proc_compliance_hours_left"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_23","text":"def test_proc_compliance_hours_left(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_set_mobile_mem","text":"Show source in test_enterprise_pool.py:104","title":"TestPoolMemberFile().test_set_mobile_mem"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_24","text":"def test_set_mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_set_mobile_procs","text":"Show source in test_enterprise_pool.py:98","title":"TestPoolMemberFile().test_set_mobile_procs"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_25","text":"def test_set_mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_sys_installed_mem","text":"Show source in test_enterprise_pool.py:134","title":"TestPoolMemberFile().test_sys_installed_mem"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_26","text":"def test_sys_installed_mem(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_sys_installed_procs","text":"Show source in test_enterprise_pool.py:131","title":"TestPoolMemberFile().test_sys_installed_procs"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_27","text":"def test_sys_installed_procs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_sys_mtms","text":"Show source in test_enterprise_pool.py:137","title":"TestPoolMemberFile().test_sys_mtms"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_28","text":"def test_sys_mtms(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_sys_name","text":"Show source in test_enterprise_pool.py:128","title":"TestPoolMemberFile().test_sys_name"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_29","text":"def test_sys_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_sys_state","text":"Show source in test_enterprise_pool.py:140","title":"TestPoolMemberFile().test_sys_state"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_30","text":"def test_sys_state(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_type","text":"Show source in test_enterprise_pool.py:88","title":"TestPoolMemberFile().test_type"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_31","text":"def test_type(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_unret_mobile_mem","text":"Show source in test_enterprise_pool.py:119","title":"TestPoolMemberFile().test_unret_mobile_mem"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_32","text":"def test_unret_mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#testpoolmemberfiletest_unret_mobile_procs","text":"Show source in test_enterprise_pool.py:116","title":"TestPoolMemberFile().test_unret_mobile_procs"},{"location":"pypowervm/tests/wrappers/test_enterprise_pool/#signature_33","text":"def test_unret_mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/","text":"Test Entry Pypowervm Index / Pypowervm / Tests / Wrappers / Test Entry Auto-generated documentation for pypowervm.tests.wrappers.test_entry module. Test Entry SubWrapper TestActionableList TestActionableList().test_append TestActionableList().test_complex_path TestActionableList().test_extend TestActionableList().test_insert TestActionableList().test_pop TestActionableList().test_remove TestCreate TestCreate().setUp TestCreate().test_create_child TestCreate().test_create_other_service TestCreate().test_create_raises TestCreate().test_create_root TestDelete TestDelete().setUp TestDelete().test_delete TestElement TestElement().test_child_poaching TestElement().test_toxmlstring TestElementList TestElementList().setUp TestElementList().test_everything TestElementWrapper TestElementWrapper().setUp TestElementWrapper().test_element_clone TestElementWrapper().test_elementwrapper_clone TestElementWrapper().test_entry_clone TestElementWrapper().test_entrywrapper_clone TestElementWrapper().test_equality TestElementWrapper().test_feed_clone TestElementWrapper().test_fresh_element TestElementWrapper().test_href TestElementWrapper().test_inequality_by_subelem_change TestElementWrapper().test_response_clone TestElementWrapper().test_unequal TestEntryWrapper TestEntryWrapper().setUp TestEntryWrapper().test_etag TestEntryWrapper().test_load TestEntryWrapper().test_set_uuid TestEntryWrapper().test_toxmlstring TestGet TestGet().setUp TestGet().test_get_by_href TestGet().test_get_child TestGet().test_get_errors TestGet().test_get_root TestGetters TestGetters().test_entry_wrapper_getter TestGetters().test_feed_getter TestGetters().test_uuid_feed_getter TestRefresh TestRefresh().setUp TestRefresh().test_etag_match TestRefresh().test_etag_no_match TestRefresh().test_no_etag TestRefresh().test_use_etag_false TestSearch TestSearch().setUp TestSearch().test_child_bad_args TestSearch().test_child_no_search_key TestSearch().test_child_with_parent_spec TestSearch().test_good TestSearch().test_negate TestSearch().test_no_such_search_key TestSearch().test_quote TestSearch().test_search_all_parents TestSearch().test_search_by_feed TestSearch().test_search_with_xag TestSetUUIDMixin TestSetUUIDMixin().test_set_uuid TestUpdate TestUpdate().setUp TestUpdate().test_force_update TestUpdate().test_update TestUpdate().test_update_with_get_xag TestUpdate().test_update_xag TestWrapper TestWrapper().test_get_val_bool TestWrapper().test_get_val_float TestWrapper().test_get_val_int TestWrapper().test_get_val_percent TestWrapper().test_get_val_str TestWrapperElemList TestWrapperElemList().setUp TestWrapperElemList().test_append TestWrapperElemList().test_extend TestWrapperElemList().test_get TestWrapperElemList().test_in TestWrapperElemList().test_index TestWrapperElemList().test_length TestWrapperElemList().test_repr TestWrapperElemList().test_str SubWrapper Show source in test_entry.py:58 Signature class SubWrapper(ewrap.Wrapper): def __init__(self, **kwargs): ... TestActionableList Show source in test_entry.py:707 Tests for the Actionable List class. Signature class TestActionableList(unittest.TestCase): ... TestActionableList().test_append Show source in test_entry.py:720 Signature def test_append(self): ... TestActionableList().test_complex_path Show source in test_entry.py:760 Signature def test_complex_path(self): ... TestActionableList().test_extend Show source in test_entry.py:710 Signature def test_extend(self): ... TestActionableList().test_insert Show source in test_entry.py:740 Signature def test_insert(self): ... TestActionableList().test_pop Show source in test_entry.py:750 Signature def test_pop(self): ... TestActionableList().test_remove Show source in test_entry.py:730 Signature def test_remove(self): ... TestCreate Show source in test_entry.py:1261 Signature class TestCreate(testtools.TestCase): ... TestCreate().setUp Show source in test_entry.py:1262 Signature def setUp(self): ... TestCreate().test_create_child Show source in test_entry.py:1278 Signature def test_create_child(self): ... TestCreate().test_create_other_service Show source in test_entry.py:1301 Ensure non-UOM service goes through. Signature def test_create_other_service(self): ... TestCreate().test_create_raises Show source in test_entry.py:1314 Verify invalid inputs raise exceptions. Signature def test_create_raises(self): ... TestCreate().test_create_root Show source in test_entry.py:1266 Signature def test_create_root(self): ... TestDelete Show source in test_entry.py:1241 Signature class TestDelete(testtools.TestCase): ... TestDelete().setUp Show source in test_entry.py:1242 Signature def setUp(self): ... TestDelete().test_delete Show source in test_entry.py:1246 Signature def test_delete(self): ... TestElement Show source in test_entry.py:77 Signature class TestElement(twrap.TestWrapper): ... TestElement().test_child_poaching Show source in test_entry.py:81 Creating an element with children of another existing element. Ensure the existing element remains intact. Signature def test_child_poaching(self): ... TestElement().test_toxmlstring Show source in test_entry.py:100 Signature @mock.patch(\"lxml.etree.tostring\") def test_toxmlstring(self, mock_tostring): ... TestElementList Show source in test_entry.py:117 Signature class TestElementList(twrap.TestWrapper): ... TestElementList().setUp Show source in test_entry.py:121 Signature def setUp(self): ... TestElementList().test_everything Show source in test_entry.py:146 Ensure ElementList behaves like a list where implemented. Signature def test_everything(self): ... TestElementWrapper Show source in test_entry.py:360 Tests for the ElementWrapper class. Signature class TestElementWrapper(testtools.TestCase): ... TestElementWrapper().setUp Show source in test_entry.py:363 Signature def setUp(self): ... TestElementWrapper().test_element_clone Show source in test_entry.py:507 Signature def test_element_clone(self): ... TestElementWrapper().test_elementwrapper_clone Show source in test_entry.py:586 Signature def test_elementwrapper_clone(self): ... TestElementWrapper().test_entry_clone Show source in test_entry.py:533 Signature def test_entry_clone(self): ... TestElementWrapper().test_entrywrapper_clone Show source in test_entry.py:575 Signature def test_entrywrapper_clone(self): ... TestElementWrapper().test_equality Show source in test_entry.py:371 Validates that two elements loaded from the same data is equal. Signature def test_equality(self): ... TestElementWrapper().test_feed_clone Show source in test_entry.py:544 Signature def test_feed_clone(self): ... TestElementWrapper().test_fresh_element Show source in test_entry.py:409 Signature def test_fresh_element(self): ... TestElementWrapper().test_href Show source in test_entry.py:448 Signature def test_href(self): ... TestElementWrapper().test_inequality_by_subelem_change Show source in test_entry.py:383 Signature def test_inequality_by_subelem_change(self): ... TestElementWrapper().test_response_clone Show source in test_entry.py:564 Signature def test_response_clone(self): ... TestElementWrapper().test_unequal Show source in test_entry.py:391 Signature def test_unequal(self): ... TestEntryWrapper Show source in test_entry.py:264 Signature class TestEntryWrapper(testtools.TestCase): ... TestEntryWrapper().setUp Show source in test_entry.py:266 Signature def setUp(self): ... TestEntryWrapper().test_etag Show source in test_entry.py:270 Signature def test_etag(self): ... TestEntryWrapper().test_load Show source in test_entry.py:297 Signature def test_load(self): ... TestEntryWrapper().test_set_uuid Show source in test_entry.py:280 Signature def test_set_uuid(self): ... TestEntryWrapper().test_toxmlstring Show source in test_entry.py:341 Signature @mock.patch(\"lxml.etree.tostring\") def test_toxmlstring(self, mock_tostring): ... TestGet Show source in test_entry.py:796 Tests for EntryWrapper.get(). Signature class TestGet(testtools.TestCase): ... TestGet().setUp Show source in test_entry.py:799 Signature def setUp(self): ... TestGet().test_get_by_href Show source in test_entry.py:879 Signature @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.wrap\") def test_get_by_href(self, mock_wrap): ... TestGet().test_get_child Show source in test_entry.py:823 Various permutations of EntryWrapper.get on a CHILD object. Signature @mock.patch(\"pypowervm.wrappers.network.CNA.wrap\") def test_get_child(self, mock_wrap): ... TestGet().test_get_errors Show source in test_entry.py:851 Error paths in EntryWrapper.get. Signature @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.wrap\") def test_get_errors(self, mock_wrap): ... TestGet().test_get_root Show source in test_entry.py:803 Various permutations of EntryWrapper.get on a ROOT object. Signature @mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.wrap\") def test_get_root(self, mock_wrap): ... TestGetters Show source in test_entry.py:1405 Signature class TestGetters(twrap.TestWrapper): ... TestGetters().test_entry_wrapper_getter Show source in test_entry.py:1409 Signature @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.refresh\") def test_entry_wrapper_getter(self, mock_refresh): ... TestGetters().test_feed_getter Show source in test_entry.py:1492 Signature @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.refresh\") def test_feed_getter(self, mock_refresh): ... TestGetters().test_uuid_feed_getter Show source in test_entry.py:1571 Verify UUIDFeedGetter. Signature @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.refresh\") def test_uuid_feed_getter(self, mock_refresh): ... TestRefresh Show source in test_entry.py:1084 Tests for Adapter.refresh(). Signature class TestRefresh(testtools.TestCase): ... TestRefresh().setUp Show source in test_entry.py:1090 Signature def setUp(self): ... TestRefresh().test_etag_match Show source in test_entry.py:1130 Signature @mock.patch(\"pypowervm.adapter.Adapter.read_by_href\") def test_etag_match(self, mock_read): ... TestRefresh().test_etag_no_match Show source in test_entry.py:1139 Signature @mock.patch(\"pypowervm.adapter.Adapter.read_by_href\") def test_etag_no_match(self, mock_read): ... TestRefresh().test_no_etag Show source in test_entry.py:1122 Signature @mock.patch(\"pypowervm.adapter.Adapter.read_by_href\") def test_no_etag(self, mock_read): ... TestRefresh().test_use_etag_false Show source in test_entry.py:1148 Signature @mock.patch(\"pypowervm.adapter.Adapter.read_by_href\") def test_use_etag_false(self, mock_read): ... TestSearch Show source in test_entry.py:887 Tests for EntryWrapper.search(). Signature class TestSearch(testtools.TestCase): ... TestSearch().setUp Show source in test_entry.py:890 Signature def setUp(self): ... TestSearch().test_child_bad_args Show source in test_entry.py:1016 Specifying parent_uuid without parent_type is an error. Signature def test_child_bad_args(self): ... TestSearch().test_child_no_search_key Show source in test_entry.py:999 CHILD search with or without a search key (uses GET-feed-loop). Signature @mock.patch(\"pypowervm.adapter.Adapter.read\") def test_child_no_search_key(self, mock_read): ... TestSearch().test_child_with_parent_spec Show source in test_entry.py:1070 Test CHILD search using a parent instance. Signature @mock.patch(\"pypowervm.adapter.Adapter.read\") def test_child_with_parent_spec(self, mock_read): ... TestSearch().test_good Show source in test_entry.py:903 Signature @mock.patch(\"pypowervm.adapter.Adapter._request\") def test_good(self, mock_rq): ... TestSearch().test_negate Show source in test_entry.py:925 Signature @mock.patch(\"pypowervm.adapter.Adapter._request\") def test_negate(self, mock_rq): ... TestSearch().test_no_such_search_key Show source in test_entry.py:935 Ensure an invalid search key gives ValueError. Signature def test_no_such_search_key(self): ... TestSearch().test_quote Show source in test_entry.py:940 Ensure special chars in the search value are properly encoded. Signature @mock.patch(\"pypowervm.adapter.Adapter._request\") def test_quote(self, mock_rq): ... TestSearch().test_search_all_parents Show source in test_entry.py:1021 Anonymous ROOT for CHILD search. Signature @mock.patch(\"pypowervm.adapter.Adapter.read\") def test_search_all_parents(self, mock_read): ... TestSearch().test_search_by_feed Show source in test_entry.py:948 Test a search key that's not in search_keys. Signature @mock.patch(\"pypowervm.adapter.Adapter.read\") def test_search_by_feed(self, mock_read): ... TestSearch().test_search_with_xag Show source in test_entry.py:983 Test a search key that's in search_keys, but specifying xag. Signature @mock.patch(\"pypowervm.adapter.Adapter.read\") def test_search_with_xag(self, mock_read): ... TestSetUUIDMixin Show source in test_entry.py:1321 Generic tests for WrapperSetUUIDMixin. Signature class TestSetUUIDMixin(testtools.TestCase): ... TestSetUUIDMixin().test_set_uuid Show source in test_entry.py:1323 Test mixins of Element (with/without Metadata) and Entry. Signature def test_set_uuid(self): ... TestUpdate Show source in test_entry.py:1158 Signature class TestUpdate(testtools.TestCase): ... TestUpdate().setUp Show source in test_entry.py:1164 Signature def setUp(self): ... TestUpdate().test_force_update Show source in test_entry.py:1188 Signature @mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") def test_force_update(self, mock_ubp): ... TestUpdate().test_update Show source in test_entry.py:1176 Signature @mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") def test_update(self, mock_ubp): ... TestUpdate().test_update_with_get_xag Show source in test_entry.py:1220 Signature @mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") @mock.patch(\"warnings.warn\") def test_update_with_get_xag(self, mock_warn, mock_ubp): ... TestUpdate().test_update_xag Show source in test_entry.py:1206 Signature @mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") @mock.patch(\"warnings.warn\") def test_update_xag(self, mock_warn, mock_ubp): ... TestWrapper Show source in test_entry.py:198 Signature class TestWrapper(unittest.TestCase): ... TestWrapper().test_get_val_bool Show source in test_entry.py:245 Signature def test_get_val_bool(self): ... TestWrapper().test_get_val_float Show source in test_entry.py:231 Signature def test_get_val_float(self): ... TestWrapper().test_get_val_int Show source in test_entry.py:223 Signature def test_get_val_int(self): ... TestWrapper().test_get_val_percent Show source in test_entry.py:207 Signature def test_get_val_percent(self): ... TestWrapper().test_get_val_str Show source in test_entry.py:199 Signature def test_get_val_str(self): ... TestWrapperElemList Show source in test_entry.py:593 Tests for the WrapperElemList class. Signature class TestWrapperElemList(testtools.TestCase): ... TestWrapperElemList().setUp Show source in test_entry.py:596 Signature def setUp(self): ... TestWrapperElemList().test_append Show source in test_entry.py:617 Signature def test_append(self): ... TestWrapperElemList().test_extend Show source in test_entry.py:637 Signature def test_extend(self): ... TestWrapperElemList().test_get Show source in test_entry.py:606 Signature def test_get(self): ... TestWrapperElemList().test_in Show source in test_entry.py:669 Signature def test_in(self): ... TestWrapperElemList().test_index Show source in test_entry.py:675 Signature def test_index(self): ... TestWrapperElemList().test_length Show source in test_entry.py:613 Signature def test_length(self): ... TestWrapperElemList().test_repr Show source in test_entry.py:693 Signature def test_repr(self): ... TestWrapperElemList().test_str Show source in test_entry.py:680 Signature def test_str(self): ...","title":"Test Entry"},{"location":"pypowervm/tests/wrappers/test_entry/#test-entry","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Entry Auto-generated documentation for pypowervm.tests.wrappers.test_entry module. Test Entry SubWrapper TestActionableList TestActionableList().test_append TestActionableList().test_complex_path TestActionableList().test_extend TestActionableList().test_insert TestActionableList().test_pop TestActionableList().test_remove TestCreate TestCreate().setUp TestCreate().test_create_child TestCreate().test_create_other_service TestCreate().test_create_raises TestCreate().test_create_root TestDelete TestDelete().setUp TestDelete().test_delete TestElement TestElement().test_child_poaching TestElement().test_toxmlstring TestElementList TestElementList().setUp TestElementList().test_everything TestElementWrapper TestElementWrapper().setUp TestElementWrapper().test_element_clone TestElementWrapper().test_elementwrapper_clone TestElementWrapper().test_entry_clone TestElementWrapper().test_entrywrapper_clone TestElementWrapper().test_equality TestElementWrapper().test_feed_clone TestElementWrapper().test_fresh_element TestElementWrapper().test_href TestElementWrapper().test_inequality_by_subelem_change TestElementWrapper().test_response_clone TestElementWrapper().test_unequal TestEntryWrapper TestEntryWrapper().setUp TestEntryWrapper().test_etag TestEntryWrapper().test_load TestEntryWrapper().test_set_uuid TestEntryWrapper().test_toxmlstring TestGet TestGet().setUp TestGet().test_get_by_href TestGet().test_get_child TestGet().test_get_errors TestGet().test_get_root TestGetters TestGetters().test_entry_wrapper_getter TestGetters().test_feed_getter TestGetters().test_uuid_feed_getter TestRefresh TestRefresh().setUp TestRefresh().test_etag_match TestRefresh().test_etag_no_match TestRefresh().test_no_etag TestRefresh().test_use_etag_false TestSearch TestSearch().setUp TestSearch().test_child_bad_args TestSearch().test_child_no_search_key TestSearch().test_child_with_parent_spec TestSearch().test_good TestSearch().test_negate TestSearch().test_no_such_search_key TestSearch().test_quote TestSearch().test_search_all_parents TestSearch().test_search_by_feed TestSearch().test_search_with_xag TestSetUUIDMixin TestSetUUIDMixin().test_set_uuid TestUpdate TestUpdate().setUp TestUpdate().test_force_update TestUpdate().test_update TestUpdate().test_update_with_get_xag TestUpdate().test_update_xag TestWrapper TestWrapper().test_get_val_bool TestWrapper().test_get_val_float TestWrapper().test_get_val_int TestWrapper().test_get_val_percent TestWrapper().test_get_val_str TestWrapperElemList TestWrapperElemList().setUp TestWrapperElemList().test_append TestWrapperElemList().test_extend TestWrapperElemList().test_get TestWrapperElemList().test_in TestWrapperElemList().test_index TestWrapperElemList().test_length TestWrapperElemList().test_repr TestWrapperElemList().test_str","title":"Test Entry"},{"location":"pypowervm/tests/wrappers/test_entry/#subwrapper","text":"Show source in test_entry.py:58","title":"SubWrapper"},{"location":"pypowervm/tests/wrappers/test_entry/#signature","text":"class SubWrapper(ewrap.Wrapper): def __init__(self, **kwargs): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testactionablelist","text":"Show source in test_entry.py:707 Tests for the Actionable List class.","title":"TestActionableList"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_1","text":"class TestActionableList(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testactionablelisttest_append","text":"Show source in test_entry.py:720","title":"TestActionableList().test_append"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_2","text":"def test_append(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testactionablelisttest_complex_path","text":"Show source in test_entry.py:760","title":"TestActionableList().test_complex_path"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_3","text":"def test_complex_path(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testactionablelisttest_extend","text":"Show source in test_entry.py:710","title":"TestActionableList().test_extend"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_4","text":"def test_extend(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testactionablelisttest_insert","text":"Show source in test_entry.py:740","title":"TestActionableList().test_insert"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_5","text":"def test_insert(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testactionablelisttest_pop","text":"Show source in test_entry.py:750","title":"TestActionableList().test_pop"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_6","text":"def test_pop(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testactionablelisttest_remove","text":"Show source in test_entry.py:730","title":"TestActionableList().test_remove"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_7","text":"def test_remove(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testcreate","text":"Show source in test_entry.py:1261","title":"TestCreate"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_8","text":"class TestCreate(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testcreatesetup","text":"Show source in test_entry.py:1262","title":"TestCreate().setUp"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_9","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testcreatetest_create_child","text":"Show source in test_entry.py:1278","title":"TestCreate().test_create_child"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_10","text":"def test_create_child(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testcreatetest_create_other_service","text":"Show source in test_entry.py:1301 Ensure non-UOM service goes through.","title":"TestCreate().test_create_other_service"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_11","text":"def test_create_other_service(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testcreatetest_create_raises","text":"Show source in test_entry.py:1314 Verify invalid inputs raise exceptions.","title":"TestCreate().test_create_raises"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_12","text":"def test_create_raises(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testcreatetest_create_root","text":"Show source in test_entry.py:1266","title":"TestCreate().test_create_root"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_13","text":"def test_create_root(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testdelete","text":"Show source in test_entry.py:1241","title":"TestDelete"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_14","text":"class TestDelete(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testdeletesetup","text":"Show source in test_entry.py:1242","title":"TestDelete().setUp"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_15","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testdeletetest_delete","text":"Show source in test_entry.py:1246","title":"TestDelete().test_delete"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_16","text":"def test_delete(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelement","text":"Show source in test_entry.py:77","title":"TestElement"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_17","text":"class TestElement(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementtest_child_poaching","text":"Show source in test_entry.py:81 Creating an element with children of another existing element. Ensure the existing element remains intact.","title":"TestElement().test_child_poaching"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_18","text":"def test_child_poaching(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementtest_toxmlstring","text":"Show source in test_entry.py:100","title":"TestElement().test_toxmlstring"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_19","text":"@mock.patch(\"lxml.etree.tostring\") def test_toxmlstring(self, mock_tostring): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementlist","text":"Show source in test_entry.py:117","title":"TestElementList"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_20","text":"class TestElementList(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementlistsetup","text":"Show source in test_entry.py:121","title":"TestElementList().setUp"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_21","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementlisttest_everything","text":"Show source in test_entry.py:146 Ensure ElementList behaves like a list where implemented.","title":"TestElementList().test_everything"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_22","text":"def test_everything(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrapper","text":"Show source in test_entry.py:360 Tests for the ElementWrapper class.","title":"TestElementWrapper"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_23","text":"class TestElementWrapper(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappersetup","text":"Show source in test_entry.py:363","title":"TestElementWrapper().setUp"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_24","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_element_clone","text":"Show source in test_entry.py:507","title":"TestElementWrapper().test_element_clone"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_25","text":"def test_element_clone(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_elementwrapper_clone","text":"Show source in test_entry.py:586","title":"TestElementWrapper().test_elementwrapper_clone"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_26","text":"def test_elementwrapper_clone(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_entry_clone","text":"Show source in test_entry.py:533","title":"TestElementWrapper().test_entry_clone"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_27","text":"def test_entry_clone(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_entrywrapper_clone","text":"Show source in test_entry.py:575","title":"TestElementWrapper().test_entrywrapper_clone"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_28","text":"def test_entrywrapper_clone(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_equality","text":"Show source in test_entry.py:371 Validates that two elements loaded from the same data is equal.","title":"TestElementWrapper().test_equality"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_29","text":"def test_equality(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_feed_clone","text":"Show source in test_entry.py:544","title":"TestElementWrapper().test_feed_clone"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_30","text":"def test_feed_clone(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_fresh_element","text":"Show source in test_entry.py:409","title":"TestElementWrapper().test_fresh_element"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_31","text":"def test_fresh_element(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_href","text":"Show source in test_entry.py:448","title":"TestElementWrapper().test_href"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_32","text":"def test_href(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_inequality_by_subelem_change","text":"Show source in test_entry.py:383","title":"TestElementWrapper().test_inequality_by_subelem_change"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_33","text":"def test_inequality_by_subelem_change(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_response_clone","text":"Show source in test_entry.py:564","title":"TestElementWrapper().test_response_clone"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_34","text":"def test_response_clone(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testelementwrappertest_unequal","text":"Show source in test_entry.py:391","title":"TestElementWrapper().test_unequal"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_35","text":"def test_unequal(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testentrywrapper","text":"Show source in test_entry.py:264","title":"TestEntryWrapper"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_36","text":"class TestEntryWrapper(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testentrywrappersetup","text":"Show source in test_entry.py:266","title":"TestEntryWrapper().setUp"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_37","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testentrywrappertest_etag","text":"Show source in test_entry.py:270","title":"TestEntryWrapper().test_etag"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_38","text":"def test_etag(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testentrywrappertest_load","text":"Show source in test_entry.py:297","title":"TestEntryWrapper().test_load"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_39","text":"def test_load(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testentrywrappertest_set_uuid","text":"Show source in test_entry.py:280","title":"TestEntryWrapper().test_set_uuid"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_40","text":"def test_set_uuid(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testentrywrappertest_toxmlstring","text":"Show source in test_entry.py:341","title":"TestEntryWrapper().test_toxmlstring"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_41","text":"@mock.patch(\"lxml.etree.tostring\") def test_toxmlstring(self, mock_tostring): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testget","text":"Show source in test_entry.py:796 Tests for EntryWrapper.get().","title":"TestGet"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_42","text":"class TestGet(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testgetsetup","text":"Show source in test_entry.py:799","title":"TestGet().setUp"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_43","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testgettest_get_by_href","text":"Show source in test_entry.py:879","title":"TestGet().test_get_by_href"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_44","text":"@mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.wrap\") def test_get_by_href(self, mock_wrap): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testgettest_get_child","text":"Show source in test_entry.py:823 Various permutations of EntryWrapper.get on a CHILD object.","title":"TestGet().test_get_child"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_45","text":"@mock.patch(\"pypowervm.wrappers.network.CNA.wrap\") def test_get_child(self, mock_wrap): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testgettest_get_errors","text":"Show source in test_entry.py:851 Error paths in EntryWrapper.get.","title":"TestGet().test_get_errors"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_46","text":"@mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.wrap\") def test_get_errors(self, mock_wrap): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testgettest_get_root","text":"Show source in test_entry.py:803 Various permutations of EntryWrapper.get on a ROOT object.","title":"TestGet().test_get_root"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_47","text":"@mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.wrap\") def test_get_root(self, mock_wrap): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testgetters","text":"Show source in test_entry.py:1405","title":"TestGetters"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_48","text":"class TestGetters(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testgetterstest_entry_wrapper_getter","text":"Show source in test_entry.py:1409","title":"TestGetters().test_entry_wrapper_getter"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_49","text":"@mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.refresh\") def test_entry_wrapper_getter(self, mock_refresh): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testgetterstest_feed_getter","text":"Show source in test_entry.py:1492","title":"TestGetters().test_feed_getter"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_50","text":"@mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.refresh\") def test_feed_getter(self, mock_refresh): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testgetterstest_uuid_feed_getter","text":"Show source in test_entry.py:1571 Verify UUIDFeedGetter.","title":"TestGetters().test_uuid_feed_getter"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_51","text":"@mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.refresh\") def test_uuid_feed_getter(self, mock_refresh): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testrefresh","text":"Show source in test_entry.py:1084 Tests for Adapter.refresh().","title":"TestRefresh"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_52","text":"class TestRefresh(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testrefreshsetup","text":"Show source in test_entry.py:1090","title":"TestRefresh().setUp"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_53","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testrefreshtest_etag_match","text":"Show source in test_entry.py:1130","title":"TestRefresh().test_etag_match"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_54","text":"@mock.patch(\"pypowervm.adapter.Adapter.read_by_href\") def test_etag_match(self, mock_read): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testrefreshtest_etag_no_match","text":"Show source in test_entry.py:1139","title":"TestRefresh().test_etag_no_match"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_55","text":"@mock.patch(\"pypowervm.adapter.Adapter.read_by_href\") def test_etag_no_match(self, mock_read): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testrefreshtest_no_etag","text":"Show source in test_entry.py:1122","title":"TestRefresh().test_no_etag"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_56","text":"@mock.patch(\"pypowervm.adapter.Adapter.read_by_href\") def test_no_etag(self, mock_read): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testrefreshtest_use_etag_false","text":"Show source in test_entry.py:1148","title":"TestRefresh().test_use_etag_false"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_57","text":"@mock.patch(\"pypowervm.adapter.Adapter.read_by_href\") def test_use_etag_false(self, mock_read): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearch","text":"Show source in test_entry.py:887 Tests for EntryWrapper.search().","title":"TestSearch"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_58","text":"class TestSearch(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchsetup","text":"Show source in test_entry.py:890","title":"TestSearch().setUp"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_59","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchtest_child_bad_args","text":"Show source in test_entry.py:1016 Specifying parent_uuid without parent_type is an error.","title":"TestSearch().test_child_bad_args"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_60","text":"def test_child_bad_args(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchtest_child_no_search_key","text":"Show source in test_entry.py:999 CHILD search with or without a search key (uses GET-feed-loop).","title":"TestSearch().test_child_no_search_key"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_61","text":"@mock.patch(\"pypowervm.adapter.Adapter.read\") def test_child_no_search_key(self, mock_read): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchtest_child_with_parent_spec","text":"Show source in test_entry.py:1070 Test CHILD search using a parent instance.","title":"TestSearch().test_child_with_parent_spec"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_62","text":"@mock.patch(\"pypowervm.adapter.Adapter.read\") def test_child_with_parent_spec(self, mock_read): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchtest_good","text":"Show source in test_entry.py:903","title":"TestSearch().test_good"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_63","text":"@mock.patch(\"pypowervm.adapter.Adapter._request\") def test_good(self, mock_rq): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchtest_negate","text":"Show source in test_entry.py:925","title":"TestSearch().test_negate"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_64","text":"@mock.patch(\"pypowervm.adapter.Adapter._request\") def test_negate(self, mock_rq): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchtest_no_such_search_key","text":"Show source in test_entry.py:935 Ensure an invalid search key gives ValueError.","title":"TestSearch().test_no_such_search_key"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_65","text":"def test_no_such_search_key(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchtest_quote","text":"Show source in test_entry.py:940 Ensure special chars in the search value are properly encoded.","title":"TestSearch().test_quote"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_66","text":"@mock.patch(\"pypowervm.adapter.Adapter._request\") def test_quote(self, mock_rq): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchtest_search_all_parents","text":"Show source in test_entry.py:1021 Anonymous ROOT for CHILD search.","title":"TestSearch().test_search_all_parents"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_67","text":"@mock.patch(\"pypowervm.adapter.Adapter.read\") def test_search_all_parents(self, mock_read): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchtest_search_by_feed","text":"Show source in test_entry.py:948 Test a search key that's not in search_keys.","title":"TestSearch().test_search_by_feed"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_68","text":"@mock.patch(\"pypowervm.adapter.Adapter.read\") def test_search_by_feed(self, mock_read): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsearchtest_search_with_xag","text":"Show source in test_entry.py:983 Test a search key that's in search_keys, but specifying xag.","title":"TestSearch().test_search_with_xag"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_69","text":"@mock.patch(\"pypowervm.adapter.Adapter.read\") def test_search_with_xag(self, mock_read): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsetuuidmixin","text":"Show source in test_entry.py:1321 Generic tests for WrapperSetUUIDMixin.","title":"TestSetUUIDMixin"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_70","text":"class TestSetUUIDMixin(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testsetuuidmixintest_set_uuid","text":"Show source in test_entry.py:1323 Test mixins of Element (with/without Metadata) and Entry.","title":"TestSetUUIDMixin().test_set_uuid"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_71","text":"def test_set_uuid(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testupdate","text":"Show source in test_entry.py:1158","title":"TestUpdate"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_72","text":"class TestUpdate(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testupdatesetup","text":"Show source in test_entry.py:1164","title":"TestUpdate().setUp"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_73","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testupdatetest_force_update","text":"Show source in test_entry.py:1188","title":"TestUpdate().test_force_update"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_74","text":"@mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") def test_force_update(self, mock_ubp): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testupdatetest_update","text":"Show source in test_entry.py:1176","title":"TestUpdate().test_update"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_75","text":"@mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") def test_update(self, mock_ubp): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testupdatetest_update_with_get_xag","text":"Show source in test_entry.py:1220","title":"TestUpdate().test_update_with_get_xag"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_76","text":"@mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") @mock.patch(\"warnings.warn\") def test_update_with_get_xag(self, mock_warn, mock_ubp): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testupdatetest_update_xag","text":"Show source in test_entry.py:1206","title":"TestUpdate().test_update_xag"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_77","text":"@mock.patch(\"pypowervm.adapter.Adapter.update_by_path\") @mock.patch(\"warnings.warn\") def test_update_xag(self, mock_warn, mock_ubp): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapper","text":"Show source in test_entry.py:198","title":"TestWrapper"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_78","text":"class TestWrapper(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrappertest_get_val_bool","text":"Show source in test_entry.py:245","title":"TestWrapper().test_get_val_bool"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_79","text":"def test_get_val_bool(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrappertest_get_val_float","text":"Show source in test_entry.py:231","title":"TestWrapper().test_get_val_float"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_80","text":"def test_get_val_float(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrappertest_get_val_int","text":"Show source in test_entry.py:223","title":"TestWrapper().test_get_val_int"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_81","text":"def test_get_val_int(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrappertest_get_val_percent","text":"Show source in test_entry.py:207","title":"TestWrapper().test_get_val_percent"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_82","text":"def test_get_val_percent(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrappertest_get_val_str","text":"Show source in test_entry.py:199","title":"TestWrapper().test_get_val_str"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_83","text":"def test_get_val_str(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapperelemlist","text":"Show source in test_entry.py:593 Tests for the WrapperElemList class.","title":"TestWrapperElemList"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_84","text":"class TestWrapperElemList(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapperelemlistsetup","text":"Show source in test_entry.py:596","title":"TestWrapperElemList().setUp"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_85","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapperelemlisttest_append","text":"Show source in test_entry.py:617","title":"TestWrapperElemList().test_append"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_86","text":"def test_append(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapperelemlisttest_extend","text":"Show source in test_entry.py:637","title":"TestWrapperElemList().test_extend"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_87","text":"def test_extend(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapperelemlisttest_get","text":"Show source in test_entry.py:606","title":"TestWrapperElemList().test_get"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_88","text":"def test_get(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapperelemlisttest_in","text":"Show source in test_entry.py:669","title":"TestWrapperElemList().test_in"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_89","text":"def test_in(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapperelemlisttest_index","text":"Show source in test_entry.py:675","title":"TestWrapperElemList().test_index"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_90","text":"def test_index(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapperelemlisttest_length","text":"Show source in test_entry.py:613","title":"TestWrapperElemList().test_length"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_91","text":"def test_length(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapperelemlisttest_repr","text":"Show source in test_entry.py:693","title":"TestWrapperElemList().test_repr"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_92","text":"def test_repr(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_entry/#testwrapperelemlisttest_str","text":"Show source in test_entry.py:680","title":"TestWrapperElemList().test_str"},{"location":"pypowervm/tests/wrappers/test_entry/#signature_93","text":"def test_str(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_event/","text":"TestEvent Pypowervm Index / Pypowervm / Tests / Wrappers / TestEvent Auto-generated documentation for pypowervm.tests.wrappers.test_event module. TestEvent TestEvent TestEvent().test_bld TestEvent().test_get TestEvent().test_getters TestEvent().test_str TestEvent Show source in test_event.py:23 Signature class TestEvent(twrap.TestWrapper): ... TestEvent().test_bld Show source in test_event.py:46 Signature def test_bld(self): ... TestEvent().test_get Show source in test_event.py:27 Signature @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.get\") def test_get(self, mock_ewrap_get): ... TestEvent().test_getters Show source in test_event.py:34 Signature def test_getters(self): ... TestEvent().test_str Show source in test_event.py:58 Signature def test_str(self): ...","title":"TestEvent"},{"location":"pypowervm/tests/wrappers/test_event/#testevent","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / TestEvent Auto-generated documentation for pypowervm.tests.wrappers.test_event module. TestEvent TestEvent TestEvent().test_bld TestEvent().test_get TestEvent().test_getters TestEvent().test_str","title":"TestEvent"},{"location":"pypowervm/tests/wrappers/test_event/#testevent_1","text":"Show source in test_event.py:23","title":"TestEvent"},{"location":"pypowervm/tests/wrappers/test_event/#signature","text":"class TestEvent(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_event/#testeventtest_bld","text":"Show source in test_event.py:46","title":"TestEvent().test_bld"},{"location":"pypowervm/tests/wrappers/test_event/#signature_1","text":"def test_bld(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_event/#testeventtest_get","text":"Show source in test_event.py:27","title":"TestEvent().test_get"},{"location":"pypowervm/tests/wrappers/test_event/#signature_2","text":"@mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.get\") def test_get(self, mock_ewrap_get): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_event/#testeventtest_getters","text":"Show source in test_event.py:34","title":"TestEvent().test_getters"},{"location":"pypowervm/tests/wrappers/test_event/#signature_3","text":"def test_getters(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_event/#testeventtest_str","text":"Show source in test_event.py:58","title":"TestEvent().test_str"},{"location":"pypowervm/tests/wrappers/test_event/#signature_4","text":"def test_str(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_http_error/","text":"TestHttpError Pypowervm Index / Pypowervm / Tests / Wrappers / TestHttpError Auto-generated documentation for pypowervm.tests.wrappers.test_http_error module. TestHttpError TestHttpError TestHttpError().setUp TestHttpError().test_wrap TestHttpError Show source in test_http_error.py:39 Signature class TestHttpError(unittest.TestCase): ... TestHttpError().setUp Show source in test_http_error.py:41 Signature def setUp(self): ... TestHttpError().test_wrap Show source in test_http_error.py:49 Signature def test_wrap(self): ...","title":"TestHttpError"},{"location":"pypowervm/tests/wrappers/test_http_error/#testhttperror","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / TestHttpError Auto-generated documentation for pypowervm.tests.wrappers.test_http_error module. TestHttpError TestHttpError TestHttpError().setUp TestHttpError().test_wrap","title":"TestHttpError"},{"location":"pypowervm/tests/wrappers/test_http_error/#testhttperror_1","text":"Show source in test_http_error.py:39","title":"TestHttpError"},{"location":"pypowervm/tests/wrappers/test_http_error/#signature","text":"class TestHttpError(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_http_error/#testhttperrorsetup","text":"Show source in test_http_error.py:41","title":"TestHttpError().setUp"},{"location":"pypowervm/tests/wrappers/test_http_error/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_http_error/#testhttperrortest_wrap","text":"Show source in test_http_error.py:49","title":"TestHttpError().test_wrap"},{"location":"pypowervm/tests/wrappers/test_http_error/#signature_2","text":"def test_wrap(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/","text":"Test Iocard Pypowervm Index / Pypowervm / Tests / Wrappers / Test Iocard Auto-generated documentation for pypowervm.tests.wrappers.test_iocard module. Test Iocard TestLogicalPort TestLogicalPort().test_logical_ports TestSRIOVAdapter TestSRIOVAdapter().setUp TestSRIOVAdapter().test_attrs TestSRIOVAdapter().test_ids TestSRIOVAdapter().test_list TestSRIOVAdapter().test_mode TestSRIOVAdapter().test_personality TestSRIOVAdapter().test_physical_ports TestSRIOVAdapter().test_physical_ports_no_vivify TestSRIOVAdapter().test_state TestVNIC TestVNIC().test_backdev_props TestVNIC().test_details_props_inner TestVNIC().test_details_props_outer TestVNIC().test_vnic_and_backdev_bld TestVNIC().test_vnic_props TestLogicalPort Show source in test_iocard.py:169 Signature class TestLogicalPort(twrap.TestWrapper): ... TestLogicalPort().test_logical_ports Show source in test_iocard.py:174 Signature def test_logical_ports(self): ... TestSRIOVAdapter Show source in test_iocard.py:26 Signature class TestSRIOVAdapter(twrap.TestWrapper): ... TestSRIOVAdapter().setUp Show source in test_iocard.py:31 Signature def setUp(self): ... TestSRIOVAdapter().test_attrs Show source in test_iocard.py:40 Signature def test_attrs(self): ... TestSRIOVAdapter().test_ids Show source in test_iocard.py:48 Test .id and .sriov_adap_id. Signature def test_ids(self): ... TestSRIOVAdapter().test_list Show source in test_iocard.py:35 Signature def test_list(self): ... TestSRIOVAdapter().test_mode Show source in test_iocard.py:57 Signature def test_mode(self): ... TestSRIOVAdapter().test_personality Show source in test_iocard.py:63 Signature def test_personality(self): ... TestSRIOVAdapter().test_physical_ports Show source in test_iocard.py:72 Signature def test_physical_ports(self): ... TestSRIOVAdapter().test_physical_ports_no_vivify Show source in test_iocard.py:153 Don't accidentally vivify [Converged]EthernetPhysicalPorts. See https://bugs.launchpad.net/pypowervm/+bug/1617050 This test case has to prove that, when EthernetPhysicalPorts doesn't exist in the XML, asking for phys_ports doesn't create it. Signature def test_physical_ports_no_vivify(self): ... TestSRIOVAdapter().test_state Show source in test_iocard.py:69 Signature def test_state(self): ... TestVNIC Show source in test_iocard.py:263 Signature class TestVNIC(twrap.TestWrapper): ... TestVNIC().test_backdev_props Show source in test_iocard.py:392 Signature def test_backdev_props(self): ... TestVNIC().test_details_props_inner Show source in test_iocard.py:359 Signature def test_details_props_inner(self): ... TestVNIC().test_details_props_outer Show source in test_iocard.py:362 Signature def test_details_props_outer(self): ... TestVNIC().test_vnic_and_backdev_bld Show source in test_iocard.py:275 Signature def test_vnic_and_backdev_bld(self): ... TestVNIC().test_vnic_props Show source in test_iocard.py:267 Signature def test_vnic_props(self): ...","title":"Test Iocard"},{"location":"pypowervm/tests/wrappers/test_iocard/#test-iocard","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Iocard Auto-generated documentation for pypowervm.tests.wrappers.test_iocard module. Test Iocard TestLogicalPort TestLogicalPort().test_logical_ports TestSRIOVAdapter TestSRIOVAdapter().setUp TestSRIOVAdapter().test_attrs TestSRIOVAdapter().test_ids TestSRIOVAdapter().test_list TestSRIOVAdapter().test_mode TestSRIOVAdapter().test_personality TestSRIOVAdapter().test_physical_ports TestSRIOVAdapter().test_physical_ports_no_vivify TestSRIOVAdapter().test_state TestVNIC TestVNIC().test_backdev_props TestVNIC().test_details_props_inner TestVNIC().test_details_props_outer TestVNIC().test_vnic_and_backdev_bld TestVNIC().test_vnic_props","title":"Test Iocard"},{"location":"pypowervm/tests/wrappers/test_iocard/#testlogicalport","text":"Show source in test_iocard.py:169","title":"TestLogicalPort"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature","text":"class TestLogicalPort(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testlogicalporttest_logical_ports","text":"Show source in test_iocard.py:174","title":"TestLogicalPort().test_logical_ports"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_1","text":"def test_logical_ports(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testsriovadapter","text":"Show source in test_iocard.py:26","title":"TestSRIOVAdapter"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_2","text":"class TestSRIOVAdapter(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testsriovadaptersetup","text":"Show source in test_iocard.py:31","title":"TestSRIOVAdapter().setUp"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_3","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testsriovadaptertest_attrs","text":"Show source in test_iocard.py:40","title":"TestSRIOVAdapter().test_attrs"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_4","text":"def test_attrs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testsriovadaptertest_ids","text":"Show source in test_iocard.py:48 Test .id and .sriov_adap_id.","title":"TestSRIOVAdapter().test_ids"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_5","text":"def test_ids(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testsriovadaptertest_list","text":"Show source in test_iocard.py:35","title":"TestSRIOVAdapter().test_list"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_6","text":"def test_list(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testsriovadaptertest_mode","text":"Show source in test_iocard.py:57","title":"TestSRIOVAdapter().test_mode"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_7","text":"def test_mode(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testsriovadaptertest_personality","text":"Show source in test_iocard.py:63","title":"TestSRIOVAdapter().test_personality"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_8","text":"def test_personality(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testsriovadaptertest_physical_ports","text":"Show source in test_iocard.py:72","title":"TestSRIOVAdapter().test_physical_ports"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_9","text":"def test_physical_ports(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testsriovadaptertest_physical_ports_no_vivify","text":"Show source in test_iocard.py:153 Don't accidentally vivify [Converged]EthernetPhysicalPorts. See https://bugs.launchpad.net/pypowervm/+bug/1617050 This test case has to prove that, when EthernetPhysicalPorts doesn't exist in the XML, asking for phys_ports doesn't create it.","title":"TestSRIOVAdapter().test_physical_ports_no_vivify"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_10","text":"def test_physical_ports_no_vivify(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testsriovadaptertest_state","text":"Show source in test_iocard.py:69","title":"TestSRIOVAdapter().test_state"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_11","text":"def test_state(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testvnic","text":"Show source in test_iocard.py:263","title":"TestVNIC"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_12","text":"class TestVNIC(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testvnictest_backdev_props","text":"Show source in test_iocard.py:392","title":"TestVNIC().test_backdev_props"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_13","text":"def test_backdev_props(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testvnictest_details_props_inner","text":"Show source in test_iocard.py:359","title":"TestVNIC().test_details_props_inner"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_14","text":"def test_details_props_inner(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testvnictest_details_props_outer","text":"Show source in test_iocard.py:362","title":"TestVNIC().test_details_props_outer"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_15","text":"def test_details_props_outer(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testvnictest_vnic_and_backdev_bld","text":"Show source in test_iocard.py:275","title":"TestVNIC().test_vnic_and_backdev_bld"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_16","text":"def test_vnic_and_backdev_bld(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_iocard/#testvnictest_vnic_props","text":"Show source in test_iocard.py:267","title":"TestVNIC().test_vnic_props"},{"location":"pypowervm/tests/wrappers/test_iocard/#signature_17","text":"def test_vnic_props(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/","text":"Test Job Pypowervm Index / Pypowervm / Tests / Wrappers / Test Job Auto-generated documentation for pypowervm.tests.wrappers.test_job module. Test Job TestJobEntryWrapper TestJobEntryWrapper().call_simple_getter TestJobEntryWrapper().setUp TestJobEntryWrapper().set_single_value TestJobEntryWrapper().set_test_property_values TestJobEntryWrapper().test_cancel_job TestJobEntryWrapper().test_cancel_job_thread TestJobEntryWrapper().test_delete_job TestJobEntryWrapper().test_get_job_id TestJobEntryWrapper().test_get_job_message TestJobEntryWrapper().test_get_job_resp_exception_msg TestJobEntryWrapper().test_get_job_results_message TestJobEntryWrapper().test_get_job_status TestJobEntryWrapper().test_job_parameters TestJobEntryWrapper().test_montor_job TestJobEntryWrapper().test_poll_and_delete_thread TestJobEntryWrapper().test_poll_while_status TestJobEntryWrapper().test_run_job TestJobEntryWrapper().verify_equal TestJobEntryWrapper Show source in test_job.py:38 Signature class TestJobEntryWrapper(testtools.TestCase): ... TestJobEntryWrapper().call_simple_getter Show source in test_job.py:105 Signature def call_simple_getter(self, wrapper, method_name, expected_value, expected_bad_value): ... TestJobEntryWrapper().setUp Show source in test_job.py:40 Signature def setUp(self): ... TestJobEntryWrapper().set_single_value Show source in test_job.py:62 Signature def set_single_value(self, entry, property_name, value): ... TestJobEntryWrapper().set_test_property_values Show source in test_job.py:69 Set expected values in entry so test code can work consistently. Signature def set_test_property_values(self): ... TestJobEntryWrapper().test_cancel_job Show source in test_job.py:301 Signature @mock.patch(\"pypowervm.wrappers.job.CancelJobThread.start\") @mock.patch(\"pypowervm.wrappers.job.Job.delete_job\") @mock.patch(\"pypowervm.wrappers.job.Job._monitor_job\") def test_cancel_job(self, mock_monitor, mock_delete, mock_start): ... TestJobEntryWrapper().test_cancel_job_thread Show source in test_job.py:293 Signature @mock.patch(\"pypowervm.wrappers.job.Job.poll_while_status\") @mock.patch(\"pypowervm.wrappers.job.Job.delete_job\") def test_cancel_job_thread(self, mock_del, mock_poll): ... TestJobEntryWrapper().test_delete_job Show source in test_job.py:323 Signature @mock.patch(\"pypowervm.wrappers.job.Job.job_status\") def test_delete_job(self, mock_status): ... TestJobEntryWrapper().test_get_job_id Show source in test_job.py:123 Signature def test_get_job_id(self): ... TestJobEntryWrapper().test_get_job_message Show source in test_job.py:131 Signature def test_get_job_message(self): ... TestJobEntryWrapper().test_get_job_resp_exception_msg Show source in test_job.py:136 Signature def test_get_job_resp_exception_msg(self): ... TestJobEntryWrapper().test_get_job_results_message Show source in test_job.py:141 Signature def test_get_job_results_message(self): ... TestJobEntryWrapper().test_get_job_status Show source in test_job.py:127 Signature def test_get_job_status(self): ... TestJobEntryWrapper().test_job_parameters Show source in test_job.py:146 Signature def test_job_parameters(self): ... TestJobEntryWrapper().test_montor_job Show source in test_job.py:217 Signature @mock.patch(\"pypowervm.wrappers.job.Job.poll_while_status\") @mock.patch(\"pypowervm.wrappers.job.PollAndDeleteThread\") def test_montor_job(self, mock_thread, mock_poll): ... TestJobEntryWrapper().test_poll_and_delete_thread Show source in test_job.py:277 Signature @mock.patch(\"pypowervm.wrappers.job.Job.poll_while_status\") @mock.patch(\"pypowervm.wrappers.job.Job.delete_job\") def test_poll_and_delete_thread(self, mock_del, mock_poll): ... TestJobEntryWrapper().test_poll_while_status Show source in test_job.py:245 Signature @mock.patch(\"time.time\") @mock.patch(\"time.sleep\") @mock.patch(\"pypowervm.wrappers.job.Job.job_status\") def test_poll_while_status(self, mock_status, mock_sleep, mock_time): ... TestJobEntryWrapper().test_run_job Show source in test_job.py:175 Signature @mock.patch(\"pypowervm.wrappers.job.Job._monitor_job\") @mock.patch(\"pypowervm.wrappers.job.Job.cancel_job\") @mock.patch(\"pypowervm.wrappers.job.Job.delete_job\") @mock.patch(\"pypowervm.wrappers.job.Job.job_status\") def test_run_job(self, mock_status, mock_del, mock_cancel, mock_monitor): ... TestJobEntryWrapper().verify_equal Show source in test_job.py:90 Signature def verify_equal(self, method_name, returned_value, expected_value): ...","title":"Test Job"},{"location":"pypowervm/tests/wrappers/test_job/#test-job","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Job Auto-generated documentation for pypowervm.tests.wrappers.test_job module. Test Job TestJobEntryWrapper TestJobEntryWrapper().call_simple_getter TestJobEntryWrapper().setUp TestJobEntryWrapper().set_single_value TestJobEntryWrapper().set_test_property_values TestJobEntryWrapper().test_cancel_job TestJobEntryWrapper().test_cancel_job_thread TestJobEntryWrapper().test_delete_job TestJobEntryWrapper().test_get_job_id TestJobEntryWrapper().test_get_job_message TestJobEntryWrapper().test_get_job_resp_exception_msg TestJobEntryWrapper().test_get_job_results_message TestJobEntryWrapper().test_get_job_status TestJobEntryWrapper().test_job_parameters TestJobEntryWrapper().test_montor_job TestJobEntryWrapper().test_poll_and_delete_thread TestJobEntryWrapper().test_poll_while_status TestJobEntryWrapper().test_run_job TestJobEntryWrapper().verify_equal","title":"Test Job"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrapper","text":"Show source in test_job.py:38","title":"TestJobEntryWrapper"},{"location":"pypowervm/tests/wrappers/test_job/#signature","text":"class TestJobEntryWrapper(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappercall_simple_getter","text":"Show source in test_job.py:105","title":"TestJobEntryWrapper().call_simple_getter"},{"location":"pypowervm/tests/wrappers/test_job/#signature_1","text":"def call_simple_getter(self, wrapper, method_name, expected_value, expected_bad_value): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappersetup","text":"Show source in test_job.py:40","title":"TestJobEntryWrapper().setUp"},{"location":"pypowervm/tests/wrappers/test_job/#signature_2","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrapperset_single_value","text":"Show source in test_job.py:62","title":"TestJobEntryWrapper().set_single_value"},{"location":"pypowervm/tests/wrappers/test_job/#signature_3","text":"def set_single_value(self, entry, property_name, value): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrapperset_test_property_values","text":"Show source in test_job.py:69 Set expected values in entry so test code can work consistently.","title":"TestJobEntryWrapper().set_test_property_values"},{"location":"pypowervm/tests/wrappers/test_job/#signature_4","text":"def set_test_property_values(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_cancel_job","text":"Show source in test_job.py:301","title":"TestJobEntryWrapper().test_cancel_job"},{"location":"pypowervm/tests/wrappers/test_job/#signature_5","text":"@mock.patch(\"pypowervm.wrappers.job.CancelJobThread.start\") @mock.patch(\"pypowervm.wrappers.job.Job.delete_job\") @mock.patch(\"pypowervm.wrappers.job.Job._monitor_job\") def test_cancel_job(self, mock_monitor, mock_delete, mock_start): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_cancel_job_thread","text":"Show source in test_job.py:293","title":"TestJobEntryWrapper().test_cancel_job_thread"},{"location":"pypowervm/tests/wrappers/test_job/#signature_6","text":"@mock.patch(\"pypowervm.wrappers.job.Job.poll_while_status\") @mock.patch(\"pypowervm.wrappers.job.Job.delete_job\") def test_cancel_job_thread(self, mock_del, mock_poll): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_delete_job","text":"Show source in test_job.py:323","title":"TestJobEntryWrapper().test_delete_job"},{"location":"pypowervm/tests/wrappers/test_job/#signature_7","text":"@mock.patch(\"pypowervm.wrappers.job.Job.job_status\") def test_delete_job(self, mock_status): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_get_job_id","text":"Show source in test_job.py:123","title":"TestJobEntryWrapper().test_get_job_id"},{"location":"pypowervm/tests/wrappers/test_job/#signature_8","text":"def test_get_job_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_get_job_message","text":"Show source in test_job.py:131","title":"TestJobEntryWrapper().test_get_job_message"},{"location":"pypowervm/tests/wrappers/test_job/#signature_9","text":"def test_get_job_message(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_get_job_resp_exception_msg","text":"Show source in test_job.py:136","title":"TestJobEntryWrapper().test_get_job_resp_exception_msg"},{"location":"pypowervm/tests/wrappers/test_job/#signature_10","text":"def test_get_job_resp_exception_msg(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_get_job_results_message","text":"Show source in test_job.py:141","title":"TestJobEntryWrapper().test_get_job_results_message"},{"location":"pypowervm/tests/wrappers/test_job/#signature_11","text":"def test_get_job_results_message(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_get_job_status","text":"Show source in test_job.py:127","title":"TestJobEntryWrapper().test_get_job_status"},{"location":"pypowervm/tests/wrappers/test_job/#signature_12","text":"def test_get_job_status(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_job_parameters","text":"Show source in test_job.py:146","title":"TestJobEntryWrapper().test_job_parameters"},{"location":"pypowervm/tests/wrappers/test_job/#signature_13","text":"def test_job_parameters(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_montor_job","text":"Show source in test_job.py:217","title":"TestJobEntryWrapper().test_montor_job"},{"location":"pypowervm/tests/wrappers/test_job/#signature_14","text":"@mock.patch(\"pypowervm.wrappers.job.Job.poll_while_status\") @mock.patch(\"pypowervm.wrappers.job.PollAndDeleteThread\") def test_montor_job(self, mock_thread, mock_poll): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_poll_and_delete_thread","text":"Show source in test_job.py:277","title":"TestJobEntryWrapper().test_poll_and_delete_thread"},{"location":"pypowervm/tests/wrappers/test_job/#signature_15","text":"@mock.patch(\"pypowervm.wrappers.job.Job.poll_while_status\") @mock.patch(\"pypowervm.wrappers.job.Job.delete_job\") def test_poll_and_delete_thread(self, mock_del, mock_poll): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_poll_while_status","text":"Show source in test_job.py:245","title":"TestJobEntryWrapper().test_poll_while_status"},{"location":"pypowervm/tests/wrappers/test_job/#signature_16","text":"@mock.patch(\"time.time\") @mock.patch(\"time.sleep\") @mock.patch(\"pypowervm.wrappers.job.Job.job_status\") def test_poll_while_status(self, mock_status, mock_sleep, mock_time): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrappertest_run_job","text":"Show source in test_job.py:175","title":"TestJobEntryWrapper().test_run_job"},{"location":"pypowervm/tests/wrappers/test_job/#signature_17","text":"@mock.patch(\"pypowervm.wrappers.job.Job._monitor_job\") @mock.patch(\"pypowervm.wrappers.job.Job.cancel_job\") @mock.patch(\"pypowervm.wrappers.job.Job.delete_job\") @mock.patch(\"pypowervm.wrappers.job.Job.job_status\") def test_run_job(self, mock_status, mock_del, mock_cancel, mock_monitor): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_job/#testjobentrywrapperverify_equal","text":"Show source in test_job.py:90","title":"TestJobEntryWrapper().verify_equal"},{"location":"pypowervm/tests/wrappers/test_job/#signature_18","text":"def verify_equal(self, method_name, returned_value, expected_value): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/","text":"TestLogicalPartition Pypowervm Index / Pypowervm / Tests / Wrappers / TestLogicalPartition Auto-generated documentation for pypowervm.tests.wrappers.test_logical_partition module. TestLogicalPartition TestIBMiSpecific TestIBMiSpecific().test_desig_ipl_src TestIBMiSpecific().test_restricted_io TestIBMiSpecific().test_rr_real_values TestIBMiSpecific().test_tagged_io TestIOCfg TestIOCfg().setUp TestIOCfg().test_bld TestIOCfg().test_data TestLogicalPartition TestLogicalPartition().call_simple_getter TestLogicalPartition().setUp TestLogicalPartition().test_allow_perf_data_collection TestLogicalPartition().test_associated_managed_system_uuid TestLogicalPartition().test_avail_priority TestLogicalPartition().test_bootmode TestLogicalPartition().test_can_lpm TestLogicalPartition().test_can_lpm_ibmi TestLogicalPartition().test_can_modifies TestLogicalPartition().test_can_modify TestLogicalPartition().test_capabilities TestLogicalPartition().test_desired TestLogicalPartition().test_desired_units TestLogicalPartition().test_desired_virtual TestLogicalPartition().test_disable_secure_boot TestLogicalPartition().test_get_cur_dram_pmem_volumes TestLogicalPartition().test_get_cur_pmem_volumes TestLogicalPartition().test_get_current_secure_boot TestLogicalPartition().test_get_current_sharing_mode TestLogicalPartition().test_get_id TestLogicalPartition().test_get_max_dram_pmem_volumes TestLogicalPartition().test_get_max_pmem_volumes TestLogicalPartition().test_get_name TestLogicalPartition().test_get_operating_system TestLogicalPartition().test_get_pending_secure_boot TestLogicalPartition().test_get_proc_compat_modes TestLogicalPartition().test_get_proc_mode TestLogicalPartition().test_get_ref_code TestLogicalPartition().test_get_ref_code_full TestLogicalPartition().test_get_shared_proc_pool_id TestLogicalPartition().test_get_state TestLogicalPartition().test_get_type TestLogicalPartition().test_get_val_str TestLogicalPartition().test_is_mgmt_partition TestLogicalPartition().test_is_svc_partition TestLogicalPartition().test_keylock_pos TestLogicalPartition().test_max TestLogicalPartition().test_max_units TestLogicalPartition().test_max_virtual TestLogicalPartition().test_min TestLogicalPartition().test_min_units TestLogicalPartition().test_min_virtual TestLogicalPartition().test_nvram TestLogicalPartition().test_profile_sync TestLogicalPartition().test_rmc_state TestLogicalPartition().test_rr_off TestLogicalPartition().test_srr TestLogicalPartition().test_subwrapper_getters TestLogicalPartition().test_uncapped_weight TestLogicalPartition().test_uptime TestLogicalPartition().test_uuid TestLogicalPartition().verify_equal TestMemCfg TestMemCfg().setUp TestMemCfg().test_current_mem TestMemCfg().test_mem TestPartitionIOConfiguration TestPartitionIOConfiguration().setUp TestPartitionIOConfiguration().test_io_slots TestPartitionIOConfiguration().test_max_slots TestPhysFCPort TestPhysFCPort().test_bld TestIBMiSpecific Show source in test_logical_partition.py:563 IBMi-specific tests, requiring a test file from an IBMi partition. Signature class TestIBMiSpecific(twrap.TestWrapper): ... TestIBMiSpecific().test_desig_ipl_src Show source in test_logical_partition.py:572 Signature def test_desig_ipl_src(self): ... TestIBMiSpecific().test_restricted_io Show source in test_logical_partition.py:568 Signature def test_restricted_io(self): ... TestIBMiSpecific().test_rr_real_values Show source in test_logical_partition.py:622 Test Remote Restart fields when RR capable. Signature @mock.patch(\"warnings.warn\") def test_rr_real_values(self, mock_warn): ... TestIBMiSpecific().test_tagged_io Show source in test_logical_partition.py:583 Signature def test_tagged_io(self): ... TestIOCfg Show source in test_logical_partition.py:677 Test the lpar I/O configuration. Signature class TestIOCfg(twrap.TestWrapper): ... TestIOCfg().setUp Show source in test_logical_partition.py:683 Signature def setUp(self): ... TestIOCfg().test_bld Show source in test_logical_partition.py:687 Signature def test_bld(self): ... TestIOCfg().test_data Show source in test_logical_partition.py:702 Signature def test_data(self): ... TestLogicalPartition Show source in test_logical_partition.py:40 Signature class TestLogicalPartition(testtools.TestCase): ... TestLogicalPartition().call_simple_getter Show source in test_logical_partition.py:124 Signature def call_simple_getter( self, method_name, expected_value, expected_bad_value, use_dedicated=False ): ... TestLogicalPartition().setUp Show source in test_logical_partition.py:49 Signature def setUp(self): ... TestLogicalPartition().test_allow_perf_data_collection Show source in test_logical_partition.py:296 Signature def test_allow_perf_data_collection(self): ... TestLogicalPartition().test_associated_managed_system_uuid Show source in test_logical_partition.py:265 Signature def test_associated_managed_system_uuid(self): ... TestLogicalPartition().test_avail_priority Show source in test_logical_partition.py:197 Signature def test_avail_priority(self): ... TestLogicalPartition().test_bootmode Show source in test_logical_partition.py:284 Signature def test_bootmode(self): ... TestLogicalPartition().test_can_lpm Show source in test_logical_partition.py:360 Tests for the can_lpm method. Signature def test_can_lpm(self): ... TestLogicalPartition().test_can_lpm_ibmi Show source in test_logical_partition.py:396 Tests for the can_lpm method for IBM i branches. Signature def test_can_lpm_ibmi(self): ... TestLogicalPartition().test_can_modifies Show source in test_logical_partition.py:313 Simple check on the 'can_modify_xxx' methods. Signature def test_can_modifies(self): ... TestLogicalPartition().test_can_modify Show source in test_logical_partition.py:322 Detailed testing on the _can_modify method. Signature def test_can_modify(self): ... TestLogicalPartition().test_capabilities Show source in test_logical_partition.py:448 Signature def test_capabilities(self): ... TestLogicalPartition().test_desired Show source in test_logical_partition.py:527 Signature def test_desired(self): ... TestLogicalPartition().test_desired_units Show source in test_logical_partition.py:471 Signature def test_desired_units(self): ... TestLogicalPartition().test_desired_virtual Show source in test_logical_partition.py:492 Signature def test_desired_virtual(self): ... TestLogicalPartition().test_disable_secure_boot Show source in test_logical_partition.py:291 Signature def test_disable_secure_boot(self): ... TestLogicalPartition().test_get_cur_dram_pmem_volumes Show source in test_logical_partition.py:237 Signature def test_get_cur_dram_pmem_volumes(self): ... TestLogicalPartition().test_get_cur_pmem_volumes Show source in test_logical_partition.py:229 Signature def test_get_cur_pmem_volumes(self): ... TestLogicalPartition().test_get_current_secure_boot Show source in test_logical_partition.py:221 Signature def test_get_current_secure_boot(self): ... TestLogicalPartition().test_get_current_sharing_mode Show source in test_logical_partition.py:464 Signature def test_get_current_sharing_mode(self): ... TestLogicalPartition().test_get_id Show source in test_logical_partition.py:165 Signature def test_get_id(self): ... TestLogicalPartition().test_get_max_dram_pmem_volumes Show source in test_logical_partition.py:233 Signature def test_get_max_dram_pmem_volumes(self): ... TestLogicalPartition().test_get_max_pmem_volumes Show source in test_logical_partition.py:225 Signature def test_get_max_pmem_volumes(self): ... TestLogicalPartition().test_get_name Show source in test_logical_partition.py:162 Signature def test_get_name(self): ... TestLogicalPartition().test_get_operating_system Show source in test_logical_partition.py:213 Signature def test_get_operating_system(self): ... TestLogicalPartition().test_get_pending_secure_boot Show source in test_logical_partition.py:217 Signature def test_get_pending_secure_boot(self): ... TestLogicalPartition().test_get_proc_compat_modes Show source in test_logical_partition.py:258 Signature def test_get_proc_compat_modes(self): ... TestLogicalPartition().test_get_proc_mode Show source in test_logical_partition.py:454 Signature def test_get_proc_mode(self): ... TestLogicalPartition().test_get_ref_code Show source in test_logical_partition.py:168 Signature def test_get_ref_code(self): ... TestLogicalPartition().test_get_ref_code_full Show source in test_logical_partition.py:171 Signature def test_get_ref_code_full(self): ... TestLogicalPartition().test_get_shared_proc_pool_id Show source in test_logical_partition.py:513 Signature def test_get_shared_proc_pool_id(self): ... TestLogicalPartition().test_get_state Show source in test_logical_partition.py:157 Signature def test_get_state(self): ... TestLogicalPartition().test_get_type Show source in test_logical_partition.py:262 Signature def test_get_type(self): ... TestLogicalPartition().test_get_val_str Show source in test_logical_partition.py:143 Signature def test_get_val_str(self): ... TestLogicalPartition().test_is_mgmt_partition Show source in test_logical_partition.py:269 Signature def test_is_mgmt_partition(self): ... TestLogicalPartition().test_is_svc_partition Show source in test_logical_partition.py:272 Signature def test_is_svc_partition(self): ... TestLogicalPartition().test_keylock_pos Show source in test_logical_partition.py:277 Signature def test_keylock_pos(self): ... TestLogicalPartition().test_max Show source in test_logical_partition.py:534 Signature def test_max(self): ... TestLogicalPartition().test_max_units Show source in test_logical_partition.py:478 Signature def test_max_units(self): ... TestLogicalPartition().test_max_virtual Show source in test_logical_partition.py:499 Signature def test_max_virtual(self): ... TestLogicalPartition().test_min Show source in test_logical_partition.py:541 Signature def test_min(self): ... TestLogicalPartition().test_min_units Show source in test_logical_partition.py:485 Signature def test_min_units(self): ... TestLogicalPartition().test_min_virtual Show source in test_logical_partition.py:506 Signature def test_min_virtual(self): ... TestLogicalPartition().test_nvram Show source in test_logical_partition.py:548 Signature def test_nvram(self): ... TestLogicalPartition().test_profile_sync Show source in test_logical_partition.py:202 Signature def test_profile_sync(self): ... TestLogicalPartition().test_rmc_state Show source in test_logical_partition.py:191 Signature def test_rmc_state(self): ... TestLogicalPartition().test_rr_off Show source in test_logical_partition.py:241 Remote Restart fields when not RR capable. Signature @mock.patch(\"warnings.warn\") def test_rr_off(self, mock_warn): ... TestLogicalPartition().test_srr Show source in test_logical_partition.py:253 Signature def test_srr(self): ... TestLogicalPartition().test_subwrapper_getters Show source in test_logical_partition.py:301 Signature def test_subwrapper_getters(self): ... TestLogicalPartition().test_uncapped_weight Show source in test_logical_partition.py:518 Signature def test_uncapped_weight(self): ... TestLogicalPartition().test_uptime Show source in test_logical_partition.py:559 Signature def test_uptime(self): ... TestLogicalPartition().test_uuid Show source in test_logical_partition.py:177 Signature def test_uuid(self): ... TestLogicalPartition().verify_equal Show source in test_logical_partition.py:99 Signature def verify_equal(self, method_name, returned_value, expected_value): ... TestMemCfg Show source in test_logical_partition.py:653 Test cases to test the lpar mem operations. Signature class TestMemCfg(twrap.TestWrapper): ... TestMemCfg().setUp Show source in test_logical_partition.py:659 Signature def setUp(self): ... TestMemCfg().test_current_mem Show source in test_logical_partition.py:673 Signature def test_current_mem(self): ... TestMemCfg().test_mem Show source in test_logical_partition.py:663 Signature def test_mem(self): ... TestPartitionIOConfiguration Show source in test_logical_partition.py:634 Signature class TestPartitionIOConfiguration(twrap.TestWrapper): ... TestPartitionIOConfiguration().setUp Show source in test_logical_partition.py:639 Signature def setUp(self): ... TestPartitionIOConfiguration().test_io_slots Show source in test_logical_partition.py:646 Signature def test_io_slots(self): ... TestPartitionIOConfiguration().test_max_slots Show source in test_logical_partition.py:643 Signature def test_max_slots(self): ... TestPhysFCPort Show source in test_logical_partition.py:707 Signature class TestPhysFCPort(unittest.TestCase): ... TestPhysFCPort().test_bld Show source in test_logical_partition.py:709 Signature def test_bld(self): ...","title":"TestLogicalPartition"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartition","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / TestLogicalPartition Auto-generated documentation for pypowervm.tests.wrappers.test_logical_partition module. TestLogicalPartition TestIBMiSpecific TestIBMiSpecific().test_desig_ipl_src TestIBMiSpecific().test_restricted_io TestIBMiSpecific().test_rr_real_values TestIBMiSpecific().test_tagged_io TestIOCfg TestIOCfg().setUp TestIOCfg().test_bld TestIOCfg().test_data TestLogicalPartition TestLogicalPartition().call_simple_getter TestLogicalPartition().setUp TestLogicalPartition().test_allow_perf_data_collection TestLogicalPartition().test_associated_managed_system_uuid TestLogicalPartition().test_avail_priority TestLogicalPartition().test_bootmode TestLogicalPartition().test_can_lpm TestLogicalPartition().test_can_lpm_ibmi TestLogicalPartition().test_can_modifies TestLogicalPartition().test_can_modify TestLogicalPartition().test_capabilities TestLogicalPartition().test_desired TestLogicalPartition().test_desired_units TestLogicalPartition().test_desired_virtual TestLogicalPartition().test_disable_secure_boot TestLogicalPartition().test_get_cur_dram_pmem_volumes TestLogicalPartition().test_get_cur_pmem_volumes TestLogicalPartition().test_get_current_secure_boot TestLogicalPartition().test_get_current_sharing_mode TestLogicalPartition().test_get_id TestLogicalPartition().test_get_max_dram_pmem_volumes TestLogicalPartition().test_get_max_pmem_volumes TestLogicalPartition().test_get_name TestLogicalPartition().test_get_operating_system TestLogicalPartition().test_get_pending_secure_boot TestLogicalPartition().test_get_proc_compat_modes TestLogicalPartition().test_get_proc_mode TestLogicalPartition().test_get_ref_code TestLogicalPartition().test_get_ref_code_full TestLogicalPartition().test_get_shared_proc_pool_id TestLogicalPartition().test_get_state TestLogicalPartition().test_get_type TestLogicalPartition().test_get_val_str TestLogicalPartition().test_is_mgmt_partition TestLogicalPartition().test_is_svc_partition TestLogicalPartition().test_keylock_pos TestLogicalPartition().test_max TestLogicalPartition().test_max_units TestLogicalPartition().test_max_virtual TestLogicalPartition().test_min TestLogicalPartition().test_min_units TestLogicalPartition().test_min_virtual TestLogicalPartition().test_nvram TestLogicalPartition().test_profile_sync TestLogicalPartition().test_rmc_state TestLogicalPartition().test_rr_off TestLogicalPartition().test_srr TestLogicalPartition().test_subwrapper_getters TestLogicalPartition().test_uncapped_weight TestLogicalPartition().test_uptime TestLogicalPartition().test_uuid TestLogicalPartition().verify_equal TestMemCfg TestMemCfg().setUp TestMemCfg().test_current_mem TestMemCfg().test_mem TestPartitionIOConfiguration TestPartitionIOConfiguration().setUp TestPartitionIOConfiguration().test_io_slots TestPartitionIOConfiguration().test_max_slots TestPhysFCPort TestPhysFCPort().test_bld","title":"TestLogicalPartition"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testibmispecific","text":"Show source in test_logical_partition.py:563 IBMi-specific tests, requiring a test file from an IBMi partition.","title":"TestIBMiSpecific"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature","text":"class TestIBMiSpecific(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testibmispecifictest_desig_ipl_src","text":"Show source in test_logical_partition.py:572","title":"TestIBMiSpecific().test_desig_ipl_src"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_1","text":"def test_desig_ipl_src(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testibmispecifictest_restricted_io","text":"Show source in test_logical_partition.py:568","title":"TestIBMiSpecific().test_restricted_io"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_2","text":"def test_restricted_io(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testibmispecifictest_rr_real_values","text":"Show source in test_logical_partition.py:622 Test Remote Restart fields when RR capable.","title":"TestIBMiSpecific().test_rr_real_values"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_3","text":"@mock.patch(\"warnings.warn\") def test_rr_real_values(self, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testibmispecifictest_tagged_io","text":"Show source in test_logical_partition.py:583","title":"TestIBMiSpecific().test_tagged_io"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_4","text":"def test_tagged_io(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testiocfg","text":"Show source in test_logical_partition.py:677 Test the lpar I/O configuration.","title":"TestIOCfg"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_5","text":"class TestIOCfg(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testiocfgsetup","text":"Show source in test_logical_partition.py:683","title":"TestIOCfg().setUp"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_6","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testiocfgtest_bld","text":"Show source in test_logical_partition.py:687","title":"TestIOCfg().test_bld"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_7","text":"def test_bld(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testiocfgtest_data","text":"Show source in test_logical_partition.py:702","title":"TestIOCfg().test_data"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_8","text":"def test_data(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartition_1","text":"Show source in test_logical_partition.py:40","title":"TestLogicalPartition"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_9","text":"class TestLogicalPartition(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitioncall_simple_getter","text":"Show source in test_logical_partition.py:124","title":"TestLogicalPartition().call_simple_getter"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_10","text":"def call_simple_getter( self, method_name, expected_value, expected_bad_value, use_dedicated=False ): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitionsetup","text":"Show source in test_logical_partition.py:49","title":"TestLogicalPartition().setUp"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_11","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_allow_perf_data_collection","text":"Show source in test_logical_partition.py:296","title":"TestLogicalPartition().test_allow_perf_data_collection"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_12","text":"def test_allow_perf_data_collection(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_associated_managed_system_uuid","text":"Show source in test_logical_partition.py:265","title":"TestLogicalPartition().test_associated_managed_system_uuid"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_13","text":"def test_associated_managed_system_uuid(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_avail_priority","text":"Show source in test_logical_partition.py:197","title":"TestLogicalPartition().test_avail_priority"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_14","text":"def test_avail_priority(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_bootmode","text":"Show source in test_logical_partition.py:284","title":"TestLogicalPartition().test_bootmode"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_15","text":"def test_bootmode(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_can_lpm","text":"Show source in test_logical_partition.py:360 Tests for the can_lpm method.","title":"TestLogicalPartition().test_can_lpm"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_16","text":"def test_can_lpm(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_can_lpm_ibmi","text":"Show source in test_logical_partition.py:396 Tests for the can_lpm method for IBM i branches.","title":"TestLogicalPartition().test_can_lpm_ibmi"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_17","text":"def test_can_lpm_ibmi(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_can_modifies","text":"Show source in test_logical_partition.py:313 Simple check on the 'can_modify_xxx' methods.","title":"TestLogicalPartition().test_can_modifies"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_18","text":"def test_can_modifies(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_can_modify","text":"Show source in test_logical_partition.py:322 Detailed testing on the _can_modify method.","title":"TestLogicalPartition().test_can_modify"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_19","text":"def test_can_modify(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_capabilities","text":"Show source in test_logical_partition.py:448","title":"TestLogicalPartition().test_capabilities"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_20","text":"def test_capabilities(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_desired","text":"Show source in test_logical_partition.py:527","title":"TestLogicalPartition().test_desired"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_21","text":"def test_desired(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_desired_units","text":"Show source in test_logical_partition.py:471","title":"TestLogicalPartition().test_desired_units"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_22","text":"def test_desired_units(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_desired_virtual","text":"Show source in test_logical_partition.py:492","title":"TestLogicalPartition().test_desired_virtual"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_23","text":"def test_desired_virtual(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_disable_secure_boot","text":"Show source in test_logical_partition.py:291","title":"TestLogicalPartition().test_disable_secure_boot"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_24","text":"def test_disable_secure_boot(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_cur_dram_pmem_volumes","text":"Show source in test_logical_partition.py:237","title":"TestLogicalPartition().test_get_cur_dram_pmem_volumes"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_25","text":"def test_get_cur_dram_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_cur_pmem_volumes","text":"Show source in test_logical_partition.py:229","title":"TestLogicalPartition().test_get_cur_pmem_volumes"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_26","text":"def test_get_cur_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_current_secure_boot","text":"Show source in test_logical_partition.py:221","title":"TestLogicalPartition().test_get_current_secure_boot"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_27","text":"def test_get_current_secure_boot(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_current_sharing_mode","text":"Show source in test_logical_partition.py:464","title":"TestLogicalPartition().test_get_current_sharing_mode"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_28","text":"def test_get_current_sharing_mode(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_id","text":"Show source in test_logical_partition.py:165","title":"TestLogicalPartition().test_get_id"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_29","text":"def test_get_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_max_dram_pmem_volumes","text":"Show source in test_logical_partition.py:233","title":"TestLogicalPartition().test_get_max_dram_pmem_volumes"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_30","text":"def test_get_max_dram_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_max_pmem_volumes","text":"Show source in test_logical_partition.py:225","title":"TestLogicalPartition().test_get_max_pmem_volumes"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_31","text":"def test_get_max_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_name","text":"Show source in test_logical_partition.py:162","title":"TestLogicalPartition().test_get_name"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_32","text":"def test_get_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_operating_system","text":"Show source in test_logical_partition.py:213","title":"TestLogicalPartition().test_get_operating_system"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_33","text":"def test_get_operating_system(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_pending_secure_boot","text":"Show source in test_logical_partition.py:217","title":"TestLogicalPartition().test_get_pending_secure_boot"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_34","text":"def test_get_pending_secure_boot(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_proc_compat_modes","text":"Show source in test_logical_partition.py:258","title":"TestLogicalPartition().test_get_proc_compat_modes"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_35","text":"def test_get_proc_compat_modes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_proc_mode","text":"Show source in test_logical_partition.py:454","title":"TestLogicalPartition().test_get_proc_mode"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_36","text":"def test_get_proc_mode(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_ref_code","text":"Show source in test_logical_partition.py:168","title":"TestLogicalPartition().test_get_ref_code"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_37","text":"def test_get_ref_code(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_ref_code_full","text":"Show source in test_logical_partition.py:171","title":"TestLogicalPartition().test_get_ref_code_full"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_38","text":"def test_get_ref_code_full(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_shared_proc_pool_id","text":"Show source in test_logical_partition.py:513","title":"TestLogicalPartition().test_get_shared_proc_pool_id"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_39","text":"def test_get_shared_proc_pool_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_state","text":"Show source in test_logical_partition.py:157","title":"TestLogicalPartition().test_get_state"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_40","text":"def test_get_state(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_type","text":"Show source in test_logical_partition.py:262","title":"TestLogicalPartition().test_get_type"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_41","text":"def test_get_type(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_get_val_str","text":"Show source in test_logical_partition.py:143","title":"TestLogicalPartition().test_get_val_str"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_42","text":"def test_get_val_str(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_is_mgmt_partition","text":"Show source in test_logical_partition.py:269","title":"TestLogicalPartition().test_is_mgmt_partition"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_43","text":"def test_is_mgmt_partition(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_is_svc_partition","text":"Show source in test_logical_partition.py:272","title":"TestLogicalPartition().test_is_svc_partition"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_44","text":"def test_is_svc_partition(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_keylock_pos","text":"Show source in test_logical_partition.py:277","title":"TestLogicalPartition().test_keylock_pos"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_45","text":"def test_keylock_pos(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_max","text":"Show source in test_logical_partition.py:534","title":"TestLogicalPartition().test_max"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_46","text":"def test_max(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_max_units","text":"Show source in test_logical_partition.py:478","title":"TestLogicalPartition().test_max_units"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_47","text":"def test_max_units(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_max_virtual","text":"Show source in test_logical_partition.py:499","title":"TestLogicalPartition().test_max_virtual"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_48","text":"def test_max_virtual(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_min","text":"Show source in test_logical_partition.py:541","title":"TestLogicalPartition().test_min"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_49","text":"def test_min(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_min_units","text":"Show source in test_logical_partition.py:485","title":"TestLogicalPartition().test_min_units"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_50","text":"def test_min_units(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_min_virtual","text":"Show source in test_logical_partition.py:506","title":"TestLogicalPartition().test_min_virtual"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_51","text":"def test_min_virtual(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_nvram","text":"Show source in test_logical_partition.py:548","title":"TestLogicalPartition().test_nvram"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_52","text":"def test_nvram(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_profile_sync","text":"Show source in test_logical_partition.py:202","title":"TestLogicalPartition().test_profile_sync"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_53","text":"def test_profile_sync(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_rmc_state","text":"Show source in test_logical_partition.py:191","title":"TestLogicalPartition().test_rmc_state"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_54","text":"def test_rmc_state(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_rr_off","text":"Show source in test_logical_partition.py:241 Remote Restart fields when not RR capable.","title":"TestLogicalPartition().test_rr_off"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_55","text":"@mock.patch(\"warnings.warn\") def test_rr_off(self, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_srr","text":"Show source in test_logical_partition.py:253","title":"TestLogicalPartition().test_srr"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_56","text":"def test_srr(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_subwrapper_getters","text":"Show source in test_logical_partition.py:301","title":"TestLogicalPartition().test_subwrapper_getters"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_57","text":"def test_subwrapper_getters(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_uncapped_weight","text":"Show source in test_logical_partition.py:518","title":"TestLogicalPartition().test_uncapped_weight"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_58","text":"def test_uncapped_weight(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_uptime","text":"Show source in test_logical_partition.py:559","title":"TestLogicalPartition().test_uptime"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_59","text":"def test_uptime(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitiontest_uuid","text":"Show source in test_logical_partition.py:177","title":"TestLogicalPartition().test_uuid"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_60","text":"def test_uuid(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testlogicalpartitionverify_equal","text":"Show source in test_logical_partition.py:99","title":"TestLogicalPartition().verify_equal"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_61","text":"def verify_equal(self, method_name, returned_value, expected_value): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testmemcfg","text":"Show source in test_logical_partition.py:653 Test cases to test the lpar mem operations.","title":"TestMemCfg"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_62","text":"class TestMemCfg(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testmemcfgsetup","text":"Show source in test_logical_partition.py:659","title":"TestMemCfg().setUp"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_63","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testmemcfgtest_current_mem","text":"Show source in test_logical_partition.py:673","title":"TestMemCfg().test_current_mem"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_64","text":"def test_current_mem(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testmemcfgtest_mem","text":"Show source in test_logical_partition.py:663","title":"TestMemCfg().test_mem"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_65","text":"def test_mem(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testpartitionioconfiguration","text":"Show source in test_logical_partition.py:634","title":"TestPartitionIOConfiguration"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_66","text":"class TestPartitionIOConfiguration(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testpartitionioconfigurationsetup","text":"Show source in test_logical_partition.py:639","title":"TestPartitionIOConfiguration().setUp"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_67","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testpartitionioconfigurationtest_io_slots","text":"Show source in test_logical_partition.py:646","title":"TestPartitionIOConfiguration().test_io_slots"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_68","text":"def test_io_slots(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testpartitionioconfigurationtest_max_slots","text":"Show source in test_logical_partition.py:643","title":"TestPartitionIOConfiguration().test_max_slots"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_69","text":"def test_max_slots(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testphysfcport","text":"Show source in test_logical_partition.py:707","title":"TestPhysFCPort"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_70","text":"class TestPhysFCPort(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#testphysfcporttest_bld","text":"Show source in test_logical_partition.py:709","title":"TestPhysFCPort().test_bld"},{"location":"pypowervm/tests/wrappers/test_logical_partition/#signature_71","text":"def test_bld(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/","text":"Test Managed System Pypowervm Index / Pypowervm / Tests / Wrappers / Test Managed System Auto-generated documentation for pypowervm.tests.wrappers.test_managed_system module. Test Managed System TestMSEntryWrapper TestMSEntryWrapper().call_simple_getter TestMSEntryWrapper().setUp TestMSEntryWrapper().test_asio_wwpn_prefix TestMSEntryWrapper().test_asio_wwpns TestMSEntryWrapper().test_default_ppt_ratio TestMSEntryWrapper().test_get_capabilities TestMSEntryWrapper().test_get_firmware_memory TestMSEntryWrapper().test_get_host_ip_address TestMSEntryWrapper().test_get_memory_free TestMSEntryWrapper().test_get_memory_total TestMSEntryWrapper().test_get_metered_pool_id TestMSEntryWrapper().test_get_min_proc_units TestMSEntryWrapper().test_get_model TestMSEntryWrapper().test_get_mtms_str TestMSEntryWrapper().test_get_proc_units TestMSEntryWrapper().test_get_proc_units_avail TestMSEntryWrapper().test_get_proc_units_configurable TestMSEntryWrapper().test_get_serial TestMSEntryWrapper().test_get_system_name TestMSEntryWrapper().test_get_type TestMSEntryWrapper().test_get_val_str TestMSEntryWrapper().test_highest_compat_mode TestMSEntryWrapper().test_ioslot_assignment TestMSEntryWrapper().test_ioslot_bus_grp_required TestMSEntryWrapper().test_ioslot_description TestMSEntryWrapper().test_ioslot_drc_index TestMSEntryWrapper().test_ioslot_drc_name TestMSEntryWrapper().test_ioslot_feat_codes TestMSEntryWrapper().test_ioslot_pci_class TestMSEntryWrapper().test_ioslot_pci_dev_id TestMSEntryWrapper().test_ioslot_pci_rev_id TestMSEntryWrapper().test_ioslot_pci_subsys_dev_id TestMSEntryWrapper().test_ioslot_pci_subsys_vendor_id TestMSEntryWrapper().test_ioslot_pci_vendor_id TestMSEntryWrapper().test_max_procs_per_aix_linux_lpar TestMSEntryWrapper().test_max_vcpus_per_aix_linux_lpar TestMSEntryWrapper().test_migration_data TestMSEntryWrapper().test_page_table_ratio TestMSEntryWrapper().test_proc_compat_modes TestMSEntryWrapper().test_processor_is_throttled TestMSEntryWrapper().test_session_is_master TestMSEntryWrapper().test_supported_ibmi_console_codepage TestMSEntryWrapper().test_vios_links TestMSEntryWrapper().verify_equal TestMTMS TestMTMS().test_mtms TestMSEntryWrapper Show source in test_managed_system.py:29 Signature class TestMSEntryWrapper(unittest.TestCase): ... TestMSEntryWrapper().call_simple_getter Show source in test_managed_system.py:71 Signature def call_simple_getter(self, method_name, expected_value, expected_bad_value): ... TestMSEntryWrapper().setUp Show source in test_managed_system.py:31 Signature def setUp(self): ... TestMSEntryWrapper().test_asio_wwpn_prefix Show source in test_managed_system.py:196 Signature def test_asio_wwpn_prefix(self): ... TestMSEntryWrapper().test_asio_wwpns Show source in test_managed_system.py:193 Signature def test_asio_wwpns(self): ... TestMSEntryWrapper().test_default_ppt_ratio Show source in test_managed_system.py:146 Signature def test_default_ppt_ratio(self): ... TestMSEntryWrapper().test_get_capabilities Show source in test_managed_system.py:260 Signature def test_get_capabilities(self): ... TestMSEntryWrapper().test_get_firmware_memory Show source in test_managed_system.py:140 Signature def test_get_firmware_memory(self): ... TestMSEntryWrapper().test_get_host_ip_address Show source in test_managed_system.py:137 Signature def test_get_host_ip_address(self): ... TestMSEntryWrapper().test_get_memory_free Show source in test_managed_system.py:134 Signature def test_get_memory_free(self): ... TestMSEntryWrapper().test_get_memory_total Show source in test_managed_system.py:131 Signature def test_get_memory_total(self): ... TestMSEntryWrapper().test_get_metered_pool_id Show source in test_managed_system.py:348 Signature def test_get_metered_pool_id(self): ... TestMSEntryWrapper().test_get_min_proc_units Show source in test_managed_system.py:122 Signature def test_get_min_proc_units(self): ... TestMSEntryWrapper().test_get_model Show source in test_managed_system.py:99 Signature def test_get_model(self): ... TestMSEntryWrapper().test_get_mtms_str Show source in test_managed_system.py:108 Signature def test_get_mtms_str(self): ... TestMSEntryWrapper().test_get_proc_units Show source in test_managed_system.py:119 Signature def test_get_proc_units(self): ... TestMSEntryWrapper().test_get_proc_units_avail Show source in test_managed_system.py:128 Signature def test_get_proc_units_avail(self): ... TestMSEntryWrapper().test_get_proc_units_configurable Show source in test_managed_system.py:125 Signature def test_get_proc_units_configurable(self): ... TestMSEntryWrapper().test_get_serial Show source in test_managed_system.py:105 Signature def test_get_serial(self): ... TestMSEntryWrapper().test_get_system_name Show source in test_managed_system.py:158 Signature def test_get_system_name(self): ... TestMSEntryWrapper().test_get_type Show source in test_managed_system.py:102 Signature def test_get_type(self): ... TestMSEntryWrapper().test_get_val_str Show source in test_managed_system.py:87 Signature def test_get_val_str(self): ... TestMSEntryWrapper().test_highest_compat_mode Show source in test_managed_system.py:111 Signature def test_highest_compat_mode(self): ... TestMSEntryWrapper().test_ioslot_assignment Show source in test_managed_system.py:214 Signature def test_ioslot_assignment(self): ... TestMSEntryWrapper().test_ioslot_bus_grp_required Show source in test_managed_system.py:200 Signature def test_ioslot_bus_grp_required(self): ... TestMSEntryWrapper().test_ioslot_description Show source in test_managed_system.py:204 Signature def test_ioslot_description(self): ... TestMSEntryWrapper().test_ioslot_drc_index Show source in test_managed_system.py:250 Signature def test_ioslot_drc_index(self): ... TestMSEntryWrapper().test_ioslot_drc_name Show source in test_managed_system.py:254 Signature def test_ioslot_drc_name(self): ... TestMSEntryWrapper().test_ioslot_feat_codes Show source in test_managed_system.py:210 Signature def test_ioslot_feat_codes(self): ... TestMSEntryWrapper().test_ioslot_pci_class Show source in test_managed_system.py:225 Signature def test_ioslot_pci_class(self): ... TestMSEntryWrapper().test_ioslot_pci_dev_id Show source in test_managed_system.py:229 Signature def test_ioslot_pci_dev_id(self): ... TestMSEntryWrapper().test_ioslot_pci_rev_id Show source in test_managed_system.py:237 Signature def test_ioslot_pci_rev_id(self): ... TestMSEntryWrapper().test_ioslot_pci_subsys_dev_id Show source in test_managed_system.py:233 Signature def test_ioslot_pci_subsys_dev_id(self): ... TestMSEntryWrapper().test_ioslot_pci_subsys_vendor_id Show source in test_managed_system.py:245 Signature def test_ioslot_pci_subsys_vendor_id(self): ... TestMSEntryWrapper().test_ioslot_pci_vendor_id Show source in test_managed_system.py:241 Signature def test_ioslot_pci_vendor_id(self): ... TestMSEntryWrapper().test_max_procs_per_aix_linux_lpar Show source in test_managed_system.py:166 Signature def test_max_procs_per_aix_linux_lpar(self): ... TestMSEntryWrapper().test_max_vcpus_per_aix_linux_lpar Show source in test_managed_system.py:176 Signature def test_max_vcpus_per_aix_linux_lpar(self): ... TestMSEntryWrapper().test_migration_data Show source in test_managed_system.py:311 Signature def test_migration_data(self): ... TestMSEntryWrapper().test_page_table_ratio Show source in test_managed_system.py:143 Signature def test_page_table_ratio(self): ... TestMSEntryWrapper().test_proc_compat_modes Show source in test_managed_system.py:114 Signature def test_proc_compat_modes(self): ... TestMSEntryWrapper().test_processor_is_throttled Show source in test_managed_system.py:351 Signature def test_processor_is_throttled(self): ... TestMSEntryWrapper().test_session_is_master Show source in test_managed_system.py:308 Signature def test_session_is_master(self): ... TestMSEntryWrapper().test_supported_ibmi_console_codepage Show source in test_managed_system.py:149 Signature def test_supported_ibmi_console_codepage(self): ... TestMSEntryWrapper().test_vios_links Show source in test_managed_system.py:186 Signature def test_vios_links(self): ... TestMSEntryWrapper().verify_equal Show source in test_managed_system.py:66 Signature def verify_equal(self, method_name, returned_value, expected_value): ... TestMTMS Show source in test_managed_system.py:355 Signature class TestMTMS(unittest.TestCase): ... TestMTMS().test_mtms Show source in test_managed_system.py:356 Signature def test_mtms(self): ...","title":"Test Managed System"},{"location":"pypowervm/tests/wrappers/test_managed_system/#test-managed-system","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Managed System Auto-generated documentation for pypowervm.tests.wrappers.test_managed_system module. Test Managed System TestMSEntryWrapper TestMSEntryWrapper().call_simple_getter TestMSEntryWrapper().setUp TestMSEntryWrapper().test_asio_wwpn_prefix TestMSEntryWrapper().test_asio_wwpns TestMSEntryWrapper().test_default_ppt_ratio TestMSEntryWrapper().test_get_capabilities TestMSEntryWrapper().test_get_firmware_memory TestMSEntryWrapper().test_get_host_ip_address TestMSEntryWrapper().test_get_memory_free TestMSEntryWrapper().test_get_memory_total TestMSEntryWrapper().test_get_metered_pool_id TestMSEntryWrapper().test_get_min_proc_units TestMSEntryWrapper().test_get_model TestMSEntryWrapper().test_get_mtms_str TestMSEntryWrapper().test_get_proc_units TestMSEntryWrapper().test_get_proc_units_avail TestMSEntryWrapper().test_get_proc_units_configurable TestMSEntryWrapper().test_get_serial TestMSEntryWrapper().test_get_system_name TestMSEntryWrapper().test_get_type TestMSEntryWrapper().test_get_val_str TestMSEntryWrapper().test_highest_compat_mode TestMSEntryWrapper().test_ioslot_assignment TestMSEntryWrapper().test_ioslot_bus_grp_required TestMSEntryWrapper().test_ioslot_description TestMSEntryWrapper().test_ioslot_drc_index TestMSEntryWrapper().test_ioslot_drc_name TestMSEntryWrapper().test_ioslot_feat_codes TestMSEntryWrapper().test_ioslot_pci_class TestMSEntryWrapper().test_ioslot_pci_dev_id TestMSEntryWrapper().test_ioslot_pci_rev_id TestMSEntryWrapper().test_ioslot_pci_subsys_dev_id TestMSEntryWrapper().test_ioslot_pci_subsys_vendor_id TestMSEntryWrapper().test_ioslot_pci_vendor_id TestMSEntryWrapper().test_max_procs_per_aix_linux_lpar TestMSEntryWrapper().test_max_vcpus_per_aix_linux_lpar TestMSEntryWrapper().test_migration_data TestMSEntryWrapper().test_page_table_ratio TestMSEntryWrapper().test_proc_compat_modes TestMSEntryWrapper().test_processor_is_throttled TestMSEntryWrapper().test_session_is_master TestMSEntryWrapper().test_supported_ibmi_console_codepage TestMSEntryWrapper().test_vios_links TestMSEntryWrapper().verify_equal TestMTMS TestMTMS().test_mtms","title":"Test Managed System"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrapper","text":"Show source in test_managed_system.py:29","title":"TestMSEntryWrapper"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature","text":"class TestMSEntryWrapper(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappercall_simple_getter","text":"Show source in test_managed_system.py:71","title":"TestMSEntryWrapper().call_simple_getter"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_1","text":"def call_simple_getter(self, method_name, expected_value, expected_bad_value): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappersetup","text":"Show source in test_managed_system.py:31","title":"TestMSEntryWrapper().setUp"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_2","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_asio_wwpn_prefix","text":"Show source in test_managed_system.py:196","title":"TestMSEntryWrapper().test_asio_wwpn_prefix"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_3","text":"def test_asio_wwpn_prefix(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_asio_wwpns","text":"Show source in test_managed_system.py:193","title":"TestMSEntryWrapper().test_asio_wwpns"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_4","text":"def test_asio_wwpns(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_default_ppt_ratio","text":"Show source in test_managed_system.py:146","title":"TestMSEntryWrapper().test_default_ppt_ratio"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_5","text":"def test_default_ppt_ratio(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_capabilities","text":"Show source in test_managed_system.py:260","title":"TestMSEntryWrapper().test_get_capabilities"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_6","text":"def test_get_capabilities(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_firmware_memory","text":"Show source in test_managed_system.py:140","title":"TestMSEntryWrapper().test_get_firmware_memory"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_7","text":"def test_get_firmware_memory(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_host_ip_address","text":"Show source in test_managed_system.py:137","title":"TestMSEntryWrapper().test_get_host_ip_address"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_8","text":"def test_get_host_ip_address(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_memory_free","text":"Show source in test_managed_system.py:134","title":"TestMSEntryWrapper().test_get_memory_free"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_9","text":"def test_get_memory_free(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_memory_total","text":"Show source in test_managed_system.py:131","title":"TestMSEntryWrapper().test_get_memory_total"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_10","text":"def test_get_memory_total(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_metered_pool_id","text":"Show source in test_managed_system.py:348","title":"TestMSEntryWrapper().test_get_metered_pool_id"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_11","text":"def test_get_metered_pool_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_min_proc_units","text":"Show source in test_managed_system.py:122","title":"TestMSEntryWrapper().test_get_min_proc_units"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_12","text":"def test_get_min_proc_units(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_model","text":"Show source in test_managed_system.py:99","title":"TestMSEntryWrapper().test_get_model"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_13","text":"def test_get_model(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_mtms_str","text":"Show source in test_managed_system.py:108","title":"TestMSEntryWrapper().test_get_mtms_str"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_14","text":"def test_get_mtms_str(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_proc_units","text":"Show source in test_managed_system.py:119","title":"TestMSEntryWrapper().test_get_proc_units"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_15","text":"def test_get_proc_units(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_proc_units_avail","text":"Show source in test_managed_system.py:128","title":"TestMSEntryWrapper().test_get_proc_units_avail"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_16","text":"def test_get_proc_units_avail(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_proc_units_configurable","text":"Show source in test_managed_system.py:125","title":"TestMSEntryWrapper().test_get_proc_units_configurable"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_17","text":"def test_get_proc_units_configurable(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_serial","text":"Show source in test_managed_system.py:105","title":"TestMSEntryWrapper().test_get_serial"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_18","text":"def test_get_serial(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_system_name","text":"Show source in test_managed_system.py:158","title":"TestMSEntryWrapper().test_get_system_name"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_19","text":"def test_get_system_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_type","text":"Show source in test_managed_system.py:102","title":"TestMSEntryWrapper().test_get_type"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_20","text":"def test_get_type(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_get_val_str","text":"Show source in test_managed_system.py:87","title":"TestMSEntryWrapper().test_get_val_str"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_21","text":"def test_get_val_str(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_highest_compat_mode","text":"Show source in test_managed_system.py:111","title":"TestMSEntryWrapper().test_highest_compat_mode"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_22","text":"def test_highest_compat_mode(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_assignment","text":"Show source in test_managed_system.py:214","title":"TestMSEntryWrapper().test_ioslot_assignment"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_23","text":"def test_ioslot_assignment(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_bus_grp_required","text":"Show source in test_managed_system.py:200","title":"TestMSEntryWrapper().test_ioslot_bus_grp_required"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_24","text":"def test_ioslot_bus_grp_required(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_description","text":"Show source in test_managed_system.py:204","title":"TestMSEntryWrapper().test_ioslot_description"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_25","text":"def test_ioslot_description(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_drc_index","text":"Show source in test_managed_system.py:250","title":"TestMSEntryWrapper().test_ioslot_drc_index"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_26","text":"def test_ioslot_drc_index(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_drc_name","text":"Show source in test_managed_system.py:254","title":"TestMSEntryWrapper().test_ioslot_drc_name"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_27","text":"def test_ioslot_drc_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_feat_codes","text":"Show source in test_managed_system.py:210","title":"TestMSEntryWrapper().test_ioslot_feat_codes"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_28","text":"def test_ioslot_feat_codes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_pci_class","text":"Show source in test_managed_system.py:225","title":"TestMSEntryWrapper().test_ioslot_pci_class"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_29","text":"def test_ioslot_pci_class(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_pci_dev_id","text":"Show source in test_managed_system.py:229","title":"TestMSEntryWrapper().test_ioslot_pci_dev_id"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_30","text":"def test_ioslot_pci_dev_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_pci_rev_id","text":"Show source in test_managed_system.py:237","title":"TestMSEntryWrapper().test_ioslot_pci_rev_id"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_31","text":"def test_ioslot_pci_rev_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_pci_subsys_dev_id","text":"Show source in test_managed_system.py:233","title":"TestMSEntryWrapper().test_ioslot_pci_subsys_dev_id"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_32","text":"def test_ioslot_pci_subsys_dev_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_pci_subsys_vendor_id","text":"Show source in test_managed_system.py:245","title":"TestMSEntryWrapper().test_ioslot_pci_subsys_vendor_id"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_33","text":"def test_ioslot_pci_subsys_vendor_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_ioslot_pci_vendor_id","text":"Show source in test_managed_system.py:241","title":"TestMSEntryWrapper().test_ioslot_pci_vendor_id"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_34","text":"def test_ioslot_pci_vendor_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_max_procs_per_aix_linux_lpar","text":"Show source in test_managed_system.py:166","title":"TestMSEntryWrapper().test_max_procs_per_aix_linux_lpar"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_35","text":"def test_max_procs_per_aix_linux_lpar(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_max_vcpus_per_aix_linux_lpar","text":"Show source in test_managed_system.py:176","title":"TestMSEntryWrapper().test_max_vcpus_per_aix_linux_lpar"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_36","text":"def test_max_vcpus_per_aix_linux_lpar(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_migration_data","text":"Show source in test_managed_system.py:311","title":"TestMSEntryWrapper().test_migration_data"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_37","text":"def test_migration_data(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_page_table_ratio","text":"Show source in test_managed_system.py:143","title":"TestMSEntryWrapper().test_page_table_ratio"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_38","text":"def test_page_table_ratio(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_proc_compat_modes","text":"Show source in test_managed_system.py:114","title":"TestMSEntryWrapper().test_proc_compat_modes"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_39","text":"def test_proc_compat_modes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_processor_is_throttled","text":"Show source in test_managed_system.py:351","title":"TestMSEntryWrapper().test_processor_is_throttled"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_40","text":"def test_processor_is_throttled(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_session_is_master","text":"Show source in test_managed_system.py:308","title":"TestMSEntryWrapper().test_session_is_master"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_41","text":"def test_session_is_master(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_supported_ibmi_console_codepage","text":"Show source in test_managed_system.py:149","title":"TestMSEntryWrapper().test_supported_ibmi_console_codepage"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_42","text":"def test_supported_ibmi_console_codepage(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrappertest_vios_links","text":"Show source in test_managed_system.py:186","title":"TestMSEntryWrapper().test_vios_links"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_43","text":"def test_vios_links(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmsentrywrapperverify_equal","text":"Show source in test_managed_system.py:66","title":"TestMSEntryWrapper().verify_equal"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_44","text":"def verify_equal(self, method_name, returned_value, expected_value): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmtms","text":"Show source in test_managed_system.py:355","title":"TestMTMS"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_45","text":"class TestMTMS(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_managed_system/#testmtmstest_mtms","text":"Show source in test_managed_system.py:356","title":"TestMTMS().test_mtms"},{"location":"pypowervm/tests/wrappers/test_managed_system/#signature_46","text":"def test_mtms(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_mgmt_console/","text":"Test Mgmt Console Pypowervm Index / Pypowervm / Tests / Wrappers / Test Mgmt Console Auto-generated documentation for pypowervm.tests.wrappers.test_mgmt_console module. Test Mgmt Console TestMCEntryWrapper TestMCEntryWrapper().test_mgmt_console TestMCEntryWrapperSSH TestMCEntryWrapperSSH().test_mgmt_console TestMCEntryWrapper Show source in test_mgmt_console.py:43 Signature class TestMCEntryWrapper(twrap.TestWrapper): ... TestMCEntryWrapper().test_mgmt_console Show source in test_mgmt_console.py:47 Signature def test_mgmt_console(self): ... TestMCEntryWrapperSSH Show source in test_mgmt_console.py:64 Signature class TestMCEntryWrapperSSH(twrap.TestWrapper): ... TestMCEntryWrapperSSH().test_mgmt_console Show source in test_mgmt_console.py:68 Signature def test_mgmt_console(self): ...","title":"Test Mgmt Console"},{"location":"pypowervm/tests/wrappers/test_mgmt_console/#test-mgmt-console","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Mgmt Console Auto-generated documentation for pypowervm.tests.wrappers.test_mgmt_console module. Test Mgmt Console TestMCEntryWrapper TestMCEntryWrapper().test_mgmt_console TestMCEntryWrapperSSH TestMCEntryWrapperSSH().test_mgmt_console","title":"Test Mgmt Console"},{"location":"pypowervm/tests/wrappers/test_mgmt_console/#testmcentrywrapper","text":"Show source in test_mgmt_console.py:43","title":"TestMCEntryWrapper"},{"location":"pypowervm/tests/wrappers/test_mgmt_console/#signature","text":"class TestMCEntryWrapper(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_mgmt_console/#testmcentrywrappertest_mgmt_console","text":"Show source in test_mgmt_console.py:47","title":"TestMCEntryWrapper().test_mgmt_console"},{"location":"pypowervm/tests/wrappers/test_mgmt_console/#signature_1","text":"def test_mgmt_console(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_mgmt_console/#testmcentrywrapperssh","text":"Show source in test_mgmt_console.py:64","title":"TestMCEntryWrapperSSH"},{"location":"pypowervm/tests/wrappers/test_mgmt_console/#signature_2","text":"class TestMCEntryWrapperSSH(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_mgmt_console/#testmcentrywrappersshtest_mgmt_console","text":"Show source in test_mgmt_console.py:68","title":"TestMCEntryWrapperSSH().test_mgmt_console"},{"location":"pypowervm/tests/wrappers/test_mgmt_console/#signature_3","text":"def test_mgmt_console(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_monitor/","text":"Test Monitor Pypowervm Index / Pypowervm / Tests / Wrappers / Test Monitor Auto-generated documentation for pypowervm.tests.wrappers.test_monitor module. Test Monitor TestLTMMetrics TestLTMMetrics().test_ltm_metrics TestPCM TestPCM().test_pcm TestPCM().test_str_to_datetime TestSTMMetrics TestSTMMetrics().test_stm_metrics TestLTMMetrics Show source in test_monitor.py:67 Signature class TestLTMMetrics(twrap.TestWrapper): ... TestLTMMetrics().test_ltm_metrics Show source in test_monitor.py:72 Signature def test_ltm_metrics(self): ... TestPCM Show source in test_monitor.py:27 Signature class TestPCM(twrap.TestWrapper): ... TestPCM().test_pcm Show source in test_monitor.py:32 Signature def test_pcm(self): ... TestPCM().test_str_to_datetime Show source in test_monitor.py:55 Signature def test_str_to_datetime(self): ... TestSTMMetrics Show source in test_monitor.py:92 Signature class TestSTMMetrics(twrap.TestWrapper): ... TestSTMMetrics().test_stm_metrics Show source in test_monitor.py:97 Signature def test_stm_metrics(self): ...","title":"Test Monitor"},{"location":"pypowervm/tests/wrappers/test_monitor/#test-monitor","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Monitor Auto-generated documentation for pypowervm.tests.wrappers.test_monitor module. Test Monitor TestLTMMetrics TestLTMMetrics().test_ltm_metrics TestPCM TestPCM().test_pcm TestPCM().test_str_to_datetime TestSTMMetrics TestSTMMetrics().test_stm_metrics","title":"Test Monitor"},{"location":"pypowervm/tests/wrappers/test_monitor/#testltmmetrics","text":"Show source in test_monitor.py:67","title":"TestLTMMetrics"},{"location":"pypowervm/tests/wrappers/test_monitor/#signature","text":"class TestLTMMetrics(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_monitor/#testltmmetricstest_ltm_metrics","text":"Show source in test_monitor.py:72","title":"TestLTMMetrics().test_ltm_metrics"},{"location":"pypowervm/tests/wrappers/test_monitor/#signature_1","text":"def test_ltm_metrics(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_monitor/#testpcm","text":"Show source in test_monitor.py:27","title":"TestPCM"},{"location":"pypowervm/tests/wrappers/test_monitor/#signature_2","text":"class TestPCM(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_monitor/#testpcmtest_pcm","text":"Show source in test_monitor.py:32","title":"TestPCM().test_pcm"},{"location":"pypowervm/tests/wrappers/test_monitor/#signature_3","text":"def test_pcm(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_monitor/#testpcmtest_str_to_datetime","text":"Show source in test_monitor.py:55","title":"TestPCM().test_str_to_datetime"},{"location":"pypowervm/tests/wrappers/test_monitor/#signature_4","text":"def test_str_to_datetime(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_monitor/#teststmmetrics","text":"Show source in test_monitor.py:92","title":"TestSTMMetrics"},{"location":"pypowervm/tests/wrappers/test_monitor/#signature_5","text":"class TestSTMMetrics(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_monitor/#teststmmetricstest_stm_metrics","text":"Show source in test_monitor.py:97","title":"TestSTMMetrics().test_stm_metrics"},{"location":"pypowervm/tests/wrappers/test_monitor/#signature_6","text":"def test_stm_metrics(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/","text":"TestNetwork Pypowervm Index / Pypowervm / Tests / Wrappers / TestNetwork Auto-generated documentation for pypowervm.tests.wrappers.test_network module. TestNetwork TestCNAWrapper TestCNAWrapper().setUp TestCNAWrapper().test_attrs TestCNAWrapper().test_cna_create TestCNAWrapper().test_enabled TestCNAWrapper().test_get_mac TestCNAWrapper().test_get_slot TestCNAWrapper().test_get_trunk_pri TestCNAWrapper().test_is_trunk TestCNAWrapper().test_lpar_id TestCNAWrapper().test_mac_set TestCNAWrapper().test_mtu TestCNAWrapper().test_ovs_attrs TestCNAWrapper().test_pvid TestCNAWrapper().test_set_dev_name TestCNAWrapper().test_set_trunk_pri TestCNAWrapper().test_standard_crt TestCNAWrapper().test_tagged_vlan_modification TestCNAWrapper().test_trunk_crt TestCNAWrapper().test_unasi_field TestCNAWrapper().test_unique_crt TestCNAWrapper().test_vswitch_uri TestCNAWrapper().test_wrapper_class TestLoadGroup TestLoadGroup().test_wrapper_class TestNetBridge TestNetBridge().test_wrapper_class TestNetwork TestNetwork().set_vnet TestNetwork().test_arbitrary_pvids TestNetwork().test_configuration_state TestNetwork().test_contrl_channel TestNetwork().test_contrl_channel_id TestNetwork().test_crt_load_group TestNetwork().test_crt_net_bridge TestNetwork().test_crt_sea TestNetwork().test_crt_trunk_adapter TestNetwork().test_list_vlan_no_vnet TestNetwork().test_list_vlans TestNetwork().test_load_balance TestNetwork().test_load_group_modification TestNetwork().test_load_groups TestNetwork().test_no_primary_adpt TestNetwork().test_pvid TestNetwork().test_sea_modification TestNetwork().test_sea_trunks TestNetwork().test_seas TestNetwork().test_supports_vlan TestNetwork().test_supports_vlan_no_vnet TestNetwork().test_uuid TestNetwork().test_varied_on TestNetwork().test_vnet_uri_list TestNetwork().test_vswitch_id TestSEA TestSEA().test_wrapper_class TestTrunkAdapter TestTrunkAdapter().test_wrapper_class TestVNetwork TestVNetwork().test_name TestVNetwork().test_vnet TestVNetwork().test_vnet_new TestVNetwork().test_wrapper_class TestVSwitch TestVSwitch().test_bld TestVSwitch().test_data TestVSwitch().test_feed TestVSwitch().test_set_mode TestVSwitch().test_wrapper_class TestCNAWrapper Show source in test_network.py:529 Signature class TestCNAWrapper(twrap.TestWrapper): ... TestCNAWrapper().setUp Show source in test_network.py:535 Signature def setUp(self): ... TestCNAWrapper().test_attrs Show source in test_network.py:736 Test getting the attributes. Signature def test_attrs(self): ... TestCNAWrapper().test_cna_create Show source in test_network.py:635 CNA.create hack that mucks with UseNextAvailable(High)SlotID. Signature @mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.create\") @mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.get\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") def test_cna_create(self, mock_vget, mock_lget, mock_ewrap_create): ... TestCNAWrapper().test_enabled Show source in test_network.py:843 Test that we disable/enable. Signature def test_enabled(self): ... TestCNAWrapper().test_get_mac Show source in test_network.py:794 Test that we can get the mac address. Signature def test_get_mac(self): ... TestCNAWrapper().test_get_slot Show source in test_network.py:790 Test getting the VirtualSlotID. Signature def test_get_slot(self): ... TestCNAWrapper().test_get_trunk_pri Show source in test_network.py:817 Test that we can get the trunk priority. Signature def test_get_trunk_pri(self): ... TestCNAWrapper().test_is_trunk Show source in test_network.py:827 Test that we can get if this adapter is a trunk. Signature def test_is_trunk(self): ... TestCNAWrapper().test_lpar_id Show source in test_network.py:833 Test that we can get the local partition id. Signature def test_lpar_id(self): ... TestCNAWrapper().test_mac_set Show source in test_network.py:783 Signature def test_mac_set(self): ... TestCNAWrapper().test_mtu Show source in test_network.py:864 Signature def test_mtu(self): ... TestCNAWrapper().test_ovs_attrs Show source in test_network.py:851 Signature def test_ovs_attrs(self): ... TestCNAWrapper().test_pvid Show source in test_network.py:798 Test that the PVID returns properly. Signature def test_pvid(self): ... TestCNAWrapper().test_set_dev_name Show source in test_network.py:837 Test that we can set the device name. Signature def test_set_dev_name(self): ... TestCNAWrapper().test_set_trunk_pri Show source in test_network.py:821 Test that we can set the trunk priority. Signature def test_set_trunk_pri(self): ... TestCNAWrapper().test_standard_crt Show source in test_network.py:539 Tests a standard create of the CNA. Signature def test_standard_crt(self): ... TestCNAWrapper().test_tagged_vlan_modification Show source in test_network.py:762 Tests that the tagged vlans can be modified. Signature def test_tagged_vlan_modification(self): ... TestCNAWrapper().test_trunk_crt Show source in test_network.py:558 Tests a standard create of the CNA. Signature def test_trunk_crt(self): ... TestCNAWrapper().test_unasi_field Show source in test_network.py:597 UseNextAvailable(High)SlotID field is (not) used, as appropriate. Signature def test_unasi_field(self): ... TestCNAWrapper().test_unique_crt Show source in test_network.py:576 Tests the create path with a non-standard flow for the CNA. Signature def test_unique_crt(self): ... TestCNAWrapper().test_vswitch_uri Show source in test_network.py:805 Signature def test_vswitch_uri(self): ... TestCNAWrapper().test_wrapper_class Show source in test_network.py:811 Signature def test_wrapper_class(self): ... TestLoadGroup Show source in test_network.py:121 Signature class TestLoadGroup(unittest.TestCase): ... TestLoadGroup().test_wrapper_class Show source in test_network.py:122 Signature def test_wrapper_class(self): ... TestNetBridge Show source in test_network.py:146 Signature class TestNetBridge(unittest.TestCase): ... TestNetBridge().test_wrapper_class Show source in test_network.py:147 Signature def test_wrapper_class(self): ... TestNetwork Show source in test_network.py:154 Signature class TestNetwork(twrap.TestWrapper): ... TestNetwork().set_vnet Show source in test_network.py:160 Signature def set_vnet(self, aware): ... TestNetwork().test_arbitrary_pvids Show source in test_network.py:413 Signature def test_arbitrary_pvids(self): ... TestNetwork().test_configuration_state Show source in test_network.py:169 Signature def test_configuration_state(self): ... TestNetwork().test_contrl_channel Show source in test_network.py:185 Signature def test_contrl_channel(self): ... TestNetwork().test_contrl_channel_id Show source in test_network.py:193 Signature def test_contrl_channel_id(self): ... TestNetwork().test_crt_load_group Show source in test_network.py:296 Signature def test_crt_load_group(self): ... TestNetwork().test_crt_net_bridge Show source in test_network.py:196 Signature def test_crt_net_bridge(self): ... TestNetwork().test_crt_sea Show source in test_network.py:249 Signature def test_crt_sea(self): ... TestNetwork().test_crt_trunk_adapter Show source in test_network.py:273 Signature def test_crt_trunk_adapter(self): ... TestNetwork().test_list_vlan_no_vnet Show source in test_network.py:442 Tests that a VLAN change affects trunks, not vnets. Signature def test_list_vlan_no_vnet(self): ... TestNetwork().test_list_vlans Show source in test_network.py:419 Signature def test_list_vlans(self): ... TestNetwork().test_load_balance Show source in test_network.py:173 Signature def test_load_balance(self): ... TestNetwork().test_load_group_modification Show source in test_network.py:335 Verifies that the callbacks to the Network Bridge work. When modifying the Virtual Network list in the Load Group, those updates should be reflected back into the Network Bridge. Signature def test_load_group_modification(self): ... TestNetwork().test_load_groups Show source in test_network.py:310 Signature def test_load_groups(self): ... TestNetwork().test_no_primary_adpt Show source in test_network.py:400 Tests rare case that SEA has no primary adapter. Signature def test_no_primary_adpt(self): ... TestNetwork().test_pvid Show source in test_network.py:166 Signature def test_pvid(self): ... TestNetwork().test_sea_modification Show source in test_network.py:350 Verifies that the SEA can have a Trunk Adapter added to it. Signature def test_sea_modification(self): ... TestNetwork().test_sea_trunks Show source in test_network.py:478 Tests the trunk adapters on the SEA. Signature def test_sea_trunks(self): ... TestNetwork().test_seas Show source in test_network.py:450 Signature def test_seas(self): ... TestNetwork().test_supports_vlan Show source in test_network.py:367 Tests the supports_vlan method. Signature def test_supports_vlan(self): ... TestNetwork().test_supports_vlan_no_vnet Show source in test_network.py:392 Tests that a VLAN change affects trunks, not vnets. Signature def test_supports_vlan_no_vnet(self): ... TestNetwork().test_uuid Show source in test_network.py:176 Signature def test_uuid(self): ... TestNetwork().test_varied_on Show source in test_network.py:519 Signature def test_varied_on(self): ... TestNetwork().test_vnet_uri_list Show source in test_network.py:180 Signature def test_vnet_uri_list(self): ... TestNetwork().test_vswitch_id Show source in test_network.py:409 Tests that the pass thru of the vswitch id works. Signature def test_vswitch_id(self): ... TestSEA Show source in test_network.py:138 Signature class TestSEA(unittest.TestCase): ... TestSEA().test_wrapper_class Show source in test_network.py:139 Signature def test_wrapper_class(self): ... TestTrunkAdapter Show source in test_network.py:129 Signature class TestTrunkAdapter(unittest.TestCase): ... TestTrunkAdapter().test_wrapper_class Show source in test_network.py:130 Signature def test_wrapper_class(self): ... TestVNetwork Show source in test_network.py:35 Signature class TestVNetwork(twrap.TestWrapper): ... TestVNetwork().test_name Show source in test_network.py:50 Signature def test_name(self): ... TestVNetwork().test_vnet Show source in test_network.py:40 Signature def test_vnet(self): ... TestVNetwork().test_vnet_new Show source in test_network.py:54 Tests the method that returns a VNet ElementWrapper. Signature def test_vnet_new(self): ... TestVNetwork().test_wrapper_class Show source in test_network.py:61 Signature def test_wrapper_class(self): ... TestVSwitch Show source in test_network.py:68 Signature class TestVSwitch(twrap.TestWrapper): ... TestVSwitch().test_bld Show source in test_network.py:73 Tests that the vSwitch element can be built. Signature def test_bld(self): ... TestVSwitch().test_data Show source in test_network.py:92 Signature def test_data(self): ... TestVSwitch().test_feed Show source in test_network.py:85 Tests the feed of virtual switches. Signature def test_feed(self): ... TestVSwitch().test_set_mode Show source in test_network.py:111 Tests that the vSwitch element can have the mode set. Signature def test_set_mode(self): ... TestVSwitch().test_wrapper_class Show source in test_network.py:105 Signature def test_wrapper_class(self): ...","title":"TestNetwork"},{"location":"pypowervm/tests/wrappers/test_network/#testnetwork","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / TestNetwork Auto-generated documentation for pypowervm.tests.wrappers.test_network module. TestNetwork TestCNAWrapper TestCNAWrapper().setUp TestCNAWrapper().test_attrs TestCNAWrapper().test_cna_create TestCNAWrapper().test_enabled TestCNAWrapper().test_get_mac TestCNAWrapper().test_get_slot TestCNAWrapper().test_get_trunk_pri TestCNAWrapper().test_is_trunk TestCNAWrapper().test_lpar_id TestCNAWrapper().test_mac_set TestCNAWrapper().test_mtu TestCNAWrapper().test_ovs_attrs TestCNAWrapper().test_pvid TestCNAWrapper().test_set_dev_name TestCNAWrapper().test_set_trunk_pri TestCNAWrapper().test_standard_crt TestCNAWrapper().test_tagged_vlan_modification TestCNAWrapper().test_trunk_crt TestCNAWrapper().test_unasi_field TestCNAWrapper().test_unique_crt TestCNAWrapper().test_vswitch_uri TestCNAWrapper().test_wrapper_class TestLoadGroup TestLoadGroup().test_wrapper_class TestNetBridge TestNetBridge().test_wrapper_class TestNetwork TestNetwork().set_vnet TestNetwork().test_arbitrary_pvids TestNetwork().test_configuration_state TestNetwork().test_contrl_channel TestNetwork().test_contrl_channel_id TestNetwork().test_crt_load_group TestNetwork().test_crt_net_bridge TestNetwork().test_crt_sea TestNetwork().test_crt_trunk_adapter TestNetwork().test_list_vlan_no_vnet TestNetwork().test_list_vlans TestNetwork().test_load_balance TestNetwork().test_load_group_modification TestNetwork().test_load_groups TestNetwork().test_no_primary_adpt TestNetwork().test_pvid TestNetwork().test_sea_modification TestNetwork().test_sea_trunks TestNetwork().test_seas TestNetwork().test_supports_vlan TestNetwork().test_supports_vlan_no_vnet TestNetwork().test_uuid TestNetwork().test_varied_on TestNetwork().test_vnet_uri_list TestNetwork().test_vswitch_id TestSEA TestSEA().test_wrapper_class TestTrunkAdapter TestTrunkAdapter().test_wrapper_class TestVNetwork TestVNetwork().test_name TestVNetwork().test_vnet TestVNetwork().test_vnet_new TestVNetwork().test_wrapper_class TestVSwitch TestVSwitch().test_bld TestVSwitch().test_data TestVSwitch().test_feed TestVSwitch().test_set_mode TestVSwitch().test_wrapper_class","title":"TestNetwork"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrapper","text":"Show source in test_network.py:529","title":"TestCNAWrapper"},{"location":"pypowervm/tests/wrappers/test_network/#signature","text":"class TestCNAWrapper(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappersetup","text":"Show source in test_network.py:535","title":"TestCNAWrapper().setUp"},{"location":"pypowervm/tests/wrappers/test_network/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_attrs","text":"Show source in test_network.py:736 Test getting the attributes.","title":"TestCNAWrapper().test_attrs"},{"location":"pypowervm/tests/wrappers/test_network/#signature_2","text":"def test_attrs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_cna_create","text":"Show source in test_network.py:635 CNA.create hack that mucks with UseNextAvailable(High)SlotID.","title":"TestCNAWrapper().test_cna_create"},{"location":"pypowervm/tests/wrappers/test_network/#signature_3","text":"@mock.patch(\"pypowervm.wrappers.entry_wrapper.EntryWrapper.create\") @mock.patch(\"pypowervm.wrappers.logical_partition.LPAR.get\") @mock.patch(\"pypowervm.wrappers.virtual_io_server.VIOS.get\") def test_cna_create(self, mock_vget, mock_lget, mock_ewrap_create): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_enabled","text":"Show source in test_network.py:843 Test that we disable/enable.","title":"TestCNAWrapper().test_enabled"},{"location":"pypowervm/tests/wrappers/test_network/#signature_4","text":"def test_enabled(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_get_mac","text":"Show source in test_network.py:794 Test that we can get the mac address.","title":"TestCNAWrapper().test_get_mac"},{"location":"pypowervm/tests/wrappers/test_network/#signature_5","text":"def test_get_mac(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_get_slot","text":"Show source in test_network.py:790 Test getting the VirtualSlotID.","title":"TestCNAWrapper().test_get_slot"},{"location":"pypowervm/tests/wrappers/test_network/#signature_6","text":"def test_get_slot(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_get_trunk_pri","text":"Show source in test_network.py:817 Test that we can get the trunk priority.","title":"TestCNAWrapper().test_get_trunk_pri"},{"location":"pypowervm/tests/wrappers/test_network/#signature_7","text":"def test_get_trunk_pri(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_is_trunk","text":"Show source in test_network.py:827 Test that we can get if this adapter is a trunk.","title":"TestCNAWrapper().test_is_trunk"},{"location":"pypowervm/tests/wrappers/test_network/#signature_8","text":"def test_is_trunk(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_lpar_id","text":"Show source in test_network.py:833 Test that we can get the local partition id.","title":"TestCNAWrapper().test_lpar_id"},{"location":"pypowervm/tests/wrappers/test_network/#signature_9","text":"def test_lpar_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_mac_set","text":"Show source in test_network.py:783","title":"TestCNAWrapper().test_mac_set"},{"location":"pypowervm/tests/wrappers/test_network/#signature_10","text":"def test_mac_set(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_mtu","text":"Show source in test_network.py:864","title":"TestCNAWrapper().test_mtu"},{"location":"pypowervm/tests/wrappers/test_network/#signature_11","text":"def test_mtu(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_ovs_attrs","text":"Show source in test_network.py:851","title":"TestCNAWrapper().test_ovs_attrs"},{"location":"pypowervm/tests/wrappers/test_network/#signature_12","text":"def test_ovs_attrs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_pvid","text":"Show source in test_network.py:798 Test that the PVID returns properly.","title":"TestCNAWrapper().test_pvid"},{"location":"pypowervm/tests/wrappers/test_network/#signature_13","text":"def test_pvid(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_set_dev_name","text":"Show source in test_network.py:837 Test that we can set the device name.","title":"TestCNAWrapper().test_set_dev_name"},{"location":"pypowervm/tests/wrappers/test_network/#signature_14","text":"def test_set_dev_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_set_trunk_pri","text":"Show source in test_network.py:821 Test that we can set the trunk priority.","title":"TestCNAWrapper().test_set_trunk_pri"},{"location":"pypowervm/tests/wrappers/test_network/#signature_15","text":"def test_set_trunk_pri(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_standard_crt","text":"Show source in test_network.py:539 Tests a standard create of the CNA.","title":"TestCNAWrapper().test_standard_crt"},{"location":"pypowervm/tests/wrappers/test_network/#signature_16","text":"def test_standard_crt(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_tagged_vlan_modification","text":"Show source in test_network.py:762 Tests that the tagged vlans can be modified.","title":"TestCNAWrapper().test_tagged_vlan_modification"},{"location":"pypowervm/tests/wrappers/test_network/#signature_17","text":"def test_tagged_vlan_modification(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_trunk_crt","text":"Show source in test_network.py:558 Tests a standard create of the CNA.","title":"TestCNAWrapper().test_trunk_crt"},{"location":"pypowervm/tests/wrappers/test_network/#signature_18","text":"def test_trunk_crt(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_unasi_field","text":"Show source in test_network.py:597 UseNextAvailable(High)SlotID field is (not) used, as appropriate.","title":"TestCNAWrapper().test_unasi_field"},{"location":"pypowervm/tests/wrappers/test_network/#signature_19","text":"def test_unasi_field(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_unique_crt","text":"Show source in test_network.py:576 Tests the create path with a non-standard flow for the CNA.","title":"TestCNAWrapper().test_unique_crt"},{"location":"pypowervm/tests/wrappers/test_network/#signature_20","text":"def test_unique_crt(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_vswitch_uri","text":"Show source in test_network.py:805","title":"TestCNAWrapper().test_vswitch_uri"},{"location":"pypowervm/tests/wrappers/test_network/#signature_21","text":"def test_vswitch_uri(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testcnawrappertest_wrapper_class","text":"Show source in test_network.py:811","title":"TestCNAWrapper().test_wrapper_class"},{"location":"pypowervm/tests/wrappers/test_network/#signature_22","text":"def test_wrapper_class(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testloadgroup","text":"Show source in test_network.py:121","title":"TestLoadGroup"},{"location":"pypowervm/tests/wrappers/test_network/#signature_23","text":"class TestLoadGroup(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testloadgrouptest_wrapper_class","text":"Show source in test_network.py:122","title":"TestLoadGroup().test_wrapper_class"},{"location":"pypowervm/tests/wrappers/test_network/#signature_24","text":"def test_wrapper_class(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetbridge","text":"Show source in test_network.py:146","title":"TestNetBridge"},{"location":"pypowervm/tests/wrappers/test_network/#signature_25","text":"class TestNetBridge(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetbridgetest_wrapper_class","text":"Show source in test_network.py:147","title":"TestNetBridge().test_wrapper_class"},{"location":"pypowervm/tests/wrappers/test_network/#signature_26","text":"def test_wrapper_class(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetwork_1","text":"Show source in test_network.py:154","title":"TestNetwork"},{"location":"pypowervm/tests/wrappers/test_network/#signature_27","text":"class TestNetwork(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworkset_vnet","text":"Show source in test_network.py:160","title":"TestNetwork().set_vnet"},{"location":"pypowervm/tests/wrappers/test_network/#signature_28","text":"def set_vnet(self, aware): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_arbitrary_pvids","text":"Show source in test_network.py:413","title":"TestNetwork().test_arbitrary_pvids"},{"location":"pypowervm/tests/wrappers/test_network/#signature_29","text":"def test_arbitrary_pvids(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_configuration_state","text":"Show source in test_network.py:169","title":"TestNetwork().test_configuration_state"},{"location":"pypowervm/tests/wrappers/test_network/#signature_30","text":"def test_configuration_state(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_contrl_channel","text":"Show source in test_network.py:185","title":"TestNetwork().test_contrl_channel"},{"location":"pypowervm/tests/wrappers/test_network/#signature_31","text":"def test_contrl_channel(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_contrl_channel_id","text":"Show source in test_network.py:193","title":"TestNetwork().test_contrl_channel_id"},{"location":"pypowervm/tests/wrappers/test_network/#signature_32","text":"def test_contrl_channel_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_crt_load_group","text":"Show source in test_network.py:296","title":"TestNetwork().test_crt_load_group"},{"location":"pypowervm/tests/wrappers/test_network/#signature_33","text":"def test_crt_load_group(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_crt_net_bridge","text":"Show source in test_network.py:196","title":"TestNetwork().test_crt_net_bridge"},{"location":"pypowervm/tests/wrappers/test_network/#signature_34","text":"def test_crt_net_bridge(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_crt_sea","text":"Show source in test_network.py:249","title":"TestNetwork().test_crt_sea"},{"location":"pypowervm/tests/wrappers/test_network/#signature_35","text":"def test_crt_sea(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_crt_trunk_adapter","text":"Show source in test_network.py:273","title":"TestNetwork().test_crt_trunk_adapter"},{"location":"pypowervm/tests/wrappers/test_network/#signature_36","text":"def test_crt_trunk_adapter(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_list_vlan_no_vnet","text":"Show source in test_network.py:442 Tests that a VLAN change affects trunks, not vnets.","title":"TestNetwork().test_list_vlan_no_vnet"},{"location":"pypowervm/tests/wrappers/test_network/#signature_37","text":"def test_list_vlan_no_vnet(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_list_vlans","text":"Show source in test_network.py:419","title":"TestNetwork().test_list_vlans"},{"location":"pypowervm/tests/wrappers/test_network/#signature_38","text":"def test_list_vlans(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_load_balance","text":"Show source in test_network.py:173","title":"TestNetwork().test_load_balance"},{"location":"pypowervm/tests/wrappers/test_network/#signature_39","text":"def test_load_balance(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_load_group_modification","text":"Show source in test_network.py:335 Verifies that the callbacks to the Network Bridge work. When modifying the Virtual Network list in the Load Group, those updates should be reflected back into the Network Bridge.","title":"TestNetwork().test_load_group_modification"},{"location":"pypowervm/tests/wrappers/test_network/#signature_40","text":"def test_load_group_modification(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_load_groups","text":"Show source in test_network.py:310","title":"TestNetwork().test_load_groups"},{"location":"pypowervm/tests/wrappers/test_network/#signature_41","text":"def test_load_groups(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_no_primary_adpt","text":"Show source in test_network.py:400 Tests rare case that SEA has no primary adapter.","title":"TestNetwork().test_no_primary_adpt"},{"location":"pypowervm/tests/wrappers/test_network/#signature_42","text":"def test_no_primary_adpt(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_pvid","text":"Show source in test_network.py:166","title":"TestNetwork().test_pvid"},{"location":"pypowervm/tests/wrappers/test_network/#signature_43","text":"def test_pvid(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_sea_modification","text":"Show source in test_network.py:350 Verifies that the SEA can have a Trunk Adapter added to it.","title":"TestNetwork().test_sea_modification"},{"location":"pypowervm/tests/wrappers/test_network/#signature_44","text":"def test_sea_modification(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_sea_trunks","text":"Show source in test_network.py:478 Tests the trunk adapters on the SEA.","title":"TestNetwork().test_sea_trunks"},{"location":"pypowervm/tests/wrappers/test_network/#signature_45","text":"def test_sea_trunks(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_seas","text":"Show source in test_network.py:450","title":"TestNetwork().test_seas"},{"location":"pypowervm/tests/wrappers/test_network/#signature_46","text":"def test_seas(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_supports_vlan","text":"Show source in test_network.py:367 Tests the supports_vlan method.","title":"TestNetwork().test_supports_vlan"},{"location":"pypowervm/tests/wrappers/test_network/#signature_47","text":"def test_supports_vlan(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_supports_vlan_no_vnet","text":"Show source in test_network.py:392 Tests that a VLAN change affects trunks, not vnets.","title":"TestNetwork().test_supports_vlan_no_vnet"},{"location":"pypowervm/tests/wrappers/test_network/#signature_48","text":"def test_supports_vlan_no_vnet(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_uuid","text":"Show source in test_network.py:176","title":"TestNetwork().test_uuid"},{"location":"pypowervm/tests/wrappers/test_network/#signature_49","text":"def test_uuid(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_varied_on","text":"Show source in test_network.py:519","title":"TestNetwork().test_varied_on"},{"location":"pypowervm/tests/wrappers/test_network/#signature_50","text":"def test_varied_on(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_vnet_uri_list","text":"Show source in test_network.py:180","title":"TestNetwork().test_vnet_uri_list"},{"location":"pypowervm/tests/wrappers/test_network/#signature_51","text":"def test_vnet_uri_list(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testnetworktest_vswitch_id","text":"Show source in test_network.py:409 Tests that the pass thru of the vswitch id works.","title":"TestNetwork().test_vswitch_id"},{"location":"pypowervm/tests/wrappers/test_network/#signature_52","text":"def test_vswitch_id(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testsea","text":"Show source in test_network.py:138","title":"TestSEA"},{"location":"pypowervm/tests/wrappers/test_network/#signature_53","text":"class TestSEA(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testseatest_wrapper_class","text":"Show source in test_network.py:139","title":"TestSEA().test_wrapper_class"},{"location":"pypowervm/tests/wrappers/test_network/#signature_54","text":"def test_wrapper_class(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testtrunkadapter","text":"Show source in test_network.py:129","title":"TestTrunkAdapter"},{"location":"pypowervm/tests/wrappers/test_network/#signature_55","text":"class TestTrunkAdapter(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testtrunkadaptertest_wrapper_class","text":"Show source in test_network.py:130","title":"TestTrunkAdapter().test_wrapper_class"},{"location":"pypowervm/tests/wrappers/test_network/#signature_56","text":"def test_wrapper_class(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvnetwork","text":"Show source in test_network.py:35","title":"TestVNetwork"},{"location":"pypowervm/tests/wrappers/test_network/#signature_57","text":"class TestVNetwork(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvnetworktest_name","text":"Show source in test_network.py:50","title":"TestVNetwork().test_name"},{"location":"pypowervm/tests/wrappers/test_network/#signature_58","text":"def test_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvnetworktest_vnet","text":"Show source in test_network.py:40","title":"TestVNetwork().test_vnet"},{"location":"pypowervm/tests/wrappers/test_network/#signature_59","text":"def test_vnet(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvnetworktest_vnet_new","text":"Show source in test_network.py:54 Tests the method that returns a VNet ElementWrapper.","title":"TestVNetwork().test_vnet_new"},{"location":"pypowervm/tests/wrappers/test_network/#signature_60","text":"def test_vnet_new(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvnetworktest_wrapper_class","text":"Show source in test_network.py:61","title":"TestVNetwork().test_wrapper_class"},{"location":"pypowervm/tests/wrappers/test_network/#signature_61","text":"def test_wrapper_class(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvswitch","text":"Show source in test_network.py:68","title":"TestVSwitch"},{"location":"pypowervm/tests/wrappers/test_network/#signature_62","text":"class TestVSwitch(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvswitchtest_bld","text":"Show source in test_network.py:73 Tests that the vSwitch element can be built.","title":"TestVSwitch().test_bld"},{"location":"pypowervm/tests/wrappers/test_network/#signature_63","text":"def test_bld(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvswitchtest_data","text":"Show source in test_network.py:92","title":"TestVSwitch().test_data"},{"location":"pypowervm/tests/wrappers/test_network/#signature_64","text":"def test_data(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvswitchtest_feed","text":"Show source in test_network.py:85 Tests the feed of virtual switches.","title":"TestVSwitch().test_feed"},{"location":"pypowervm/tests/wrappers/test_network/#signature_65","text":"def test_feed(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvswitchtest_set_mode","text":"Show source in test_network.py:111 Tests that the vSwitch element can have the mode set.","title":"TestVSwitch().test_set_mode"},{"location":"pypowervm/tests/wrappers/test_network/#signature_66","text":"def test_set_mode(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_network/#testvswitchtest_wrapper_class","text":"Show source in test_network.py:105","title":"TestVSwitch().test_wrapper_class"},{"location":"pypowervm/tests/wrappers/test_network/#signature_67","text":"def test_wrapper_class(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_search/","text":"TestSearch Pypowervm Index / Pypowervm / Tests / Wrappers / TestSearch Auto-generated documentation for pypowervm.tests.wrappers.test_search module. TestSearch TestSearch TestSearch().test_all_search_keys TestSearch Show source in test_search.py:30 Signature class TestSearch(unittest.TestCase): ... TestSearch().test_all_search_keys Show source in test_search.py:48 Signature def test_all_search_keys(self): ...","title":"TestSearch"},{"location":"pypowervm/tests/wrappers/test_search/#testsearch","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / TestSearch Auto-generated documentation for pypowervm.tests.wrappers.test_search module. TestSearch TestSearch TestSearch().test_all_search_keys","title":"TestSearch"},{"location":"pypowervm/tests/wrappers/test_search/#testsearch_1","text":"Show source in test_search.py:30","title":"TestSearch"},{"location":"pypowervm/tests/wrappers/test_search/#signature","text":"class TestSearch(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_search/#testsearchtest_all_search_keys","text":"Show source in test_search.py:48","title":"TestSearch().test_all_search_keys"},{"location":"pypowervm/tests/wrappers/test_search/#signature_1","text":"def test_all_search_keys(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_shared_proc_pool/","text":"Test Shared Proc Pool Pypowervm Index / Pypowervm / Tests / Wrappers / Test Shared Proc Pool Auto-generated documentation for pypowervm.tests.wrappers.test_shared_proc_pool module. Test Shared Proc Pool TestShrPrcPoolTestCase TestShrPrcPoolTestCase().test_setters TestShrPrcPoolTestCase().test_validate_attribues TestShrPrcPoolTestCase Show source in test_shared_proc_pool.py:23 Signature class TestShrPrcPoolTestCase(twrap.TestWrapper): ... TestShrPrcPoolTestCase().test_setters Show source in test_shared_proc_pool.py:48 Signature def test_setters(self): ... TestShrPrcPoolTestCase().test_validate_attribues Show source in test_shared_proc_pool.py:28 Signature def test_validate_attribues(self): ...","title":"Test Shared Proc Pool"},{"location":"pypowervm/tests/wrappers/test_shared_proc_pool/#test-shared-proc-pool","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Shared Proc Pool Auto-generated documentation for pypowervm.tests.wrappers.test_shared_proc_pool module. Test Shared Proc Pool TestShrPrcPoolTestCase TestShrPrcPoolTestCase().test_setters TestShrPrcPoolTestCase().test_validate_attribues","title":"Test Shared Proc Pool"},{"location":"pypowervm/tests/wrappers/test_shared_proc_pool/#testshrprcpooltestcase","text":"Show source in test_shared_proc_pool.py:23","title":"TestShrPrcPoolTestCase"},{"location":"pypowervm/tests/wrappers/test_shared_proc_pool/#signature","text":"class TestShrPrcPoolTestCase(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_shared_proc_pool/#testshrprcpooltestcasetest_setters","text":"Show source in test_shared_proc_pool.py:48","title":"TestShrPrcPoolTestCase().test_setters"},{"location":"pypowervm/tests/wrappers/test_shared_proc_pool/#signature_1","text":"def test_setters(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_shared_proc_pool/#testshrprcpooltestcasetest_validate_attribues","text":"Show source in test_shared_proc_pool.py:28","title":"TestShrPrcPoolTestCase().test_validate_attribues"},{"location":"pypowervm/tests/wrappers/test_shared_proc_pool/#signature_2","text":"def test_validate_attribues(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/","text":"Test Storage Pypowervm Index / Pypowervm / Tests / Wrappers / Test Storage Auto-generated documentation for pypowervm.tests.wrappers.test_storage module. Test Storage TestLUEnt TestLUEnt().test_logical_units TestLUEnt().test_lu_bld TestLUEnt().test_lu_bld_ref TestLUEnt().test_lu_equality TestLUEnt().test_lu_hash TestLUEnt().test_lu_ordering TestSharedStoragePool TestSharedStoragePool().test_capacity TestSharedStoragePool().test_free_space TestSharedStoragePool().test_fresh_ssp TestSharedStoragePool().test_logical_units TestSharedStoragePool().test_lu_bld TestSharedStoragePool().test_lu_equality TestSharedStoragePool().test_lu_hash TestSharedStoragePool().test_lu_ordering TestSharedStoragePool().test_name TestSharedStoragePool().test_over_commit_space TestSharedStoragePool().test_physical_volumes TestSharedStoragePool().test_total_lu_size TestSharedStoragePool().test_udid TestStorageTypes TestStorageTypes().test_fileio TestStorageTypes().test_pv TestStorageTypes().test_rbd TestStorageTypes().test_vdisk TestTargetDevs TestTargetDevs().test_bld_set TestTargetDevs().test_subtypes_props TestTier TestTier().test_props TestVFCClientAdapter TestVFCClientAdapter().test_vfc_client_adapter TestVIOS TestVIOS().test_bogus_pg83_in_pv TestVIOS().test_pg83_absent_from_pv TestVIOS().test_pg83_in_pv TestVIOS().test_pg83_raises_if_no_parent_entry TestVolumeGroup TestVolumeGroup().test_add_lv TestVolumeGroup().test_add_media_repo TestVolumeGroup().test_add_phys_vol TestVolumeGroup().test_add_vdisk TestVolumeGroup().test_base TestVolumeGroup().test_bld TestVolumeGroup().test_ordering TestVolumeGroup().test_physical_volumes TestVolumeGroup().test_update_media_repo TestVolumeGroup().test_virtual_disk TestVolumeGroup().test_vmedia_repos TestLUEnt Show source in test_storage.py:285 Signature class TestLUEnt(twrap.TestWrapper): ... TestLUEnt().test_logical_units Show source in test_storage.py:289 Signature def test_logical_units(self): ... TestLUEnt().test_lu_bld Show source in test_storage.py:304 Signature def test_lu_bld(self): ... TestLUEnt().test_lu_bld_ref Show source in test_storage.py:344 Signature def test_lu_bld_ref(self): ... TestLUEnt().test_lu_equality Show source in test_storage.py:374 Signature def test_lu_equality(self): ... TestLUEnt().test_lu_hash Show source in test_storage.py:388 Signature def test_lu_hash(self): ... TestLUEnt().test_lu_ordering Show source in test_storage.py:357 Signature def test_lu_ordering(self): ... TestSharedStoragePool Show source in test_storage.py:429 Signature class TestSharedStoragePool(twrap.TestWrapper): ... TestSharedStoragePool().test_capacity Show source in test_storage.py:441 Signature def test_capacity(self): ... TestSharedStoragePool().test_free_space Show source in test_storage.py:444 Signature def test_free_space(self): ... TestSharedStoragePool().test_fresh_ssp Show source in test_storage.py:494 Signature def test_fresh_ssp(self): ... TestSharedStoragePool().test_logical_units Show source in test_storage.py:472 Signature def test_logical_units(self): ... TestSharedStoragePool().test_lu_bld Show source in test_storage.py:509 Signature def test_lu_bld(self): ... TestSharedStoragePool().test_lu_equality Show source in test_storage.py:552 Signature def test_lu_equality(self): ... TestSharedStoragePool().test_lu_hash Show source in test_storage.py:565 Signature def test_lu_hash(self): ... TestSharedStoragePool().test_lu_ordering Show source in test_storage.py:535 Signature def test_lu_ordering(self): ... TestSharedStoragePool().test_name Show source in test_storage.py:434 Signature def test_name(self): ... TestSharedStoragePool().test_over_commit_space Show source in test_storage.py:447 Signature def test_over_commit_space(self): ... TestSharedStoragePool().test_physical_volumes Show source in test_storage.py:453 Signature def test_physical_volumes(self): ... TestSharedStoragePool().test_total_lu_size Show source in test_storage.py:450 Signature def test_total_lu_size(self): ... TestSharedStoragePool().test_udid Show source in test_storage.py:437 Signature def test_udid(self): ... TestStorageTypes Show source in test_storage.py:729 Signature class TestStorageTypes(testtools.TestCase): ... TestStorageTypes().test_fileio Show source in test_storage.py:730 Signature def test_fileio(self): ... TestStorageTypes().test_pv Show source in test_storage.py:802 Signature def test_pv(self): ... TestStorageTypes().test_rbd Show source in test_storage.py:755 Signature def test_rbd(self): ... TestStorageTypes().test_vdisk Show source in test_storage.py:773 Signature def test_vdisk(self): ... TestTargetDevs Show source in test_storage.py:666 Tests for VSCSIMapping.target_dev and {storage_type}TargetDev wrappers. SCSI mapping target devices in the test file are laid out as follows: index type LUA 0 LUTargetDev 0x8200000000000000 1 None - 2 None - 3 LUTargetDev 0x8400000000000000 4 LUTargetDev 0x8500000000000000 5 VOptTargetDev 0x8100000000000000 6 LUTargetDev 0x8300000000000000 7 PVTargetDev 0x8600000000000000 8 VDiskTargetDev 0x8700000000000000 Signature class TestTargetDevs(twrap.TestWrapper): ... TestTargetDevs().test_bld_set Show source in test_storage.py:711 Test *TargetDev.bld(lua) and setting VSCSIMapping.target_dev. Signature def test_bld_set(self): ... TestTargetDevs().test_subtypes_props Show source in test_storage.py:685 Right subtypes and LUA gets/sets from VSCSIMapping.target_dev. Signature def test_subtypes_props(self): ... TestTier Show source in test_storage.py:414 Signature class TestTier(twrap.TestWrapper): ... TestTier().test_props Show source in test_storage.py:418 Signature def test_props(self): ... TestVFCClientAdapter Show source in test_storage.py:591 Signature class TestVFCClientAdapter(twrap.TestWrapper): ... TestVFCClientAdapter().test_vfc_client_adapter Show source in test_storage.py:595 Check getters on VFCClientAdapter. The hard part - the wrapping - was done by TestWrapper. Signature def test_vfc_client_adapter(self): ... TestVIOS Show source in test_storage.py:610 Signature class TestVIOS(twrap.TestWrapper): ... TestVIOS().test_bogus_pg83_in_pv Show source in test_storage.py:660 Bogus pg83 data in the doesn't trigger the Job. Signature def test_bogus_pg83_in_pv(self): ... TestVIOS().test_pg83_absent_from_pv Show source in test_storage.py:624 LUARecovery.QUERY_INVENTORY when no pg83 in . Signature @mock.patch(\"pypowervm.wrappers.job.Job.wrap\") def test_pg83_absent_from_pv(self, mock_wrap): ... TestVIOS().test_pg83_in_pv Show source in test_storage.py:614 Legitimate pg83 data from the . Signature def test_pg83_in_pv(self): ... TestVIOS().test_pg83_raises_if_no_parent_entry Show source in test_storage.py:653 Raise attempting to get pg83 if PV has no parent_entry. Signature def test_pg83_raises_if_no_parent_entry(self): ... TestVolumeGroup Show source in test_storage.py:27 Signature class TestVolumeGroup(twrap.TestWrapper): ... TestVolumeGroup().test_add_lv Show source in test_storage.py:165 Duplicate of above with the LV alias. Signature def test_add_lv(self): ... TestVolumeGroup().test_add_media_repo Show source in test_storage.py:213 Performs a simple add to the volume group of a new media repo. Signature def test_add_media_repo(self): ... TestVolumeGroup().test_add_phys_vol Show source in test_storage.py:195 Performs a test flow that adds a physical volume to the vol grp. Signature def test_add_phys_vol(self): ... TestVolumeGroup().test_add_vdisk Show source in test_storage.py:122 Performs a test flow that adds a virtual disk. Signature def test_add_vdisk(self): ... TestVolumeGroup().test_base Show source in test_storage.py:32 Tests baseline function within the Volume Group. Signature def test_base(self): ... TestVolumeGroup().test_bld Show source in test_storage.py:272 Signature def test_bld(self): ... TestVolumeGroup().test_ordering Show source in test_storage.py:254 Set fields out of order; ensure they end up in the right order. Signature def test_ordering(self): ... TestVolumeGroup().test_physical_volumes Show source in test_storage.py:58 Tests the physical volumes in the VG. Signature def test_physical_volumes(self): ... TestVolumeGroup().test_update_media_repo Show source in test_storage.py:233 Performs a simple test to add optical media to an existing repo. Signature def test_update_media_repo(self): ... TestVolumeGroup().test_virtual_disk Show source in test_storage.py:77 Tests the virtual disk gets. Signature def test_virtual_disk(self): ... TestVolumeGroup().test_vmedia_repos Show source in test_storage.py:41 Tests the virtual media repositories. Signature def test_vmedia_repos(self): ...","title":"Test Storage"},{"location":"pypowervm/tests/wrappers/test_storage/#test-storage","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Storage Auto-generated documentation for pypowervm.tests.wrappers.test_storage module. Test Storage TestLUEnt TestLUEnt().test_logical_units TestLUEnt().test_lu_bld TestLUEnt().test_lu_bld_ref TestLUEnt().test_lu_equality TestLUEnt().test_lu_hash TestLUEnt().test_lu_ordering TestSharedStoragePool TestSharedStoragePool().test_capacity TestSharedStoragePool().test_free_space TestSharedStoragePool().test_fresh_ssp TestSharedStoragePool().test_logical_units TestSharedStoragePool().test_lu_bld TestSharedStoragePool().test_lu_equality TestSharedStoragePool().test_lu_hash TestSharedStoragePool().test_lu_ordering TestSharedStoragePool().test_name TestSharedStoragePool().test_over_commit_space TestSharedStoragePool().test_physical_volumes TestSharedStoragePool().test_total_lu_size TestSharedStoragePool().test_udid TestStorageTypes TestStorageTypes().test_fileio TestStorageTypes().test_pv TestStorageTypes().test_rbd TestStorageTypes().test_vdisk TestTargetDevs TestTargetDevs().test_bld_set TestTargetDevs().test_subtypes_props TestTier TestTier().test_props TestVFCClientAdapter TestVFCClientAdapter().test_vfc_client_adapter TestVIOS TestVIOS().test_bogus_pg83_in_pv TestVIOS().test_pg83_absent_from_pv TestVIOS().test_pg83_in_pv TestVIOS().test_pg83_raises_if_no_parent_entry TestVolumeGroup TestVolumeGroup().test_add_lv TestVolumeGroup().test_add_media_repo TestVolumeGroup().test_add_phys_vol TestVolumeGroup().test_add_vdisk TestVolumeGroup().test_base TestVolumeGroup().test_bld TestVolumeGroup().test_ordering TestVolumeGroup().test_physical_volumes TestVolumeGroup().test_update_media_repo TestVolumeGroup().test_virtual_disk TestVolumeGroup().test_vmedia_repos","title":"Test Storage"},{"location":"pypowervm/tests/wrappers/test_storage/#testluent","text":"Show source in test_storage.py:285","title":"TestLUEnt"},{"location":"pypowervm/tests/wrappers/test_storage/#signature","text":"class TestLUEnt(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testluenttest_logical_units","text":"Show source in test_storage.py:289","title":"TestLUEnt().test_logical_units"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_1","text":"def test_logical_units(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testluenttest_lu_bld","text":"Show source in test_storage.py:304","title":"TestLUEnt().test_lu_bld"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_2","text":"def test_lu_bld(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testluenttest_lu_bld_ref","text":"Show source in test_storage.py:344","title":"TestLUEnt().test_lu_bld_ref"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_3","text":"def test_lu_bld_ref(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testluenttest_lu_equality","text":"Show source in test_storage.py:374","title":"TestLUEnt().test_lu_equality"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_4","text":"def test_lu_equality(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testluenttest_lu_hash","text":"Show source in test_storage.py:388","title":"TestLUEnt().test_lu_hash"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_5","text":"def test_lu_hash(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testluenttest_lu_ordering","text":"Show source in test_storage.py:357","title":"TestLUEnt().test_lu_ordering"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_6","text":"def test_lu_ordering(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepool","text":"Show source in test_storage.py:429","title":"TestSharedStoragePool"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_7","text":"class TestSharedStoragePool(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_capacity","text":"Show source in test_storage.py:441","title":"TestSharedStoragePool().test_capacity"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_8","text":"def test_capacity(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_free_space","text":"Show source in test_storage.py:444","title":"TestSharedStoragePool().test_free_space"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_9","text":"def test_free_space(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_fresh_ssp","text":"Show source in test_storage.py:494","title":"TestSharedStoragePool().test_fresh_ssp"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_10","text":"def test_fresh_ssp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_logical_units","text":"Show source in test_storage.py:472","title":"TestSharedStoragePool().test_logical_units"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_11","text":"def test_logical_units(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_lu_bld","text":"Show source in test_storage.py:509","title":"TestSharedStoragePool().test_lu_bld"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_12","text":"def test_lu_bld(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_lu_equality","text":"Show source in test_storage.py:552","title":"TestSharedStoragePool().test_lu_equality"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_13","text":"def test_lu_equality(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_lu_hash","text":"Show source in test_storage.py:565","title":"TestSharedStoragePool().test_lu_hash"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_14","text":"def test_lu_hash(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_lu_ordering","text":"Show source in test_storage.py:535","title":"TestSharedStoragePool().test_lu_ordering"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_15","text":"def test_lu_ordering(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_name","text":"Show source in test_storage.py:434","title":"TestSharedStoragePool().test_name"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_16","text":"def test_name(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_over_commit_space","text":"Show source in test_storage.py:447","title":"TestSharedStoragePool().test_over_commit_space"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_17","text":"def test_over_commit_space(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_physical_volumes","text":"Show source in test_storage.py:453","title":"TestSharedStoragePool().test_physical_volumes"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_18","text":"def test_physical_volumes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_total_lu_size","text":"Show source in test_storage.py:450","title":"TestSharedStoragePool().test_total_lu_size"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_19","text":"def test_total_lu_size(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testsharedstoragepooltest_udid","text":"Show source in test_storage.py:437","title":"TestSharedStoragePool().test_udid"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_20","text":"def test_udid(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#teststoragetypes","text":"Show source in test_storage.py:729","title":"TestStorageTypes"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_21","text":"class TestStorageTypes(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#teststoragetypestest_fileio","text":"Show source in test_storage.py:730","title":"TestStorageTypes().test_fileio"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_22","text":"def test_fileio(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#teststoragetypestest_pv","text":"Show source in test_storage.py:802","title":"TestStorageTypes().test_pv"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_23","text":"def test_pv(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#teststoragetypestest_rbd","text":"Show source in test_storage.py:755","title":"TestStorageTypes().test_rbd"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_24","text":"def test_rbd(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#teststoragetypestest_vdisk","text":"Show source in test_storage.py:773","title":"TestStorageTypes().test_vdisk"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_25","text":"def test_vdisk(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testtargetdevs","text":"Show source in test_storage.py:666 Tests for VSCSIMapping.target_dev and {storage_type}TargetDev wrappers. SCSI mapping target devices in the test file are laid out as follows: index type LUA 0 LUTargetDev 0x8200000000000000 1 None - 2 None - 3 LUTargetDev 0x8400000000000000 4 LUTargetDev 0x8500000000000000 5 VOptTargetDev 0x8100000000000000 6 LUTargetDev 0x8300000000000000 7 PVTargetDev 0x8600000000000000 8 VDiskTargetDev 0x8700000000000000","title":"TestTargetDevs"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_26","text":"class TestTargetDevs(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testtargetdevstest_bld_set","text":"Show source in test_storage.py:711 Test *TargetDev.bld(lua) and setting VSCSIMapping.target_dev.","title":"TestTargetDevs().test_bld_set"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_27","text":"def test_bld_set(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testtargetdevstest_subtypes_props","text":"Show source in test_storage.py:685 Right subtypes and LUA gets/sets from VSCSIMapping.target_dev.","title":"TestTargetDevs().test_subtypes_props"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_28","text":"def test_subtypes_props(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testtier","text":"Show source in test_storage.py:414","title":"TestTier"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_29","text":"class TestTier(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testtiertest_props","text":"Show source in test_storage.py:418","title":"TestTier().test_props"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_30","text":"def test_props(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvfcclientadapter","text":"Show source in test_storage.py:591","title":"TestVFCClientAdapter"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_31","text":"class TestVFCClientAdapter(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvfcclientadaptertest_vfc_client_adapter","text":"Show source in test_storage.py:595 Check getters on VFCClientAdapter. The hard part - the wrapping - was done by TestWrapper.","title":"TestVFCClientAdapter().test_vfc_client_adapter"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_32","text":"def test_vfc_client_adapter(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvios","text":"Show source in test_storage.py:610","title":"TestVIOS"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_33","text":"class TestVIOS(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testviostest_bogus_pg83_in_pv","text":"Show source in test_storage.py:660 Bogus pg83 data in the doesn't trigger the Job.","title":"TestVIOS().test_bogus_pg83_in_pv"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_34","text":"def test_bogus_pg83_in_pv(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testviostest_pg83_absent_from_pv","text":"Show source in test_storage.py:624 LUARecovery.QUERY_INVENTORY when no pg83 in .","title":"TestVIOS().test_pg83_absent_from_pv"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_35","text":"@mock.patch(\"pypowervm.wrappers.job.Job.wrap\") def test_pg83_absent_from_pv(self, mock_wrap): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testviostest_pg83_in_pv","text":"Show source in test_storage.py:614 Legitimate pg83 data from the .","title":"TestVIOS().test_pg83_in_pv"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_36","text":"def test_pg83_in_pv(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testviostest_pg83_raises_if_no_parent_entry","text":"Show source in test_storage.py:653 Raise attempting to get pg83 if PV has no parent_entry.","title":"TestVIOS().test_pg83_raises_if_no_parent_entry"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_37","text":"def test_pg83_raises_if_no_parent_entry(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegroup","text":"Show source in test_storage.py:27","title":"TestVolumeGroup"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_38","text":"class TestVolumeGroup(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_add_lv","text":"Show source in test_storage.py:165 Duplicate of above with the LV alias.","title":"TestVolumeGroup().test_add_lv"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_39","text":"def test_add_lv(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_add_media_repo","text":"Show source in test_storage.py:213 Performs a simple add to the volume group of a new media repo.","title":"TestVolumeGroup().test_add_media_repo"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_40","text":"def test_add_media_repo(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_add_phys_vol","text":"Show source in test_storage.py:195 Performs a test flow that adds a physical volume to the vol grp.","title":"TestVolumeGroup().test_add_phys_vol"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_41","text":"def test_add_phys_vol(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_add_vdisk","text":"Show source in test_storage.py:122 Performs a test flow that adds a virtual disk.","title":"TestVolumeGroup().test_add_vdisk"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_42","text":"def test_add_vdisk(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_base","text":"Show source in test_storage.py:32 Tests baseline function within the Volume Group.","title":"TestVolumeGroup().test_base"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_43","text":"def test_base(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_bld","text":"Show source in test_storage.py:272","title":"TestVolumeGroup().test_bld"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_44","text":"def test_bld(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_ordering","text":"Show source in test_storage.py:254 Set fields out of order; ensure they end up in the right order.","title":"TestVolumeGroup().test_ordering"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_45","text":"def test_ordering(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_physical_volumes","text":"Show source in test_storage.py:58 Tests the physical volumes in the VG.","title":"TestVolumeGroup().test_physical_volumes"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_46","text":"def test_physical_volumes(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_update_media_repo","text":"Show source in test_storage.py:233 Performs a simple test to add optical media to an existing repo.","title":"TestVolumeGroup().test_update_media_repo"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_47","text":"def test_update_media_repo(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_virtual_disk","text":"Show source in test_storage.py:77 Tests the virtual disk gets.","title":"TestVolumeGroup().test_virtual_disk"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_48","text":"def test_virtual_disk(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_storage/#testvolumegrouptest_vmedia_repos","text":"Show source in test_storage.py:41 Tests the virtual media repositories.","title":"TestVolumeGroup().test_vmedia_repos"},{"location":"pypowervm/tests/wrappers/test_storage/#signature_49","text":"def test_vmedia_repos(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_vios_file/","text":"TestVIOSFile Pypowervm Index / Pypowervm / Tests / Wrappers / TestVIOSFile Auto-generated documentation for pypowervm.tests.wrappers.test_vios_file module. TestVIOSFile TestVIOSFile TestVIOSFile().test_file TestVIOSFile().test_wrapper_class TestVIOSFile Show source in test_vios_file.py:22 Signature class TestVIOSFile(twrap.TestWrapper): ... TestVIOSFile().test_file Show source in test_vios_file.py:33 Signature def test_file(self): ... TestVIOSFile().test_wrapper_class Show source in test_vios_file.py:27 Signature def test_wrapper_class(self): ...","title":"TestVIOSFile"},{"location":"pypowervm/tests/wrappers/test_vios_file/#testviosfile","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / TestVIOSFile Auto-generated documentation for pypowervm.tests.wrappers.test_vios_file module. TestVIOSFile TestVIOSFile TestVIOSFile().test_file TestVIOSFile().test_wrapper_class","title":"TestVIOSFile"},{"location":"pypowervm/tests/wrappers/test_vios_file/#testviosfile_1","text":"Show source in test_vios_file.py:22","title":"TestVIOSFile"},{"location":"pypowervm/tests/wrappers/test_vios_file/#signature","text":"class TestVIOSFile(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_vios_file/#testviosfiletest_file","text":"Show source in test_vios_file.py:33","title":"TestVIOSFile().test_file"},{"location":"pypowervm/tests/wrappers/test_vios_file/#signature_1","text":"def test_file(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_vios_file/#testviosfiletest_wrapper_class","text":"Show source in test_vios_file.py:27","title":"TestVIOSFile().test_wrapper_class"},{"location":"pypowervm/tests/wrappers/test_vios_file/#signature_2","text":"def test_wrapper_class(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/","text":"Test Virtual Io Server Pypowervm Index / Pypowervm / Tests / Wrappers / Test Virtual Io Server Auto-generated documentation for pypowervm.tests.wrappers.test_virtual_io_server module. Test Virtual Io Server TestCrtRelatedHref TestCrtRelatedHref().test_crt_related_href TestFeed3 TestFeed3().test_vivify_io_adpts_for_link_agg TestFeed3().test_xags TestGenericIOAdapter TestGenericIOAdapter().setUp TestGenericIOAdapter().test_attrs TestIOAdapterChoices TestIOAdapterChoices().setUp TestIOAdapterChoices().test_adapter_choices TestIOSlots TestIOSlots().setUp TestIOSlots().test_attrs TestIOSlots().test_bld TestIOSlots().test_io_adpt TestIOSlots().test_io_slots_setter TestPartitionIOConfiguration TestPartitionIOConfiguration().setUp TestPartitionIOConfiguration().test_io_slots TestPartitionIOConfiguration().test_max_slots TestPhysFCAdapter TestPhysFCAdapter().setUp TestPhysFCAdapter().test_attrs TestPhysFCAdapter().test_fc_ports TestPhysFCPort TestPhysFCPort().setUp TestPhysFCPort().test_attrs TestVIOSWrapper TestVIOSWrapper().test_derive_orphan_trunk_adapters TestVIOSWrapper().test_get_ip_addresses TestVIOSWrapper().test_hdisk_from_uuid_found TestVIOSWrapper().test_hdisk_from_uuid_notfound TestVIOSWrapper().test_hdisk_reserve_policy_found TestVIOSWrapper().test_hdisk_reserve_policy_notfound TestVIOSWrapper().test_license_accept TestVIOSWrapper().test_mover_service_partition TestVIOSWrapper().test_pfc_ports TestVIOSWrapper().test_phys_vols TestVIOSWrapper().test_rmc_ip TestVIOSWrapper().test_seas TestVIOSWrapper().test_trunks TestVIOSWrapper().test_update_timeout TestVIOSWrapper().test_vnic_capabilities TestVIOSWrapper().test_wwpns TestVSCSIBus TestVSCSIBus().test_bld TestVSCSIBus().test_bld_from_existing TestVSCSIBus().test_mappings TestVSCSIBus().test_props TestViosMappings TestViosMappings().setUp TestViosMappings().test_bld_scsi_mapping_from_existing TestViosMappings().test_bld_scsi_mapping_lu TestViosMappings().test_bld_scsi_mapping_pv TestViosMappings().test_bld_scsi_mapping_vdisk TestViosMappings().test_bld_scsi_mapping_vopt TestViosMappings().test_bld_vfc_mapping TestViosMappings().test_bld_vfc_mapping_with_slot TestViosMappings().test_clone_scsi_mapping_no_storage TestViosMappings().test_get_scsi_mappings TestViosMappings().test_vfc_mappings TestCrtRelatedHref Show source in test_virtual_io_server.py:567 Signature class TestCrtRelatedHref(unittest.TestCase): ... TestCrtRelatedHref().test_crt_related_href Show source in test_virtual_io_server.py:568 Tests to make sure that related elements are well formed. Signature @mock.patch(\"pypowervm.adapter.Session\") def test_crt_related_href(self, mock_sess): ... TestFeed3 Show source in test_virtual_io_server.py:831 Tests that specifically need fake_vios_feed3.txt Signature class TestFeed3(twrap.TestWrapper): ... TestFeed3().test_vivify_io_adpts_for_link_agg Show source in test_virtual_io_server.py:836 Vivifying FreeIOAdaptersForLinkAggregation adds the Network xag. Signature def test_vivify_io_adpts_for_link_agg(self): ... TestFeed3().test_xags Show source in test_virtual_io_server.py:849 Test deprecated extented attribute groups on the VIOS class. This can be removed once VIOS.xags is removed. Signature @mock.patch(\"warnings.warn\") def test_xags(self, mock_warn): ... TestGenericIOAdapter Show source in test_virtual_io_server.py:736 Signature class TestGenericIOAdapter(twrap.TestWrapper): ... TestGenericIOAdapter().setUp Show source in test_virtual_io_server.py:741 Signature def setUp(self): ... TestGenericIOAdapter().test_attrs Show source in test_virtual_io_server.py:745 Signature def test_attrs(self): ... TestIOAdapterChoices Show source in test_virtual_io_server.py:806 Signature class TestIOAdapterChoices(twrap.TestWrapper): ... TestIOAdapterChoices().setUp Show source in test_virtual_io_server.py:811 Signature def setUp(self): ... TestIOAdapterChoices().test_adapter_choices Show source in test_virtual_io_server.py:815 Signature def test_adapter_choices(self): ... TestIOSlots Show source in test_virtual_io_server.py:687 Signature class TestIOSlots(twrap.TestWrapper): ... TestIOSlots().setUp Show source in test_virtual_io_server.py:692 Signature def setUp(self): ... TestIOSlots().test_attrs Show source in test_virtual_io_server.py:696 Signature def test_attrs(self): ... TestIOSlots().test_bld Show source in test_virtual_io_server.py:729 Signature def test_bld(self): ... TestIOSlots().test_io_adpt Show source in test_virtual_io_server.py:722 Signature @mock.patch(\"warnings.warn\") def test_io_adpt(self, mock_warn): ... TestIOSlots().test_io_slots_setter Show source in test_virtual_io_server.py:713 Signature def test_io_slots_setter(self): ... TestPartitionIOConfiguration Show source in test_virtual_io_server.py:668 Signature class TestPartitionIOConfiguration(twrap.TestWrapper): ... TestPartitionIOConfiguration().setUp Show source in test_virtual_io_server.py:673 Signature def setUp(self): ... TestPartitionIOConfiguration().test_io_slots Show source in test_virtual_io_server.py:680 Signature def test_io_slots(self): ... TestPartitionIOConfiguration().test_max_slots Show source in test_virtual_io_server.py:677 Signature def test_max_slots(self): ... TestPhysFCAdapter Show source in test_virtual_io_server.py:756 Signature class TestPhysFCAdapter(twrap.TestWrapper): ... TestPhysFCAdapter().setUp Show source in test_virtual_io_server.py:761 Signature def setUp(self): ... TestPhysFCAdapter().test_attrs Show source in test_virtual_io_server.py:765 Signature def test_attrs(self): ... TestPhysFCAdapter().test_fc_ports Show source in test_virtual_io_server.py:776 Signature def test_fc_ports(self): ... TestPhysFCPort Show source in test_virtual_io_server.py:780 Signature class TestPhysFCPort(twrap.TestWrapper): ... TestPhysFCPort().setUp Show source in test_virtual_io_server.py:785 Signature def setUp(self): ... TestPhysFCPort().test_attrs Show source in test_virtual_io_server.py:790 Signature def test_attrs(self): ... TestVIOSWrapper Show source in test_virtual_io_server.py:29 Signature class TestVIOSWrapper(twrap.TestWrapper): ... TestVIOSWrapper().test_derive_orphan_trunk_adapters Show source in test_virtual_io_server.py:106 Signature def test_derive_orphan_trunk_adapters(self): ... TestVIOSWrapper().test_get_ip_addresses Show source in test_virtual_io_server.py:53 Signature def test_get_ip_addresses(self): ... TestVIOSWrapper().test_hdisk_from_uuid_found Show source in test_virtual_io_server.py:85 Signature def test_hdisk_from_uuid_found(self): ... TestVIOSWrapper().test_hdisk_from_uuid_notfound Show source in test_virtual_io_server.py:90 Signature def test_hdisk_from_uuid_notfound(self): ... TestVIOSWrapper().test_hdisk_reserve_policy_found Show source in test_virtual_io_server.py:72 Signature def test_hdisk_reserve_policy_found(self): ... TestVIOSWrapper().test_hdisk_reserve_policy_notfound Show source in test_virtual_io_server.py:79 Signature def test_hdisk_reserve_policy_notfound(self): ... TestVIOSWrapper().test_license_accept Show source in test_virtual_io_server.py:65 Signature def test_license_accept(self): ... TestVIOSWrapper().test_mover_service_partition Show source in test_virtual_io_server.py:57 Signature def test_mover_service_partition(self): ... TestVIOSWrapper().test_pfc_ports Show source in test_virtual_io_server.py:127 Tests that the physical FC ports can be gathered. Signature def test_pfc_ports(self): ... TestVIOSWrapper().test_phys_vols Show source in test_virtual_io_server.py:141 Tests that the physical volumes can be gathered. Signature def test_phys_vols(self): ... TestVIOSWrapper().test_rmc_ip Show source in test_virtual_io_server.py:62 Signature def test_rmc_ip(self): ... TestVIOSWrapper().test_seas Show source in test_virtual_io_server.py:94 Signature def test_seas(self): ... TestVIOSWrapper().test_trunks Show source in test_virtual_io_server.py:100 Signature def test_trunks(self): ... TestVIOSWrapper().test_update_timeout Show source in test_virtual_io_server.py:34 Signature def test_update_timeout(self): ... TestVIOSWrapper().test_vnic_capabilities Show source in test_virtual_io_server.py:68 Signature def test_vnic_capabilities(self): ... TestVIOSWrapper().test_wwpns Show source in test_virtual_io_server.py:111 Tests the helper methods to get WWPNs more easily. Signature def test_wwpns(self): ... TestVSCSIBus Show source in test_virtual_io_server.py:582 Signature class TestVSCSIBus(twrap.TestWrapper): ... TestVSCSIBus().test_bld Show source in test_virtual_io_server.py:609 Signature def test_bld(self): ... TestVSCSIBus().test_bld_from_existing Show source in test_virtual_io_server.py:627 Signature def test_bld_from_existing(self): ... TestVSCSIBus().test_mappings Show source in test_virtual_io_server.py:639 Signature def test_mappings(self): ... TestVSCSIBus().test_props Show source in test_virtual_io_server.py:586 Signature def test_props(self): ... TestViosMappings Show source in test_virtual_io_server.py:163 Signature class TestViosMappings(twrap.TestWrapper): ... TestViosMappings().setUp Show source in test_virtual_io_server.py:169 Signature def setUp(self): ... TestViosMappings().test_bld_scsi_mapping_from_existing Show source in test_virtual_io_server.py:514 Signature def test_bld_scsi_mapping_from_existing(self): ... TestViosMappings().test_bld_scsi_mapping_lu Show source in test_virtual_io_server.py:281 Validation that the element is correct. Signature def test_bld_scsi_mapping_lu(self): ... TestViosMappings().test_bld_scsi_mapping_pv Show source in test_virtual_io_server.py:313 Validation that the element is correct. Signature def test_bld_scsi_mapping_pv(self): ... TestViosMappings().test_bld_scsi_mapping_vdisk Show source in test_virtual_io_server.py:242 Validation that the element is correct. Signature def test_bld_scsi_mapping_vdisk(self): ... TestViosMappings().test_bld_scsi_mapping_vopt Show source in test_virtual_io_server.py:173 Validation that the element is correct. Signature def test_bld_scsi_mapping_vopt(self): ... TestViosMappings().test_bld_vfc_mapping Show source in test_virtual_io_server.py:477 Signature def test_bld_vfc_mapping(self): ... TestViosMappings().test_bld_vfc_mapping_with_slot Show source in test_virtual_io_server.py:492 Signature def test_bld_vfc_mapping_with_slot(self): ... TestViosMappings().test_clone_scsi_mapping_no_storage Show source in test_virtual_io_server.py:351 Clone a VSCSI mapping with no storage element. Signature def test_clone_scsi_mapping_no_storage(self): ... TestViosMappings().test_get_scsi_mappings Show source in test_virtual_io_server.py:370 Signature def test_get_scsi_mappings(self): ... TestViosMappings().test_vfc_mappings Show source in test_virtual_io_server.py:420 Signature def test_vfc_mappings(self): ...","title":"Test Virtual Io Server"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#test-virtual-io-server","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Virtual Io Server Auto-generated documentation for pypowervm.tests.wrappers.test_virtual_io_server module. Test Virtual Io Server TestCrtRelatedHref TestCrtRelatedHref().test_crt_related_href TestFeed3 TestFeed3().test_vivify_io_adpts_for_link_agg TestFeed3().test_xags TestGenericIOAdapter TestGenericIOAdapter().setUp TestGenericIOAdapter().test_attrs TestIOAdapterChoices TestIOAdapterChoices().setUp TestIOAdapterChoices().test_adapter_choices TestIOSlots TestIOSlots().setUp TestIOSlots().test_attrs TestIOSlots().test_bld TestIOSlots().test_io_adpt TestIOSlots().test_io_slots_setter TestPartitionIOConfiguration TestPartitionIOConfiguration().setUp TestPartitionIOConfiguration().test_io_slots TestPartitionIOConfiguration().test_max_slots TestPhysFCAdapter TestPhysFCAdapter().setUp TestPhysFCAdapter().test_attrs TestPhysFCAdapter().test_fc_ports TestPhysFCPort TestPhysFCPort().setUp TestPhysFCPort().test_attrs TestVIOSWrapper TestVIOSWrapper().test_derive_orphan_trunk_adapters TestVIOSWrapper().test_get_ip_addresses TestVIOSWrapper().test_hdisk_from_uuid_found TestVIOSWrapper().test_hdisk_from_uuid_notfound TestVIOSWrapper().test_hdisk_reserve_policy_found TestVIOSWrapper().test_hdisk_reserve_policy_notfound TestVIOSWrapper().test_license_accept TestVIOSWrapper().test_mover_service_partition TestVIOSWrapper().test_pfc_ports TestVIOSWrapper().test_phys_vols TestVIOSWrapper().test_rmc_ip TestVIOSWrapper().test_seas TestVIOSWrapper().test_trunks TestVIOSWrapper().test_update_timeout TestVIOSWrapper().test_vnic_capabilities TestVIOSWrapper().test_wwpns TestVSCSIBus TestVSCSIBus().test_bld TestVSCSIBus().test_bld_from_existing TestVSCSIBus().test_mappings TestVSCSIBus().test_props TestViosMappings TestViosMappings().setUp TestViosMappings().test_bld_scsi_mapping_from_existing TestViosMappings().test_bld_scsi_mapping_lu TestViosMappings().test_bld_scsi_mapping_pv TestViosMappings().test_bld_scsi_mapping_vdisk TestViosMappings().test_bld_scsi_mapping_vopt TestViosMappings().test_bld_vfc_mapping TestViosMappings().test_bld_vfc_mapping_with_slot TestViosMappings().test_clone_scsi_mapping_no_storage TestViosMappings().test_get_scsi_mappings TestViosMappings().test_vfc_mappings","title":"Test Virtual Io Server"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testcrtrelatedhref","text":"Show source in test_virtual_io_server.py:567","title":"TestCrtRelatedHref"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature","text":"class TestCrtRelatedHref(unittest.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testcrtrelatedhreftest_crt_related_href","text":"Show source in test_virtual_io_server.py:568 Tests to make sure that related elements are well formed.","title":"TestCrtRelatedHref().test_crt_related_href"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_1","text":"@mock.patch(\"pypowervm.adapter.Session\") def test_crt_related_href(self, mock_sess): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testfeed3","text":"Show source in test_virtual_io_server.py:831 Tests that specifically need fake_vios_feed3.txt","title":"TestFeed3"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_2","text":"class TestFeed3(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testfeed3test_vivify_io_adpts_for_link_agg","text":"Show source in test_virtual_io_server.py:836 Vivifying FreeIOAdaptersForLinkAggregation adds the Network xag.","title":"TestFeed3().test_vivify_io_adpts_for_link_agg"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_3","text":"def test_vivify_io_adpts_for_link_agg(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testfeed3test_xags","text":"Show source in test_virtual_io_server.py:849 Test deprecated extented attribute groups on the VIOS class. This can be removed once VIOS.xags is removed.","title":"TestFeed3().test_xags"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_4","text":"@mock.patch(\"warnings.warn\") def test_xags(self, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testgenericioadapter","text":"Show source in test_virtual_io_server.py:736","title":"TestGenericIOAdapter"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_5","text":"class TestGenericIOAdapter(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testgenericioadaptersetup","text":"Show source in test_virtual_io_server.py:741","title":"TestGenericIOAdapter().setUp"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_6","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testgenericioadaptertest_attrs","text":"Show source in test_virtual_io_server.py:745","title":"TestGenericIOAdapter().test_attrs"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_7","text":"def test_attrs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testioadapterchoices","text":"Show source in test_virtual_io_server.py:806","title":"TestIOAdapterChoices"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_8","text":"class TestIOAdapterChoices(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testioadapterchoicessetup","text":"Show source in test_virtual_io_server.py:811","title":"TestIOAdapterChoices().setUp"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_9","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testioadapterchoicestest_adapter_choices","text":"Show source in test_virtual_io_server.py:815","title":"TestIOAdapterChoices().test_adapter_choices"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_10","text":"def test_adapter_choices(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testioslots","text":"Show source in test_virtual_io_server.py:687","title":"TestIOSlots"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_11","text":"class TestIOSlots(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testioslotssetup","text":"Show source in test_virtual_io_server.py:692","title":"TestIOSlots().setUp"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_12","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testioslotstest_attrs","text":"Show source in test_virtual_io_server.py:696","title":"TestIOSlots().test_attrs"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_13","text":"def test_attrs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testioslotstest_bld","text":"Show source in test_virtual_io_server.py:729","title":"TestIOSlots().test_bld"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_14","text":"def test_bld(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testioslotstest_io_adpt","text":"Show source in test_virtual_io_server.py:722","title":"TestIOSlots().test_io_adpt"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_15","text":"@mock.patch(\"warnings.warn\") def test_io_adpt(self, mock_warn): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testioslotstest_io_slots_setter","text":"Show source in test_virtual_io_server.py:713","title":"TestIOSlots().test_io_slots_setter"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_16","text":"def test_io_slots_setter(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testpartitionioconfiguration","text":"Show source in test_virtual_io_server.py:668","title":"TestPartitionIOConfiguration"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_17","text":"class TestPartitionIOConfiguration(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testpartitionioconfigurationsetup","text":"Show source in test_virtual_io_server.py:673","title":"TestPartitionIOConfiguration().setUp"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_18","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testpartitionioconfigurationtest_io_slots","text":"Show source in test_virtual_io_server.py:680","title":"TestPartitionIOConfiguration().test_io_slots"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_19","text":"def test_io_slots(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testpartitionioconfigurationtest_max_slots","text":"Show source in test_virtual_io_server.py:677","title":"TestPartitionIOConfiguration().test_max_slots"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_20","text":"def test_max_slots(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testphysfcadapter","text":"Show source in test_virtual_io_server.py:756","title":"TestPhysFCAdapter"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_21","text":"class TestPhysFCAdapter(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testphysfcadaptersetup","text":"Show source in test_virtual_io_server.py:761","title":"TestPhysFCAdapter().setUp"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_22","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testphysfcadaptertest_attrs","text":"Show source in test_virtual_io_server.py:765","title":"TestPhysFCAdapter().test_attrs"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_23","text":"def test_attrs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testphysfcadaptertest_fc_ports","text":"Show source in test_virtual_io_server.py:776","title":"TestPhysFCAdapter().test_fc_ports"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_24","text":"def test_fc_ports(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testphysfcport","text":"Show source in test_virtual_io_server.py:780","title":"TestPhysFCPort"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_25","text":"class TestPhysFCPort(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testphysfcportsetup","text":"Show source in test_virtual_io_server.py:785","title":"TestPhysFCPort().setUp"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_26","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testphysfcporttest_attrs","text":"Show source in test_virtual_io_server.py:790","title":"TestPhysFCPort().test_attrs"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_27","text":"def test_attrs(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrapper","text":"Show source in test_virtual_io_server.py:29","title":"TestVIOSWrapper"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_28","text":"class TestVIOSWrapper(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_derive_orphan_trunk_adapters","text":"Show source in test_virtual_io_server.py:106","title":"TestVIOSWrapper().test_derive_orphan_trunk_adapters"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_29","text":"def test_derive_orphan_trunk_adapters(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_get_ip_addresses","text":"Show source in test_virtual_io_server.py:53","title":"TestVIOSWrapper().test_get_ip_addresses"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_30","text":"def test_get_ip_addresses(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_hdisk_from_uuid_found","text":"Show source in test_virtual_io_server.py:85","title":"TestVIOSWrapper().test_hdisk_from_uuid_found"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_31","text":"def test_hdisk_from_uuid_found(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_hdisk_from_uuid_notfound","text":"Show source in test_virtual_io_server.py:90","title":"TestVIOSWrapper().test_hdisk_from_uuid_notfound"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_32","text":"def test_hdisk_from_uuid_notfound(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_hdisk_reserve_policy_found","text":"Show source in test_virtual_io_server.py:72","title":"TestVIOSWrapper().test_hdisk_reserve_policy_found"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_33","text":"def test_hdisk_reserve_policy_found(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_hdisk_reserve_policy_notfound","text":"Show source in test_virtual_io_server.py:79","title":"TestVIOSWrapper().test_hdisk_reserve_policy_notfound"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_34","text":"def test_hdisk_reserve_policy_notfound(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_license_accept","text":"Show source in test_virtual_io_server.py:65","title":"TestVIOSWrapper().test_license_accept"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_35","text":"def test_license_accept(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_mover_service_partition","text":"Show source in test_virtual_io_server.py:57","title":"TestVIOSWrapper().test_mover_service_partition"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_36","text":"def test_mover_service_partition(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_pfc_ports","text":"Show source in test_virtual_io_server.py:127 Tests that the physical FC ports can be gathered.","title":"TestVIOSWrapper().test_pfc_ports"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_37","text":"def test_pfc_ports(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_phys_vols","text":"Show source in test_virtual_io_server.py:141 Tests that the physical volumes can be gathered.","title":"TestVIOSWrapper().test_phys_vols"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_38","text":"def test_phys_vols(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_rmc_ip","text":"Show source in test_virtual_io_server.py:62","title":"TestVIOSWrapper().test_rmc_ip"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_39","text":"def test_rmc_ip(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_seas","text":"Show source in test_virtual_io_server.py:94","title":"TestVIOSWrapper().test_seas"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_40","text":"def test_seas(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_trunks","text":"Show source in test_virtual_io_server.py:100","title":"TestVIOSWrapper().test_trunks"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_41","text":"def test_trunks(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_update_timeout","text":"Show source in test_virtual_io_server.py:34","title":"TestVIOSWrapper().test_update_timeout"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_42","text":"def test_update_timeout(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_vnic_capabilities","text":"Show source in test_virtual_io_server.py:68","title":"TestVIOSWrapper().test_vnic_capabilities"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_43","text":"def test_vnic_capabilities(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvioswrappertest_wwpns","text":"Show source in test_virtual_io_server.py:111 Tests the helper methods to get WWPNs more easily.","title":"TestVIOSWrapper().test_wwpns"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_44","text":"def test_wwpns(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvscsibus","text":"Show source in test_virtual_io_server.py:582","title":"TestVSCSIBus"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_45","text":"class TestVSCSIBus(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvscsibustest_bld","text":"Show source in test_virtual_io_server.py:609","title":"TestVSCSIBus().test_bld"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_46","text":"def test_bld(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvscsibustest_bld_from_existing","text":"Show source in test_virtual_io_server.py:627","title":"TestVSCSIBus().test_bld_from_existing"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_47","text":"def test_bld_from_existing(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvscsibustest_mappings","text":"Show source in test_virtual_io_server.py:639","title":"TestVSCSIBus().test_mappings"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_48","text":"def test_mappings(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testvscsibustest_props","text":"Show source in test_virtual_io_server.py:586","title":"TestVSCSIBus().test_props"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_49","text":"def test_props(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappings","text":"Show source in test_virtual_io_server.py:163","title":"TestViosMappings"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_50","text":"class TestViosMappings(twrap.TestWrapper): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingssetup","text":"Show source in test_virtual_io_server.py:169","title":"TestViosMappings().setUp"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_51","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingstest_bld_scsi_mapping_from_existing","text":"Show source in test_virtual_io_server.py:514","title":"TestViosMappings().test_bld_scsi_mapping_from_existing"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_52","text":"def test_bld_scsi_mapping_from_existing(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingstest_bld_scsi_mapping_lu","text":"Show source in test_virtual_io_server.py:281 Validation that the element is correct.","title":"TestViosMappings().test_bld_scsi_mapping_lu"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_53","text":"def test_bld_scsi_mapping_lu(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingstest_bld_scsi_mapping_pv","text":"Show source in test_virtual_io_server.py:313 Validation that the element is correct.","title":"TestViosMappings().test_bld_scsi_mapping_pv"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_54","text":"def test_bld_scsi_mapping_pv(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingstest_bld_scsi_mapping_vdisk","text":"Show source in test_virtual_io_server.py:242 Validation that the element is correct.","title":"TestViosMappings().test_bld_scsi_mapping_vdisk"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_55","text":"def test_bld_scsi_mapping_vdisk(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingstest_bld_scsi_mapping_vopt","text":"Show source in test_virtual_io_server.py:173 Validation that the element is correct.","title":"TestViosMappings().test_bld_scsi_mapping_vopt"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_56","text":"def test_bld_scsi_mapping_vopt(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingstest_bld_vfc_mapping","text":"Show source in test_virtual_io_server.py:477","title":"TestViosMappings().test_bld_vfc_mapping"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_57","text":"def test_bld_vfc_mapping(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingstest_bld_vfc_mapping_with_slot","text":"Show source in test_virtual_io_server.py:492","title":"TestViosMappings().test_bld_vfc_mapping_with_slot"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_58","text":"def test_bld_vfc_mapping_with_slot(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingstest_clone_scsi_mapping_no_storage","text":"Show source in test_virtual_io_server.py:351 Clone a VSCSI mapping with no storage element.","title":"TestViosMappings().test_clone_scsi_mapping_no_storage"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_59","text":"def test_clone_scsi_mapping_no_storage(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingstest_get_scsi_mappings","text":"Show source in test_virtual_io_server.py:370","title":"TestViosMappings().test_get_scsi_mappings"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_60","text":"def test_get_scsi_mappings(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#testviosmappingstest_vfc_mappings","text":"Show source in test_virtual_io_server.py:420","title":"TestViosMappings().test_vfc_mappings"},{"location":"pypowervm/tests/wrappers/test_virtual_io_server/#signature_61","text":"def test_vfc_mappings(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/","text":"Test Wrapper Properties Pypowervm Index / Pypowervm / Tests / Wrappers / Test Wrapper Properties Auto-generated documentation for pypowervm.tests.wrappers.test_wrapper_properties module. Test Wrapper Properties TestXAGs TestXAGs().test_wrapper_registration TestXAGs().test_xags TestXAGs().verify_xags TestXAGs Show source in test_wrapper_properties.py:32 Signature class TestXAGs(testtools.TestCase): ... TestXAGs().test_wrapper_registration Show source in test_wrapper_properties.py:91 All wrapper subclasses must be registered via [base_]pvm_type. Signature def test_wrapper_registration(self): ... TestXAGs().test_xags Show source in test_wrapper_properties.py:52 Verify xags associated with properties of wrapper classes. Signature def test_xags(self): ... TestXAGs().verify_xags Show source in test_wrapper_properties.py:34 Verify extended attribute groups for properties of a wrapper class. Arguments wcls - The pypowervm.wrappers.entry_wrapper.Wrapper subclass to test. expected_xags - A dict mapping wcls's property names to their respective extended attribute group names. Can (should) only include those properties for which an extended attribute group is registered. (If it contains any other properties, the value must be None.) Format is { prop_name: xag_name } Signature def verify_xags(self, wcls, expected_xags): ...","title":"Test Wrapper Properties"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/#test-wrapper-properties","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Test Wrapper Properties Auto-generated documentation for pypowervm.tests.wrappers.test_wrapper_properties module. Test Wrapper Properties TestXAGs TestXAGs().test_wrapper_registration TestXAGs().test_xags TestXAGs().verify_xags","title":"Test Wrapper Properties"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/#testxags","text":"Show source in test_wrapper_properties.py:32","title":"TestXAGs"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/#signature","text":"class TestXAGs(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/#testxagstest_wrapper_registration","text":"Show source in test_wrapper_properties.py:91 All wrapper subclasses must be registered via [base_]pvm_type.","title":"TestXAGs().test_wrapper_registration"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/#signature_1","text":"def test_wrapper_registration(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/#testxagstest_xags","text":"Show source in test_wrapper_properties.py:52 Verify xags associated with properties of wrapper classes.","title":"TestXAGs().test_xags"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/#signature_2","text":"def test_xags(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/#testxagsverify_xags","text":"Show source in test_wrapper_properties.py:34 Verify extended attribute groups for properties of a wrapper class.","title":"TestXAGs().verify_xags"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/#arguments","text":"wcls - The pypowervm.wrappers.entry_wrapper.Wrapper subclass to test. expected_xags - A dict mapping wcls's property names to their respective extended attribute group names. Can (should) only include those properties for which an extended attribute group is registered. (If it contains any other properties, the value must be None.) Format is { prop_name: xag_name }","title":"Arguments"},{"location":"pypowervm/tests/wrappers/test_wrapper_properties/#signature_3","text":"def verify_xags(self, wcls, expected_xags): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/","text":"Pcm Pypowervm Index / Pypowervm / Tests / Wrappers / Pcm Auto-generated documentation for pypowervm.tests.wrappers.pcm module. Pcm Modules Modules Test Lpar Test Phyp Test Vios","title":"Pcm"},{"location":"pypowervm/tests/wrappers/pcm/#pcm","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Pcm Auto-generated documentation for pypowervm.tests.wrappers.pcm module. Pcm Modules","title":"Pcm"},{"location":"pypowervm/tests/wrappers/pcm/#modules","text":"Test Lpar Test Phyp Test Vios","title":"Modules"},{"location":"pypowervm/tests/wrappers/pcm/test_lpar/","text":"Test Lpar Pypowervm Index / Pypowervm / Tests / Wrappers / Pcm / Test Lpar Auto-generated documentation for pypowervm.tests.wrappers.pcm.test_lpar module. Test Lpar TestLparLTM TestLparLTM().setUp TestLparLTM().test_parse TestLparLTM Show source in test_lpar.py:28 Signature class TestLparLTM(testtools.TestCase): ... TestLparLTM().setUp Show source in test_lpar.py:30 Signature def setUp(self): ... TestLparLTM().test_parse Show source in test_lpar.py:34 Signature def test_parse(self): ...","title":"Test Lpar"},{"location":"pypowervm/tests/wrappers/pcm/test_lpar/#test-lpar","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Pcm / Test Lpar Auto-generated documentation for pypowervm.tests.wrappers.pcm.test_lpar module. Test Lpar TestLparLTM TestLparLTM().setUp TestLparLTM().test_parse","title":"Test Lpar"},{"location":"pypowervm/tests/wrappers/pcm/test_lpar/#testlparltm","text":"Show source in test_lpar.py:28","title":"TestLparLTM"},{"location":"pypowervm/tests/wrappers/pcm/test_lpar/#signature","text":"class TestLparLTM(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_lpar/#testlparltmsetup","text":"Show source in test_lpar.py:30","title":"TestLparLTM().setUp"},{"location":"pypowervm/tests/wrappers/pcm/test_lpar/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_lpar/#testlparltmtest_parse","text":"Show source in test_lpar.py:34","title":"TestLparLTM().test_parse"},{"location":"pypowervm/tests/wrappers/pcm/test_lpar/#signature_2","text":"def test_parse(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_phyp/","text":"Test Phyp Pypowervm Index / Pypowervm / Tests / Wrappers / Pcm / Test Phyp Auto-generated documentation for pypowervm.tests.wrappers.pcm.test_phyp module. Test Phyp TestPhypLTM TestPhypLTM().setUp TestPhypLTM().test_parse TestPhypLTM Show source in test_phyp.py:27 Signature class TestPhypLTM(testtools.TestCase): ... TestPhypLTM().setUp Show source in test_phyp.py:29 Signature def setUp(self): ... TestPhypLTM().test_parse Show source in test_phyp.py:34 Signature def test_parse(self): ...","title":"Test Phyp"},{"location":"pypowervm/tests/wrappers/pcm/test_phyp/#test-phyp","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Pcm / Test Phyp Auto-generated documentation for pypowervm.tests.wrappers.pcm.test_phyp module. Test Phyp TestPhypLTM TestPhypLTM().setUp TestPhypLTM().test_parse","title":"Test Phyp"},{"location":"pypowervm/tests/wrappers/pcm/test_phyp/#testphypltm","text":"Show source in test_phyp.py:27","title":"TestPhypLTM"},{"location":"pypowervm/tests/wrappers/pcm/test_phyp/#signature","text":"class TestPhypLTM(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_phyp/#testphypltmsetup","text":"Show source in test_phyp.py:29","title":"TestPhypLTM().setUp"},{"location":"pypowervm/tests/wrappers/pcm/test_phyp/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_phyp/#testphypltmtest_parse","text":"Show source in test_phyp.py:34","title":"TestPhypLTM().test_parse"},{"location":"pypowervm/tests/wrappers/pcm/test_phyp/#signature_2","text":"def test_parse(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/","text":"Test Vios Pypowervm Index / Pypowervm / Tests / Wrappers / Pcm / Test Vios Auto-generated documentation for pypowervm.tests.wrappers.pcm.test_vios module. Test Vios TestViosLTM TestViosLTM().setUp TestViosLTM().test_parse TestViosLTMSparse TestViosLTMSparse().setUp TestViosLTMSparse().test_parse TestViosLTM Show source in test_vios.py:28 Signature class TestViosLTM(testtools.TestCase): ... TestViosLTM().setUp Show source in test_vios.py:30 Signature def setUp(self): ... TestViosLTM().test_parse Show source in test_vios.py:35 Signature def test_parse(self): ... TestViosLTMSparse Show source in test_vios.py:137 Signature class TestViosLTMSparse(testtools.TestCase): ... TestViosLTMSparse().setUp Show source in test_vios.py:139 Signature def setUp(self): ... TestViosLTMSparse().test_parse Show source in test_vios.py:144 Signature def test_parse(self): ...","title":"Test Vios"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#test-vios","text":"Pypowervm Index / Pypowervm / Tests / Wrappers / Pcm / Test Vios Auto-generated documentation for pypowervm.tests.wrappers.pcm.test_vios module. Test Vios TestViosLTM TestViosLTM().setUp TestViosLTM().test_parse TestViosLTMSparse TestViosLTMSparse().setUp TestViosLTMSparse().test_parse","title":"Test Vios"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#testviosltm","text":"Show source in test_vios.py:28","title":"TestViosLTM"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#signature","text":"class TestViosLTM(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#testviosltmsetup","text":"Show source in test_vios.py:30","title":"TestViosLTM().setUp"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#signature_1","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#testviosltmtest_parse","text":"Show source in test_vios.py:35","title":"TestViosLTM().test_parse"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#signature_2","text":"def test_parse(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#testviosltmsparse","text":"Show source in test_vios.py:137","title":"TestViosLTMSparse"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#signature_3","text":"class TestViosLTMSparse(testtools.TestCase): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#testviosltmsparsesetup","text":"Show source in test_vios.py:139","title":"TestViosLTMSparse().setUp"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#signature_4","text":"def setUp(self): ...","title":"Signature"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#testviosltmsparsetest_parse","text":"Show source in test_vios.py:144","title":"TestViosLTMSparse().test_parse"},{"location":"pypowervm/tests/wrappers/pcm/test_vios/#signature_5","text":"def test_parse(self): ...","title":"Signature"},{"location":"pypowervm/utils/","text":"Utils Pypowervm Index / Pypowervm / Utils Auto-generated documentation for pypowervm.utils module. Utils Modules Modules LPARBuilder Retry Transaction Uuid Validation Wrappers","title":"Utils"},{"location":"pypowervm/utils/#utils","text":"Pypowervm Index / Pypowervm / Utils Auto-generated documentation for pypowervm.utils module. Utils Modules","title":"Utils"},{"location":"pypowervm/utils/#modules","text":"LPARBuilder Retry Transaction Uuid Validation Wrappers","title":"Modules"},{"location":"pypowervm/utils/lpar_builder/","text":"LPARBuilder Pypowervm Index / Pypowervm / Utils / LPARBuilder Auto-generated documentation for pypowervm.utils.lpar_builder module. Attributes NAME - Dict keys used for input to the builder: 'name' ALLOWED_PPT_RATIOS - Contains the mapping of the ratio to REST accepted values. REST does not take the actual ratio value as argument, instead it takes an enumeration of accepted values starting from 0.: {'1:64': 0, '1:128': 1, '1:256': 2, '1:512': 3, '1:1024': 4, '1:2048': 5, '1:4096': 6} MAX_IO_SLOTS - I/O configuration Sure would love to change this to MAX_VIRT_IO_SLOTS or similar, but compat...: 'max_io_slots' ALT_LOAD_SRC - IBMi specific keys: 'alt_load_src' MINIMUM_ATTRS - The minimum attributes that must be supplied to create an LPAR: (NAME, MEM, VCPU) SHARED_PROC_KEYS - Keys that indicate that shared processors are being configured: PROC_UNITS_KEYS + (UNCAPPED_WEIGHT) DEF_PROC_UNIT_FACT - Defaults: 0.5 LPARBuilder AvailPriority BoolField BoolField.convert_value BoundField BoundField().validate ChoiceField ChoiceField.convert_value ChoiceField().validate DedProcShareMode DedicatedProc DefaultStandardize DefaultStandardize().ded_proc DefaultStandardize().general DefaultStandardize().io_config DefaultStandardize().memory DefaultStandardize().shr_proc EnableLparMetric EnforceAffinityCheck EnforceAffinityCheck().validate Field Field.convert_value Field().validate FloatBoundField IDBoundField IOSlots IntBoundField LPARBuilder LPARBuilder().build LPARBuilder().build_ded_proc LPARBuilder().build_io_config LPARBuilder().build_mem LPARBuilder().build_shr_proc LPARBuilder().rebuild LPARBuilderException LPARType Memory Memory().validate MinDesiredMaxField MinDesiredMaxField().validate PhysicalPageTableRatio PhysicalPageTableRatio.convert_value PhysicalPageTableRatio().validate ProcCompatMode ProcUnits RestrictedIO SecureBoot SecureBoot().validate SimplifiedRemoteRestart Standardize Standardize().ded_proc Standardize().general Standardize().io_config Standardize().memory Standardize().set_attr Standardize().shr_proc VCpu AvailPriority Show source in lpar_builder.py:784 Signature class AvailPriority(IntBoundField): ... See also IntBoundField BoolField Show source in lpar_builder.py:488 Facilitates validating boolean fields. Signature class BoolField(Field): ... See also Field BoolField.convert_value Show source in lpar_builder.py:492 Signature @classmethod def convert_value(cls, value): ... BoundField Show source in lpar_builder.py:535 Signature class BoundField(Field): ... See also Field BoundField().validate Show source in lpar_builder.py:539 Signature def validate(self): ... ChoiceField Show source in lpar_builder.py:506 Signature class ChoiceField(Field): ... See also Field ChoiceField.convert_value Show source in lpar_builder.py:509 Signature @classmethod def convert_value(cls, value): ... ChoiceField().validate Show source in lpar_builder.py:527 Signature def validate(self): ... DedProcShareMode Show source in lpar_builder.py:761 Signature class DedProcShareMode(ChoiceField): def __init__(self, value, allow_none=False): ... See also ChoiceField DedicatedProc Show source in lpar_builder.py:717 Signature class DedicatedProc(BoolField): ... See also BoolField DefaultStandardize Show source in lpar_builder.py:172 Default standardizer. This class implements the Standardize interface. It takes a simple approach for augmenting missing LPAR settings. It does reasonable validation of the LPAR attributes. It first validates the user input as-is, then fills in any missing attributes that are required and supported by the host. Finally, it validates what it's sending back to the caller. If any validation rules are missed, the PowerVM management interface will catch them and surface an error at that time. Signature class DefaultStandardize(Standardize): def __init__( self, mngd_sys, proc_units_factor=DEF_PROC_UNIT_FACT, max_slots=DEF_MAX_SLOT, uncapped_weight=DEF_UNCAPPED_WT, spp=DEF_SPP, avail_priority=DEF_AVAIL_PRI, srr=DEF_SRR, proc_compat=bp.LPARCompat.DEFAULT, enable_lpar_metric=DEF_LPAR_METRIC, secure_boot=DEF_SECURE_BOOT, ): ... See also DEF_AVAIL_PRI DEF_LPAR_METRIC DEF_MAX_SLOT DEF_PROC_UNIT_FACT DEF_SECURE_BOOT DEF_SPP DEF_SRR DEF_UNCAPPED_WT Standardize DefaultStandardize().ded_proc Show source in lpar_builder.py:419 Signature def ded_proc(self): ... DefaultStandardize().general Show source in lpar_builder.py:325 Signature def general(self): ... DefaultStandardize().io_config Show source in lpar_builder.py:431 Validates and standardizes the LPAR's I/O configuration. Returns dict of attributes. Expected: MAX_IO_SLOTS, PHYS_IO_SLOTS (may be empty) Signature def io_config(self): ... DefaultStandardize().memory Show source in lpar_builder.py:362 Signature def memory(self): ... DefaultStandardize().shr_proc Show source in lpar_builder.py:374 Signature def shr_proc(self): ... EnableLparMetric Show source in lpar_builder.py:795 Signature class EnableLparMetric(BoolField): ... See also BoolField EnforceAffinityCheck Show source in lpar_builder.py:833 Signature class EnforceAffinityCheck(BoolField): def __init__(self, value, host_cap, allow_none=True): ... See also BoolField EnforceAffinityCheck().validate Show source in lpar_builder.py:841 Performs validation of the affinity check attribute. Signature def validate(self): ... Field Show source in lpar_builder.py:444 Represents a field to validate. Signature class Field(object): def __init__(self, value, name=None, allow_none=True): ... Field.convert_value Show source in lpar_builder.py:454 Static converter for the Field type. Signature @classmethod def convert_value(cls, value): ... Field().validate Show source in lpar_builder.py:476 Signature def validate(self): ... FloatBoundField Show source in lpar_builder.py:570 Signature class FloatBoundField(BoundField): ... See also BoundField IDBoundField Show source in lpar_builder.py:790 Signature class IDBoundField(IntBoundField): ... See also IntBoundField IOSlots Show source in lpar_builder.py:769 Maximum virtual I/O slots. This is not to be confused with the actual io_slots (list of IOSlot) in the partition's io_config (PartitionIOConfiguration), which is set in the builder via the 'phys_io_slots' (PHYS_IO_SLOTS) key. Signature class IOSlots(IntBoundField): def __init__(self, value, allow_none=False): ... See also IntBoundField IntBoundField Show source in lpar_builder.py:565 Signature class IntBoundField(BoundField): ... See also BoundField LPARBuilder Show source in lpar_builder.py:856 Signature class LPARBuilder(object): def __init__(self, adapter, attr, stdz): ... LPARBuilder().build Show source in lpar_builder.py:957 Signature def build(self): ... LPARBuilder().build_ded_proc Show source in lpar_builder.py:867 Signature def build_ded_proc(self): ... LPARBuilder().build_io_config Show source in lpar_builder.py:906 Signature def build_io_config(self): ... LPARBuilder().build_mem Show source in lpar_builder.py:892 Signature def build_mem(self): ... LPARBuilder().build_shr_proc Show source in lpar_builder.py:877 Signature def build_shr_proc(self): ... LPARBuilder().rebuild Show source in lpar_builder.py:987 Signature def rebuild(self, lpar_w): ... LPARBuilderException Show source in lpar_builder.py:102 Exceptions thrown from the lpar builder. Signature class LPARBuilderException(Exception): ... LPARType Show source in lpar_builder.py:721 Signature class LPARType(ChoiceField): def __init__(self, value, allow_none=False): ... See also ChoiceField Memory Show source in lpar_builder.py:637 Signature class Memory(MinDesiredMaxField): def __init__( self, min_value, desired_value, max_value, ame_ef, host_ame_cap, lmb_size, allow_none=True, ): ... See also MinDesiredMaxField Memory().validate Show source in lpar_builder.py:654 Signature def validate(self): ... MinDesiredMaxField Show source in lpar_builder.py:575 Signature class MinDesiredMaxField(object): def __init__( self, field_type, min_name, des_name, max_name, min_value, desired_value, max_value, min_min=None, max_max=None, name=None, allow_none=True, ): ... MinDesiredMaxField().validate Show source in lpar_builder.py:598 Signature def validate(self): ... PhysicalPageTableRatio Show source in lpar_builder.py:803 Signature class PhysicalPageTableRatio(ChoiceField): def __init__(self, value, host_cap, allow_none=True): ... See also ChoiceField PhysicalPageTableRatio.convert_value Show source in lpar_builder.py:812 Converts the ratio as a string to the REST accepted values. Signature @classmethod def convert_value(cls, value): ... PhysicalPageTableRatio().validate Show source in lpar_builder.py:822 Performs validation of the PPT ratio attribute. Signature def validate(self): ... ProcCompatMode Show source in lpar_builder.py:729 Signature class ProcCompatMode(ChoiceField): def __init__(self, value, host_modes=None, allow_none=True): ... See also ChoiceField ProcUnits Show source in lpar_builder.py:704 Signature class ProcUnits(MinDesiredMaxField): def __init__(self, min_value, desired_value, max_value, allow_none=True): ... See also MinDesiredMaxField RestrictedIO Show source in lpar_builder.py:852 Signature class RestrictedIO(BoolField): ... See also BoolField SecureBoot Show source in lpar_builder.py:739 Secure boot policy. Signature class SecureBoot(IntBoundField): def __init__(self, value, host_cap, allow_none=False): ... See also IntBoundField SecureBoot().validate Show source in lpar_builder.py:751 Performs the additional host capability check for secure boot. Signature def validate(self): ... SimplifiedRemoteRestart Show source in lpar_builder.py:799 Signature class SimplifiedRemoteRestart(BoolField): ... See also BoolField Standardize Show source in lpar_builder.py:108 Interface class to standardize the LPAR definition A standardizer is responsible for validating the LPAR attributes that are presented and augmenting those which are required to create the LPAR. Signature class Standardize(object): def __init__(self): ... Standardize().ded_proc Show source in lpar_builder.py:145 Validates and standardizes the dedicated processor LPAR attributes. Returns dict of attributes. Expected: VCPU, MIN_VCPU, MAX_VCPU, SHARING_MODE Signature def ded_proc(self): ... Standardize().general Show source in lpar_builder.py:125 Validates and standardizes the general LPAR attributes. Returns dict of attributes. Expected: NAME, ENV, MAX_IO_SLOTS, AVAIL_PRIORITY, PROC_COMPAT Optional: SRR_CAPABLE, UUID, ID IBMi value: CONSOLE, LOAD_SRC, ALT_LOAD_SRC, RESTRICTED_IO Signature def general(self): ... Standardize().io_config Show source in lpar_builder.py:163 Validates and standardizes the LPAR's I/O configuration. Returns dict of attributes. Expected: MAX_IO_SLOTS, PHYS_IO_SLOTS (may be empty) Signature def io_config(self): ... Standardize().memory Show source in lpar_builder.py:137 Validates and standardizes the memory LPAR attributes. Returns dict of attributes. Expected: MEM, MIN_MEM, MAX_MEM Signature def memory(self): ... Standardize().set_attr Show source in lpar_builder.py:118 Set the attributes to be validated and standardized. Arguments attr - dict of lpar attributes provided by the user Signature def set_attr(self, attr): ... Standardize().shr_proc Show source in lpar_builder.py:153 Validates and standardizes the shared processor LPAR attributes. Returns dict of attributes. Expected: VCPU, MIN_VCPU, MAX_VCPU, PROC_UNITS, MAX_PROC_U, MIN_PROC_U, SHARING_MODE, UNCAPPED_WEIGHT(if UNCAPPED) Signature def shr_proc(self): ... VCpu Show source in lpar_builder.py:692 Signature class VCpu(MinDesiredMaxField): def __init__(self, min_value, desired_value, max_value, allow_none=True): ... See also MinDesiredMaxField","title":"LPARBuilder"},{"location":"pypowervm/utils/lpar_builder/#lparbuilder","text":"Pypowervm Index / Pypowervm / Utils / LPARBuilder Auto-generated documentation for pypowervm.utils.lpar_builder module.","title":"LPARBuilder"},{"location":"pypowervm/utils/lpar_builder/#attributes","text":"NAME - Dict keys used for input to the builder: 'name' ALLOWED_PPT_RATIOS - Contains the mapping of the ratio to REST accepted values. REST does not take the actual ratio value as argument, instead it takes an enumeration of accepted values starting from 0.: {'1:64': 0, '1:128': 1, '1:256': 2, '1:512': 3, '1:1024': 4, '1:2048': 5, '1:4096': 6} MAX_IO_SLOTS - I/O configuration Sure would love to change this to MAX_VIRT_IO_SLOTS or similar, but compat...: 'max_io_slots' ALT_LOAD_SRC - IBMi specific keys: 'alt_load_src' MINIMUM_ATTRS - The minimum attributes that must be supplied to create an LPAR: (NAME, MEM, VCPU) SHARED_PROC_KEYS - Keys that indicate that shared processors are being configured: PROC_UNITS_KEYS + (UNCAPPED_WEIGHT) DEF_PROC_UNIT_FACT - Defaults: 0.5 LPARBuilder AvailPriority BoolField BoolField.convert_value BoundField BoundField().validate ChoiceField ChoiceField.convert_value ChoiceField().validate DedProcShareMode DedicatedProc DefaultStandardize DefaultStandardize().ded_proc DefaultStandardize().general DefaultStandardize().io_config DefaultStandardize().memory DefaultStandardize().shr_proc EnableLparMetric EnforceAffinityCheck EnforceAffinityCheck().validate Field Field.convert_value Field().validate FloatBoundField IDBoundField IOSlots IntBoundField LPARBuilder LPARBuilder().build LPARBuilder().build_ded_proc LPARBuilder().build_io_config LPARBuilder().build_mem LPARBuilder().build_shr_proc LPARBuilder().rebuild LPARBuilderException LPARType Memory Memory().validate MinDesiredMaxField MinDesiredMaxField().validate PhysicalPageTableRatio PhysicalPageTableRatio.convert_value PhysicalPageTableRatio().validate ProcCompatMode ProcUnits RestrictedIO SecureBoot SecureBoot().validate SimplifiedRemoteRestart Standardize Standardize().ded_proc Standardize().general Standardize().io_config Standardize().memory Standardize().set_attr Standardize().shr_proc VCpu","title":"Attributes"},{"location":"pypowervm/utils/lpar_builder/#availpriority","text":"Show source in lpar_builder.py:784","title":"AvailPriority"},{"location":"pypowervm/utils/lpar_builder/#signature","text":"class AvailPriority(IntBoundField): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also","text":"IntBoundField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#boolfield","text":"Show source in lpar_builder.py:488 Facilitates validating boolean fields.","title":"BoolField"},{"location":"pypowervm/utils/lpar_builder/#signature_1","text":"class BoolField(Field): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_1","text":"Field","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#boolfieldconvert_value","text":"Show source in lpar_builder.py:492","title":"BoolField.convert_value"},{"location":"pypowervm/utils/lpar_builder/#signature_2","text":"@classmethod def convert_value(cls, value): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#boundfield","text":"Show source in lpar_builder.py:535","title":"BoundField"},{"location":"pypowervm/utils/lpar_builder/#signature_3","text":"class BoundField(Field): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_2","text":"Field","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#boundfieldvalidate","text":"Show source in lpar_builder.py:539","title":"BoundField().validate"},{"location":"pypowervm/utils/lpar_builder/#signature_4","text":"def validate(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#choicefield","text":"Show source in lpar_builder.py:506","title":"ChoiceField"},{"location":"pypowervm/utils/lpar_builder/#signature_5","text":"class ChoiceField(Field): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_3","text":"Field","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#choicefieldconvert_value","text":"Show source in lpar_builder.py:509","title":"ChoiceField.convert_value"},{"location":"pypowervm/utils/lpar_builder/#signature_6","text":"@classmethod def convert_value(cls, value): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#choicefieldvalidate","text":"Show source in lpar_builder.py:527","title":"ChoiceField().validate"},{"location":"pypowervm/utils/lpar_builder/#signature_7","text":"def validate(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#dedprocsharemode","text":"Show source in lpar_builder.py:761","title":"DedProcShareMode"},{"location":"pypowervm/utils/lpar_builder/#signature_8","text":"class DedProcShareMode(ChoiceField): def __init__(self, value, allow_none=False): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_4","text":"ChoiceField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#dedicatedproc","text":"Show source in lpar_builder.py:717","title":"DedicatedProc"},{"location":"pypowervm/utils/lpar_builder/#signature_9","text":"class DedicatedProc(BoolField): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_5","text":"BoolField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#defaultstandardize","text":"Show source in lpar_builder.py:172 Default standardizer. This class implements the Standardize interface. It takes a simple approach for augmenting missing LPAR settings. It does reasonable validation of the LPAR attributes. It first validates the user input as-is, then fills in any missing attributes that are required and supported by the host. Finally, it validates what it's sending back to the caller. If any validation rules are missed, the PowerVM management interface will catch them and surface an error at that time.","title":"DefaultStandardize"},{"location":"pypowervm/utils/lpar_builder/#signature_10","text":"class DefaultStandardize(Standardize): def __init__( self, mngd_sys, proc_units_factor=DEF_PROC_UNIT_FACT, max_slots=DEF_MAX_SLOT, uncapped_weight=DEF_UNCAPPED_WT, spp=DEF_SPP, avail_priority=DEF_AVAIL_PRI, srr=DEF_SRR, proc_compat=bp.LPARCompat.DEFAULT, enable_lpar_metric=DEF_LPAR_METRIC, secure_boot=DEF_SECURE_BOOT, ): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_6","text":"DEF_AVAIL_PRI DEF_LPAR_METRIC DEF_MAX_SLOT DEF_PROC_UNIT_FACT DEF_SECURE_BOOT DEF_SPP DEF_SRR DEF_UNCAPPED_WT Standardize","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#defaultstandardizeded_proc","text":"Show source in lpar_builder.py:419","title":"DefaultStandardize().ded_proc"},{"location":"pypowervm/utils/lpar_builder/#signature_11","text":"def ded_proc(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#defaultstandardizegeneral","text":"Show source in lpar_builder.py:325","title":"DefaultStandardize().general"},{"location":"pypowervm/utils/lpar_builder/#signature_12","text":"def general(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#defaultstandardizeio_config","text":"Show source in lpar_builder.py:431 Validates and standardizes the LPAR's I/O configuration.","title":"DefaultStandardize().io_config"},{"location":"pypowervm/utils/lpar_builder/#returns","text":"dict of attributes. Expected: MAX_IO_SLOTS, PHYS_IO_SLOTS (may be empty)","title":"Returns"},{"location":"pypowervm/utils/lpar_builder/#signature_13","text":"def io_config(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#defaultstandardizememory","text":"Show source in lpar_builder.py:362","title":"DefaultStandardize().memory"},{"location":"pypowervm/utils/lpar_builder/#signature_14","text":"def memory(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#defaultstandardizeshr_proc","text":"Show source in lpar_builder.py:374","title":"DefaultStandardize().shr_proc"},{"location":"pypowervm/utils/lpar_builder/#signature_15","text":"def shr_proc(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#enablelparmetric","text":"Show source in lpar_builder.py:795","title":"EnableLparMetric"},{"location":"pypowervm/utils/lpar_builder/#signature_16","text":"class EnableLparMetric(BoolField): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_7","text":"BoolField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#enforceaffinitycheck","text":"Show source in lpar_builder.py:833","title":"EnforceAffinityCheck"},{"location":"pypowervm/utils/lpar_builder/#signature_17","text":"class EnforceAffinityCheck(BoolField): def __init__(self, value, host_cap, allow_none=True): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_8","text":"BoolField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#enforceaffinitycheckvalidate","text":"Show source in lpar_builder.py:841 Performs validation of the affinity check attribute.","title":"EnforceAffinityCheck().validate"},{"location":"pypowervm/utils/lpar_builder/#signature_18","text":"def validate(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#field","text":"Show source in lpar_builder.py:444 Represents a field to validate.","title":"Field"},{"location":"pypowervm/utils/lpar_builder/#signature_19","text":"class Field(object): def __init__(self, value, name=None, allow_none=True): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#fieldconvert_value","text":"Show source in lpar_builder.py:454 Static converter for the Field type.","title":"Field.convert_value"},{"location":"pypowervm/utils/lpar_builder/#signature_20","text":"@classmethod def convert_value(cls, value): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#fieldvalidate","text":"Show source in lpar_builder.py:476","title":"Field().validate"},{"location":"pypowervm/utils/lpar_builder/#signature_21","text":"def validate(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#floatboundfield","text":"Show source in lpar_builder.py:570","title":"FloatBoundField"},{"location":"pypowervm/utils/lpar_builder/#signature_22","text":"class FloatBoundField(BoundField): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_9","text":"BoundField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#idboundfield","text":"Show source in lpar_builder.py:790","title":"IDBoundField"},{"location":"pypowervm/utils/lpar_builder/#signature_23","text":"class IDBoundField(IntBoundField): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_10","text":"IntBoundField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#ioslots","text":"Show source in lpar_builder.py:769 Maximum virtual I/O slots. This is not to be confused with the actual io_slots (list of IOSlot) in the partition's io_config (PartitionIOConfiguration), which is set in the builder via the 'phys_io_slots' (PHYS_IO_SLOTS) key.","title":"IOSlots"},{"location":"pypowervm/utils/lpar_builder/#signature_24","text":"class IOSlots(IntBoundField): def __init__(self, value, allow_none=False): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_11","text":"IntBoundField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#intboundfield","text":"Show source in lpar_builder.py:565","title":"IntBoundField"},{"location":"pypowervm/utils/lpar_builder/#signature_25","text":"class IntBoundField(BoundField): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_12","text":"BoundField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#lparbuilder_1","text":"Show source in lpar_builder.py:856","title":"LPARBuilder"},{"location":"pypowervm/utils/lpar_builder/#signature_26","text":"class LPARBuilder(object): def __init__(self, adapter, attr, stdz): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#lparbuilderbuild","text":"Show source in lpar_builder.py:957","title":"LPARBuilder().build"},{"location":"pypowervm/utils/lpar_builder/#signature_27","text":"def build(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#lparbuilderbuild_ded_proc","text":"Show source in lpar_builder.py:867","title":"LPARBuilder().build_ded_proc"},{"location":"pypowervm/utils/lpar_builder/#signature_28","text":"def build_ded_proc(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#lparbuilderbuild_io_config","text":"Show source in lpar_builder.py:906","title":"LPARBuilder().build_io_config"},{"location":"pypowervm/utils/lpar_builder/#signature_29","text":"def build_io_config(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#lparbuilderbuild_mem","text":"Show source in lpar_builder.py:892","title":"LPARBuilder().build_mem"},{"location":"pypowervm/utils/lpar_builder/#signature_30","text":"def build_mem(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#lparbuilderbuild_shr_proc","text":"Show source in lpar_builder.py:877","title":"LPARBuilder().build_shr_proc"},{"location":"pypowervm/utils/lpar_builder/#signature_31","text":"def build_shr_proc(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#lparbuilderrebuild","text":"Show source in lpar_builder.py:987","title":"LPARBuilder().rebuild"},{"location":"pypowervm/utils/lpar_builder/#signature_32","text":"def rebuild(self, lpar_w): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#lparbuilderexception","text":"Show source in lpar_builder.py:102 Exceptions thrown from the lpar builder.","title":"LPARBuilderException"},{"location":"pypowervm/utils/lpar_builder/#signature_33","text":"class LPARBuilderException(Exception): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#lpartype","text":"Show source in lpar_builder.py:721","title":"LPARType"},{"location":"pypowervm/utils/lpar_builder/#signature_34","text":"class LPARType(ChoiceField): def __init__(self, value, allow_none=False): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_13","text":"ChoiceField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#memory","text":"Show source in lpar_builder.py:637","title":"Memory"},{"location":"pypowervm/utils/lpar_builder/#signature_35","text":"class Memory(MinDesiredMaxField): def __init__( self, min_value, desired_value, max_value, ame_ef, host_ame_cap, lmb_size, allow_none=True, ): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_14","text":"MinDesiredMaxField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#memoryvalidate","text":"Show source in lpar_builder.py:654","title":"Memory().validate"},{"location":"pypowervm/utils/lpar_builder/#signature_36","text":"def validate(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#mindesiredmaxfield","text":"Show source in lpar_builder.py:575","title":"MinDesiredMaxField"},{"location":"pypowervm/utils/lpar_builder/#signature_37","text":"class MinDesiredMaxField(object): def __init__( self, field_type, min_name, des_name, max_name, min_value, desired_value, max_value, min_min=None, max_max=None, name=None, allow_none=True, ): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#mindesiredmaxfieldvalidate","text":"Show source in lpar_builder.py:598","title":"MinDesiredMaxField().validate"},{"location":"pypowervm/utils/lpar_builder/#signature_38","text":"def validate(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#physicalpagetableratio","text":"Show source in lpar_builder.py:803","title":"PhysicalPageTableRatio"},{"location":"pypowervm/utils/lpar_builder/#signature_39","text":"class PhysicalPageTableRatio(ChoiceField): def __init__(self, value, host_cap, allow_none=True): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_15","text":"ChoiceField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#physicalpagetableratioconvert_value","text":"Show source in lpar_builder.py:812 Converts the ratio as a string to the REST accepted values.","title":"PhysicalPageTableRatio.convert_value"},{"location":"pypowervm/utils/lpar_builder/#signature_40","text":"@classmethod def convert_value(cls, value): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#physicalpagetableratiovalidate","text":"Show source in lpar_builder.py:822 Performs validation of the PPT ratio attribute.","title":"PhysicalPageTableRatio().validate"},{"location":"pypowervm/utils/lpar_builder/#signature_41","text":"def validate(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#proccompatmode","text":"Show source in lpar_builder.py:729","title":"ProcCompatMode"},{"location":"pypowervm/utils/lpar_builder/#signature_42","text":"class ProcCompatMode(ChoiceField): def __init__(self, value, host_modes=None, allow_none=True): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_16","text":"ChoiceField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#procunits","text":"Show source in lpar_builder.py:704","title":"ProcUnits"},{"location":"pypowervm/utils/lpar_builder/#signature_43","text":"class ProcUnits(MinDesiredMaxField): def __init__(self, min_value, desired_value, max_value, allow_none=True): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_17","text":"MinDesiredMaxField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#restrictedio","text":"Show source in lpar_builder.py:852","title":"RestrictedIO"},{"location":"pypowervm/utils/lpar_builder/#signature_44","text":"class RestrictedIO(BoolField): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_18","text":"BoolField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#secureboot","text":"Show source in lpar_builder.py:739 Secure boot policy.","title":"SecureBoot"},{"location":"pypowervm/utils/lpar_builder/#signature_45","text":"class SecureBoot(IntBoundField): def __init__(self, value, host_cap, allow_none=False): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_19","text":"IntBoundField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#securebootvalidate","text":"Show source in lpar_builder.py:751 Performs the additional host capability check for secure boot.","title":"SecureBoot().validate"},{"location":"pypowervm/utils/lpar_builder/#signature_46","text":"def validate(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#simplifiedremoterestart","text":"Show source in lpar_builder.py:799","title":"SimplifiedRemoteRestart"},{"location":"pypowervm/utils/lpar_builder/#signature_47","text":"class SimplifiedRemoteRestart(BoolField): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_20","text":"BoolField","title":"See also"},{"location":"pypowervm/utils/lpar_builder/#standardize","text":"Show source in lpar_builder.py:108 Interface class to standardize the LPAR definition A standardizer is responsible for validating the LPAR attributes that are presented and augmenting those which are required to create the LPAR.","title":"Standardize"},{"location":"pypowervm/utils/lpar_builder/#signature_48","text":"class Standardize(object): def __init__(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#standardizeded_proc","text":"Show source in lpar_builder.py:145 Validates and standardizes the dedicated processor LPAR attributes.","title":"Standardize().ded_proc"},{"location":"pypowervm/utils/lpar_builder/#returns_1","text":"dict of attributes. Expected: VCPU, MIN_VCPU, MAX_VCPU, SHARING_MODE","title":"Returns"},{"location":"pypowervm/utils/lpar_builder/#signature_49","text":"def ded_proc(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#standardizegeneral","text":"Show source in lpar_builder.py:125 Validates and standardizes the general LPAR attributes.","title":"Standardize().general"},{"location":"pypowervm/utils/lpar_builder/#returns_2","text":"dict of attributes. Expected: NAME, ENV, MAX_IO_SLOTS, AVAIL_PRIORITY, PROC_COMPAT Optional: SRR_CAPABLE, UUID, ID IBMi value: CONSOLE, LOAD_SRC, ALT_LOAD_SRC, RESTRICTED_IO","title":"Returns"},{"location":"pypowervm/utils/lpar_builder/#signature_50","text":"def general(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#standardizeio_config","text":"Show source in lpar_builder.py:163 Validates and standardizes the LPAR's I/O configuration.","title":"Standardize().io_config"},{"location":"pypowervm/utils/lpar_builder/#returns_3","text":"dict of attributes. Expected: MAX_IO_SLOTS, PHYS_IO_SLOTS (may be empty)","title":"Returns"},{"location":"pypowervm/utils/lpar_builder/#signature_51","text":"def io_config(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#standardizememory","text":"Show source in lpar_builder.py:137 Validates and standardizes the memory LPAR attributes.","title":"Standardize().memory"},{"location":"pypowervm/utils/lpar_builder/#returns_4","text":"dict of attributes. Expected: MEM, MIN_MEM, MAX_MEM","title":"Returns"},{"location":"pypowervm/utils/lpar_builder/#signature_52","text":"def memory(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#standardizeset_attr","text":"Show source in lpar_builder.py:118 Set the attributes to be validated and standardized.","title":"Standardize().set_attr"},{"location":"pypowervm/utils/lpar_builder/#arguments","text":"attr - dict of lpar attributes provided by the user","title":"Arguments"},{"location":"pypowervm/utils/lpar_builder/#signature_53","text":"def set_attr(self, attr): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#standardizeshr_proc","text":"Show source in lpar_builder.py:153 Validates and standardizes the shared processor LPAR attributes.","title":"Standardize().shr_proc"},{"location":"pypowervm/utils/lpar_builder/#returns_5","text":"dict of attributes. Expected: VCPU, MIN_VCPU, MAX_VCPU, PROC_UNITS, MAX_PROC_U, MIN_PROC_U, SHARING_MODE, UNCAPPED_WEIGHT(if UNCAPPED)","title":"Returns"},{"location":"pypowervm/utils/lpar_builder/#signature_54","text":"def shr_proc(self): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#vcpu","text":"Show source in lpar_builder.py:692","title":"VCpu"},{"location":"pypowervm/utils/lpar_builder/#signature_55","text":"class VCpu(MinDesiredMaxField): def __init__(self, min_value, desired_value, max_value, allow_none=True): ...","title":"Signature"},{"location":"pypowervm/utils/lpar_builder/#see-also_21","text":"MinDesiredMaxField","title":"See also"},{"location":"pypowervm/utils/retry/","text":"Retry Pypowervm Index / Pypowervm / Utils / Retry Auto-generated documentation for pypowervm.utils.retry module. Attributes RANDOM_DELAY_STEPS - Used by STEPPED_RANDOM_DELAY. Each entry corresponds to the kwargs for gen_random_delay. There's no magic to these numbers; they're fairly arbitrary.: ({'max_s': 0}, {'max_s': 1}, {'min_s': 0.5, 'max_s': 4}, {'min_s': 2, 'max_s': 13}, {'min_s': 6.5, 'max_s': 30}, {'max_s': 60}) Retry STEPPED_DELAY STEPPED_RANDOM_DELAY gen_random_delay refresh_wrapper retry STEPPED_DELAY Show source in retry.py:51 A delay function that increases its delay per attempt. The steps will be: - Attempt 1: 0.0s - Attempt 2: 0.5s - Attempt 3: 2.0s - Attempt 4: 6.5s - Attempt 5: 20s - Attempt 6+: 30s Signature def STEPPED_DELAY(attempt, max_attempts, *args, **kwds): ... STEPPED_RANDOM_DELAY Show source in retry.py:80 A delay function for increasing random sleep times. The RANDOM_DELAY_STEPS variable is used to determine the min/max for each step. This is a graduating scale - based on the overall max_attempts specified. If there are 60 max attempts, the first 10 will use the first delay in RANDOM_DELAY_STEPS, the next ten will use the second delay in RANDOM_DELAY_STEPS, etc... If there are only 6 retries, then the first will use the first position in RANDOM_DELAY_STEPS, the second will map to the second RANDOM_DELAY_STEPS and so on. Signature def STEPPED_RANDOM_DELAY(attempt, max_attempts, *args, **kwargs): ... gen_random_delay Show source in retry.py:66 Generate a delay function that waits a random amount of time. Arguments min_s - Minimum number of seconds to delay (float). max_s - Maximum number of seconds to delay (float). Returns A delay method suitable for passing to retry's delay_func kwarg. Signature def gen_random_delay(min_s=0, max_s=10): ... refresh_wrapper Show source in retry.py:106 A @retry argmod_func to refresh a Wrapper, which must be the first arg. When using @retry to decorate a method which modifies a Wrapper, a common cause of retry is etag mismatch. In this case, the retry should refresh the wrapper before attempting the modifications again. This method may be passed to @retry's argmod_func argument to effect such a refresh. Note that the decorated method must be defined such that the wrapper is its first argument. Signature def refresh_wrapper(trynum, maxtries, *args, **kwargs): ... retry Show source in retry.py:127 Retry method decorator. Arguments tries - The max number of calls to the wrapped method. delay_func - A method to delay before retrying. Defaults to no delay. The parameters that are sent are: - the number of the current try - the maximum number of tries - the arguments to the decorated method - the keyword arguments to the decorated method No return value is expected. retry_except - An exception class (or tuple thereof) to retry if received. Defaults to no exceptions besides the HttpError which is handled separately by the http_codes parameter. http_codes - A list of http response codes to retry if received. Default is to not handle any specific http codes. test_func - A method to call to determine whether to retry. This method takes precedence over http codes. That is, if specified, the http codes are not considered. The parameters that are sent are: - the exception that was received - the number of the current try - the maximum number of tries - the arguments to the decorated method - the keyword arguments to the decorated method The return value is expected to be boolean, True or False, where True means to retry the decorated method. resp_checker - A method to call when no exception is caught, to check the response and determine whether to retry. The parameters that are sent are: - the number of the current try - the maximum number of tries - the arguments to the decorated method - the keyword arguments to the decorated method The return value is expected to be boolean, True or False, where True means to retry the decorated method. limit_except - An exception to raise if the number of tries is exhausted. argmod_func - A method to call after delay_func, before retrying, to modify the arguments to the main method. The input parameters are: - the number of the current try - the maximum number of tries - the non-keyword arguments to the decorated method - the keyword arguments to the decorated method The return is expected to a list and a dict of the new arguments to the decorated method. Example: def argmod(t, m, a, *k): l = list(a) l[0] += 1 k['foo'] = bar return l, k Returns The return value of the wrapped method. Signature def retry( tries=3, delay_func=NO_DELAY, retry_except=None, http_codes=DFT_RETRY_CODES, test_func=None, resp_checker=NO_CHECKER, limit_except=None, argmod_func=NO_ARGMOD, ): ... See also DFT_RETRY_CODES NO_ARGMOD NO_CHECKER NO_DELAY","title":"Retry"},{"location":"pypowervm/utils/retry/#retry","text":"Pypowervm Index / Pypowervm / Utils / Retry Auto-generated documentation for pypowervm.utils.retry module.","title":"Retry"},{"location":"pypowervm/utils/retry/#attributes","text":"RANDOM_DELAY_STEPS - Used by STEPPED_RANDOM_DELAY. Each entry corresponds to the kwargs for gen_random_delay. There's no magic to these numbers; they're fairly arbitrary.: ({'max_s': 0}, {'max_s': 1}, {'min_s': 0.5, 'max_s': 4}, {'min_s': 2, 'max_s': 13}, {'min_s': 6.5, 'max_s': 30}, {'max_s': 60}) Retry STEPPED_DELAY STEPPED_RANDOM_DELAY gen_random_delay refresh_wrapper retry","title":"Attributes"},{"location":"pypowervm/utils/retry/#stepped_delay","text":"Show source in retry.py:51 A delay function that increases its delay per attempt. The steps will be: - Attempt 1: 0.0s - Attempt 2: 0.5s - Attempt 3: 2.0s - Attempt 4: 6.5s - Attempt 5: 20s - Attempt 6+: 30s","title":"STEPPED_DELAY"},{"location":"pypowervm/utils/retry/#signature","text":"def STEPPED_DELAY(attempt, max_attempts, *args, **kwds): ...","title":"Signature"},{"location":"pypowervm/utils/retry/#stepped_random_delay","text":"Show source in retry.py:80 A delay function for increasing random sleep times. The RANDOM_DELAY_STEPS variable is used to determine the min/max for each step. This is a graduating scale - based on the overall max_attempts specified. If there are 60 max attempts, the first 10 will use the first delay in RANDOM_DELAY_STEPS, the next ten will use the second delay in RANDOM_DELAY_STEPS, etc... If there are only 6 retries, then the first will use the first position in RANDOM_DELAY_STEPS, the second will map to the second RANDOM_DELAY_STEPS and so on.","title":"STEPPED_RANDOM_DELAY"},{"location":"pypowervm/utils/retry/#signature_1","text":"def STEPPED_RANDOM_DELAY(attempt, max_attempts, *args, **kwargs): ...","title":"Signature"},{"location":"pypowervm/utils/retry/#gen_random_delay","text":"Show source in retry.py:66 Generate a delay function that waits a random amount of time.","title":"gen_random_delay"},{"location":"pypowervm/utils/retry/#arguments","text":"min_s - Minimum number of seconds to delay (float). max_s - Maximum number of seconds to delay (float).","title":"Arguments"},{"location":"pypowervm/utils/retry/#returns","text":"A delay method suitable for passing to retry's delay_func kwarg.","title":"Returns"},{"location":"pypowervm/utils/retry/#signature_2","text":"def gen_random_delay(min_s=0, max_s=10): ...","title":"Signature"},{"location":"pypowervm/utils/retry/#refresh_wrapper","text":"Show source in retry.py:106 A @retry argmod_func to refresh a Wrapper, which must be the first arg. When using @retry to decorate a method which modifies a Wrapper, a common cause of retry is etag mismatch. In this case, the retry should refresh the wrapper before attempting the modifications again. This method may be passed to @retry's argmod_func argument to effect such a refresh. Note that the decorated method must be defined such that the wrapper is its first argument.","title":"refresh_wrapper"},{"location":"pypowervm/utils/retry/#signature_3","text":"def refresh_wrapper(trynum, maxtries, *args, **kwargs): ...","title":"Signature"},{"location":"pypowervm/utils/retry/#retry_1","text":"Show source in retry.py:127 Retry method decorator.","title":"retry"},{"location":"pypowervm/utils/retry/#arguments_1","text":"tries - The max number of calls to the wrapped method. delay_func - A method to delay before retrying. Defaults to no delay. The parameters that are sent are: - the number of the current try - the maximum number of tries - the arguments to the decorated method - the keyword arguments to the decorated method No return value is expected. retry_except - An exception class (or tuple thereof) to retry if received. Defaults to no exceptions besides the HttpError which is handled separately by the http_codes parameter. http_codes - A list of http response codes to retry if received. Default is to not handle any specific http codes. test_func - A method to call to determine whether to retry. This method takes precedence over http codes. That is, if specified, the http codes are not considered. The parameters that are sent are: - the exception that was received - the number of the current try - the maximum number of tries - the arguments to the decorated method - the keyword arguments to the decorated method The return value is expected to be boolean, True or False, where True means to retry the decorated method. resp_checker - A method to call when no exception is caught, to check the response and determine whether to retry. The parameters that are sent are: - the number of the current try - the maximum number of tries - the arguments to the decorated method - the keyword arguments to the decorated method The return value is expected to be boolean, True or False, where True means to retry the decorated method. limit_except - An exception to raise if the number of tries is exhausted. argmod_func - A method to call after delay_func, before retrying, to modify the arguments to the main method. The input parameters are: - the number of the current try - the maximum number of tries - the non-keyword arguments to the decorated method - the keyword arguments to the decorated method The return is expected to a list and a dict of the new arguments to the decorated method. Example: def argmod(t, m, a, *k): l = list(a) l[0] += 1 k['foo'] = bar return l, k","title":"Arguments"},{"location":"pypowervm/utils/retry/#returns_1","text":"The return value of the wrapped method.","title":"Returns"},{"location":"pypowervm/utils/retry/#signature_4","text":"def retry( tries=3, delay_func=NO_DELAY, retry_except=None, http_codes=DFT_RETRY_CODES, test_func=None, resp_checker=NO_CHECKER, limit_except=None, argmod_func=NO_ARGMOD, ): ...","title":"Signature"},{"location":"pypowervm/utils/retry/#see-also","text":"DFT_RETRY_CODES NO_ARGMOD NO_CHECKER NO_DELAY","title":"See also"},{"location":"pypowervm/utils/transaction/","text":"Transaction Pypowervm Index / Pypowervm / Utils / Transaction Auto-generated documentation for pypowervm.utils.transaction module. Transaction ContextThreadPoolExecutor ContextThreadPoolExecutor().submit FeedTask FeedTask().add_functor_subtask FeedTask().add_post_execute FeedTask().add_subtask FeedTask().execute FeedTask().feed FeedTask().get_wrapper FeedTask().wrapper_tasks Subtask Subtask().execute WrapperTask WrapperTask().add_functor_subtask WrapperTask().add_subtask WrapperTask().execute WrapperTask().subtasks WrapperTask().wrapper entry_transaction ContextThreadPoolExecutor Show source in transaction.py:482 Signature class ContextThreadPoolExecutor(th.ThreadPoolExecutor): ... ContextThreadPoolExecutor().submit Show source in transaction.py:483 Signature def submit(self, fn, *args, **kwargs): ... FeedTask Show source in transaction.py:500 Invokes WrapperTasks in parallel over each EntryWrapper in a feed. Usage Creation: # Preferred fm = FeedTask('lpar_frobnicate', LPAR.getter(adapter)) or # Non-preferred. See 'Greedy Methods' warning below feed = LPAR.wrap(adapter.read(LPAR.schema_type, ...)) fm = FeedTask('lpar_frobnicate', feed) Adding Subtasks: # Preferred fm.add_subtask(FrobnicateLpar(foo, bar)) fm.add_functor_subtask(frobnify, abc, xyz) and/or # Non-preferred. See 'Greedy Methods' warning below for uuid, txn in fm.wrapper_tasks.items(): if meets_criteria(txn.wrapper, uuid): txn.add_subtask(FrobnicateLpar(baz, blah)) fm.wrapper_tasks[known_uuid].add_subtask(FrobnicateLpar(baz, blah) Execution/TaskFlow management: main_flow.add(fm) ... taskflow.engines.run(main_flow) Warning: Greedy Methods This implementation makes every effort to defer the feed GET as long as possible. The more time passes between the GET and the execution of the WrapperTasks, the more likely it is that some out-of-band change will have modified one of the objects represented in the feed. This will cause an etag mismatch on that WrapperTask's update (POST), resulting in that WrapperTask being redriven, which costs an extra GET+POST to the REST server. Consumers of this class can thwart these efforts by: a) Initializing the FeedTask with an already-retrieved feed instead of a FeedGetter; or b) Using any of the following methods/properties prior to execution. All of these will trigger a GET of the feed if not already fetched: .wrapper_tasks .get_wrapper(uuid) .feed The cost is incurred only the first time one of these is used. If your workflow requires calling one of these early, it is not necessary to avoid them subsequently. Signature class FeedTask(tf_task.Task): def __init__(self, name, feed_or_getter, max_workers=10, update_timeout=-1): ... FeedTask().add_functor_subtask Show source in transaction.py:659 Add a functor Subtask to all WrapperTasks in this FeedTask. To add Subtasks to individual WrapperTasks, iterate over the result of the 'wrapper_tasks' property. Specification is the same as for WrapperTask.add_functor_subtask. Signature def add_functor_subtask(self, func, *args, **kwargs): ... FeedTask().add_post_execute Show source in transaction.py:669 Add some number of TaskFlow Tasks to run after the WrapperTasks. Such Tasks may 'require' a parameter called wrapper_task_rets, which will be a dict of the form: {uuid: { 'wrapper': wrapper, label1: return_value, label2: return_value, ... labelN: return_value}} ...where: uuid is the UUID of the WrapperTask's wrapper. wrapper is the WrapperTask's wrapper in its final (possibly-updated) form. labelN: return_value are the return values from Subtasks using the 'provides' mechanism. Each label corresponds to the name given by the Subtask's 'provides' argument. Arguments tasks - Some number of TaskFlow Tasks (or Flows) to be executed linearly after the parallel WrapperTasks have completed. Signature def add_post_execute(self, *tasks): ... FeedTask().add_subtask Show source in transaction.py:642 Add a Subtask to all WrapperTasks in this FeedTask. To add Subtasks to individual WrapperTasks, iterate over the result of the 'wrapper_tasks' property. Specification is the same as for WrapperTask.add_subtask. Signature def add_subtask(self, task): ... FeedTask().execute Show source in transaction.py:750 Run this FeedTask's WrapperTasks in parallel TaskFlow engine. Returns Dictionary of results provided by subtasks and post-execs. The shape of this dict is as normally expected from TaskFlow, noting that the WrapperTasks are executed in a subflow and their results processed into wrapper_task_rets. For example: {'wrapper_task_rets': { uuid: {...}, uuid: {...}, ...} 'post_exec_x_provides': ..., 'post_exec_y_provides': ..., ...} Signature def execute(self): ... FeedTask().feed Show source in transaction.py:693 (Greedy) Returns this FeedTask's feed (list of wrappers). The first access of this property triggers a GET of the feed if it has not already been fetched, so use this only if you need the EntryWrappers outside of the execution itself. Signature @property def feed(self): ... FeedTask().get_wrapper Show source in transaction.py:627 (Greedy) Returns the EntryWrapper associated with a particular UUID. Note that this method triggers a GET of the feed if it has not already been fetched, so use judiciously. Arguments uuid - The UUID of the wrapper of interest. Returns The EntryWrapper instance with the specified UUID. Raises KeyError - If there's no WrapperTask for a wrapper with the specified UUID. Signature def get_wrapper(self, uuid): ... FeedTask().wrapper_tasks Show source in transaction.py:603 (Greedy) Dictionary of {uuid: WrapperTask} for all wrappers. The first access of this property triggers a GET of the feed if it has not already been fetched, so use judiciously. Signature @property def wrapper_tasks(self): ... Subtask Show source in transaction.py:135 A single EntryWrapper modification to be performed within a WrapperTask. A subclass performs its work by overriding the execute method. That method may or may not make changes to the EntryWrapper, which is its first argument. Its return value must indicate whether changes were made to the wrapper: this is the trigger used by WrapperTask to determine whether to POST the changes back to the REST server via update(). The return value is saved by the surrounding WrapperTask if the 'provides' argument is used on initialization. This value can then be retrieved by subsequent Subtasks. A Subtask should never update() or refresh() the wrapper. That is handled by the surrounding WrapperTask. See WrapperTask for example usage. Signature class Subtask(object): def __init__(self, *save_args, **save_kwargs): ... Subtask().execute Show source in transaction.py:177 Modify the EntryWrapper (must be overridden by the subclass). The execute method has two responsibilities: 1) Performs the modification to the EntryWrapper which is passed as its first argument. 2) Indicates whether any modifications were performed. Examples def execute(thingy_wrapper, primary_widget, provided=None): update_needed = False if primary_widget not in thingy_wrapper.widgets: thingy_wrapper.set_primary_widget(primary_widget) update_needed = True # Was a widget list provided by a prior Subtask? if provided is not None: widget_list = provided.get('widget_list', []) for widget in widget_list: thingy_wrapper.widgets.append(widget) update_needed = True return update_needed :param args - Positional arguments accepted by the execute method. The first argument will always be the EntryWrapper. Overrides may define their signatures using explicit parameter names. :param kwargs - Keyword arguments accepted by the execute method. Overrides may use explicit parameter names. :param provided - Dict of return values provided by Subtasks whose execution preceded this one, and which used the 'provides' keyword argument to save their returns. The keys of the dict are the 'provides' strings of the prior Subtasks. :return - The return value must be a single value (this may be a list, but not a tuple) which evaluates to True or False. Unless this Subtask was initialized with flag_update=False, any True value indicates that the wrapper was modified and should be POSTed back to the REST server via update(). Any False value (including None, [], {}, etc) indicates that this Subtask did not modify the wrapper. (Note that it may still be POSTed if modified by other Subtasks in the same WrapperTask.) Signature @abc.abstractmethod def execute(self, *args, **kwargs): ... WrapperTask Show source in transaction.py:266 An atomic modify-and-POST transaction Task over a single EntryWrapper. The modifications should comprise some number of Subtask instances, added to this WrapperTask via the add_subtask and/or add_functor_subtask methods. These Subtasks should only modify the EntryWrapper, and should not POST (.update()) it back to the REST Server. The WrapperTask will decide whether a POST is needed based on the returns from the Subtasks' execute methods, and perform it if indicated. The WrapperTask's execute method is encompassed by @entry_transaction, meaning that: 1) The initial GET of the EntryWrapper may be deferred until after the lock is acquired. 2) The execute method is locked on the UUID of the Entry in question. 3) If the final update (POST) fails due to etag mismatch, the EntryWrapper is refetched and the entire transaction is redriven from the start. Usage: class ModifyGizmos(Subtask): def execute(self, wrapper, gizmo_list, provides='first_gizmo'): update_needed = None if gizmo_list: wrapper.gizmos.append(gizmo_list) update_needed = gizmo_list[0] return update_needed def add_widget(wrapper, widget, frob=False, provided=None): if provided is not None: widget.first_gizmo = provided.get('first_gizmo') wrapper.widgets.append(widget, frob) return len(wrapper.widgets) ... tx = WrapperTask(\"do_lpar_things\", LPAR.getter(adapter, lpar_uuid)) or tx = WrapperTask(\"do_lpar_things\", LPAR.getter(adapter, lpar_uuid), subtasks=existing_wrapper_task.subtasks) or # Not recommended - increased probability of retry wrapper = LPAR.wrap(adapter.read(LPAR.schema_type, lpar_uuid)) tx = WrapperTask(\"do_lpar_things\", wrapper) ... tx.add_subtask(ModifyGizmos([giz1, giz2])) ... logspec = [LOG.info, _LI(\"Added widget %(widget)s to LPAR %(lpar)s.\"), {'widget': widget.name, 'lpar': lpar_uuid}] tx.add_functor_subtask(add_widget, widget, provides='widget_count', logspec=logspec) ... finalized_lpar = tx.execute() Signature class WrapperTask(tf_task.Task): def __init__( self, name, wrapper_or_getter, subtasks=None, allow_empty=False, update_timeout=-1, ): ... WrapperTask().add_functor_subtask Show source in transaction.py:386 Create and add a Subtask for an already-defined method. Arguments func - A callable to be the core of the Subtask. The contract for this method is identical to that of Subtask.execute - see that method's docstring for details. args - Positional arguments to be passed to the callable func (after the EntryWrapper parameter) when it is executed within the WrapperTask. kwargs - Keyword arguments to be passed to the callable func when it is executed within the WrapperTask. May contain the following values, which are treated specially and NOT passed to the callable func: provides: See Subtask. init (provides). flag_update: See Subtask. init (flag_update). logspec: Iterable comprising a logging function, a format string, and zero or more arguments. The log method is invoked before the func. Example: logspec = [LOG.info, _LI(\"Deleting widget %(widget)s from \" \"instance %(instance)s.\"), {'widget': widg, 'instance': instance.name}] FunctorSubtask(..., logspec=logspec) Returns self, for chaining convenience. Signature def add_functor_subtask(self, func, *args, **kwargs): ... WrapperTask().add_subtask Show source in transaction.py:365 Add a Subtask to this WrapperTask. Subtasks will be invoked serially and synchronously in the order in which they are added. Arguments task - Instance of a Subtask subclass containing the logic to invoke. Returns self, for chaining convenience. Signature def add_subtask(self, task): ... WrapperTask().execute Show source in transaction.py:438 Invoke subtasks and update under @entry_transaction. The flow is as follows: 1 Lock on wrapper UUID 2 GET wrapper if necessary 3 For each registered Subtask: - Invoke the Subtask to modify the wrapper 4 If update is necessary, POST the wrapper. If POST fails with etag mismatch: - Refresh the wrapper - goto 2 5 Unlock Signature def execute(self): ... WrapperTask().subtasks Show source in transaction.py:429 Return the sequence of Subtasks registered with this WrapperTask. This is returned as a tuple (not modifiable). To add subtasks, use the add_[functor_]subtask method. Signature @property def subtasks(self): ... WrapperTask().wrapper Show source in transaction.py:413 (Fetches and) returns the EntryWrapper. Use this only if you need the EntryWrapper outside of the WrapperTask's execution itself. Note that this guarantees a GET outside of lock, and should therefore be used only if absolutely necessary. Signature @property def wrapper(self): ... entry_transaction Show source in transaction.py:54 Decorator to facilitate transaction semantics on a PowerVM object. Typically, a method thus decorated will make some set of changes to an EntryWrapper and then perform one or more REST operations thereon. The consumer of the decorated method may pass either an EntryWrapper or an EntryWrapperGetter as the first argument. The developer of the decorated method is guaranteed that the first argument is an EntryWrapper. This decorator provides three things: 1) The decorated method may be invoked with either an EntryWrapper or an EntryWrapperGetter as its first argument. However, within the body of the method, that argument is guaranteed to be the appropriate EntryWrapper. 2) The decorated method is locked on the UUID of the PowerVM object on which it operates (represented by its first argument). Only one method thus decorated can operate on that PowerVM object at one time. 3) If the decorated method fails due to an etag mismatch - indicating that the wrapper was updated out-of-band between when it was retrieved and when it was updated - the wrapper is refreshed and the entire method is redriven. Note: If the etag mistmatch occurs, the STEPPED_DELAY function is used from the retry.py. This provides a gradual increase in the delay (except for the first retry - which is immediate). A maximum number of 6 retries will occur. Example usage: @entry_transaction def add_gizmos_to_vios_wrapper(vios_wrapper, gizmos): vios_wrapper.gizmo_list.extend(gizmos) return vios_wrapper.update() This method can then be invoked either as: add_gizmos_to_vios_wrapper(existing_vios_wrapper, gizmos) or as: add_gizmos_to_vios_wrapper(pvm_vios.VIOS.getter(adapter, uuid), gizmos) Signature def entry_transaction(func): ...","title":"Transaction"},{"location":"pypowervm/utils/transaction/#transaction","text":"Pypowervm Index / Pypowervm / Utils / Transaction Auto-generated documentation for pypowervm.utils.transaction module. Transaction ContextThreadPoolExecutor ContextThreadPoolExecutor().submit FeedTask FeedTask().add_functor_subtask FeedTask().add_post_execute FeedTask().add_subtask FeedTask().execute FeedTask().feed FeedTask().get_wrapper FeedTask().wrapper_tasks Subtask Subtask().execute WrapperTask WrapperTask().add_functor_subtask WrapperTask().add_subtask WrapperTask().execute WrapperTask().subtasks WrapperTask().wrapper entry_transaction","title":"Transaction"},{"location":"pypowervm/utils/transaction/#contextthreadpoolexecutor","text":"Show source in transaction.py:482","title":"ContextThreadPoolExecutor"},{"location":"pypowervm/utils/transaction/#signature","text":"class ContextThreadPoolExecutor(th.ThreadPoolExecutor): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#contextthreadpoolexecutorsubmit","text":"Show source in transaction.py:483","title":"ContextThreadPoolExecutor().submit"},{"location":"pypowervm/utils/transaction/#signature_1","text":"def submit(self, fn, *args, **kwargs): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#feedtask","text":"Show source in transaction.py:500 Invokes WrapperTasks in parallel over each EntryWrapper in a feed. Usage Creation: # Preferred fm = FeedTask('lpar_frobnicate', LPAR.getter(adapter)) or # Non-preferred. See 'Greedy Methods' warning below feed = LPAR.wrap(adapter.read(LPAR.schema_type, ...)) fm = FeedTask('lpar_frobnicate', feed) Adding Subtasks: # Preferred fm.add_subtask(FrobnicateLpar(foo, bar)) fm.add_functor_subtask(frobnify, abc, xyz) and/or # Non-preferred. See 'Greedy Methods' warning below for uuid, txn in fm.wrapper_tasks.items(): if meets_criteria(txn.wrapper, uuid): txn.add_subtask(FrobnicateLpar(baz, blah)) fm.wrapper_tasks[known_uuid].add_subtask(FrobnicateLpar(baz, blah) Execution/TaskFlow management: main_flow.add(fm) ... taskflow.engines.run(main_flow) Warning: Greedy Methods This implementation makes every effort to defer the feed GET as long as possible. The more time passes between the GET and the execution of the WrapperTasks, the more likely it is that some out-of-band change will have modified one of the objects represented in the feed. This will cause an etag mismatch on that WrapperTask's update (POST), resulting in that WrapperTask being redriven, which costs an extra GET+POST to the REST server. Consumers of this class can thwart these efforts by: a) Initializing the FeedTask with an already-retrieved feed instead of a FeedGetter; or b) Using any of the following methods/properties prior to execution. All of these will trigger a GET of the feed if not already fetched: .wrapper_tasks .get_wrapper(uuid) .feed The cost is incurred only the first time one of these is used. If your workflow requires calling one of these early, it is not necessary to avoid them subsequently.","title":"FeedTask"},{"location":"pypowervm/utils/transaction/#signature_2","text":"class FeedTask(tf_task.Task): def __init__(self, name, feed_or_getter, max_workers=10, update_timeout=-1): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#feedtaskadd_functor_subtask","text":"Show source in transaction.py:659 Add a functor Subtask to all WrapperTasks in this FeedTask. To add Subtasks to individual WrapperTasks, iterate over the result of the 'wrapper_tasks' property. Specification is the same as for WrapperTask.add_functor_subtask.","title":"FeedTask().add_functor_subtask"},{"location":"pypowervm/utils/transaction/#signature_3","text":"def add_functor_subtask(self, func, *args, **kwargs): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#feedtaskadd_post_execute","text":"Show source in transaction.py:669 Add some number of TaskFlow Tasks to run after the WrapperTasks. Such Tasks may 'require' a parameter called wrapper_task_rets, which will be a dict of the form: {uuid: { 'wrapper': wrapper, label1: return_value, label2: return_value, ... labelN: return_value}} ...where: uuid is the UUID of the WrapperTask's wrapper. wrapper is the WrapperTask's wrapper in its final (possibly-updated) form. labelN: return_value are the return values from Subtasks using the 'provides' mechanism. Each label corresponds to the name given by the Subtask's 'provides' argument.","title":"FeedTask().add_post_execute"},{"location":"pypowervm/utils/transaction/#arguments","text":"tasks - Some number of TaskFlow Tasks (or Flows) to be executed linearly after the parallel WrapperTasks have completed.","title":"Arguments"},{"location":"pypowervm/utils/transaction/#signature_4","text":"def add_post_execute(self, *tasks): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#feedtaskadd_subtask","text":"Show source in transaction.py:642 Add a Subtask to all WrapperTasks in this FeedTask. To add Subtasks to individual WrapperTasks, iterate over the result of the 'wrapper_tasks' property. Specification is the same as for WrapperTask.add_subtask.","title":"FeedTask().add_subtask"},{"location":"pypowervm/utils/transaction/#signature_5","text":"def add_subtask(self, task): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#feedtaskexecute","text":"Show source in transaction.py:750 Run this FeedTask's WrapperTasks in parallel TaskFlow engine.","title":"FeedTask().execute"},{"location":"pypowervm/utils/transaction/#returns","text":"Dictionary of results provided by subtasks and post-execs. The shape of this dict is as normally expected from TaskFlow, noting that the WrapperTasks are executed in a subflow and their results processed into wrapper_task_rets. For example: {'wrapper_task_rets': { uuid: {...}, uuid: {...}, ...} 'post_exec_x_provides': ..., 'post_exec_y_provides': ..., ...}","title":"Returns"},{"location":"pypowervm/utils/transaction/#signature_6","text":"def execute(self): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#feedtaskfeed","text":"Show source in transaction.py:693 (Greedy) Returns this FeedTask's feed (list of wrappers). The first access of this property triggers a GET of the feed if it has not already been fetched, so use this only if you need the EntryWrappers outside of the execution itself.","title":"FeedTask().feed"},{"location":"pypowervm/utils/transaction/#signature_7","text":"@property def feed(self): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#feedtaskget_wrapper","text":"Show source in transaction.py:627 (Greedy) Returns the EntryWrapper associated with a particular UUID. Note that this method triggers a GET of the feed if it has not already been fetched, so use judiciously.","title":"FeedTask().get_wrapper"},{"location":"pypowervm/utils/transaction/#arguments_1","text":"uuid - The UUID of the wrapper of interest.","title":"Arguments"},{"location":"pypowervm/utils/transaction/#returns_1","text":"The EntryWrapper instance with the specified UUID.","title":"Returns"},{"location":"pypowervm/utils/transaction/#raises","text":"KeyError - If there's no WrapperTask for a wrapper with the specified UUID.","title":"Raises"},{"location":"pypowervm/utils/transaction/#signature_8","text":"def get_wrapper(self, uuid): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#feedtaskwrapper_tasks","text":"Show source in transaction.py:603 (Greedy) Dictionary of {uuid: WrapperTask} for all wrappers. The first access of this property triggers a GET of the feed if it has not already been fetched, so use judiciously.","title":"FeedTask().wrapper_tasks"},{"location":"pypowervm/utils/transaction/#signature_9","text":"@property def wrapper_tasks(self): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#subtask","text":"Show source in transaction.py:135 A single EntryWrapper modification to be performed within a WrapperTask. A subclass performs its work by overriding the execute method. That method may or may not make changes to the EntryWrapper, which is its first argument. Its return value must indicate whether changes were made to the wrapper: this is the trigger used by WrapperTask to determine whether to POST the changes back to the REST server via update(). The return value is saved by the surrounding WrapperTask if the 'provides' argument is used on initialization. This value can then be retrieved by subsequent Subtasks. A Subtask should never update() or refresh() the wrapper. That is handled by the surrounding WrapperTask. See WrapperTask for example usage.","title":"Subtask"},{"location":"pypowervm/utils/transaction/#signature_10","text":"class Subtask(object): def __init__(self, *save_args, **save_kwargs): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#subtaskexecute","text":"Show source in transaction.py:177 Modify the EntryWrapper (must be overridden by the subclass). The execute method has two responsibilities: 1) Performs the modification to the EntryWrapper which is passed as its first argument. 2) Indicates whether any modifications were performed.","title":"Subtask().execute"},{"location":"pypowervm/utils/transaction/#examples","text":"def execute(thingy_wrapper, primary_widget, provided=None): update_needed = False if primary_widget not in thingy_wrapper.widgets: thingy_wrapper.set_primary_widget(primary_widget) update_needed = True # Was a widget list provided by a prior Subtask? if provided is not None: widget_list = provided.get('widget_list', []) for widget in widget_list: thingy_wrapper.widgets.append(widget) update_needed = True return update_needed :param args - Positional arguments accepted by the execute method. The first argument will always be the EntryWrapper. Overrides may define their signatures using explicit parameter names. :param kwargs - Keyword arguments accepted by the execute method. Overrides may use explicit parameter names. :param provided - Dict of return values provided by Subtasks whose execution preceded this one, and which used the 'provides' keyword argument to save their returns. The keys of the dict are the 'provides' strings of the prior Subtasks. :return - The return value must be a single value (this may be a list, but not a tuple) which evaluates to True or False. Unless this Subtask was initialized with flag_update=False, any True value indicates that the wrapper was modified and should be POSTed back to the REST server via update(). Any False value (including None, [], {}, etc) indicates that this Subtask did not modify the wrapper. (Note that it may still be POSTed if modified by other Subtasks in the same WrapperTask.)","title":"Examples"},{"location":"pypowervm/utils/transaction/#signature_11","text":"@abc.abstractmethod def execute(self, *args, **kwargs): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#wrappertask","text":"Show source in transaction.py:266 An atomic modify-and-POST transaction Task over a single EntryWrapper. The modifications should comprise some number of Subtask instances, added to this WrapperTask via the add_subtask and/or add_functor_subtask methods. These Subtasks should only modify the EntryWrapper, and should not POST (.update()) it back to the REST Server. The WrapperTask will decide whether a POST is needed based on the returns from the Subtasks' execute methods, and perform it if indicated. The WrapperTask's execute method is encompassed by @entry_transaction, meaning that: 1) The initial GET of the EntryWrapper may be deferred until after the lock is acquired. 2) The execute method is locked on the UUID of the Entry in question. 3) If the final update (POST) fails due to etag mismatch, the EntryWrapper is refetched and the entire transaction is redriven from the start. Usage: class ModifyGizmos(Subtask): def execute(self, wrapper, gizmo_list, provides='first_gizmo'): update_needed = None if gizmo_list: wrapper.gizmos.append(gizmo_list) update_needed = gizmo_list[0] return update_needed def add_widget(wrapper, widget, frob=False, provided=None): if provided is not None: widget.first_gizmo = provided.get('first_gizmo') wrapper.widgets.append(widget, frob) return len(wrapper.widgets) ... tx = WrapperTask(\"do_lpar_things\", LPAR.getter(adapter, lpar_uuid)) or tx = WrapperTask(\"do_lpar_things\", LPAR.getter(adapter, lpar_uuid), subtasks=existing_wrapper_task.subtasks) or # Not recommended - increased probability of retry wrapper = LPAR.wrap(adapter.read(LPAR.schema_type, lpar_uuid)) tx = WrapperTask(\"do_lpar_things\", wrapper) ... tx.add_subtask(ModifyGizmos([giz1, giz2])) ... logspec = [LOG.info, _LI(\"Added widget %(widget)s to LPAR %(lpar)s.\"), {'widget': widget.name, 'lpar': lpar_uuid}] tx.add_functor_subtask(add_widget, widget, provides='widget_count', logspec=logspec) ... finalized_lpar = tx.execute()","title":"WrapperTask"},{"location":"pypowervm/utils/transaction/#signature_12","text":"class WrapperTask(tf_task.Task): def __init__( self, name, wrapper_or_getter, subtasks=None, allow_empty=False, update_timeout=-1, ): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#wrappertaskadd_functor_subtask","text":"Show source in transaction.py:386 Create and add a Subtask for an already-defined method.","title":"WrapperTask().add_functor_subtask"},{"location":"pypowervm/utils/transaction/#arguments_2","text":"func - A callable to be the core of the Subtask. The contract for this method is identical to that of Subtask.execute - see that method's docstring for details. args - Positional arguments to be passed to the callable func (after the EntryWrapper parameter) when it is executed within the WrapperTask. kwargs - Keyword arguments to be passed to the callable func when it is executed within the WrapperTask. May contain the following values, which are treated specially and NOT passed to the callable func: provides: See Subtask. init (provides). flag_update: See Subtask. init (flag_update). logspec: Iterable comprising a logging function, a format string, and zero or more arguments. The log method is invoked before the func. Example: logspec = [LOG.info, _LI(\"Deleting widget %(widget)s from \" \"instance %(instance)s.\"), {'widget': widg, 'instance': instance.name}] FunctorSubtask(..., logspec=logspec)","title":"Arguments"},{"location":"pypowervm/utils/transaction/#returns_2","text":"self, for chaining convenience.","title":"Returns"},{"location":"pypowervm/utils/transaction/#signature_13","text":"def add_functor_subtask(self, func, *args, **kwargs): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#wrappertaskadd_subtask","text":"Show source in transaction.py:365 Add a Subtask to this WrapperTask. Subtasks will be invoked serially and synchronously in the order in which they are added.","title":"WrapperTask().add_subtask"},{"location":"pypowervm/utils/transaction/#arguments_3","text":"task - Instance of a Subtask subclass containing the logic to invoke.","title":"Arguments"},{"location":"pypowervm/utils/transaction/#returns_3","text":"self, for chaining convenience.","title":"Returns"},{"location":"pypowervm/utils/transaction/#signature_14","text":"def add_subtask(self, task): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#wrappertaskexecute","text":"Show source in transaction.py:438 Invoke subtasks and update under @entry_transaction. The flow is as follows: 1 Lock on wrapper UUID 2 GET wrapper if necessary 3 For each registered Subtask: - Invoke the Subtask to modify the wrapper 4 If update is necessary, POST the wrapper. If POST fails with etag mismatch: - Refresh the wrapper - goto 2 5 Unlock","title":"WrapperTask().execute"},{"location":"pypowervm/utils/transaction/#signature_15","text":"def execute(self): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#wrappertasksubtasks","text":"Show source in transaction.py:429 Return the sequence of Subtasks registered with this WrapperTask. This is returned as a tuple (not modifiable). To add subtasks, use the add_[functor_]subtask method.","title":"WrapperTask().subtasks"},{"location":"pypowervm/utils/transaction/#signature_16","text":"@property def subtasks(self): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#wrappertaskwrapper","text":"Show source in transaction.py:413 (Fetches and) returns the EntryWrapper. Use this only if you need the EntryWrapper outside of the WrapperTask's execution itself. Note that this guarantees a GET outside of lock, and should therefore be used only if absolutely necessary.","title":"WrapperTask().wrapper"},{"location":"pypowervm/utils/transaction/#signature_17","text":"@property def wrapper(self): ...","title":"Signature"},{"location":"pypowervm/utils/transaction/#entry_transaction","text":"Show source in transaction.py:54 Decorator to facilitate transaction semantics on a PowerVM object. Typically, a method thus decorated will make some set of changes to an EntryWrapper and then perform one or more REST operations thereon. The consumer of the decorated method may pass either an EntryWrapper or an EntryWrapperGetter as the first argument. The developer of the decorated method is guaranteed that the first argument is an EntryWrapper. This decorator provides three things: 1) The decorated method may be invoked with either an EntryWrapper or an EntryWrapperGetter as its first argument. However, within the body of the method, that argument is guaranteed to be the appropriate EntryWrapper. 2) The decorated method is locked on the UUID of the PowerVM object on which it operates (represented by its first argument). Only one method thus decorated can operate on that PowerVM object at one time. 3) If the decorated method fails due to an etag mismatch - indicating that the wrapper was updated out-of-band between when it was retrieved and when it was updated - the wrapper is refreshed and the entire method is redriven. Note: If the etag mistmatch occurs, the STEPPED_DELAY function is used from the retry.py. This provides a gradual increase in the delay (except for the first retry - which is immediate). A maximum number of 6 retries will occur. Example usage: @entry_transaction def add_gizmos_to_vios_wrapper(vios_wrapper, gizmos): vios_wrapper.gizmo_list.extend(gizmos) return vios_wrapper.update() This method can then be invoked either as: add_gizmos_to_vios_wrapper(existing_vios_wrapper, gizmos) or as: add_gizmos_to_vios_wrapper(pvm_vios.VIOS.getter(adapter, uuid), gizmos)","title":"entry_transaction"},{"location":"pypowervm/utils/transaction/#signature_18","text":"def entry_transaction(func): ...","title":"Signature"},{"location":"pypowervm/utils/uuid/","text":"Uuid Pypowervm Index / Pypowervm / Utils / Uuid Auto-generated documentation for pypowervm.utils.uuid module. Uuid convert_uuid_to_pvm id_or_uuid convert_uuid_to_pvm Show source in uuid.py:22 Converts a standard UUID to PowerVM format PowerVM uuids always set the byte 0, bit 0 to 0. Arguments uuid - A standard format uuid string Returns A PowerVM compliant uuid Signature def convert_uuid_to_pvm(uuid): ... id_or_uuid Show source in uuid.py:33 Sanitizes a short ID or string UUID, and indicates which was used. Use as: is_uuid, lpar_id = id_or_uuid(lpar_id) if is_uuid: # lpar_id is a string UUID else: # lpar_id is LPAR short ID of type int Arguments an_id - Short ID (may be string or int) or string UUID of, e.g., an LPAR. Returns Boolean. If True, the other return is a UUID string. If False, it is an integer. The input ID, either converted to int, or in its original string form if a UUID. Signature def id_or_uuid(an_id): ...","title":"Uuid"},{"location":"pypowervm/utils/uuid/#uuid","text":"Pypowervm Index / Pypowervm / Utils / Uuid Auto-generated documentation for pypowervm.utils.uuid module. Uuid convert_uuid_to_pvm id_or_uuid","title":"Uuid"},{"location":"pypowervm/utils/uuid/#convert_uuid_to_pvm","text":"Show source in uuid.py:22 Converts a standard UUID to PowerVM format PowerVM uuids always set the byte 0, bit 0 to 0.","title":"convert_uuid_to_pvm"},{"location":"pypowervm/utils/uuid/#arguments","text":"uuid - A standard format uuid string","title":"Arguments"},{"location":"pypowervm/utils/uuid/#returns","text":"A PowerVM compliant uuid","title":"Returns"},{"location":"pypowervm/utils/uuid/#signature","text":"def convert_uuid_to_pvm(uuid): ...","title":"Signature"},{"location":"pypowervm/utils/uuid/#id_or_uuid","text":"Show source in uuid.py:33 Sanitizes a short ID or string UUID, and indicates which was used. Use as: is_uuid, lpar_id = id_or_uuid(lpar_id) if is_uuid: # lpar_id is a string UUID else: # lpar_id is LPAR short ID of type int","title":"id_or_uuid"},{"location":"pypowervm/utils/uuid/#arguments_1","text":"an_id - Short ID (may be string or int) or string UUID of, e.g., an LPAR.","title":"Arguments"},{"location":"pypowervm/utils/uuid/#returns_1","text":"Boolean. If True, the other return is a UUID string. If False, it is an integer. The input ID, either converted to int, or in its original string form if a UUID.","title":"Returns"},{"location":"pypowervm/utils/uuid/#signature_1","text":"def id_or_uuid(an_id): ...","title":"Signature"},{"location":"pypowervm/utils/validation/","text":"Validation Pypowervm Index / Pypowervm / Utils / Validation Auto-generated documentation for pypowervm.utils.validation module. Validation BaseValidator BaseValidator().validate CapabilitiesValidator LPARWrapperValidator LPARWrapperValidator().validate_all MemValidator ProcValidator ValidatorException BaseValidator Show source in validation.py:78 Base Validator. This class is responsible for delegating validation depending on if it's a deploy, active resize, or inactive resize. If the caller intends to perform resize validation then they must pass the cur_lpar_w argument. The cur_lpar_w is the current LPAR wrapper describing the LPAR before any resizing has taken place, while lpar_w represents the LPAR with new (resized) values. If cur_lpar_w is None then deploy validation logic will ensue. Signature class BaseValidator(object): def __init__(self, lpar_w, host_w, cur_lpar_w=None): ... BaseValidator().validate Show source in validation.py:96 Determines what validation is requested and invokes it. Arguments check_dlpar - flag indicating if we need to validate dlpar capability. Signature def validate(self, check_dlpar=True): ... CapabilitiesValidator Show source in validation.py:513 Capabilities Validator. This class implements capabilities validation for lpars in the case of deploy, inactive resize, and active resize. Instance attributes populated by _populate_new_values :attr srr_enabled: srr capability of the lpar Signature class CapabilitiesValidator(BaseValidator): ... See also BaseValidator LPARWrapperValidator Show source in validation.py:35 LPAR Validator. This class implements additional validation for LPARs for use during resize or deployment. It is meant to catch any violations that would cause errors at the PowerVM management interface. Signature class LPARWrapperValidator(object): def __init__(self, lpar_w, host_w, cur_lpar_w=None): ... LPARWrapperValidator().validate_all Show source in validation.py:59 Invoke attribute validation classes to perform validation Arguments check_dlpar - indicates the need to validate the dlpar capability. It is False when update is requested with force option. Signature def validate_all(self, check_dlpar=True): ... MemValidator Show source in validation.py:181 Memory Validator. This class implements memory validation for lpars in the case of deploy, inactive resize, and active resize. Instance attributes populated by _populate_new_values :attr des_mem: desired memory of the new lpar :attr max_mem: maximum memory of the new lpar :attr min_mem: minimum memory of the new lpar :attr avail_mem: available memory on the host :attr ppt_ratio: desired ppt ratio of the new lpar :attr res_name: name of the resource Signature class MemValidator(BaseValidator): def __init__(self, lpar_w, host_w, cur_lpar_w=None): ... See also BaseValidator ProcValidator Show source in validation.py:293 Processor Validator. This class implements processor validation for LPARs in the case of deploy, inactive resize, and active resize. Instance attributes populated by _populate_new_values :attr has_dedicated: LPAR has dedicated processors boolean :attr procs_avail: available procs on host :attr des_procs: desired processors from new LPAR :attr res_name: name of the resource :attr max_procs_per_aix_linux_lpar: max procs per LPAR on host :attr max_sys_procs_limit: LPAR max procs limit on host :attr des_vcpus: LPAR desired vcpus :attr max_vcpus: LPAR max vcpus :attr min_vcpus: LPAR min vcpus :attr proc_compat_mode: Processor compatibility mode :attr pool_id: LPAR shared processor pool ID (only for shared proc mode) :attr max_proc_units: LPAR max proc units (only for shared processor mode) :attr min_proc_units: LPAR min proc units (only for shared processor mode) Signature class ProcValidator(BaseValidator): ... See also BaseValidator ValidatorException Show source in validation.py:30 Exceptions thrown from the validators. Signature class ValidatorException(Exception): ...","title":"Validation"},{"location":"pypowervm/utils/validation/#validation","text":"Pypowervm Index / Pypowervm / Utils / Validation Auto-generated documentation for pypowervm.utils.validation module. Validation BaseValidator BaseValidator().validate CapabilitiesValidator LPARWrapperValidator LPARWrapperValidator().validate_all MemValidator ProcValidator ValidatorException","title":"Validation"},{"location":"pypowervm/utils/validation/#basevalidator","text":"Show source in validation.py:78 Base Validator. This class is responsible for delegating validation depending on if it's a deploy, active resize, or inactive resize. If the caller intends to perform resize validation then they must pass the cur_lpar_w argument. The cur_lpar_w is the current LPAR wrapper describing the LPAR before any resizing has taken place, while lpar_w represents the LPAR with new (resized) values. If cur_lpar_w is None then deploy validation logic will ensue.","title":"BaseValidator"},{"location":"pypowervm/utils/validation/#signature","text":"class BaseValidator(object): def __init__(self, lpar_w, host_w, cur_lpar_w=None): ...","title":"Signature"},{"location":"pypowervm/utils/validation/#basevalidatorvalidate","text":"Show source in validation.py:96 Determines what validation is requested and invokes it.","title":"BaseValidator().validate"},{"location":"pypowervm/utils/validation/#arguments","text":"check_dlpar - flag indicating if we need to validate dlpar capability.","title":"Arguments"},{"location":"pypowervm/utils/validation/#signature_1","text":"def validate(self, check_dlpar=True): ...","title":"Signature"},{"location":"pypowervm/utils/validation/#capabilitiesvalidator","text":"Show source in validation.py:513 Capabilities Validator. This class implements capabilities validation for lpars in the case of deploy, inactive resize, and active resize. Instance attributes populated by _populate_new_values :attr srr_enabled: srr capability of the lpar","title":"CapabilitiesValidator"},{"location":"pypowervm/utils/validation/#signature_2","text":"class CapabilitiesValidator(BaseValidator): ...","title":"Signature"},{"location":"pypowervm/utils/validation/#see-also","text":"BaseValidator","title":"See also"},{"location":"pypowervm/utils/validation/#lparwrappervalidator","text":"Show source in validation.py:35 LPAR Validator. This class implements additional validation for LPARs for use during resize or deployment. It is meant to catch any violations that would cause errors at the PowerVM management interface.","title":"LPARWrapperValidator"},{"location":"pypowervm/utils/validation/#signature_3","text":"class LPARWrapperValidator(object): def __init__(self, lpar_w, host_w, cur_lpar_w=None): ...","title":"Signature"},{"location":"pypowervm/utils/validation/#lparwrappervalidatorvalidate_all","text":"Show source in validation.py:59 Invoke attribute validation classes to perform validation","title":"LPARWrapperValidator().validate_all"},{"location":"pypowervm/utils/validation/#arguments_1","text":"check_dlpar - indicates the need to validate the dlpar capability. It is False when update is requested with force option.","title":"Arguments"},{"location":"pypowervm/utils/validation/#signature_4","text":"def validate_all(self, check_dlpar=True): ...","title":"Signature"},{"location":"pypowervm/utils/validation/#memvalidator","text":"Show source in validation.py:181 Memory Validator. This class implements memory validation for lpars in the case of deploy, inactive resize, and active resize. Instance attributes populated by _populate_new_values :attr des_mem: desired memory of the new lpar :attr max_mem: maximum memory of the new lpar :attr min_mem: minimum memory of the new lpar :attr avail_mem: available memory on the host :attr ppt_ratio: desired ppt ratio of the new lpar :attr res_name: name of the resource","title":"MemValidator"},{"location":"pypowervm/utils/validation/#signature_5","text":"class MemValidator(BaseValidator): def __init__(self, lpar_w, host_w, cur_lpar_w=None): ...","title":"Signature"},{"location":"pypowervm/utils/validation/#see-also_1","text":"BaseValidator","title":"See also"},{"location":"pypowervm/utils/validation/#procvalidator","text":"Show source in validation.py:293 Processor Validator. This class implements processor validation for LPARs in the case of deploy, inactive resize, and active resize. Instance attributes populated by _populate_new_values :attr has_dedicated: LPAR has dedicated processors boolean :attr procs_avail: available procs on host :attr des_procs: desired processors from new LPAR :attr res_name: name of the resource :attr max_procs_per_aix_linux_lpar: max procs per LPAR on host :attr max_sys_procs_limit: LPAR max procs limit on host :attr des_vcpus: LPAR desired vcpus :attr max_vcpus: LPAR max vcpus :attr min_vcpus: LPAR min vcpus :attr proc_compat_mode: Processor compatibility mode :attr pool_id: LPAR shared processor pool ID (only for shared proc mode) :attr max_proc_units: LPAR max proc units (only for shared processor mode) :attr min_proc_units: LPAR min proc units (only for shared processor mode)","title":"ProcValidator"},{"location":"pypowervm/utils/validation/#signature_6","text":"class ProcValidator(BaseValidator): ...","title":"Signature"},{"location":"pypowervm/utils/validation/#see-also_2","text":"BaseValidator","title":"See also"},{"location":"pypowervm/utils/validation/#validatorexception","text":"Show source in validation.py:30 Exceptions thrown from the validators.","title":"ValidatorException"},{"location":"pypowervm/utils/validation/#signature_7","text":"class ValidatorException(Exception): ...","title":"Signature"},{"location":"pypowervm/utils/wrappers/","text":"Wrappers Pypowervm Index / Pypowervm / Utils / Wrappers Auto-generated documentation for pypowervm.utils.wrappers module. Wrappers wrapper_class_iter wrapper_class_iter Show source in wrappers.py:52 Iterator over all Wrapper subclasses defined in pypowervm.wrappers. Each yield is the Wrapper subclass itself. Signature def wrapper_class_iter(): ...","title":"Wrappers"},{"location":"pypowervm/utils/wrappers/#wrappers","text":"Pypowervm Index / Pypowervm / Utils / Wrappers Auto-generated documentation for pypowervm.utils.wrappers module. Wrappers wrapper_class_iter","title":"Wrappers"},{"location":"pypowervm/utils/wrappers/#wrapper_class_iter","text":"Show source in wrappers.py:52 Iterator over all Wrapper subclasses defined in pypowervm.wrappers. Each yield is the Wrapper subclass itself.","title":"wrapper_class_iter"},{"location":"pypowervm/utils/wrappers/#signature","text":"def wrapper_class_iter(): ...","title":"Signature"},{"location":"pypowervm/wrappers/","text":"Wrappers Pypowervm Index / Pypowervm / Wrappers Auto-generated documentation for pypowervm.wrappers module. Wrappers Modules Modules BasePartition Cluster Enterprise Pool EntryWrapper Event HttpError Iocard Job Logical Partition Managed System ManagementConsole Monitor MTMS Network Pcm Pmem SharedProcPool Storage Vios File Virtual Io Server","title":"Wrappers"},{"location":"pypowervm/wrappers/#wrappers","text":"Pypowervm Index / Pypowervm / Wrappers Auto-generated documentation for pypowervm.wrappers module. Wrappers Modules","title":"Wrappers"},{"location":"pypowervm/wrappers/#modules","text":"BasePartition Cluster Enterprise Pool EntryWrapper Event HttpError Iocard Job Logical Partition Managed System ManagementConsole Monitor MTMS Network Pcm Pmem SharedProcPool Storage Vios File Virtual Io Server","title":"Modules"},{"location":"pypowervm/wrappers/base_partition/","text":"BasePartition Pypowervm Index / Pypowervm / Wrappers / BasePartition Auto-generated documentation for pypowervm.wrappers.base_partition module. Attributes IO_CFG_ROOT - Partition I/O Configuration (_IO): _BP_IO_CFG IO_SLOTS_ROOT - Constants for the I/O Slot Configuration: 'ProfileIOSlots' ASSOC_IO_SLOT_ROOT - Constants for the Associated I/O Slot: 'AssociatedIOSlot' IO_ADPT_ROOT - Constants for generic I/O Adapter: 'IOAdapter' BasePartition BasePartition BasePartition().allow_perf_data_collection BasePartition().allow_perf_data_collection BasePartition().assoc_sys_uuid BasePartition().avail_priority BasePartition().avail_priority BasePartition().bootmode BasePartition().bootmode BasePartition().capabilities BasePartition().cur_dram_pmem_volumes BasePartition().cur_pmem_volumes BasePartition().current_secure_boot BasePartition().disable_secure_boot BasePartition().disable_secure_boot BasePartition().env BasePartition().id BasePartition().io_config BasePartition().io_config BasePartition().is_mgmt_partition BasePartition().is_service_partition BasePartition().is_service_partition BasePartition().keylock_pos BasePartition().keylock_pos BasePartition().max_dram_pmem_volumes BasePartition().max_pmem_volumes BasePartition().mem_config BasePartition().mem_config BasePartition().name BasePartition().name BasePartition().nvram BasePartition().nvram BasePartition().operating_system BasePartition().partition_uuid BasePartition().pending_proc_compat_mode BasePartition().pending_secure_boot BasePartition().pending_secure_boot BasePartition().proc_compat_mode BasePartition().proc_compat_mode BasePartition().proc_config BasePartition().proc_config BasePartition().profile_sync BasePartition().profile_sync BasePartition().ref_code BasePartition().ref_code_full BasePartition().rmc_ip BasePartition().rmc_state BasePartition().state BasePartition().uptime BootMode DedicatedProcessorConfiguration DedicatedProcessorConfiguration.bld DedicatedProcessorConfiguration().desired DedicatedProcessorConfiguration().desired DedicatedProcessorConfiguration().max DedicatedProcessorConfiguration().max DedicatedProcessorConfiguration().min DedicatedProcessorConfiguration().min DedicatedSharingMode IOSlot IOSlot().__get_prop IOSlot().adapter IOSlot.bld IOSlot().bus_grp_required IOSlot().bus_grp_required IOSlot().description IOSlot().description IOSlot().drc_index IOSlot().drc_index IOSlot().drc_name IOSlot().drc_name IOSlot().io_adapter IOSlot().io_adapter IOSlot().pc_adpt_id IOSlot().pc_adpt_id IOSlot().pci_class IOSlot().pci_class IOSlot().pci_dev_id IOSlot().pci_dev_id IOSlot().pci_mfg_id IOSlot().pci_mfg_id IOSlot().pci_rev_id IOSlot().pci_rev_id IOSlot().pci_subsys_dev_id IOSlot().pci_subsys_dev_id IOSlot().pci_subsys_vendor_id IOSlot().pci_subsys_vendor_id IOSlot().pci_vendor_id IOSlot().pci_vendor_id IOSlot().phys_loc IOSlot().phys_loc IOSlot().required IOSlot().required KeylockPos LPARCompat LPARState LPARType PartitionCapabilities PartitionCapabilities().io_dlpar PartitionCapabilities().mem_dlpar PartitionCapabilities().proc_dlpar PartitionIOConfiguration PartitionIOConfiguration.bld PartitionIOConfiguration().io_slots PartitionIOConfiguration().io_slots PartitionIOConfiguration().max_virtual_slots PartitionIOConfiguration().max_virtual_slots PartitionIOConfiguration().tagged_io PartitionIOConfiguration().tagged_io PartitionMemoryConfiguration PartitionMemoryConfiguration().ame_enabled PartitionMemoryConfiguration.bld PartitionMemoryConfiguration().current PartitionMemoryConfiguration().desired PartitionMemoryConfiguration().desired PartitionMemoryConfiguration().exp_factor PartitionMemoryConfiguration().exp_factor PartitionMemoryConfiguration().max PartitionMemoryConfiguration().max PartitionMemoryConfiguration().min PartitionMemoryConfiguration().min PartitionMemoryConfiguration().ppt_ratio PartitionMemoryConfiguration().ppt_ratio PartitionMemoryConfiguration().shared_enabled PartitionProcessorConfiguration PartitionProcessorConfiguration.bld_dedicated PartitionProcessorConfiguration.bld_shared PartitionProcessorConfiguration().dedicated_proc_cfg PartitionProcessorConfiguration().has_dedicated PartitionProcessorConfiguration().shared_proc_cfg PartitionProcessorConfiguration().sharing_mode PartitionProcessorConfiguration().sharing_mode RMCState SharedProcessorConfiguration SharedProcessorConfiguration.bld SharedProcessorConfiguration().desired_units SharedProcessorConfiguration().desired_units SharedProcessorConfiguration().desired_virtual SharedProcessorConfiguration().desired_virtual SharedProcessorConfiguration().max_units SharedProcessorConfiguration().max_units SharedProcessorConfiguration().max_virtual SharedProcessorConfiguration().max_virtual SharedProcessorConfiguration().min_units SharedProcessorConfiguration().min_units SharedProcessorConfiguration().min_virtual SharedProcessorConfiguration().min_virtual SharedProcessorConfiguration().pool_id SharedProcessorConfiguration().pool_id SharedProcessorConfiguration().uncapped_weight SharedProcessorConfiguration().uncapped_weight SharingMode TaggedIO TaggedIO().alt_load_src TaggedIO().alt_load_src TaggedIO.bld TaggedIO().console TaggedIO().console TaggedIO().load_src TaggedIO().load_src BasePartition Show source in base_partition.py:484 Base class for Logical Partition (LPAR) & Virtual I/O Server (VIOS). This corresponds to the abstract BasePartition object in the PowerVM schema. Signature class BasePartition(ewrap.EntryWrapper, _DlparCapable): ... BasePartition().allow_perf_data_collection Show source in base_partition.py:713 Signature @property def allow_perf_data_collection(self): ... BasePartition().allow_perf_data_collection Show source in base_partition.py:717 Signature @allow_perf_data_collection.setter def allow_perf_data_collection(self, value): ... BasePartition().assoc_sys_uuid Show source in base_partition.py:559 UUID of the associated ManagedSystem. Signature @property def assoc_sys_uuid(self): ... BasePartition().avail_priority Show source in base_partition.py:591 Signature @property def avail_priority(self): ... BasePartition().avail_priority Show source in base_partition.py:595 Signature @avail_priority.setter def avail_priority(self, value): ... BasePartition().bootmode Show source in base_partition.py:663 Boot mode - one of the BootMode enum values. Signature @property def bootmode(self): ... BasePartition().bootmode Show source in base_partition.py:668 Signature @bootmode.setter def bootmode(self, val): ... BasePartition().capabilities Show source in base_partition.py:722 Signature @property def capabilities(self): ... BasePartition().cur_dram_pmem_volumes Show source in base_partition.py:792 Signature @property def cur_dram_pmem_volumes(self): ... BasePartition().cur_pmem_volumes Show source in base_partition.py:784 Signature @property def cur_pmem_volumes(self): ... BasePartition().current_secure_boot Show source in base_partition.py:698 The Secure Boot Policy Value The secure boot value will determine what level of enforcement will take place when the LPAR is booted. The following are the values and their interpretations: * 0: Secure boot disabled * 1: Secure boot enabled (log only) * 2: Secure boot enabled and enforced * 3-9: Secure boot enabled and enforced. Firmware or OS may take additional measures. Signature @property def current_secure_boot(self): ... BasePartition().disable_secure_boot Show source in base_partition.py:674 Signature @property def disable_secure_boot(self): ... BasePartition().disable_secure_boot Show source in base_partition.py:678 Signature @disable_secure_boot.setter def disable_secure_boot(self, value): ... BasePartition().env Show source in base_partition.py:543 See the LPARType Enumeration. Should usually be 'AIX/Linux' for LPAR. 'Virtual IO Server' should only happen for VIOS. Signature @property def env(self): ... BasePartition().id Show source in base_partition.py:534 Short ID (not UUID). Signature @property def id(self): ... BasePartition().io_config Show source in base_partition.py:727 The Partition I/O Configuration. Signature @property def io_config(self): ... BasePartition().io_config Show source in base_partition.py:733 The Partition I/O Configuration for the LPAR. Signature @io_config.setter def io_config(self, io_cfg): ... BasePartition().is_mgmt_partition Show source in base_partition.py:636 Is this the management partition? Default False if field absent. Signature @property def is_mgmt_partition(self): ... BasePartition().is_service_partition Show source in base_partition.py:641 Is this the service partition? Default False if field absent. Signature @property def is_service_partition(self): ... BasePartition().is_service_partition Show source in base_partition.py:646 Set if this is the service partition. Signature @is_service_partition.setter def is_service_partition(self, value): ... BasePartition().keylock_pos Show source in base_partition.py:651 Keylock position - see KeylockPos enumeration. Signature @property def keylock_pos(self): ... BasePartition().keylock_pos Show source in base_partition.py:656 Keylock position - see KeylockPos enumeration. Signature @keylock_pos.setter def keylock_pos(self, value): ... BasePartition().max_dram_pmem_volumes Show source in base_partition.py:788 Signature @property def max_dram_pmem_volumes(self): ... BasePartition().max_pmem_volumes Show source in base_partition.py:780 Signature @property def max_pmem_volumes(self): ... BasePartition().mem_config Show source in base_partition.py:741 The Partition Memory Configuration for the LPAR. Signature @property def mem_config(self): ... BasePartition().mem_config Show source in base_partition.py:747 The Partition Memory Configuration for the LPAR. Signature @mem_config.setter def mem_config(self, mem_cfg): ... BasePartition().name Show source in base_partition.py:525 Short name (not ID, MTMS, or hostname). Signature @property def name(self): ... BasePartition().name Show source in base_partition.py:530 Signature @name.setter def name(self, val): ... BasePartition().nvram Show source in base_partition.py:765 Signature @ewrap.Wrapper.xag_property(const.XAG.NVRAM) def nvram(self): ... BasePartition().nvram Show source in base_partition.py:769 Signature @nvram.setter def nvram(self, nvram): ... BasePartition().operating_system Show source in base_partition.py:578 String representing the OS and version, or 'Unknown'. Signature @property def operating_system(self): ... BasePartition().partition_uuid Show source in base_partition.py:555 Signature @property def partition_uuid(self): ... BasePartition().pending_proc_compat_mode Show source in base_partition.py:618 Pending processor compatibility mode. See LPARCompat. E.g. 'POWER7', 'POWER7_Plus', 'POWER8', etc. Signature @property def pending_proc_compat_mode(self): ... BasePartition().pending_secure_boot Show source in base_partition.py:684 The Pending Secure Boot Policy Value This parameter can be set while the LPAR is running. It will be the policy used when the LPAR is next booted. Signature @property def pending_secure_boot(self): ... BasePartition().pending_secure_boot Show source in base_partition.py:693 Signature @pending_secure_boot.setter def pending_secure_boot(self, value): ... BasePartition().proc_compat_mode Show source in base_partition.py:609 Current processor compatibility mode. See LPARCompat. E.g. 'POWER7', 'POWER7_Plus', 'POWER8', etc. Signature @property def proc_compat_mode(self): ... BasePartition().proc_compat_mode Show source in base_partition.py:627 Sets PENDING proc compat mode. Note that corresponding getter retrieves the CURRENT proc compat mode. Signature @proc_compat_mode.setter def proc_compat_mode(self, value): ... BasePartition().proc_config Show source in base_partition.py:753 The Partition Processor Configuration for the LPAR. Signature @property def proc_config(self): ... BasePartition().proc_config Show source in base_partition.py:759 The Partition Processor Configuration for the LPAR. Signature @proc_config.setter def proc_config(self, proc_config): ... BasePartition().profile_sync Show source in base_partition.py:599 Signature @property def profile_sync(self): ... BasePartition().profile_sync Show source in base_partition.py:603 Signature @profile_sync.setter def profile_sync(self, value): ... BasePartition().ref_code Show source in base_partition.py:583 Signature @property def ref_code(self): ... BasePartition().ref_code_full Show source in base_partition.py:587 Signature @property def ref_code_full(self): ... BasePartition().rmc_ip Show source in base_partition.py:573 IP address used for RMC communication, as a string. Signature @property def rmc_ip(self): ... BasePartition().rmc_state Show source in base_partition.py:565 See RMCState. e.g. 'active', 'inactive', 'busy', etc. Signature @property def rmc_state(self): ... BasePartition().state Show source in base_partition.py:517 See LPARState. e.g. 'not activated', 'running', 'migrating running', etc. Signature @property def state(self): ... BasePartition().uptime Show source in base_partition.py:775 Integer time since partition boot, in seconds. Signature @property def uptime(self): ... BootMode Show source in base_partition.py:389 Mirror of PartitionBootMode.Enum. Valid values for LPAR.bootmode/VIOS.bootmode. Not to be confused with pypowervm.tasks.power.BootMode. Example usage: lwrap.bootmode = BootMode.NORM lwrap.update() Signature class BootMode(object): ... DedicatedProcessorConfiguration Show source in base_partition.py:1143 Represents the partition's Dedicated Processor Configuration. Signature class DedicatedProcessorConfiguration(ewrap.ElementWrapper): ... DedicatedProcessorConfiguration.bld Show source in base_partition.py:1146 Builds a Dedicated Processor configuration wrapper. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) proc - Number of virtual processors (int) min_proc - Minimum processors, default to proc value max_proc - Maximum processors, default to proc value Returns Processor Config with dedicated processors Signature @classmethod def bld(cls, adapter, proc, min_proc=None, max_proc=None): ... DedicatedProcessorConfiguration().desired Show source in base_partition.py:1172 Signature @property def desired(self): ... DedicatedProcessorConfiguration().desired Show source in base_partition.py:1176 Signature @desired.setter def desired(self, value): ... DedicatedProcessorConfiguration().max Show source in base_partition.py:1180 Signature @property def max(self): ... DedicatedProcessorConfiguration().max Show source in base_partition.py:1184 Signature @max.setter def max(self, value): ... DedicatedProcessorConfiguration().min Show source in base_partition.py:1188 Signature @property def min(self): ... DedicatedProcessorConfiguration().min Show source in base_partition.py:1192 Signature @min.setter def min(self, value): ... DedicatedSharingMode Show source in base_partition.py:315 Dedicated Processor sharing modes. Subset of LogicalPartitionProcessorSharingModeEnum. Signature class DedicatedSharingMode(object): ... IOSlot Show source in base_partition.py:1311 An I/O Slot represents a device bus on the system. It may contain a piece of hardware within it. Signature class IOSlot(ewrap.ElementWrapper, ewrap.ElementWrapper): ... IOSlot().__get_prop Show source in base_partition.py:1461 Thin wrapper to get the Associated I/O Slot and get a property. Signature def __get_prop(self, func): ... IOSlot().adapter Show source in base_partition.py:1523 DEPRECATED - use 'io_adapter' method instead. Signature @property def adapter(self): ... IOSlot.bld Show source in base_partition.py:1316 Build a new IOSlot wrapper with all required parameters. Returns A new IOSlot wrapper. Signature @classmethod def bld(cls, adapter, bus_grp_required, drc_index, required=False): ... IOSlot().bus_grp_required Show source in base_partition.py:1368 Signature @property def bus_grp_required(self): ... IOSlot().bus_grp_required Show source in base_partition.py:1471 Signature @property def bus_grp_required(self): ... IOSlot().description Show source in base_partition.py:1376 Signature @property def description(self): ... IOSlot().description Show source in base_partition.py:1475 Signature @property def description(self): ... IOSlot().drc_index Show source in base_partition.py:1416 Signature @property def drc_index(self): ... IOSlot().drc_index Show source in base_partition.py:1515 Signature @property def drc_index(self): ... IOSlot().drc_name Show source in base_partition.py:1423 Signature @property def drc_name(self): ... IOSlot().drc_name Show source in base_partition.py:1519 Signature @property def drc_name(self): ... IOSlot().io_adapter Show source in base_partition.py:1427 Jumps over the 'Related IO Adapter' element direct to the I/O. This is another area where the schema has a two step jump that the API can avoid. This method skips over the RelatedIOAdapter and jumps right to the IO Adapter. Return values are either the generic IOAdapter or the PhysFCAdapter. Signature @property def io_adapter(self): ... IOSlot().io_adapter Show source in base_partition.py:1532 Returns the physical I/O Adapter for this slot. This will be one of two types. Either a generic I/O Adapter or a Physical Fibre Channel Adapter (PhysFCAdapter). Signature @property def io_adapter(self): ... IOSlot().pc_adpt_id Show source in base_partition.py:1384 Signature @property def pc_adpt_id(self): ... IOSlot().pc_adpt_id Show source in base_partition.py:1483 Signature @property def pc_adpt_id(self): ... IOSlot().pci_class Show source in base_partition.py:1388 Signature @property def pci_class(self): ... IOSlot().pci_class Show source in base_partition.py:1487 Signature @property def pci_class(self): ... IOSlot().pci_dev_id Show source in base_partition.py:1392 Signature @property def pci_dev_id(self): ... IOSlot().pci_dev_id Show source in base_partition.py:1491 Signature @property def pci_dev_id(self): ... IOSlot().pci_mfg_id Show source in base_partition.py:1400 Signature @property def pci_mfg_id(self): ... IOSlot().pci_mfg_id Show source in base_partition.py:1499 Signature @property def pci_mfg_id(self): ... IOSlot().pci_rev_id Show source in base_partition.py:1404 Signature @property def pci_rev_id(self): ... IOSlot().pci_rev_id Show source in base_partition.py:1503 Signature @property def pci_rev_id(self): ... IOSlot().pci_subsys_dev_id Show source in base_partition.py:1396 Signature @property def pci_subsys_dev_id(self): ... IOSlot().pci_subsys_dev_id Show source in base_partition.py:1495 Signature @property def pci_subsys_dev_id(self): ... IOSlot().pci_subsys_vendor_id Show source in base_partition.py:1412 Signature @property def pci_subsys_vendor_id(self): ... IOSlot().pci_subsys_vendor_id Show source in base_partition.py:1511 Signature @property def pci_subsys_vendor_id(self): ... IOSlot().pci_vendor_id Show source in base_partition.py:1408 Signature @property def pci_vendor_id(self): ... IOSlot().pci_vendor_id Show source in base_partition.py:1507 Signature @property def pci_vendor_id(self): ... IOSlot().phys_loc Show source in base_partition.py:1380 Signature @property def phys_loc(self): ... IOSlot().phys_loc Show source in base_partition.py:1479 Signature @property def phys_loc(self): ... IOSlot().required Show source in base_partition.py:1453 Signature @property def required(self): ... IOSlot().required Show source in base_partition.py:1457 Signature @required.setter def required(self, val): ... KeylockPos Show source in base_partition.py:412 Mirror of KeylockPosition.Enum. Valid values for LPAR.keylock_pos/VIOS.keylock_pos. Not to be confused with pypowervm.tasks.power.KeylockPos. Example usage: lwrap.keylock_pos = KeylockPos.MANUAL lwrap.update() Signature class KeylockPos(object): ... LPARCompat Show source in base_partition.py:356 LPAR compatibility modes. From LogicalPartitionProcessorCompatibilityModeEnum. Signature class LPARCompat(object): ... LPARState Show source in base_partition.py:328 State of a given LPAR. From LogicalPartitionStateEnum. Signature class LPARState(object): ... LPARType Show source in base_partition.py:349 Subset of LogicalPartitionEnvironmentEnum. Signature class LPARType(object): ... PartitionCapabilities Show source in base_partition.py:799 See LogicalPartitionCapabilities. Signature class PartitionCapabilities(ewrap.ElementWrapper): ... PartitionCapabilities().io_dlpar Show source in base_partition.py:801 Signature @property def io_dlpar(self): ... PartitionCapabilities().mem_dlpar Show source in base_partition.py:805 Signature @property def mem_dlpar(self): ... PartitionCapabilities().proc_dlpar Show source in base_partition.py:809 Signature @property def proc_dlpar(self): ... PartitionIOConfiguration Show source in base_partition.py:1198 Represents the partitions Dedicated IO Configuration. Comprised of I/O Slots. There are two types of IO slots. Those dedicated to physical hardware (io_slots) and those that get used by virtual hardware. Signature class PartitionIOConfiguration(ewrap.ElementWrapper): ... PartitionIOConfiguration.bld Show source in base_partition.py:1206 Builds a Partition IO configuration wrapper. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) max_virt_slots - Number of virtual slots (int) PartitionIOConfiguration().io_slots - I/O slots to assign to the LPAR (list of IOSlot). Returns Partition IO configuration wrapper Signature @classmethod def bld(cls, adapter, max_virt_slots, io_slots=None): ... PartitionIOConfiguration().io_slots Show source in base_partition.py:1235 The physical I/O Slots. Each slot will have hardware associated with it. Signature @property def io_slots(self): ... PartitionIOConfiguration().io_slots Show source in base_partition.py:1244 Signature @io_slots.setter def io_slots(self, val): ... PartitionIOConfiguration().max_virtual_slots Show source in base_partition.py:1223 The maximum number of virtual slots. Slots are used for every VirtualScsiServerAdapter, TrunkAdapter, etc... Signature @property def max_virtual_slots(self): ... PartitionIOConfiguration().max_virtual_slots Show source in base_partition.py:1231 Signature @max_virtual_slots.setter def max_virtual_slots(self, value): ... PartitionIOConfiguration().tagged_io Show source in base_partition.py:1248 IBMi only - tagged I/O attributes of the I/O configuration. Signature @property def tagged_io(self): ... PartitionIOConfiguration().tagged_io Show source in base_partition.py:1254 Signature @tagged_io.setter def tagged_io(self, tio): ... PartitionMemoryConfiguration Show source in base_partition.py:919 Represents the partitions Memory Configuration. Signature class PartitionMemoryConfiguration(ewrap.ElementWrapper): ... PartitionMemoryConfiguration().ame_enabled Show source in base_partition.py:980 Signature @property def ame_enabled(self): ... PartitionMemoryConfiguration.bld Show source in base_partition.py:922 Creates the ParitionMemoryConfiguration. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) mem - The amount of memory for the partition in MB min_mem - The minimum amount of memory in MB. Defaults to the mem param max_mem - The maximum amount of memory in MB. Defaults to the mem param Returns The memory configuration wrapper. Signature @classmethod def bld(cls, adapter, mem, min_mem=None, max_mem=None): ... PartitionMemoryConfiguration().current Show source in base_partition.py:946 Signature @property def current(self): ... PartitionMemoryConfiguration().desired Show source in base_partition.py:950 Signature @property def desired(self): ... PartitionMemoryConfiguration().desired Show source in base_partition.py:954 Signature @desired.setter def desired(self, mem): ... PartitionMemoryConfiguration().exp_factor Show source in base_partition.py:984 The Active Memory Expansion Factor The expansion factor represents the target memory multiplier. e.g. An LPAR with EF = 2 which has 4 GB of memory will have a target expansion memory of 8 GB. Signature @property def exp_factor(self): ... PartitionMemoryConfiguration().exp_factor Show source in base_partition.py:994 The Active Memory Expansion Factor Arguments exp_factor - The expansion factor value. Setting this to 0 will turn/keep AME off. The valid values are 1.0 <= x <= 10.0 up to 2 decimal places. Signature @exp_factor.setter def exp_factor(self, exp_factor): ... PartitionMemoryConfiguration().max Show source in base_partition.py:958 Signature @property def max(self): ... PartitionMemoryConfiguration().max Show source in base_partition.py:962 Signature @max.setter def max(self, mem): ... PartitionMemoryConfiguration().min Show source in base_partition.py:966 Signature @property def min(self): ... PartitionMemoryConfiguration().min Show source in base_partition.py:970 Signature @min.setter def min(self, mem): ... PartitionMemoryConfiguration().ppt_ratio Show source in base_partition.py:1005 The Physical Page Table Ratio The physical page table ratio represents the ratio of a VM's maximum memory to the size of its physical page table. The PPT is used by the platform to maintain the translation of the VM's physical to virtual memory addresses during mobility operations (i.e. LPM). The ppt_ratio is represented as 1:2^N where accepted values for N range from 6 to 12. If the ratio is 1:4096 for a VM with 64 GB of maximum memory, it would have a PPT of 16 MB (64 GB / 4096 = 16 MB). Signature @property def ppt_ratio(self): ... PartitionMemoryConfiguration().ppt_ratio Show source in base_partition.py:1020 The Physical Page Table Ratio Arguments ppt_ratio - The ppt ratio value. Signature @ppt_ratio.setter def ppt_ratio(self, ppt_ratio): ... PartitionMemoryConfiguration().shared_enabled Show source in base_partition.py:974 Signature @property def shared_enabled(self): ... PartitionProcessorConfiguration Show source in base_partition.py:816 Represents the partitions Processor Configuration. Comprised of either the shared or dedicated processor config. Signature class PartitionProcessorConfiguration(ewrap.ElementWrapper): ... PartitionProcessorConfiguration.bld_dedicated Show source in base_partition.py:854 Builds a Dedicated Processor configuration wrapper. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) proc - Number of virtual processors (int) min_proc - Minimum processors, default to proc value max_proc - Maximum processors, default to proc value PartitionProcessorConfiguration().sharing_mode - Sharing mode of the processors, 'sre idle proces' Returns Processor Config with dedicated processors Signature @classmethod def bld_dedicated( cls, adapter, proc, min_proc=None, max_proc=None, sharing_mode=DedicatedSharingMode.SHARE_IDLE_PROCS, ): ... PartitionProcessorConfiguration.bld_shared Show source in base_partition.py:822 Builds a Shared Processor configuration wrapper. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) proc_unit - Amount of desired proc units (float) proc - Number of virtual processors (int) PartitionProcessorConfiguration().sharing_mode - Sharing mode of the processors (uncapped) uncapped_weight - Uncapped weight of the processors (0-255) min_proc_unit - Minimum proc units, default to proc unit value max_proc_unit - Maximum proc units, default to proc unit value min_proc - Minimum processors, default to proc value max_proc - Maximum processors, default to proc value proc_pool - The shared processor pool for the lpar, defaults to 0 Returns Processor Config with shared processors Signature @classmethod def bld_shared( cls, adapter, proc_unit, proc, sharing_mode=SharingMode.UNCAPPED, uncapped_weight=128, min_proc_unit=None, max_proc_unit=None, min_proc=None, max_proc=None, proc_pool=0, ): ... PartitionProcessorConfiguration().dedicated_proc_cfg Show source in base_partition.py:906 Returns the Dedicated Processor Configuration. Signature @property def dedicated_proc_cfg(self): ... PartitionProcessorConfiguration().has_dedicated Show source in base_partition.py:879 Returns boolean True if dedicated, False if shared or not found. Signature @property def has_dedicated(self): ... PartitionProcessorConfiguration().shared_proc_cfg Show source in base_partition.py:896 Returns the Shared Processor Configuration. Signature @property def shared_proc_cfg(self): ... PartitionProcessorConfiguration().sharing_mode Show source in base_partition.py:888 Signature @property def sharing_mode(self): ... PartitionProcessorConfiguration().sharing_mode Show source in base_partition.py:892 Signature @sharing_mode.setter def sharing_mode(self, value): ... RMCState Show source in base_partition.py:377 Various RMC States. From ResourceMonitoringControlStateEnum. Signature class RMCState(object): ... SharedProcessorConfiguration Show source in base_partition.py:1031 Represents the partition's Shared Processor Configuration. Signature class SharedProcessorConfiguration(ewrap.ElementWrapper): ... SharedProcessorConfiguration.bld Show source in base_partition.py:1034 Builds a Shared Processor configuration wrapper. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) proc_unit - Amount of desired proc units (float) proc - Number of virtual processors (int) SharedProcessorConfiguration().uncapped_weight - Uncapped weight of the processors, 0-255 min_proc_unit - Minimum proc units, default to proc unit value max_proc_unit - Maximum proc units, default to proc unit value min_proc - Minimum processors, default to proc value max_proc - Maximum processors, default to proc value proc_pool - The shared processor pool for the lpar, defaults to 0 Returns Processor Config with shared processors Signature @classmethod def bld( cls, adapter, proc_unit, proc, uncapped_weight=None, min_proc_unit=None, max_proc_unit=None, min_proc=None, max_proc=None, proc_pool=0, ): ... SharedProcessorConfiguration().desired_units Show source in base_partition.py:1077 Signature @property def desired_units(self): ... SharedProcessorConfiguration().desired_units Show source in base_partition.py:1081 Signature @desired_units.setter def desired_units(self, val): ... SharedProcessorConfiguration().desired_virtual Show source in base_partition.py:1101 Signature @property def desired_virtual(self): ... SharedProcessorConfiguration().desired_virtual Show source in base_partition.py:1105 Signature @desired_virtual.setter def desired_virtual(self, val): ... SharedProcessorConfiguration().max_units Show source in base_partition.py:1085 Signature @property def max_units(self): ... SharedProcessorConfiguration().max_units Show source in base_partition.py:1089 Signature @max_units.setter def max_units(self, val): ... SharedProcessorConfiguration().max_virtual Show source in base_partition.py:1109 Signature @property def max_virtual(self): ... SharedProcessorConfiguration().max_virtual Show source in base_partition.py:1113 Signature @max_virtual.setter def max_virtual(self, val): ... SharedProcessorConfiguration().min_units Show source in base_partition.py:1093 Signature @property def min_units(self): ... SharedProcessorConfiguration().min_units Show source in base_partition.py:1097 Signature @min_units.setter def min_units(self, val): ... SharedProcessorConfiguration().min_virtual Show source in base_partition.py:1117 Signature @property def min_virtual(self): ... SharedProcessorConfiguration().min_virtual Show source in base_partition.py:1121 Signature @min_virtual.setter def min_virtual(self, val): ... SharedProcessorConfiguration().pool_id Show source in base_partition.py:1125 Signature @property def pool_id(self): ... SharedProcessorConfiguration().pool_id Show source in base_partition.py:1129 Signature @pool_id.setter def pool_id(self, val): ... SharedProcessorConfiguration().uncapped_weight Show source in base_partition.py:1133 Signature @property def uncapped_weight(self): ... SharedProcessorConfiguration().uncapped_weight Show source in base_partition.py:1137 Signature @uncapped_weight.setter def uncapped_weight(self, val): ... SharingMode Show source in base_partition.py:305 Shared Processor sharing modes. Subset of LogicalPartitionProcessorSharingModeEnum. Signature class SharingMode(object): ... TaggedIO Show source in base_partition.py:1261 IBMi only - tagged I/O attributes of the I/O configuration. Signature class TaggedIO(ewrap.ElementWrapper): ... TaggedIO().alt_load_src Show source in base_partition.py:1281 Value may or may not be an integer - always returned as string. Signature @property def alt_load_src(self): ... TaggedIO().alt_load_src Show source in base_partition.py:1286 Signature @alt_load_src.setter def alt_load_src(self, value): ... TaggedIO.bld Show source in base_partition.py:1264 Builds a Partition TaggedIO wrapper. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) TaggedIO().load_src - Load source to use TaggedIO().console - Console to use for IBMi TaggedIO().alt_load_src - Alternate load source to use Returns Partition TaggedIO wrapper Signature @classmethod def bld(cls, adapter, load_src=\"0\", console=\"HMC\", alt_load_src=\"NONE\"): ... TaggedIO().console Show source in base_partition.py:1290 Value may or may not be an integer - always returned as string. Signature @property def console(self): ... TaggedIO().console Show source in base_partition.py:1295 Signature @console.setter def console(self, value): ... TaggedIO().load_src Show source in base_partition.py:1299 Value may or may not be an integer - always returned as string. Signature @property def load_src(self): ... TaggedIO().load_src Show source in base_partition.py:1304 Signature @load_src.setter def load_src(self, value): ...","title":"BasePartition"},{"location":"pypowervm/wrappers/base_partition/#basepartition","text":"Pypowervm Index / Pypowervm / Wrappers / BasePartition Auto-generated documentation for pypowervm.wrappers.base_partition module.","title":"BasePartition"},{"location":"pypowervm/wrappers/base_partition/#attributes","text":"IO_CFG_ROOT - Partition I/O Configuration (_IO): _BP_IO_CFG IO_SLOTS_ROOT - Constants for the I/O Slot Configuration: 'ProfileIOSlots' ASSOC_IO_SLOT_ROOT - Constants for the Associated I/O Slot: 'AssociatedIOSlot' IO_ADPT_ROOT - Constants for generic I/O Adapter: 'IOAdapter' BasePartition BasePartition BasePartition().allow_perf_data_collection BasePartition().allow_perf_data_collection BasePartition().assoc_sys_uuid BasePartition().avail_priority BasePartition().avail_priority BasePartition().bootmode BasePartition().bootmode BasePartition().capabilities BasePartition().cur_dram_pmem_volumes BasePartition().cur_pmem_volumes BasePartition().current_secure_boot BasePartition().disable_secure_boot BasePartition().disable_secure_boot BasePartition().env BasePartition().id BasePartition().io_config BasePartition().io_config BasePartition().is_mgmt_partition BasePartition().is_service_partition BasePartition().is_service_partition BasePartition().keylock_pos BasePartition().keylock_pos BasePartition().max_dram_pmem_volumes BasePartition().max_pmem_volumes BasePartition().mem_config BasePartition().mem_config BasePartition().name BasePartition().name BasePartition().nvram BasePartition().nvram BasePartition().operating_system BasePartition().partition_uuid BasePartition().pending_proc_compat_mode BasePartition().pending_secure_boot BasePartition().pending_secure_boot BasePartition().proc_compat_mode BasePartition().proc_compat_mode BasePartition().proc_config BasePartition().proc_config BasePartition().profile_sync BasePartition().profile_sync BasePartition().ref_code BasePartition().ref_code_full BasePartition().rmc_ip BasePartition().rmc_state BasePartition().state BasePartition().uptime BootMode DedicatedProcessorConfiguration DedicatedProcessorConfiguration.bld DedicatedProcessorConfiguration().desired DedicatedProcessorConfiguration().desired DedicatedProcessorConfiguration().max DedicatedProcessorConfiguration().max DedicatedProcessorConfiguration().min DedicatedProcessorConfiguration().min DedicatedSharingMode IOSlot IOSlot().__get_prop IOSlot().adapter IOSlot.bld IOSlot().bus_grp_required IOSlot().bus_grp_required IOSlot().description IOSlot().description IOSlot().drc_index IOSlot().drc_index IOSlot().drc_name IOSlot().drc_name IOSlot().io_adapter IOSlot().io_adapter IOSlot().pc_adpt_id IOSlot().pc_adpt_id IOSlot().pci_class IOSlot().pci_class IOSlot().pci_dev_id IOSlot().pci_dev_id IOSlot().pci_mfg_id IOSlot().pci_mfg_id IOSlot().pci_rev_id IOSlot().pci_rev_id IOSlot().pci_subsys_dev_id IOSlot().pci_subsys_dev_id IOSlot().pci_subsys_vendor_id IOSlot().pci_subsys_vendor_id IOSlot().pci_vendor_id IOSlot().pci_vendor_id IOSlot().phys_loc IOSlot().phys_loc IOSlot().required IOSlot().required KeylockPos LPARCompat LPARState LPARType PartitionCapabilities PartitionCapabilities().io_dlpar PartitionCapabilities().mem_dlpar PartitionCapabilities().proc_dlpar PartitionIOConfiguration PartitionIOConfiguration.bld PartitionIOConfiguration().io_slots PartitionIOConfiguration().io_slots PartitionIOConfiguration().max_virtual_slots PartitionIOConfiguration().max_virtual_slots PartitionIOConfiguration().tagged_io PartitionIOConfiguration().tagged_io PartitionMemoryConfiguration PartitionMemoryConfiguration().ame_enabled PartitionMemoryConfiguration.bld PartitionMemoryConfiguration().current PartitionMemoryConfiguration().desired PartitionMemoryConfiguration().desired PartitionMemoryConfiguration().exp_factor PartitionMemoryConfiguration().exp_factor PartitionMemoryConfiguration().max PartitionMemoryConfiguration().max PartitionMemoryConfiguration().min PartitionMemoryConfiguration().min PartitionMemoryConfiguration().ppt_ratio PartitionMemoryConfiguration().ppt_ratio PartitionMemoryConfiguration().shared_enabled PartitionProcessorConfiguration PartitionProcessorConfiguration.bld_dedicated PartitionProcessorConfiguration.bld_shared PartitionProcessorConfiguration().dedicated_proc_cfg PartitionProcessorConfiguration().has_dedicated PartitionProcessorConfiguration().shared_proc_cfg PartitionProcessorConfiguration().sharing_mode PartitionProcessorConfiguration().sharing_mode RMCState SharedProcessorConfiguration SharedProcessorConfiguration.bld SharedProcessorConfiguration().desired_units SharedProcessorConfiguration().desired_units SharedProcessorConfiguration().desired_virtual SharedProcessorConfiguration().desired_virtual SharedProcessorConfiguration().max_units SharedProcessorConfiguration().max_units SharedProcessorConfiguration().max_virtual SharedProcessorConfiguration().max_virtual SharedProcessorConfiguration().min_units SharedProcessorConfiguration().min_units SharedProcessorConfiguration().min_virtual SharedProcessorConfiguration().min_virtual SharedProcessorConfiguration().pool_id SharedProcessorConfiguration().pool_id SharedProcessorConfiguration().uncapped_weight SharedProcessorConfiguration().uncapped_weight SharingMode TaggedIO TaggedIO().alt_load_src TaggedIO().alt_load_src TaggedIO.bld TaggedIO().console TaggedIO().console TaggedIO().load_src TaggedIO().load_src","title":"Attributes"},{"location":"pypowervm/wrappers/base_partition/#basepartition_1","text":"Show source in base_partition.py:484 Base class for Logical Partition (LPAR) & Virtual I/O Server (VIOS). This corresponds to the abstract BasePartition object in the PowerVM schema.","title":"BasePartition"},{"location":"pypowervm/wrappers/base_partition/#signature","text":"class BasePartition(ewrap.EntryWrapper, _DlparCapable): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionallow_perf_data_collection","text":"Show source in base_partition.py:713","title":"BasePartition().allow_perf_data_collection"},{"location":"pypowervm/wrappers/base_partition/#signature_1","text":"@property def allow_perf_data_collection(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionallow_perf_data_collection_1","text":"Show source in base_partition.py:717","title":"BasePartition().allow_perf_data_collection"},{"location":"pypowervm/wrappers/base_partition/#signature_2","text":"@allow_perf_data_collection.setter def allow_perf_data_collection(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionassoc_sys_uuid","text":"Show source in base_partition.py:559 UUID of the associated ManagedSystem.","title":"BasePartition().assoc_sys_uuid"},{"location":"pypowervm/wrappers/base_partition/#signature_3","text":"@property def assoc_sys_uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionavail_priority","text":"Show source in base_partition.py:591","title":"BasePartition().avail_priority"},{"location":"pypowervm/wrappers/base_partition/#signature_4","text":"@property def avail_priority(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionavail_priority_1","text":"Show source in base_partition.py:595","title":"BasePartition().avail_priority"},{"location":"pypowervm/wrappers/base_partition/#signature_5","text":"@avail_priority.setter def avail_priority(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionbootmode","text":"Show source in base_partition.py:663 Boot mode - one of the BootMode enum values.","title":"BasePartition().bootmode"},{"location":"pypowervm/wrappers/base_partition/#signature_6","text":"@property def bootmode(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionbootmode_1","text":"Show source in base_partition.py:668","title":"BasePartition().bootmode"},{"location":"pypowervm/wrappers/base_partition/#signature_7","text":"@bootmode.setter def bootmode(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitioncapabilities","text":"Show source in base_partition.py:722","title":"BasePartition().capabilities"},{"location":"pypowervm/wrappers/base_partition/#signature_8","text":"@property def capabilities(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitioncur_dram_pmem_volumes","text":"Show source in base_partition.py:792","title":"BasePartition().cur_dram_pmem_volumes"},{"location":"pypowervm/wrappers/base_partition/#signature_9","text":"@property def cur_dram_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitioncur_pmem_volumes","text":"Show source in base_partition.py:784","title":"BasePartition().cur_pmem_volumes"},{"location":"pypowervm/wrappers/base_partition/#signature_10","text":"@property def cur_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitioncurrent_secure_boot","text":"Show source in base_partition.py:698 The Secure Boot Policy Value The secure boot value will determine what level of enforcement will take place when the LPAR is booted. The following are the values and their interpretations: * 0: Secure boot disabled * 1: Secure boot enabled (log only) * 2: Secure boot enabled and enforced * 3-9: Secure boot enabled and enforced. Firmware or OS may take additional measures.","title":"BasePartition().current_secure_boot"},{"location":"pypowervm/wrappers/base_partition/#signature_11","text":"@property def current_secure_boot(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitiondisable_secure_boot","text":"Show source in base_partition.py:674","title":"BasePartition().disable_secure_boot"},{"location":"pypowervm/wrappers/base_partition/#signature_12","text":"@property def disable_secure_boot(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitiondisable_secure_boot_1","text":"Show source in base_partition.py:678","title":"BasePartition().disable_secure_boot"},{"location":"pypowervm/wrappers/base_partition/#signature_13","text":"@disable_secure_boot.setter def disable_secure_boot(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionenv","text":"Show source in base_partition.py:543 See the LPARType Enumeration. Should usually be 'AIX/Linux' for LPAR. 'Virtual IO Server' should only happen for VIOS.","title":"BasePartition().env"},{"location":"pypowervm/wrappers/base_partition/#signature_14","text":"@property def env(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionid","text":"Show source in base_partition.py:534 Short ID (not UUID).","title":"BasePartition().id"},{"location":"pypowervm/wrappers/base_partition/#signature_15","text":"@property def id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionio_config","text":"Show source in base_partition.py:727 The Partition I/O Configuration.","title":"BasePartition().io_config"},{"location":"pypowervm/wrappers/base_partition/#signature_16","text":"@property def io_config(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionio_config_1","text":"Show source in base_partition.py:733 The Partition I/O Configuration for the LPAR.","title":"BasePartition().io_config"},{"location":"pypowervm/wrappers/base_partition/#signature_17","text":"@io_config.setter def io_config(self, io_cfg): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionis_mgmt_partition","text":"Show source in base_partition.py:636 Is this the management partition? Default False if field absent.","title":"BasePartition().is_mgmt_partition"},{"location":"pypowervm/wrappers/base_partition/#signature_18","text":"@property def is_mgmt_partition(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionis_service_partition","text":"Show source in base_partition.py:641 Is this the service partition? Default False if field absent.","title":"BasePartition().is_service_partition"},{"location":"pypowervm/wrappers/base_partition/#signature_19","text":"@property def is_service_partition(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionis_service_partition_1","text":"Show source in base_partition.py:646 Set if this is the service partition.","title":"BasePartition().is_service_partition"},{"location":"pypowervm/wrappers/base_partition/#signature_20","text":"@is_service_partition.setter def is_service_partition(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionkeylock_pos","text":"Show source in base_partition.py:651 Keylock position - see KeylockPos enumeration.","title":"BasePartition().keylock_pos"},{"location":"pypowervm/wrappers/base_partition/#signature_21","text":"@property def keylock_pos(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionkeylock_pos_1","text":"Show source in base_partition.py:656 Keylock position - see KeylockPos enumeration.","title":"BasePartition().keylock_pos"},{"location":"pypowervm/wrappers/base_partition/#signature_22","text":"@keylock_pos.setter def keylock_pos(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionmax_dram_pmem_volumes","text":"Show source in base_partition.py:788","title":"BasePartition().max_dram_pmem_volumes"},{"location":"pypowervm/wrappers/base_partition/#signature_23","text":"@property def max_dram_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionmax_pmem_volumes","text":"Show source in base_partition.py:780","title":"BasePartition().max_pmem_volumes"},{"location":"pypowervm/wrappers/base_partition/#signature_24","text":"@property def max_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionmem_config","text":"Show source in base_partition.py:741 The Partition Memory Configuration for the LPAR.","title":"BasePartition().mem_config"},{"location":"pypowervm/wrappers/base_partition/#signature_25","text":"@property def mem_config(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionmem_config_1","text":"Show source in base_partition.py:747 The Partition Memory Configuration for the LPAR.","title":"BasePartition().mem_config"},{"location":"pypowervm/wrappers/base_partition/#signature_26","text":"@mem_config.setter def mem_config(self, mem_cfg): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionname","text":"Show source in base_partition.py:525 Short name (not ID, MTMS, or hostname).","title":"BasePartition().name"},{"location":"pypowervm/wrappers/base_partition/#signature_27","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionname_1","text":"Show source in base_partition.py:530","title":"BasePartition().name"},{"location":"pypowervm/wrappers/base_partition/#signature_28","text":"@name.setter def name(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionnvram","text":"Show source in base_partition.py:765","title":"BasePartition().nvram"},{"location":"pypowervm/wrappers/base_partition/#signature_29","text":"@ewrap.Wrapper.xag_property(const.XAG.NVRAM) def nvram(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionnvram_1","text":"Show source in base_partition.py:769","title":"BasePartition().nvram"},{"location":"pypowervm/wrappers/base_partition/#signature_30","text":"@nvram.setter def nvram(self, nvram): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionoperating_system","text":"Show source in base_partition.py:578 String representing the OS and version, or 'Unknown'.","title":"BasePartition().operating_system"},{"location":"pypowervm/wrappers/base_partition/#signature_31","text":"@property def operating_system(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionpartition_uuid","text":"Show source in base_partition.py:555","title":"BasePartition().partition_uuid"},{"location":"pypowervm/wrappers/base_partition/#signature_32","text":"@property def partition_uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionpending_proc_compat_mode","text":"Show source in base_partition.py:618 Pending processor compatibility mode. See LPARCompat. E.g. 'POWER7', 'POWER7_Plus', 'POWER8', etc.","title":"BasePartition().pending_proc_compat_mode"},{"location":"pypowervm/wrappers/base_partition/#signature_33","text":"@property def pending_proc_compat_mode(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionpending_secure_boot","text":"Show source in base_partition.py:684 The Pending Secure Boot Policy Value This parameter can be set while the LPAR is running. It will be the policy used when the LPAR is next booted.","title":"BasePartition().pending_secure_boot"},{"location":"pypowervm/wrappers/base_partition/#signature_34","text":"@property def pending_secure_boot(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionpending_secure_boot_1","text":"Show source in base_partition.py:693","title":"BasePartition().pending_secure_boot"},{"location":"pypowervm/wrappers/base_partition/#signature_35","text":"@pending_secure_boot.setter def pending_secure_boot(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionproc_compat_mode","text":"Show source in base_partition.py:609 Current processor compatibility mode. See LPARCompat. E.g. 'POWER7', 'POWER7_Plus', 'POWER8', etc.","title":"BasePartition().proc_compat_mode"},{"location":"pypowervm/wrappers/base_partition/#signature_36","text":"@property def proc_compat_mode(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionproc_compat_mode_1","text":"Show source in base_partition.py:627 Sets PENDING proc compat mode. Note that corresponding getter retrieves the CURRENT proc compat mode.","title":"BasePartition().proc_compat_mode"},{"location":"pypowervm/wrappers/base_partition/#signature_37","text":"@proc_compat_mode.setter def proc_compat_mode(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionproc_config","text":"Show source in base_partition.py:753 The Partition Processor Configuration for the LPAR.","title":"BasePartition().proc_config"},{"location":"pypowervm/wrappers/base_partition/#signature_38","text":"@property def proc_config(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionproc_config_1","text":"Show source in base_partition.py:759 The Partition Processor Configuration for the LPAR.","title":"BasePartition().proc_config"},{"location":"pypowervm/wrappers/base_partition/#signature_39","text":"@proc_config.setter def proc_config(self, proc_config): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionprofile_sync","text":"Show source in base_partition.py:599","title":"BasePartition().profile_sync"},{"location":"pypowervm/wrappers/base_partition/#signature_40","text":"@property def profile_sync(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionprofile_sync_1","text":"Show source in base_partition.py:603","title":"BasePartition().profile_sync"},{"location":"pypowervm/wrappers/base_partition/#signature_41","text":"@profile_sync.setter def profile_sync(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionref_code","text":"Show source in base_partition.py:583","title":"BasePartition().ref_code"},{"location":"pypowervm/wrappers/base_partition/#signature_42","text":"@property def ref_code(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionref_code_full","text":"Show source in base_partition.py:587","title":"BasePartition().ref_code_full"},{"location":"pypowervm/wrappers/base_partition/#signature_43","text":"@property def ref_code_full(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionrmc_ip","text":"Show source in base_partition.py:573 IP address used for RMC communication, as a string.","title":"BasePartition().rmc_ip"},{"location":"pypowervm/wrappers/base_partition/#signature_44","text":"@property def rmc_ip(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionrmc_state","text":"Show source in base_partition.py:565 See RMCState. e.g. 'active', 'inactive', 'busy', etc.","title":"BasePartition().rmc_state"},{"location":"pypowervm/wrappers/base_partition/#signature_45","text":"@property def rmc_state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionstate","text":"Show source in base_partition.py:517 See LPARState. e.g. 'not activated', 'running', 'migrating running', etc.","title":"BasePartition().state"},{"location":"pypowervm/wrappers/base_partition/#signature_46","text":"@property def state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#basepartitionuptime","text":"Show source in base_partition.py:775 Integer time since partition boot, in seconds.","title":"BasePartition().uptime"},{"location":"pypowervm/wrappers/base_partition/#signature_47","text":"@property def uptime(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#bootmode","text":"Show source in base_partition.py:389 Mirror of PartitionBootMode.Enum. Valid values for LPAR.bootmode/VIOS.bootmode. Not to be confused with pypowervm.tasks.power.BootMode. Example usage: lwrap.bootmode = BootMode.NORM lwrap.update()","title":"BootMode"},{"location":"pypowervm/wrappers/base_partition/#signature_48","text":"class BootMode(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#dedicatedprocessorconfiguration","text":"Show source in base_partition.py:1143 Represents the partition's Dedicated Processor Configuration.","title":"DedicatedProcessorConfiguration"},{"location":"pypowervm/wrappers/base_partition/#signature_49","text":"class DedicatedProcessorConfiguration(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#dedicatedprocessorconfigurationbld","text":"Show source in base_partition.py:1146 Builds a Dedicated Processor configuration wrapper.","title":"DedicatedProcessorConfiguration.bld"},{"location":"pypowervm/wrappers/base_partition/#arguments","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) proc - Number of virtual processors (int) min_proc - Minimum processors, default to proc value max_proc - Maximum processors, default to proc value","title":"Arguments"},{"location":"pypowervm/wrappers/base_partition/#returns","text":"Processor Config with dedicated processors","title":"Returns"},{"location":"pypowervm/wrappers/base_partition/#signature_50","text":"@classmethod def bld(cls, adapter, proc, min_proc=None, max_proc=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#dedicatedprocessorconfigurationdesired","text":"Show source in base_partition.py:1172","title":"DedicatedProcessorConfiguration().desired"},{"location":"pypowervm/wrappers/base_partition/#signature_51","text":"@property def desired(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#dedicatedprocessorconfigurationdesired_1","text":"Show source in base_partition.py:1176","title":"DedicatedProcessorConfiguration().desired"},{"location":"pypowervm/wrappers/base_partition/#signature_52","text":"@desired.setter def desired(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#dedicatedprocessorconfigurationmax","text":"Show source in base_partition.py:1180","title":"DedicatedProcessorConfiguration().max"},{"location":"pypowervm/wrappers/base_partition/#signature_53","text":"@property def max(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#dedicatedprocessorconfigurationmax_1","text":"Show source in base_partition.py:1184","title":"DedicatedProcessorConfiguration().max"},{"location":"pypowervm/wrappers/base_partition/#signature_54","text":"@max.setter def max(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#dedicatedprocessorconfigurationmin","text":"Show source in base_partition.py:1188","title":"DedicatedProcessorConfiguration().min"},{"location":"pypowervm/wrappers/base_partition/#signature_55","text":"@property def min(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#dedicatedprocessorconfigurationmin_1","text":"Show source in base_partition.py:1192","title":"DedicatedProcessorConfiguration().min"},{"location":"pypowervm/wrappers/base_partition/#signature_56","text":"@min.setter def min(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#dedicatedsharingmode","text":"Show source in base_partition.py:315 Dedicated Processor sharing modes. Subset of LogicalPartitionProcessorSharingModeEnum.","title":"DedicatedSharingMode"},{"location":"pypowervm/wrappers/base_partition/#signature_57","text":"class DedicatedSharingMode(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslot","text":"Show source in base_partition.py:1311 An I/O Slot represents a device bus on the system. It may contain a piece of hardware within it.","title":"IOSlot"},{"location":"pypowervm/wrappers/base_partition/#signature_58","text":"class IOSlot(ewrap.ElementWrapper, ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslot__get_prop","text":"Show source in base_partition.py:1461 Thin wrapper to get the Associated I/O Slot and get a property.","title":"IOSlot().__get_prop"},{"location":"pypowervm/wrappers/base_partition/#signature_59","text":"def __get_prop(self, func): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotadapter","text":"Show source in base_partition.py:1523 DEPRECATED - use 'io_adapter' method instead.","title":"IOSlot().adapter"},{"location":"pypowervm/wrappers/base_partition/#signature_60","text":"@property def adapter(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotbld","text":"Show source in base_partition.py:1316 Build a new IOSlot wrapper with all required parameters.","title":"IOSlot.bld"},{"location":"pypowervm/wrappers/base_partition/#returns_1","text":"A new IOSlot wrapper.","title":"Returns"},{"location":"pypowervm/wrappers/base_partition/#signature_61","text":"@classmethod def bld(cls, adapter, bus_grp_required, drc_index, required=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotbus_grp_required","text":"Show source in base_partition.py:1368","title":"IOSlot().bus_grp_required"},{"location":"pypowervm/wrappers/base_partition/#signature_62","text":"@property def bus_grp_required(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotbus_grp_required_1","text":"Show source in base_partition.py:1471","title":"IOSlot().bus_grp_required"},{"location":"pypowervm/wrappers/base_partition/#signature_63","text":"@property def bus_grp_required(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotdescription","text":"Show source in base_partition.py:1376","title":"IOSlot().description"},{"location":"pypowervm/wrappers/base_partition/#signature_64","text":"@property def description(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotdescription_1","text":"Show source in base_partition.py:1475","title":"IOSlot().description"},{"location":"pypowervm/wrappers/base_partition/#signature_65","text":"@property def description(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotdrc_index","text":"Show source in base_partition.py:1416","title":"IOSlot().drc_index"},{"location":"pypowervm/wrappers/base_partition/#signature_66","text":"@property def drc_index(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotdrc_index_1","text":"Show source in base_partition.py:1515","title":"IOSlot().drc_index"},{"location":"pypowervm/wrappers/base_partition/#signature_67","text":"@property def drc_index(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotdrc_name","text":"Show source in base_partition.py:1423","title":"IOSlot().drc_name"},{"location":"pypowervm/wrappers/base_partition/#signature_68","text":"@property def drc_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotdrc_name_1","text":"Show source in base_partition.py:1519","title":"IOSlot().drc_name"},{"location":"pypowervm/wrappers/base_partition/#signature_69","text":"@property def drc_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotio_adapter","text":"Show source in base_partition.py:1427 Jumps over the 'Related IO Adapter' element direct to the I/O. This is another area where the schema has a two step jump that the API can avoid. This method skips over the RelatedIOAdapter and jumps right to the IO Adapter. Return values are either the generic IOAdapter or the PhysFCAdapter.","title":"IOSlot().io_adapter"},{"location":"pypowervm/wrappers/base_partition/#signature_70","text":"@property def io_adapter(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotio_adapter_1","text":"Show source in base_partition.py:1532 Returns the physical I/O Adapter for this slot. This will be one of two types. Either a generic I/O Adapter or a Physical Fibre Channel Adapter (PhysFCAdapter).","title":"IOSlot().io_adapter"},{"location":"pypowervm/wrappers/base_partition/#signature_71","text":"@property def io_adapter(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpc_adpt_id","text":"Show source in base_partition.py:1384","title":"IOSlot().pc_adpt_id"},{"location":"pypowervm/wrappers/base_partition/#signature_72","text":"@property def pc_adpt_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpc_adpt_id_1","text":"Show source in base_partition.py:1483","title":"IOSlot().pc_adpt_id"},{"location":"pypowervm/wrappers/base_partition/#signature_73","text":"@property def pc_adpt_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_class","text":"Show source in base_partition.py:1388","title":"IOSlot().pci_class"},{"location":"pypowervm/wrappers/base_partition/#signature_74","text":"@property def pci_class(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_class_1","text":"Show source in base_partition.py:1487","title":"IOSlot().pci_class"},{"location":"pypowervm/wrappers/base_partition/#signature_75","text":"@property def pci_class(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_dev_id","text":"Show source in base_partition.py:1392","title":"IOSlot().pci_dev_id"},{"location":"pypowervm/wrappers/base_partition/#signature_76","text":"@property def pci_dev_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_dev_id_1","text":"Show source in base_partition.py:1491","title":"IOSlot().pci_dev_id"},{"location":"pypowervm/wrappers/base_partition/#signature_77","text":"@property def pci_dev_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_mfg_id","text":"Show source in base_partition.py:1400","title":"IOSlot().pci_mfg_id"},{"location":"pypowervm/wrappers/base_partition/#signature_78","text":"@property def pci_mfg_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_mfg_id_1","text":"Show source in base_partition.py:1499","title":"IOSlot().pci_mfg_id"},{"location":"pypowervm/wrappers/base_partition/#signature_79","text":"@property def pci_mfg_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_rev_id","text":"Show source in base_partition.py:1404","title":"IOSlot().pci_rev_id"},{"location":"pypowervm/wrappers/base_partition/#signature_80","text":"@property def pci_rev_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_rev_id_1","text":"Show source in base_partition.py:1503","title":"IOSlot().pci_rev_id"},{"location":"pypowervm/wrappers/base_partition/#signature_81","text":"@property def pci_rev_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_subsys_dev_id","text":"Show source in base_partition.py:1396","title":"IOSlot().pci_subsys_dev_id"},{"location":"pypowervm/wrappers/base_partition/#signature_82","text":"@property def pci_subsys_dev_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_subsys_dev_id_1","text":"Show source in base_partition.py:1495","title":"IOSlot().pci_subsys_dev_id"},{"location":"pypowervm/wrappers/base_partition/#signature_83","text":"@property def pci_subsys_dev_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_subsys_vendor_id","text":"Show source in base_partition.py:1412","title":"IOSlot().pci_subsys_vendor_id"},{"location":"pypowervm/wrappers/base_partition/#signature_84","text":"@property def pci_subsys_vendor_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_subsys_vendor_id_1","text":"Show source in base_partition.py:1511","title":"IOSlot().pci_subsys_vendor_id"},{"location":"pypowervm/wrappers/base_partition/#signature_85","text":"@property def pci_subsys_vendor_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_vendor_id","text":"Show source in base_partition.py:1408","title":"IOSlot().pci_vendor_id"},{"location":"pypowervm/wrappers/base_partition/#signature_86","text":"@property def pci_vendor_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotpci_vendor_id_1","text":"Show source in base_partition.py:1507","title":"IOSlot().pci_vendor_id"},{"location":"pypowervm/wrappers/base_partition/#signature_87","text":"@property def pci_vendor_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotphys_loc","text":"Show source in base_partition.py:1380","title":"IOSlot().phys_loc"},{"location":"pypowervm/wrappers/base_partition/#signature_88","text":"@property def phys_loc(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotphys_loc_1","text":"Show source in base_partition.py:1479","title":"IOSlot().phys_loc"},{"location":"pypowervm/wrappers/base_partition/#signature_89","text":"@property def phys_loc(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotrequired","text":"Show source in base_partition.py:1453","title":"IOSlot().required"},{"location":"pypowervm/wrappers/base_partition/#signature_90","text":"@property def required(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#ioslotrequired_1","text":"Show source in base_partition.py:1457","title":"IOSlot().required"},{"location":"pypowervm/wrappers/base_partition/#signature_91","text":"@required.setter def required(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#keylockpos","text":"Show source in base_partition.py:412 Mirror of KeylockPosition.Enum. Valid values for LPAR.keylock_pos/VIOS.keylock_pos. Not to be confused with pypowervm.tasks.power.KeylockPos. Example usage: lwrap.keylock_pos = KeylockPos.MANUAL lwrap.update()","title":"KeylockPos"},{"location":"pypowervm/wrappers/base_partition/#signature_92","text":"class KeylockPos(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#lparcompat","text":"Show source in base_partition.py:356 LPAR compatibility modes. From LogicalPartitionProcessorCompatibilityModeEnum.","title":"LPARCompat"},{"location":"pypowervm/wrappers/base_partition/#signature_93","text":"class LPARCompat(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#lparstate","text":"Show source in base_partition.py:328 State of a given LPAR. From LogicalPartitionStateEnum.","title":"LPARState"},{"location":"pypowervm/wrappers/base_partition/#signature_94","text":"class LPARState(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#lpartype","text":"Show source in base_partition.py:349 Subset of LogicalPartitionEnvironmentEnum.","title":"LPARType"},{"location":"pypowervm/wrappers/base_partition/#signature_95","text":"class LPARType(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitioncapabilities","text":"Show source in base_partition.py:799 See LogicalPartitionCapabilities.","title":"PartitionCapabilities"},{"location":"pypowervm/wrappers/base_partition/#signature_96","text":"class PartitionCapabilities(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitioncapabilitiesio_dlpar","text":"Show source in base_partition.py:801","title":"PartitionCapabilities().io_dlpar"},{"location":"pypowervm/wrappers/base_partition/#signature_97","text":"@property def io_dlpar(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitioncapabilitiesmem_dlpar","text":"Show source in base_partition.py:805","title":"PartitionCapabilities().mem_dlpar"},{"location":"pypowervm/wrappers/base_partition/#signature_98","text":"@property def mem_dlpar(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitioncapabilitiesproc_dlpar","text":"Show source in base_partition.py:809","title":"PartitionCapabilities().proc_dlpar"},{"location":"pypowervm/wrappers/base_partition/#signature_99","text":"@property def proc_dlpar(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionioconfiguration","text":"Show source in base_partition.py:1198 Represents the partitions Dedicated IO Configuration. Comprised of I/O Slots. There are two types of IO slots. Those dedicated to physical hardware (io_slots) and those that get used by virtual hardware.","title":"PartitionIOConfiguration"},{"location":"pypowervm/wrappers/base_partition/#signature_100","text":"class PartitionIOConfiguration(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionioconfigurationbld","text":"Show source in base_partition.py:1206 Builds a Partition IO configuration wrapper.","title":"PartitionIOConfiguration.bld"},{"location":"pypowervm/wrappers/base_partition/#arguments_1","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) max_virt_slots - Number of virtual slots (int) PartitionIOConfiguration().io_slots - I/O slots to assign to the LPAR (list of IOSlot).","title":"Arguments"},{"location":"pypowervm/wrappers/base_partition/#returns_2","text":"Partition IO configuration wrapper","title":"Returns"},{"location":"pypowervm/wrappers/base_partition/#signature_101","text":"@classmethod def bld(cls, adapter, max_virt_slots, io_slots=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionioconfigurationio_slots","text":"Show source in base_partition.py:1235 The physical I/O Slots. Each slot will have hardware associated with it.","title":"PartitionIOConfiguration().io_slots"},{"location":"pypowervm/wrappers/base_partition/#signature_102","text":"@property def io_slots(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionioconfigurationio_slots_1","text":"Show source in base_partition.py:1244","title":"PartitionIOConfiguration().io_slots"},{"location":"pypowervm/wrappers/base_partition/#signature_103","text":"@io_slots.setter def io_slots(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionioconfigurationmax_virtual_slots","text":"Show source in base_partition.py:1223 The maximum number of virtual slots. Slots are used for every VirtualScsiServerAdapter, TrunkAdapter, etc...","title":"PartitionIOConfiguration().max_virtual_slots"},{"location":"pypowervm/wrappers/base_partition/#signature_104","text":"@property def max_virtual_slots(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionioconfigurationmax_virtual_slots_1","text":"Show source in base_partition.py:1231","title":"PartitionIOConfiguration().max_virtual_slots"},{"location":"pypowervm/wrappers/base_partition/#signature_105","text":"@max_virtual_slots.setter def max_virtual_slots(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionioconfigurationtagged_io","text":"Show source in base_partition.py:1248 IBMi only - tagged I/O attributes of the I/O configuration.","title":"PartitionIOConfiguration().tagged_io"},{"location":"pypowervm/wrappers/base_partition/#signature_106","text":"@property def tagged_io(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionioconfigurationtagged_io_1","text":"Show source in base_partition.py:1254","title":"PartitionIOConfiguration().tagged_io"},{"location":"pypowervm/wrappers/base_partition/#signature_107","text":"@tagged_io.setter def tagged_io(self, tio): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfiguration","text":"Show source in base_partition.py:919 Represents the partitions Memory Configuration.","title":"PartitionMemoryConfiguration"},{"location":"pypowervm/wrappers/base_partition/#signature_108","text":"class PartitionMemoryConfiguration(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationame_enabled","text":"Show source in base_partition.py:980","title":"PartitionMemoryConfiguration().ame_enabled"},{"location":"pypowervm/wrappers/base_partition/#signature_109","text":"@property def ame_enabled(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationbld","text":"Show source in base_partition.py:922 Creates the ParitionMemoryConfiguration.","title":"PartitionMemoryConfiguration.bld"},{"location":"pypowervm/wrappers/base_partition/#arguments_2","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) mem - The amount of memory for the partition in MB min_mem - The minimum amount of memory in MB. Defaults to the mem param max_mem - The maximum amount of memory in MB. Defaults to the mem param","title":"Arguments"},{"location":"pypowervm/wrappers/base_partition/#returns_3","text":"The memory configuration wrapper.","title":"Returns"},{"location":"pypowervm/wrappers/base_partition/#signature_110","text":"@classmethod def bld(cls, adapter, mem, min_mem=None, max_mem=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationcurrent","text":"Show source in base_partition.py:946","title":"PartitionMemoryConfiguration().current"},{"location":"pypowervm/wrappers/base_partition/#signature_111","text":"@property def current(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationdesired","text":"Show source in base_partition.py:950","title":"PartitionMemoryConfiguration().desired"},{"location":"pypowervm/wrappers/base_partition/#signature_112","text":"@property def desired(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationdesired_1","text":"Show source in base_partition.py:954","title":"PartitionMemoryConfiguration().desired"},{"location":"pypowervm/wrappers/base_partition/#signature_113","text":"@desired.setter def desired(self, mem): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationexp_factor","text":"Show source in base_partition.py:984 The Active Memory Expansion Factor The expansion factor represents the target memory multiplier. e.g. An LPAR with EF = 2 which has 4 GB of memory will have a target expansion memory of 8 GB.","title":"PartitionMemoryConfiguration().exp_factor"},{"location":"pypowervm/wrappers/base_partition/#signature_114","text":"@property def exp_factor(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationexp_factor_1","text":"Show source in base_partition.py:994 The Active Memory Expansion Factor","title":"PartitionMemoryConfiguration().exp_factor"},{"location":"pypowervm/wrappers/base_partition/#arguments_3","text":"exp_factor - The expansion factor value. Setting this to 0 will turn/keep AME off. The valid values are 1.0 <= x <= 10.0 up to 2 decimal places.","title":"Arguments"},{"location":"pypowervm/wrappers/base_partition/#signature_115","text":"@exp_factor.setter def exp_factor(self, exp_factor): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationmax","text":"Show source in base_partition.py:958","title":"PartitionMemoryConfiguration().max"},{"location":"pypowervm/wrappers/base_partition/#signature_116","text":"@property def max(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationmax_1","text":"Show source in base_partition.py:962","title":"PartitionMemoryConfiguration().max"},{"location":"pypowervm/wrappers/base_partition/#signature_117","text":"@max.setter def max(self, mem): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationmin","text":"Show source in base_partition.py:966","title":"PartitionMemoryConfiguration().min"},{"location":"pypowervm/wrappers/base_partition/#signature_118","text":"@property def min(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationmin_1","text":"Show source in base_partition.py:970","title":"PartitionMemoryConfiguration().min"},{"location":"pypowervm/wrappers/base_partition/#signature_119","text":"@min.setter def min(self, mem): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationppt_ratio","text":"Show source in base_partition.py:1005 The Physical Page Table Ratio The physical page table ratio represents the ratio of a VM's maximum memory to the size of its physical page table. The PPT is used by the platform to maintain the translation of the VM's physical to virtual memory addresses during mobility operations (i.e. LPM). The ppt_ratio is represented as 1:2^N where accepted values for N range from 6 to 12. If the ratio is 1:4096 for a VM with 64 GB of maximum memory, it would have a PPT of 16 MB (64 GB / 4096 = 16 MB).","title":"PartitionMemoryConfiguration().ppt_ratio"},{"location":"pypowervm/wrappers/base_partition/#signature_120","text":"@property def ppt_ratio(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationppt_ratio_1","text":"Show source in base_partition.py:1020 The Physical Page Table Ratio","title":"PartitionMemoryConfiguration().ppt_ratio"},{"location":"pypowervm/wrappers/base_partition/#arguments_4","text":"ppt_ratio - The ppt ratio value.","title":"Arguments"},{"location":"pypowervm/wrappers/base_partition/#signature_121","text":"@ppt_ratio.setter def ppt_ratio(self, ppt_ratio): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionmemoryconfigurationshared_enabled","text":"Show source in base_partition.py:974","title":"PartitionMemoryConfiguration().shared_enabled"},{"location":"pypowervm/wrappers/base_partition/#signature_122","text":"@property def shared_enabled(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionprocessorconfiguration","text":"Show source in base_partition.py:816 Represents the partitions Processor Configuration. Comprised of either the shared or dedicated processor config.","title":"PartitionProcessorConfiguration"},{"location":"pypowervm/wrappers/base_partition/#signature_123","text":"class PartitionProcessorConfiguration(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionprocessorconfigurationbld_dedicated","text":"Show source in base_partition.py:854 Builds a Dedicated Processor configuration wrapper.","title":"PartitionProcessorConfiguration.bld_dedicated"},{"location":"pypowervm/wrappers/base_partition/#arguments_5","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) proc - Number of virtual processors (int) min_proc - Minimum processors, default to proc value max_proc - Maximum processors, default to proc value PartitionProcessorConfiguration().sharing_mode - Sharing mode of the processors, 'sre idle proces'","title":"Arguments"},{"location":"pypowervm/wrappers/base_partition/#returns_4","text":"Processor Config with dedicated processors","title":"Returns"},{"location":"pypowervm/wrappers/base_partition/#signature_124","text":"@classmethod def bld_dedicated( cls, adapter, proc, min_proc=None, max_proc=None, sharing_mode=DedicatedSharingMode.SHARE_IDLE_PROCS, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionprocessorconfigurationbld_shared","text":"Show source in base_partition.py:822 Builds a Shared Processor configuration wrapper.","title":"PartitionProcessorConfiguration.bld_shared"},{"location":"pypowervm/wrappers/base_partition/#arguments_6","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) proc_unit - Amount of desired proc units (float) proc - Number of virtual processors (int) PartitionProcessorConfiguration().sharing_mode - Sharing mode of the processors (uncapped) uncapped_weight - Uncapped weight of the processors (0-255) min_proc_unit - Minimum proc units, default to proc unit value max_proc_unit - Maximum proc units, default to proc unit value min_proc - Minimum processors, default to proc value max_proc - Maximum processors, default to proc value proc_pool - The shared processor pool for the lpar, defaults to 0","title":"Arguments"},{"location":"pypowervm/wrappers/base_partition/#returns_5","text":"Processor Config with shared processors","title":"Returns"},{"location":"pypowervm/wrappers/base_partition/#signature_125","text":"@classmethod def bld_shared( cls, adapter, proc_unit, proc, sharing_mode=SharingMode.UNCAPPED, uncapped_weight=128, min_proc_unit=None, max_proc_unit=None, min_proc=None, max_proc=None, proc_pool=0, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionprocessorconfigurationdedicated_proc_cfg","text":"Show source in base_partition.py:906 Returns the Dedicated Processor Configuration.","title":"PartitionProcessorConfiguration().dedicated_proc_cfg"},{"location":"pypowervm/wrappers/base_partition/#signature_126","text":"@property def dedicated_proc_cfg(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionprocessorconfigurationhas_dedicated","text":"Show source in base_partition.py:879 Returns boolean True if dedicated, False if shared or not found.","title":"PartitionProcessorConfiguration().has_dedicated"},{"location":"pypowervm/wrappers/base_partition/#signature_127","text":"@property def has_dedicated(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionprocessorconfigurationshared_proc_cfg","text":"Show source in base_partition.py:896 Returns the Shared Processor Configuration.","title":"PartitionProcessorConfiguration().shared_proc_cfg"},{"location":"pypowervm/wrappers/base_partition/#signature_128","text":"@property def shared_proc_cfg(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionprocessorconfigurationsharing_mode","text":"Show source in base_partition.py:888","title":"PartitionProcessorConfiguration().sharing_mode"},{"location":"pypowervm/wrappers/base_partition/#signature_129","text":"@property def sharing_mode(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#partitionprocessorconfigurationsharing_mode_1","text":"Show source in base_partition.py:892","title":"PartitionProcessorConfiguration().sharing_mode"},{"location":"pypowervm/wrappers/base_partition/#signature_130","text":"@sharing_mode.setter def sharing_mode(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#rmcstate","text":"Show source in base_partition.py:377 Various RMC States. From ResourceMonitoringControlStateEnum.","title":"RMCState"},{"location":"pypowervm/wrappers/base_partition/#signature_131","text":"class RMCState(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfiguration","text":"Show source in base_partition.py:1031 Represents the partition's Shared Processor Configuration.","title":"SharedProcessorConfiguration"},{"location":"pypowervm/wrappers/base_partition/#signature_132","text":"class SharedProcessorConfiguration(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationbld","text":"Show source in base_partition.py:1034 Builds a Shared Processor configuration wrapper.","title":"SharedProcessorConfiguration.bld"},{"location":"pypowervm/wrappers/base_partition/#arguments_7","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) proc_unit - Amount of desired proc units (float) proc - Number of virtual processors (int) SharedProcessorConfiguration().uncapped_weight - Uncapped weight of the processors, 0-255 min_proc_unit - Minimum proc units, default to proc unit value max_proc_unit - Maximum proc units, default to proc unit value min_proc - Minimum processors, default to proc value max_proc - Maximum processors, default to proc value proc_pool - The shared processor pool for the lpar, defaults to 0","title":"Arguments"},{"location":"pypowervm/wrappers/base_partition/#returns_6","text":"Processor Config with shared processors","title":"Returns"},{"location":"pypowervm/wrappers/base_partition/#signature_133","text":"@classmethod def bld( cls, adapter, proc_unit, proc, uncapped_weight=None, min_proc_unit=None, max_proc_unit=None, min_proc=None, max_proc=None, proc_pool=0, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationdesired_units","text":"Show source in base_partition.py:1077","title":"SharedProcessorConfiguration().desired_units"},{"location":"pypowervm/wrappers/base_partition/#signature_134","text":"@property def desired_units(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationdesired_units_1","text":"Show source in base_partition.py:1081","title":"SharedProcessorConfiguration().desired_units"},{"location":"pypowervm/wrappers/base_partition/#signature_135","text":"@desired_units.setter def desired_units(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationdesired_virtual","text":"Show source in base_partition.py:1101","title":"SharedProcessorConfiguration().desired_virtual"},{"location":"pypowervm/wrappers/base_partition/#signature_136","text":"@property def desired_virtual(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationdesired_virtual_1","text":"Show source in base_partition.py:1105","title":"SharedProcessorConfiguration().desired_virtual"},{"location":"pypowervm/wrappers/base_partition/#signature_137","text":"@desired_virtual.setter def desired_virtual(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationmax_units","text":"Show source in base_partition.py:1085","title":"SharedProcessorConfiguration().max_units"},{"location":"pypowervm/wrappers/base_partition/#signature_138","text":"@property def max_units(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationmax_units_1","text":"Show source in base_partition.py:1089","title":"SharedProcessorConfiguration().max_units"},{"location":"pypowervm/wrappers/base_partition/#signature_139","text":"@max_units.setter def max_units(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationmax_virtual","text":"Show source in base_partition.py:1109","title":"SharedProcessorConfiguration().max_virtual"},{"location":"pypowervm/wrappers/base_partition/#signature_140","text":"@property def max_virtual(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationmax_virtual_1","text":"Show source in base_partition.py:1113","title":"SharedProcessorConfiguration().max_virtual"},{"location":"pypowervm/wrappers/base_partition/#signature_141","text":"@max_virtual.setter def max_virtual(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationmin_units","text":"Show source in base_partition.py:1093","title":"SharedProcessorConfiguration().min_units"},{"location":"pypowervm/wrappers/base_partition/#signature_142","text":"@property def min_units(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationmin_units_1","text":"Show source in base_partition.py:1097","title":"SharedProcessorConfiguration().min_units"},{"location":"pypowervm/wrappers/base_partition/#signature_143","text":"@min_units.setter def min_units(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationmin_virtual","text":"Show source in base_partition.py:1117","title":"SharedProcessorConfiguration().min_virtual"},{"location":"pypowervm/wrappers/base_partition/#signature_144","text":"@property def min_virtual(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationmin_virtual_1","text":"Show source in base_partition.py:1121","title":"SharedProcessorConfiguration().min_virtual"},{"location":"pypowervm/wrappers/base_partition/#signature_145","text":"@min_virtual.setter def min_virtual(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationpool_id","text":"Show source in base_partition.py:1125","title":"SharedProcessorConfiguration().pool_id"},{"location":"pypowervm/wrappers/base_partition/#signature_146","text":"@property def pool_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationpool_id_1","text":"Show source in base_partition.py:1129","title":"SharedProcessorConfiguration().pool_id"},{"location":"pypowervm/wrappers/base_partition/#signature_147","text":"@pool_id.setter def pool_id(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationuncapped_weight","text":"Show source in base_partition.py:1133","title":"SharedProcessorConfiguration().uncapped_weight"},{"location":"pypowervm/wrappers/base_partition/#signature_148","text":"@property def uncapped_weight(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharedprocessorconfigurationuncapped_weight_1","text":"Show source in base_partition.py:1137","title":"SharedProcessorConfiguration().uncapped_weight"},{"location":"pypowervm/wrappers/base_partition/#signature_149","text":"@uncapped_weight.setter def uncapped_weight(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#sharingmode","text":"Show source in base_partition.py:305 Shared Processor sharing modes. Subset of LogicalPartitionProcessorSharingModeEnum.","title":"SharingMode"},{"location":"pypowervm/wrappers/base_partition/#signature_150","text":"class SharingMode(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#taggedio","text":"Show source in base_partition.py:1261 IBMi only - tagged I/O attributes of the I/O configuration.","title":"TaggedIO"},{"location":"pypowervm/wrappers/base_partition/#signature_151","text":"class TaggedIO(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#taggedioalt_load_src","text":"Show source in base_partition.py:1281 Value may or may not be an integer - always returned as string.","title":"TaggedIO().alt_load_src"},{"location":"pypowervm/wrappers/base_partition/#signature_152","text":"@property def alt_load_src(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#taggedioalt_load_src_1","text":"Show source in base_partition.py:1286","title":"TaggedIO().alt_load_src"},{"location":"pypowervm/wrappers/base_partition/#signature_153","text":"@alt_load_src.setter def alt_load_src(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#taggediobld","text":"Show source in base_partition.py:1264 Builds a Partition TaggedIO wrapper.","title":"TaggedIO.bld"},{"location":"pypowervm/wrappers/base_partition/#arguments_8","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) TaggedIO().load_src - Load source to use TaggedIO().console - Console to use for IBMi TaggedIO().alt_load_src - Alternate load source to use","title":"Arguments"},{"location":"pypowervm/wrappers/base_partition/#returns_7","text":"Partition TaggedIO wrapper","title":"Returns"},{"location":"pypowervm/wrappers/base_partition/#signature_154","text":"@classmethod def bld(cls, adapter, load_src=\"0\", console=\"HMC\", alt_load_src=\"NONE\"): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#taggedioconsole","text":"Show source in base_partition.py:1290 Value may or may not be an integer - always returned as string.","title":"TaggedIO().console"},{"location":"pypowervm/wrappers/base_partition/#signature_155","text":"@property def console(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#taggedioconsole_1","text":"Show source in base_partition.py:1295","title":"TaggedIO().console"},{"location":"pypowervm/wrappers/base_partition/#signature_156","text":"@console.setter def console(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#taggedioload_src","text":"Show source in base_partition.py:1299 Value may or may not be an integer - always returned as string.","title":"TaggedIO().load_src"},{"location":"pypowervm/wrappers/base_partition/#signature_157","text":"@property def load_src(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/base_partition/#taggedioload_src_1","text":"Show source in base_partition.py:1304","title":"TaggedIO().load_src"},{"location":"pypowervm/wrappers/base_partition/#signature_158","text":"@load_src.setter def load_src(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/","text":"Cluster Pypowervm Index / Pypowervm / Wrappers / Cluster Auto-generated documentation for pypowervm.wrappers.cluster module. Cluster Cluster Cluster.bld Cluster().id Cluster().name Cluster().nodes Cluster().nodes Cluster().repos_pv Cluster().repos_pv Cluster().ssp_uri Cluster().ssp_uuid Node Node.bld Node().hostname Node().lpar_id Node().mtms Node().state Node().vios_uri Node().vios_uuid NodeState Cluster Show source in cluster.py:59 A Cluster behind a SharedStoragePool. Signature class Cluster(ewrap.EntryWrapper): ... Cluster.bld Show source in cluster.py:64 Create a fresh Cluster EntryWrapper. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) Cluster().name - String name for the Cluster. Cluster().repos_pv - storage.PV representing the repository disk. first_node - Node wrapper representing the first VIOS to host the Cluster. (The Cluster Create API only accepts a single node; others must be added later.) The VIOS must be able to see each disk. Signature @classmethod def bld(cls, adapter, name, repos_pv, first_node): ... Cluster().id Show source in cluster.py:89 The string ID according to VIOS, not a UUID or UDID. Signature @property def id(self): ... Cluster().name Show source in cluster.py:82 Signature @property def name(self): ... Cluster().nodes Show source in cluster.py:131 WrapperElemList of Node wrappers. Signature @property def nodes(self): ... Cluster().nodes Show source in cluster.py:136 Signature @nodes.setter def nodes(self, ns): ... Cluster().repos_pv Show source in cluster.py:106 Returns the (one) repository PV. Although the schema technically allows a collection of PVs under the RepositoryDisk element, a Cluster always has exactly one repository PV. Signature @property def repos_pv(self): ... Cluster().repos_pv Show source in cluster.py:120 Set the (single) PV member of RepositoryDisk. You cannot change the repository disk of a live Cluster. This setter is useful only when constructing new Clusters. Arguments pv - The PV (NOT a list) to set. Signature @repos_pv.setter def repos_pv(self, pv): ... Cluster().ssp_uri Show source in cluster.py:94 The URI of the SharedStoragePool associated with this Cluster. Signature @property def ssp_uri(self): ... Cluster().ssp_uuid Show source in cluster.py:99 The UUID of the SharedStoragePool associated with this Cluster. Signature @property def ssp_uuid(self): ... Node Show source in cluster.py:143 A Node represents a VIOS member of a Cluster. A Cluster cannot simply contain VirtualIOServer links because it is likely that some of the Cluster's members are not managed by the same instance of the PowerVM REST server, which would then have no way to construct said links. In such cases, the Node object supplies enough information about the VIOS that it could be found by a determined consumer. To add a new Node to a Cluster, only the hostname is required. n = Node() n.hostname = ... cluster.nodes.append(n) adapter.update(...) Signature class Node(ewrap.ElementWrapper): ... Node.bld Show source in cluster.py:159 Create a fresh Node ElementWrapper. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) Node().hostname - String hostname (or IP) of the Node. Node().lpar_id - Integer LPAR ID of the Node. Node().mtms - String OR mtms.MTMS wrapper representing the Machine Type, Model, and Serial Number of the system hosting the VIOS. String format: 'MT-M S' e.g. '8247-22L 1234A0B'. Node().vios_uri - String URI representing this Node. Signature @classmethod def bld(cls, adapter, hostname=None, lpar_id=None, mtms=None, vios_uri=None): ... Node().hostname Show source in cluster.py:184 Signature @property def hostname(self): ... Node().lpar_id Show source in cluster.py:191 Small integer partition ID, not UUID. Signature @property def lpar_id(self): ... Node().mtms Show source in cluster.py:199 MTMS Element wrapper of the system hosting the Node (VIOS). Signature @property def mtms(self): ... Node().state Show source in cluster.py:235 Signature @property def state(self): ... Node().vios_uri Show source in cluster.py:214 The URI of the VIOS. This is only set if the VIOS is on this system! Signature @property def vios_uri(self): ... Node().vios_uuid Show source in cluster.py:225 The UUID of the Node (VIOS). This is only set if the VIOS is on this system! Signature @property def vios_uuid(self): ... NodeState Show source in cluster.py:51 Cluster node state, from NodeState.Enum. Signature class NodeState(object): ...","title":"Cluster"},{"location":"pypowervm/wrappers/cluster/#cluster","text":"Pypowervm Index / Pypowervm / Wrappers / Cluster Auto-generated documentation for pypowervm.wrappers.cluster module. Cluster Cluster Cluster.bld Cluster().id Cluster().name Cluster().nodes Cluster().nodes Cluster().repos_pv Cluster().repos_pv Cluster().ssp_uri Cluster().ssp_uuid Node Node.bld Node().hostname Node().lpar_id Node().mtms Node().state Node().vios_uri Node().vios_uuid NodeState","title":"Cluster"},{"location":"pypowervm/wrappers/cluster/#cluster_1","text":"Show source in cluster.py:59 A Cluster behind a SharedStoragePool.","title":"Cluster"},{"location":"pypowervm/wrappers/cluster/#signature","text":"class Cluster(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#clusterbld","text":"Show source in cluster.py:64 Create a fresh Cluster EntryWrapper.","title":"Cluster.bld"},{"location":"pypowervm/wrappers/cluster/#arguments","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) Cluster().name - String name for the Cluster. Cluster().repos_pv - storage.PV representing the repository disk. first_node - Node wrapper representing the first VIOS to host the Cluster. (The Cluster Create API only accepts a single node; others must be added later.) The VIOS must be able to see each disk.","title":"Arguments"},{"location":"pypowervm/wrappers/cluster/#signature_1","text":"@classmethod def bld(cls, adapter, name, repos_pv, first_node): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#clusterid","text":"Show source in cluster.py:89 The string ID according to VIOS, not a UUID or UDID.","title":"Cluster().id"},{"location":"pypowervm/wrappers/cluster/#signature_2","text":"@property def id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#clustername","text":"Show source in cluster.py:82","title":"Cluster().name"},{"location":"pypowervm/wrappers/cluster/#signature_3","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#clusternodes","text":"Show source in cluster.py:131 WrapperElemList of Node wrappers.","title":"Cluster().nodes"},{"location":"pypowervm/wrappers/cluster/#signature_4","text":"@property def nodes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#clusternodes_1","text":"Show source in cluster.py:136","title":"Cluster().nodes"},{"location":"pypowervm/wrappers/cluster/#signature_5","text":"@nodes.setter def nodes(self, ns): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#clusterrepos_pv","text":"Show source in cluster.py:106 Returns the (one) repository PV. Although the schema technically allows a collection of PVs under the RepositoryDisk element, a Cluster always has exactly one repository PV.","title":"Cluster().repos_pv"},{"location":"pypowervm/wrappers/cluster/#signature_6","text":"@property def repos_pv(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#clusterrepos_pv_1","text":"Show source in cluster.py:120 Set the (single) PV member of RepositoryDisk. You cannot change the repository disk of a live Cluster. This setter is useful only when constructing new Clusters.","title":"Cluster().repos_pv"},{"location":"pypowervm/wrappers/cluster/#arguments_1","text":"pv - The PV (NOT a list) to set.","title":"Arguments"},{"location":"pypowervm/wrappers/cluster/#signature_7","text":"@repos_pv.setter def repos_pv(self, pv): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#clusterssp_uri","text":"Show source in cluster.py:94 The URI of the SharedStoragePool associated with this Cluster.","title":"Cluster().ssp_uri"},{"location":"pypowervm/wrappers/cluster/#signature_8","text":"@property def ssp_uri(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#clusterssp_uuid","text":"Show source in cluster.py:99 The UUID of the SharedStoragePool associated with this Cluster.","title":"Cluster().ssp_uuid"},{"location":"pypowervm/wrappers/cluster/#signature_9","text":"@property def ssp_uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#node","text":"Show source in cluster.py:143 A Node represents a VIOS member of a Cluster. A Cluster cannot simply contain VirtualIOServer links because it is likely that some of the Cluster's members are not managed by the same instance of the PowerVM REST server, which would then have no way to construct said links. In such cases, the Node object supplies enough information about the VIOS that it could be found by a determined consumer. To add a new Node to a Cluster, only the hostname is required. n = Node() n.hostname = ... cluster.nodes.append(n) adapter.update(...)","title":"Node"},{"location":"pypowervm/wrappers/cluster/#signature_10","text":"class Node(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#nodebld","text":"Show source in cluster.py:159 Create a fresh Node ElementWrapper.","title":"Node.bld"},{"location":"pypowervm/wrappers/cluster/#arguments_2","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) Node().hostname - String hostname (or IP) of the Node. Node().lpar_id - Integer LPAR ID of the Node. Node().mtms - String OR mtms.MTMS wrapper representing the Machine Type, Model, and Serial Number of the system hosting the VIOS. String format: 'MT-M S' e.g. '8247-22L 1234A0B'. Node().vios_uri - String URI representing this Node.","title":"Arguments"},{"location":"pypowervm/wrappers/cluster/#signature_11","text":"@classmethod def bld(cls, adapter, hostname=None, lpar_id=None, mtms=None, vios_uri=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#nodehostname","text":"Show source in cluster.py:184","title":"Node().hostname"},{"location":"pypowervm/wrappers/cluster/#signature_12","text":"@property def hostname(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#nodelpar_id","text":"Show source in cluster.py:191 Small integer partition ID, not UUID.","title":"Node().lpar_id"},{"location":"pypowervm/wrappers/cluster/#signature_13","text":"@property def lpar_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#nodemtms","text":"Show source in cluster.py:199 MTMS Element wrapper of the system hosting the Node (VIOS).","title":"Node().mtms"},{"location":"pypowervm/wrappers/cluster/#signature_14","text":"@property def mtms(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#nodestate","text":"Show source in cluster.py:235","title":"Node().state"},{"location":"pypowervm/wrappers/cluster/#signature_15","text":"@property def state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#nodevios_uri","text":"Show source in cluster.py:214 The URI of the VIOS. This is only set if the VIOS is on this system!","title":"Node().vios_uri"},{"location":"pypowervm/wrappers/cluster/#signature_16","text":"@property def vios_uri(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#nodevios_uuid","text":"Show source in cluster.py:225 The UUID of the Node (VIOS). This is only set if the VIOS is on this system!","title":"Node().vios_uuid"},{"location":"pypowervm/wrappers/cluster/#signature_17","text":"@property def vios_uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/cluster/#nodestate_1","text":"Show source in cluster.py:51 Cluster node state, from NodeState.Enum.","title":"NodeState"},{"location":"pypowervm/wrappers/cluster/#signature_18","text":"class NodeState(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/","text":"Enterprise Pool Pypowervm Index / Pypowervm / Wrappers / Enterprise Pool Auto-generated documentation for pypowervm.wrappers.enterprise_pool module. Enterprise Pool ComplianceState Pool Pool().avail_mobile_mem Pool().avail_mobile_procs Pool().compliance_hours_left Pool().compliance_state Pool().id Pool().master_console_mtms Pool().mgmt_consoles Pool().name Pool().total_mobile_mem Pool().total_mobile_procs Pool().unret_mobile_mem Pool().unret_mobile_procs PoolMember PoolMember().inactive_mem PoolMember().inactive_procs PoolMember().mem_compliance_hours_left PoolMember().mgmt_consoles PoolMember().mobile_mem PoolMember().mobile_mem PoolMember().mobile_procs PoolMember().mobile_procs PoolMember().proc_compliance_hours_left PoolMember().sys_installed_mem PoolMember().sys_installed_procs PoolMember().sys_mtms PoolMember().sys_name PoolMember().sys_state PoolMember().unret_mobile_mem PoolMember().unret_mobile_procs PoolMgmtConsole PoolMgmtConsole().ip_addr PoolMgmtConsole().is_master_console PoolMgmtConsole().mtms PoolMgmtConsole().name ComplianceState Show source in enterprise_pool.py:64 Signature class ComplianceState(object): ... Pool Show source in enterprise_pool.py:73 Wraps the Pool entries. Signature class Pool(entry_wrapper.EntryWrapper): ... Pool().avail_mobile_mem Show source in enterprise_pool.py:119 Integer num of the available mobile CoD memory (GB) in the pool. Signature @property def avail_mobile_mem(self): ... Pool().avail_mobile_procs Show source in enterprise_pool.py:104 Integer num of the available mobile CoD proc units in the pool. Signature @property def avail_mobile_procs(self): ... Pool().compliance_hours_left Show source in enterprise_pool.py:91 Integer num of hours until the pool is considered out of compliance. Return default of 0 if it is not found. Signature @entry_wrapper.Wrapper.xag_property(const.XAG.ADV) def compliance_hours_left(self): ... Pool().compliance_state Show source in enterprise_pool.py:86 The compliance state of the enterprise pool. Signature @property def compliance_state(self): ... Pool().id Show source in enterprise_pool.py:76 Integer enterprise pool ID. Signature @property def id(self): ... Pool().master_console_mtms Show source in enterprise_pool.py:136 The master console MTMS (machine type, model, serial number). Signature @property def master_console_mtms(self): ... Pool().mgmt_consoles Show source in enterprise_pool.py:129 Returns a WrapperElemList of PoolMgmtConsole's. Signature @property def mgmt_consoles(self): ... Pool().name Show source in enterprise_pool.py:81 The name of the enterprise pool. Signature @property def name(self): ... Pool().total_mobile_mem Show source in enterprise_pool.py:114 Integer num of the total mobile CoD memory (GB) in the pool. Signature @property def total_mobile_mem(self): ... Pool().total_mobile_procs Show source in enterprise_pool.py:99 Integer num of the total mobile CoD proc units in the pool. Signature @property def total_mobile_procs(self): ... Pool().unret_mobile_mem Show source in enterprise_pool.py:124 Integer num of the unreturned mobile CoD memory (GB) in the pool. Signature @property def unret_mobile_mem(self): ... Pool().unret_mobile_procs Show source in enterprise_pool.py:109 Integer num of the unreturned mobile CoD proc units in the pool. Signature @property def unret_mobile_procs(self): ... PoolMember Show source in enterprise_pool.py:155 Wraps the PoolMember entries. Signature class PoolMember(entry_wrapper.EntryWrapper): ... PoolMember().inactive_mem Show source in enterprise_pool.py:181 Integer amount of inactive (dark) memory (GB) on the system. Signature @property def inactive_mem(self): ... PoolMember().inactive_procs Show source in enterprise_pool.py:176 Integer num of the inactive (dark) proc units on the system. Signature @property def inactive_procs(self): ... PoolMember().mem_compliance_hours_left Show source in enterprise_pool.py:207 Integer num of memory compliance hours remaining. Number of hours remaining until the system is considered out of compliance in terms of mobile memory. Return default of 0 if it is not found. Signature @entry_wrapper.Wrapper.xag_property(const.XAG.ADV) def mem_compliance_hours_left(self): ... PoolMember().mgmt_consoles Show source in enterprise_pool.py:244 Returns a WrapperElemList of PoolMgmtConsole's. Signature @property def mgmt_consoles(self): ... PoolMember().mobile_mem Show source in enterprise_pool.py:167 Integer amount of mobile CoD memory (GB) on the system. Signature @property def mobile_mem(self): ... PoolMember().mobile_mem Show source in enterprise_pool.py:172 Signature @mobile_mem.setter def mobile_mem(self, value): ... PoolMember().mobile_procs Show source in enterprise_pool.py:158 Integer num of the mobile CoD proc units on the system. Signature @property def mobile_procs(self): ... PoolMember().mobile_procs Show source in enterprise_pool.py:163 Signature @mobile_procs.setter def mobile_procs(self, value): ... PoolMember().proc_compliance_hours_left Show source in enterprise_pool.py:196 Integer num of proc compliance hours remaining. Number of hours remaining until the system is considered out of compliance in terms of mobile procs. Return default of 0 if it is not found. Signature @entry_wrapper.Wrapper.xag_property(const.XAG.ADV) def proc_compliance_hours_left(self): ... PoolMember().sys_installed_mem Show source in enterprise_pool.py:228 Integer amount of installed memory (MB) on the system. Signature @property def sys_installed_mem(self): ... PoolMember().sys_installed_procs Show source in enterprise_pool.py:223 Integer num of the installed proc units on the system. Signature @property def sys_installed_procs(self): ... PoolMember().sys_mtms Show source in enterprise_pool.py:233 The MTMS (machine type, model, serial number) of the system. Signature @property def sys_mtms(self): ... PoolMember().sys_name Show source in enterprise_pool.py:218 The name of the system that corresponds to this pool member. Signature @property def sys_name(self): ... PoolMember().sys_state Show source in enterprise_pool.py:239 The state of the system. Signature @property def sys_state(self): ... PoolMember().unret_mobile_mem Show source in enterprise_pool.py:191 Integer amount of unreturned mobile CoD memory (GB) on the sys. Signature @property def unret_mobile_mem(self): ... PoolMember().unret_mobile_procs Show source in enterprise_pool.py:186 Integer num of the unreturned mobile CoD proc units on the sys. Signature @property def unret_mobile_procs(self): ... PoolMgmtConsole Show source in enterprise_pool.py:254 Wraps the PoolMgmtConsole elements. Signature class PoolMgmtConsole(entry_wrapper.ElementWrapper): ... PoolMgmtConsole().ip_addr Show source in enterprise_pool.py:272 String value for the IP address of the console. Signature @property def ip_addr(self): ... PoolMgmtConsole().is_master_console Show source in enterprise_pool.py:267 Boolean for whether or not this console is master for the pool. Signature @property def is_master_console(self): ... PoolMgmtConsole().mtms Show source in enterprise_pool.py:262 The MTMS (machine type, model, serial number) of the console. Signature @property def mtms(self): ... PoolMgmtConsole().name Show source in enterprise_pool.py:257 String value for the name of the management console. Signature @property def name(self): ...","title":"Enterprise Pool"},{"location":"pypowervm/wrappers/enterprise_pool/#enterprise-pool","text":"Pypowervm Index / Pypowervm / Wrappers / Enterprise Pool Auto-generated documentation for pypowervm.wrappers.enterprise_pool module. Enterprise Pool ComplianceState Pool Pool().avail_mobile_mem Pool().avail_mobile_procs Pool().compliance_hours_left Pool().compliance_state Pool().id Pool().master_console_mtms Pool().mgmt_consoles Pool().name Pool().total_mobile_mem Pool().total_mobile_procs Pool().unret_mobile_mem Pool().unret_mobile_procs PoolMember PoolMember().inactive_mem PoolMember().inactive_procs PoolMember().mem_compliance_hours_left PoolMember().mgmt_consoles PoolMember().mobile_mem PoolMember().mobile_mem PoolMember().mobile_procs PoolMember().mobile_procs PoolMember().proc_compliance_hours_left PoolMember().sys_installed_mem PoolMember().sys_installed_procs PoolMember().sys_mtms PoolMember().sys_name PoolMember().sys_state PoolMember().unret_mobile_mem PoolMember().unret_mobile_procs PoolMgmtConsole PoolMgmtConsole().ip_addr PoolMgmtConsole().is_master_console PoolMgmtConsole().mtms PoolMgmtConsole().name","title":"Enterprise Pool"},{"location":"pypowervm/wrappers/enterprise_pool/#compliancestate","text":"Show source in enterprise_pool.py:64","title":"ComplianceState"},{"location":"pypowervm/wrappers/enterprise_pool/#signature","text":"class ComplianceState(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#pool","text":"Show source in enterprise_pool.py:73 Wraps the Pool entries.","title":"Pool"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_1","text":"class Pool(entry_wrapper.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolavail_mobile_mem","text":"Show source in enterprise_pool.py:119 Integer num of the available mobile CoD memory (GB) in the pool.","title":"Pool().avail_mobile_mem"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_2","text":"@property def avail_mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolavail_mobile_procs","text":"Show source in enterprise_pool.py:104 Integer num of the available mobile CoD proc units in the pool.","title":"Pool().avail_mobile_procs"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_3","text":"@property def avail_mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolcompliance_hours_left","text":"Show source in enterprise_pool.py:91 Integer num of hours until the pool is considered out of compliance. Return default of 0 if it is not found.","title":"Pool().compliance_hours_left"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_4","text":"@entry_wrapper.Wrapper.xag_property(const.XAG.ADV) def compliance_hours_left(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolcompliance_state","text":"Show source in enterprise_pool.py:86 The compliance state of the enterprise pool.","title":"Pool().compliance_state"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_5","text":"@property def compliance_state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolid","text":"Show source in enterprise_pool.py:76 Integer enterprise pool ID.","title":"Pool().id"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_6","text":"@property def id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmaster_console_mtms","text":"Show source in enterprise_pool.py:136 The master console MTMS (machine type, model, serial number).","title":"Pool().master_console_mtms"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_7","text":"@property def master_console_mtms(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmgmt_consoles","text":"Show source in enterprise_pool.py:129 Returns a WrapperElemList of PoolMgmtConsole's.","title":"Pool().mgmt_consoles"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_8","text":"@property def mgmt_consoles(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolname","text":"Show source in enterprise_pool.py:81 The name of the enterprise pool.","title":"Pool().name"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_9","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#pooltotal_mobile_mem","text":"Show source in enterprise_pool.py:114 Integer num of the total mobile CoD memory (GB) in the pool.","title":"Pool().total_mobile_mem"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_10","text":"@property def total_mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#pooltotal_mobile_procs","text":"Show source in enterprise_pool.py:99 Integer num of the total mobile CoD proc units in the pool.","title":"Pool().total_mobile_procs"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_11","text":"@property def total_mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolunret_mobile_mem","text":"Show source in enterprise_pool.py:124 Integer num of the unreturned mobile CoD memory (GB) in the pool.","title":"Pool().unret_mobile_mem"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_12","text":"@property def unret_mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolunret_mobile_procs","text":"Show source in enterprise_pool.py:109 Integer num of the unreturned mobile CoD proc units in the pool.","title":"Pool().unret_mobile_procs"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_13","text":"@property def unret_mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmember","text":"Show source in enterprise_pool.py:155 Wraps the PoolMember entries.","title":"PoolMember"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_14","text":"class PoolMember(entry_wrapper.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmemberinactive_mem","text":"Show source in enterprise_pool.py:181 Integer amount of inactive (dark) memory (GB) on the system.","title":"PoolMember().inactive_mem"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_15","text":"@property def inactive_mem(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmemberinactive_procs","text":"Show source in enterprise_pool.py:176 Integer num of the inactive (dark) proc units on the system.","title":"PoolMember().inactive_procs"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_16","text":"@property def inactive_procs(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembermem_compliance_hours_left","text":"Show source in enterprise_pool.py:207 Integer num of memory compliance hours remaining. Number of hours remaining until the system is considered out of compliance in terms of mobile memory. Return default of 0 if it is not found.","title":"PoolMember().mem_compliance_hours_left"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_17","text":"@entry_wrapper.Wrapper.xag_property(const.XAG.ADV) def mem_compliance_hours_left(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembermgmt_consoles","text":"Show source in enterprise_pool.py:244 Returns a WrapperElemList of PoolMgmtConsole's.","title":"PoolMember().mgmt_consoles"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_18","text":"@property def mgmt_consoles(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembermobile_mem","text":"Show source in enterprise_pool.py:167 Integer amount of mobile CoD memory (GB) on the system.","title":"PoolMember().mobile_mem"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_19","text":"@property def mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembermobile_mem_1","text":"Show source in enterprise_pool.py:172","title":"PoolMember().mobile_mem"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_20","text":"@mobile_mem.setter def mobile_mem(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembermobile_procs","text":"Show source in enterprise_pool.py:158 Integer num of the mobile CoD proc units on the system.","title":"PoolMember().mobile_procs"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_21","text":"@property def mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembermobile_procs_1","text":"Show source in enterprise_pool.py:163","title":"PoolMember().mobile_procs"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_22","text":"@mobile_procs.setter def mobile_procs(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmemberproc_compliance_hours_left","text":"Show source in enterprise_pool.py:196 Integer num of proc compliance hours remaining. Number of hours remaining until the system is considered out of compliance in terms of mobile procs. Return default of 0 if it is not found.","title":"PoolMember().proc_compliance_hours_left"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_23","text":"@entry_wrapper.Wrapper.xag_property(const.XAG.ADV) def proc_compliance_hours_left(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembersys_installed_mem","text":"Show source in enterprise_pool.py:228 Integer amount of installed memory (MB) on the system.","title":"PoolMember().sys_installed_mem"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_24","text":"@property def sys_installed_mem(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembersys_installed_procs","text":"Show source in enterprise_pool.py:223 Integer num of the installed proc units on the system.","title":"PoolMember().sys_installed_procs"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_25","text":"@property def sys_installed_procs(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembersys_mtms","text":"Show source in enterprise_pool.py:233 The MTMS (machine type, model, serial number) of the system.","title":"PoolMember().sys_mtms"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_26","text":"@property def sys_mtms(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembersys_name","text":"Show source in enterprise_pool.py:218 The name of the system that corresponds to this pool member.","title":"PoolMember().sys_name"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_27","text":"@property def sys_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmembersys_state","text":"Show source in enterprise_pool.py:239 The state of the system.","title":"PoolMember().sys_state"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_28","text":"@property def sys_state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmemberunret_mobile_mem","text":"Show source in enterprise_pool.py:191 Integer amount of unreturned mobile CoD memory (GB) on the sys.","title":"PoolMember().unret_mobile_mem"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_29","text":"@property def unret_mobile_mem(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmemberunret_mobile_procs","text":"Show source in enterprise_pool.py:186 Integer num of the unreturned mobile CoD proc units on the sys.","title":"PoolMember().unret_mobile_procs"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_30","text":"@property def unret_mobile_procs(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmgmtconsole","text":"Show source in enterprise_pool.py:254 Wraps the PoolMgmtConsole elements.","title":"PoolMgmtConsole"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_31","text":"class PoolMgmtConsole(entry_wrapper.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmgmtconsoleip_addr","text":"Show source in enterprise_pool.py:272 String value for the IP address of the console.","title":"PoolMgmtConsole().ip_addr"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_32","text":"@property def ip_addr(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmgmtconsoleis_master_console","text":"Show source in enterprise_pool.py:267 Boolean for whether or not this console is master for the pool.","title":"PoolMgmtConsole().is_master_console"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_33","text":"@property def is_master_console(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmgmtconsolemtms","text":"Show source in enterprise_pool.py:262 The MTMS (machine type, model, serial number) of the console.","title":"PoolMgmtConsole().mtms"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_34","text":"@property def mtms(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/enterprise_pool/#poolmgmtconsolename","text":"Show source in enterprise_pool.py:257 String value for the name of the management console.","title":"PoolMgmtConsole().name"},{"location":"pypowervm/wrappers/enterprise_pool/#signature_35","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/","text":"EntryWrapper Pypowervm Index / Pypowervm / Wrappers / EntryWrapper Auto-generated documentation for pypowervm.wrappers.entry_wrapper module. EntryWrapper ActionableList ActionableList().append ActionableList().extend ActionableList().insert ActionableList().pop ActionableList().remove ElementWrapper ElementWrapper(). eq ElementWrapper(). hash ElementWrapper.wrap EntryWrapper EntryWrapper().create EntryWrapper().delete EntryWrapper().element EntryWrapper().etag EntryWrapper.get EntryWrapper.get_by_href EntryWrapper.getter EntryWrapper().href EntryWrapper().refresh EntryWrapper().related_href EntryWrapper.search EntryWrapper().update EntryWrapper.wrap EntryWrapperGetter EntryWrapperGetter().get EntryWrapperGetter().uuid FeedGetter FeedGetter().get UUIDFeedGetter UUIDFeedGetter().get Wrapper Wrapper().__get_val Wrapper().adapter Wrapper.base_pvm_type Wrapper().child_order Wrapper().get_href Wrapper.get_xag_for_prop Wrapper().inject Wrapper().log_missing_value Wrapper.pvm_type Wrapper().replace_list Wrapper().set_float_gb_value Wrapper().set_href Wrapper().set_parm_value Wrapper().toxmlstring Wrapper().traits Wrapper().uuid Wrapper().uuid Wrapper.xag_property WrapperElemList WrapperElemList().append WrapperElemList().extend WrapperElemList().index WrapperElemList().remove WrapperSetUUIDMixin WrapperSetUUIDMixin().set_uuid ActionableList Show source in entry_wrapper.py:1410 Provides a List that will call back to a function on modification. Does not support lower level modifications (ex. list[5] = other_elem), but does support extend, append, remove, insert and pop. Signature class ActionableList(list): def __init__(self, list_data, action): ... ActionableList().append Show source in entry_wrapper.py:1431 Signature def append(self, elem): ... ActionableList().extend Show source in entry_wrapper.py:1427 Signature def extend(self, seq): ... ActionableList().insert Show source in entry_wrapper.py:1439 Signature def insert(self, index, obj): ... ActionableList().pop Show source in entry_wrapper.py:1443 Signature def pop(self, index=-1): ... ActionableList().remove Show source in entry_wrapper.py:1435 Signature def remove(self, elem): ... ElementWrapper Show source in entry_wrapper.py:1200 Attributes has_metadata - If it's an Element, it's probably a DETAIL. (Redundant assignment, but prefer to be explicit.): False Base wrapper for Elements. Signature class ElementWrapper(Wrapper): ... See also Wrapper ElementWrapper(). eq Show source in entry_wrapper.py:1260 Tests equality. Signature def __eq__(self, other): ... ElementWrapper(). hash Show source in entry_wrapper.py:1264 Hash value. Necessary to be overwritten because of the side effect in Python 3.x of overwriting the eq method causing an object to be unhashable. Signature def __hash__(self): ... ElementWrapper.wrap Show source in entry_wrapper.py:1222 Wrap an existing adapter.Element OR construct a fresh one. This method should usually be invoked from an ElementWrapper subclass decorated by Wrapper.pvm_type, and an instance of that subclass will be returned. If invoked directly from ElementWrapper, we attempt to detect whether an appropriate subclass exists based on the Element's tag. If so, that subclass is used; otherwise a generic ElementWrapper is used. Arguments element - An existing adapter.Element to wrap. :param **kwargs: Arbitrary attributes to set on the new ElementWrapper. Returns An ElementWrapper (subclass) instance containing the element. Signature @classmethod def wrap(cls, element, **kwargs): ... EntryWrapper Show source in entry_wrapper.py:682 Attributes has_metadata - If it's an Entry, it must be a ROOT or CHILD: True Base Wrapper for the Entry object types. Signature class EntryWrapper(Wrapper): def __init__(self, entry, etag=None): ... See also Wrapper EntryWrapper().create Show source in entry_wrapper.py:1080 Performs an adapter.create (REST API PUT) with this wrapper. Arguments parent_type - If creating a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter may be either the schema_type or the EntryWrapper subclass of the parent ROOT object. parent_uuid - If creating a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter indicates the UUID of the parent ROOT object. timeout - (Optional) Integer number of seconds after which to time out the PUT request. -1, the default, causes the request to use the timeout value configured on the Session belonging to the Adapter. parent - If creating a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter is an EntryWrapper representing the parent ROOT object of the CHILD to be created. Returns New EntryWrapper of the invoking class representing the PUT response. Signature def create(self, parent_type=None, parent_uuid=None, timeout=-1, parent=None): ... EntryWrapper().delete Show source in entry_wrapper.py:1117 Performs an adapter.delete (REST API DELETE) with this wrapper. Signature def delete(self): ... EntryWrapper().element Show source in entry_wrapper.py:1153 Signature @property def element(self): ... EntryWrapper().etag Show source in entry_wrapper.py:1157 Signature @property def etag(self): ... EntryWrapper.get Show source in entry_wrapper.py:801 GET and wrap an entry or feed of this type. Shortcut to EntryWrapper.wrap(adapter.read(...)). For example, retrieving a ROOT object: resp = adapter.read(VIOS.schema_type, root_id=v_uuid, xag=xags) vwrap = VIOS.wrap(resp) Becomes: vwrap = VIOS.get(adapter, uuid=v_uuid, xag=xags) Or retrieving a CHILD feed: resp = adapter.read(System.schema_type, root_id=sys_uuid, child_type=VSwitch.schema_type) vswfeed = VSwitch.wrap(resp) Becomes: vswfeed = VSwitch.get(adapter, parent=sys) Or: vswfeed = VSwitch.get(adapter, parent_type=System, parent_uuid=sys_uuid) Arguments cls - A subclass of EntryWrapper. Its schema_type will be used as the first argument to adapter.read() adapter - The pypowervm.adapter.Adapter instance through which to perform the GET. uuid - If retrieving a single entry, specify its string UUID. For ROOT objects, you may specify either uuid or root_id; for CHILD objects, you may specify either uuid or child_id. parent_type - If the invoking class represents a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter may be either the schema_type or the EntryWrapper subclass of the parent ROOT object. parent_uuid - If the invoking class represents a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter indicates the UUID of the parent ROOT object. Do not use the root_id parameter. parent - If the invoking class represents a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter is an EntryWrapper representing the parent ROOT object of the CHILD to be retrieved. read_kwargs - Any arguments to be passed directly through to Adapter.read(). Returns An EntryWrapper (or list thereof) around the requested REST object. (Note that this may not be of the type from which the method was invoked, e.g. if the child_type parameter is used.) Signature @classmethod def get( cls, adapter, uuid=None, parent_type=None, parent_uuid=None, parent=None, **read_kwargs ): ... EntryWrapper.get_by_href Show source in entry_wrapper.py:895 Get a wrapper or feed given a URI. This can be useful for retrieving wrappers \"associated\" with other wrappers, where the association is provided via an atom link. Some examples are TrunkAdapter.associated_vswitch_uri and VNICBackDev.vios_href. Arguments adapter - A pypowervm.adapter.Adapter instance for REST API communication. EntryWrapper().href - The string URI (including scheme://host:port/) of the entry or feed to retrieve. rbh_kwargs - Keyword arguments to be passed directly to Adapter's read_by_href method. Returns EntryWrapper subclass of the appropriate type, or a list thereof, representing the entry/feed associated with the href parameter. Signature @classmethod def get_by_href(cls, adapter, href, **rbh_kwargs): ... EntryWrapper.getter Show source in entry_wrapper.py:691 Return EntryWrapperGetter or FeedGetter for this EntryWrapper type. Parameters are the same as described by EntryWrapperGetter. init If entry_uuid is None, a FeedGetter is returned. Otherwise, an EntryWrapperGetter is returned. Signature @classmethod def getter( cls, adapter, entry_uuid=None, parent_class=None, parent_uuid=None, xag=None, parent=None, ): ... EntryWrapper().href Show source in entry_wrapper.py:1161 Finds the reference to the entity. Assumes that the entity has a link element that references self. If it does not, returns None. Signature @property def href(self): ... EntryWrapper().refresh Show source in entry_wrapper.py:777 Fetch the latest version of the entry from the REST API server. If the entry has not been updated on the server, self is returned unchanged. Otherwise a new, fresh wrapper instance is returned. Generally, this should be used as: wrapper_instance = wrapper_instance.refresh() Arguments use_etag - (Optional) If False, the object's etag will not be sent with the request, ensuring that the object is retrieved afresh from the server. Returns EntryWrapper representing the latest data from the REST API server. If the input wrapper contains etag information and the server responds 304 (Not Modified), the original wrapper is returned. Otherwise, a fresh EntryWrapper of the appropriate type is returned. Signature def refresh(self, use_etag=True): ... EntryWrapper().related_href Show source in entry_wrapper.py:1170 Returns the URI to be used for references in other elements. This will return a root URI (no extended attributes, no fragments). This should be used as needed to support entries/elements that have relationships to others. Signature @property def related_href(self): ... EntryWrapper.search Show source in entry_wrapper.py:916 Performs a REST API search. Searches for object(s) of the type indicated by cls having (or not having) the key/value indicated by the (single) kwarg. Regular expressions, comparators, and logical operators are not supported. Arguments cls - A subclass of EntryWrapper. The wrapper class may define a search_keys member, which is a dictionary mapping a @property getter method name to a search key supported by the REST API for that object type. To retrieve an XML report of the supported search keys for object Foo, perform: read('Foo', suffix_type='search'). If the wrapper class does not define a search_keys member, OR if xag is None, the fallback search algorithm performs a GET of the entire feed of the object type and loops through it looking for (mis)matches on the @property indicated by the search key. adapter - The pypowervm.adapter.Adapter instance through which to perform the search. negate - If True, the search is negated - we find all objects of the indicated type where the search key does not equal the search value. xag - List of extended attribute group names. parent_type - If searching for CHILD objects, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter indicates the parent ROOT object. It may be either the string schema type or the corresponding EntryWrapper subclass. parent_uuid - If searching for CHILD objects, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter specifies the UUID of the parent ROOT object. If parent_type is specified, but parent_uuid is None, all parents of the ROOT type will be searched. This may result in a slow response time. one_result - Use when expecting (at most) one search result. If True, this method will return the first element of the search result list, or None if the search produced no results. parent - If searching for CHILD objects, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter is an EntryWrapper instance indicating the parent ROOT object. kwargs - Exactly one key=value. The key must correspond to a key in cls.search_keys and/or the name of a getter @property on the EntryWrapper subclass. Due to limitations of the REST API, if specifying xags or searching for a CHILD, the key must be the name of a getter @property. The value is the value to match. Returns If one_result=False (the default), a list of instances of the cls. The list may be empty (no results were found). It may contain more than one instance (e.g. for a negated search, or for one where the key does not represent a unique property of the object). If one_result=True, returns a single instance of cls, or None if the search produced no results. Signature @classmethod def search( cls, adapter, negate=False, xag=None, parent_type=None, parent_uuid=None, one_result=False, parent=None, **kwargs ): ... EntryWrapper().update Show source in entry_wrapper.py:1122 Performs adapter.update of this wrapper. Arguments xag - DEPRECATED - do not use. timeout - (Optional) Integer number of seconds after which to time out the POST request. -1, the default, causes the request to use the timeout value configured on the Session belonging to the Adapter. force - True if this is called as part of force resize. Returns The updated wrapper, per the response from the Adapter.update. Signature def update(self, xag=\"__DEPRECATED__\", timeout=-1, force=False): ... EntryWrapper.wrap Show source in entry_wrapper.py:724 Creates an entry (or list) from an adapter.Response or Entry. If response is specified and is a feed, a list of EntryWrapper will be returned. The entries within the feed are not guaranteed to have etags (e.g. from non-uom elements). Otherwise, a single EntryWrapper will be returned. This is NOT a list. This method should usually be invoked from an EntryWrapper subclass decorated by Wrapper.pvm_type, and an instance of that subclass will be returned. If invoked directly from EntryWrapper, we attempt to detect whether an appropriate subclass exists based on the Entry's Element's tag. If so, that subclass is used; otherwise a generic EntryWrapper is used. Arguments response_or_entry - The Response from an adapter.Adapter.read request, or an existing adapter.Entry to wrap. Returns A list of wrappers if response_or_entry is a Response with a Feed. A single wrapper if response_or_entry is an Entry or a Response with an Entry. Signature @classmethod def wrap(cls, response_or_entry, etag=None): ... EntryWrapperGetter Show source in entry_wrapper.py:1492 Attribute container with enough information to GET an EntryWrapper. An instance of this class can be used to defer the REST call which fetches a PowerVM object. This will typically be used to initialize a pypowervm.utils.transaction.WrapperTask, or as the first parameter to a method decorated as pypowervm.utils.transaction.entry_transaction, allowing that method to acquire a lock before performing the GET, thus minimizing the probability of out-of-band changes resulting in etag mismatch and requiring a retry. Signature class EntryWrapperGetter(object): def __init__( self, adapter, entry_class, entry_uuid, parent_class=None, parent_uuid=None, xag=None, parent=None, ): ... EntryWrapperGetter().get Show source in entry_wrapper.py:1543 Return the EntryWrapper indicated by this instance. If the EntryWrapper has not yet been retrieved, it is fetched via GET from the REST API. Thereafter, it is cached. Subsequent calls to this method will return the cached copy unless refresh=True, in which case the cached copy is refreshed before returning. Arguments refresh - (Optional) If True, and the specified EntryWrapper was previously retrieved, it is refreshed before being returned. If False (the default), it is returned without refreshing. If the specified EntryWrapper had not yet been retrieved, this parameter has no effect. Returns The EntryWrapper specified by this EntryWrapperGetter instance. Signature def get(self, refresh=False): ... EntryWrapperGetter().uuid Show source in entry_wrapper.py:1577 Return the UUID of the entry for which this spec was created. This mainly exists so we can ask for wrapper_or_spec.uuid. Signature @property def uuid(self): ... FeedGetter Show source in entry_wrapper.py:1586 Attribute container with enough information to GET an EntryWrapper feed. An instance of this class can be used to defer the REST call which fetches a feed of PowerVM objects (a list of EntryWrapper). This will typically be used to initialize a pypowervm.utils.transaction.FeedTask, allowing the FeedTask to defer the GET as long as possible, thus minimizing the probability of out-of-band changes resulting in etag mismatch and requiring a retry. Signature class FeedGetter(EntryWrapperGetter): def __init__( self, adapter, entry_class, parent_class=None, parent_uuid=None, xag=None, parent=None, ): ... See also EntryWrapperGetter FeedGetter().get Show source in entry_wrapper.py:1622 Return the feed (list of EntryWrappers) indicated by this instance. If the feed has not yet been retrieved, it is fetched via GET from the REST API. Thereafter, it is cached. Subsequent calls to this method will return the cached copy unless refresh or refetch is specified. The refresh option, if True, will cause each entry in the feed to be refreshed if previously cached. The refetch option, if True, will cause the feed to be refetched as a whole. Note: due to the design of the REST server, refetch will generally perform better than refresh. Arguments refresh - (Optional) If True, and the specified feed was previously retrieved, each entry therein is refreshed before the feed is returned. If the specified feed had not yet been retrieved, this parameter has no effect. If both refresh and refetch are True, refresh takes precedence. refetch - (Optional) If True, a fresh GET of the entire feed is performed, regardless of whether the feed was fetched and cached previously. If both refresh and refetch are True, refresh takes precedence. Returns The feed (list of EntryWrappers) specified by this FeedGetter instance. Signature def get(self, refresh=False, refetch=False): ... UUIDFeedGetter Show source in entry_wrapper.py:1668 Quasi-FeedGetter that builds its \"feed\" based on a list of UUIDs. This is expected to be useful for building FeedTasks when, for example: - The FeedTask is operating on an SSP (the VIOSes aren't necessarily all in the same feed); - The operation is only concerned with one REST object, but a WrapperTask is not sufficient. Signature class UUIDFeedGetter(FeedGetter): def __init__( self, adapter, entry_class, uuid_list, parent_class=None, parent_uuid=None, xag=None, parent=None, ): ... See also FeedGetter UUIDFeedGetter().get Show source in entry_wrapper.py:1702 Get the individual wrappers for each UUID and put them in a 'feed'. Arguments refresh - See FeedGetter.get. refetch - See FeedGetter.get. Signature def get(self, refresh=False, refetch=False): ... Wrapper Show source in entry_wrapper.py:44 Attributes schema_type - See pvm_type decorator: None Base wrapper object that subclasses should extend. Provides base support for operations. Will define a few methods that need to be overridden by subclasses. Signature class Wrapper(object): ... Wrapper().__get_val Show source in entry_wrapper.py:413 Retrieve the value of an element within this wrapper's ElementTree. This is the baseline for all the get_val {type} methods. Arguments property_name - The name (XPath) of the property to find. default - The default value to return if the property is not found OR if type conversion fails. converter - Optional callable accepting a single string parameter and returning a value of some other type. The converter callable should raise ValueError if conversion fails. Returns The (possibly converted) value corresponding to the identified property. Signature def __get_val(self, property_name, default=None, converter=None): ... Wrapper().adapter Show source in entry_wrapper.py:221 Signature @property def adapter(self): ... Wrapper.base_pvm_type Show source in entry_wrapper.py:82 Decorator/method to register a PowerVM base class. Use this instead of @pvm_type on Wrapper subclasses which are not to be instantiated, but are themselves bases for real Wrappers. For example, use @base_pvm_type for BasePartition; and @pvm_type for LogicalPartition and VirtualIOServer. Use as a decorator with no arguments: @Wrapper.base_pvm_type class SomeBaseClass(Wrapper): ... Or use as a method to register a base class explicitly after it has been defined: Wrapper.base_pvm_type(SomeBaseClass) Arguments cls_ - The Wrapper subclass to be decorated/registered. Returns cls_ Signature @classmethod def base_pvm_type(cls, cls_): ... Wrapper().child_order Show source in entry_wrapper.py:217 Signature @property def child_order(self): ... Wrapper().get_href Show source in entry_wrapper.py:543 Returns the hrefs from AtomLink elements. Arguments propname - The name of the schema element containing the 'href' attribute. one_result - If True, we are expecting exactly one result, and will return that one (string) result, or None. If False (the default), we will return a tuple of strings which may be empty. Signature def get_href(self, propname, one_result=False): ... Wrapper.get_xag_for_prop Show source in entry_wrapper.py:204 The extended attribute group name for a property of this Wrapper. Arguments propname - Short (unqualified) name of a property of this Wrapper, as a string. Returns String indicating the name of the extended attribute group for the given property. Should be a pypowervm.const.XAG enum value. None (not 'None') if there is no xag associated with the specified property. Signature @classmethod def get_xag_for_prop(cls, propname): ... Wrapper().inject Show source in entry_wrapper.py:253 Injects subelement as a child element, possibly replacing it. This is pypowervm.adapter.Element.inject, with ordering_list always set to self.child_order. Signature def inject(self, subelement, replace=True): ... Wrapper().log_missing_value Show source in entry_wrapper.py:538 Signature def log_missing_value(self, param): ... Wrapper.pvm_type Show source in entry_wrapper.py:130 Decorator for {Entry|Element}Wrappers of PowerVM objects. Sets foundational fields used for construction of new wrapper instances and pieces thereof. Registers the decorated class, keyed by its schema_type, This enables the wrap method to return the correct subclass even if invoked directly from ElementWrapper or EntryWrapper. Arguments schema_type - PowerVM REST API Schema type of the subclass (str). has_metadata - Indicates whether, when creating and wrapping a fresh adapter.Element, it should have a child element. ns - PowerVM REST API Schema namespace of the subclass. attrib - Default attributes for fresh Element when factory constructor is used. Wrapper().child_order - Ordered list of the element names of the first- level children of this element/entry. Used for order-agnostic construction/setting of values. Signature @classmethod def pvm_type( cls, schema_type, has_metadata=None, ns=pc.UOM_NS, attrib=pc.DEFAULT_SCHEMA_ATTR, child_order=None, ): ... Wrapper().replace_list Show source in entry_wrapper.py:319 Replaces a property on this Entry that contains a children list. The prop_children represent the new elements for the property. If the property does not already exist, this will simply append the new children. Arguments prop_name - The property name to replace with the new value. prop_children - A list of ElementWrapper objects that represent the new children for the property list. attrib - The attributes to use if the property. Defaults to the DEFAULT_SCHEM_ATTR. indirect - Name of a schema element which should wrap each of the prop_children. For example, VNIC backing devices look like: ... ... ... ... In this case, invoke this method as: replace_list( 'AssociatedBackingDevices', [ ], indirect='VirtualNICBackingDeviceChoice') Signature def replace_list( self, prop_name, prop_children, attrib=pc.DEFAULT_SCHEMA_ATTR, indirect=None ): ... Wrapper().set_float_gb_value Show source in entry_wrapper.py:390 Special case of set_parm_value for floats of Gigabyte.Type. Gigabyte.Type can't handle more than 6dp. Floating point representation issues can mean that e.g. 0.1 + 0.2 produces 0.30000000000000004. str() rounds to 12dp. So this method converts a float (or float string) to a string with exactly 6dp before storing it in the property. Arguments property_name - The schema name of the property to set (see set_parm_value). value - The floating point number or floating point string to be set. create - If True, and the property is not found, it will be created. Otherwise this method will throw an exception. (See set_parm_value.) Signature def set_float_gb_value(self, property_name, value, create=True): ... Wrapper().set_href Show source in entry_wrapper.py:573 Finds or creates the (single) named property and sets its href. If the indicated element does not exist, it (and any necessary interim parent elements) will be created. If any intervening path is non- unique, any new element paths will be created under the first one. Arguments propname - XPath to the property. href - The URI value to assign to the href attribute. rel=related is automatically assigned. Signature def set_href(self, propname, href): ... Wrapper().set_parm_value Show source in entry_wrapper.py:370 Set a child element value, possibly creating the child. Arguments property_name - The schema name of the property to set. value - The (string) value to assign to the property's 'text'. create - If True, and the property is not found, it will be created. Otherwise this method will throw an exception. attrib - The element attributes to use if the element is created. Signature def set_parm_value(self, property_name, value, create=True, attrib=None): ... Wrapper().toxmlstring Show source in entry_wrapper.py:610 Produce an XML dump of this Wrapper's Element. Arguments pretty - If True, format the XML in a visually-pleasing manner. Returns An XML string representing this Element. Signature def toxmlstring(self, pretty=False): ... Wrapper().traits Show source in entry_wrapper.py:225 Signature @property def traits(self): ... Wrapper().uuid Show source in entry_wrapper.py:229 Returns the uuid of the entry or element. Signature @property def uuid(self): ... Wrapper().uuid Show source in entry_wrapper.py:241 Sets the UUID (if supported). Arguments value - A valid PowerVM UUID value in either uuid format or string format Signature @uuid.setter def uuid(self, value): ... Wrapper.xag_property Show source in entry_wrapper.py:172 Decorator to tag a @property with an extended attribute group. Use this decorator in place of (not in addition to) @property. Within class Foo: @xag_property('bar') def some_prop(self): ... confers the same property-ness on 'some_prop' as would @property def some_prop(self): ... but it also associates some_prop with extended attribute group name 'bar' such that Foo.get_xag_for_prop('some_prop') returns the value 'bar'. Arguments xag - String name of the extended attribute group with which the decorated property is associated. May either be one of the pypowervm.const.XAG enum values; or a member of one of the pypowervm.entities.*XAGs collections (for example, see pypowervm.wrappers.virtual_io_server.phys_vols). Signature @classmethod def xag_property(cls, xag): ... WrapperElemList Show source in entry_wrapper.py:1273 The wrappers can create complex Lists (from a Group from the response). The lists that they wrap tend to be generated on each 'get' from the property. This list allows for modification of the 'wrappers' that get returned, which update the backing elements. This is not a full implementation of a list. Only the 'common use' methods are supported Functions that are provided: - Getting via index (ex. list[1]) - Obtaining the length (ex. len(list)) - Extending the list (ex. list.extend(other_list)) - Appending to the list (ex. list.append(other_elem)) - Removing from the list (ex. list.remove(other_elem)) Signature class WrapperElemList(list): def __init__(self, root_elem, child_class=None, indirect=None, **kwargs): ... WrapperElemList().append Show source in entry_wrapper.py:1387 Signature def append(self, elem): ... WrapperElemList().extend Show source in entry_wrapper.py:1383 Signature def extend(self, seq): ... WrapperElemList().index Show source in entry_wrapper.py:1354 Signature def index(self, value): ... WrapperElemList().remove Show source in entry_wrapper.py:1391 Signature def remove(self, elem): ... WrapperSetUUIDMixin Show source in entry_wrapper.py:1450 Abstract mixin to enable a Wrapper instance to set its UUID. USE WITH CAUTION. Caveats: This will only work on Wrappers with has_metadata=True. Not all elements accept a consumer-set UUID. Of those that do, some only accept it at creation, not on update. Signature class WrapperSetUUIDMixin(object): ... WrapperSetUUIDMixin().set_uuid Show source in entry_wrapper.py:1459 Set the UUID of the XML entity represented by this Wrapper. Arguments new_uuid - The UUID to set. Must valid uuid type or string properly formatted (e.g. 8-4-4-4-12) Signature def set_uuid(self, new_uuid): ...","title":"EntryWrapper"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapper","text":"Pypowervm Index / Pypowervm / Wrappers / EntryWrapper Auto-generated documentation for pypowervm.wrappers.entry_wrapper module. EntryWrapper ActionableList ActionableList().append ActionableList().extend ActionableList().insert ActionableList().pop ActionableList().remove ElementWrapper ElementWrapper(). eq ElementWrapper(). hash ElementWrapper.wrap EntryWrapper EntryWrapper().create EntryWrapper().delete EntryWrapper().element EntryWrapper().etag EntryWrapper.get EntryWrapper.get_by_href EntryWrapper.getter EntryWrapper().href EntryWrapper().refresh EntryWrapper().related_href EntryWrapper.search EntryWrapper().update EntryWrapper.wrap EntryWrapperGetter EntryWrapperGetter().get EntryWrapperGetter().uuid FeedGetter FeedGetter().get UUIDFeedGetter UUIDFeedGetter().get Wrapper Wrapper().__get_val Wrapper().adapter Wrapper.base_pvm_type Wrapper().child_order Wrapper().get_href Wrapper.get_xag_for_prop Wrapper().inject Wrapper().log_missing_value Wrapper.pvm_type Wrapper().replace_list Wrapper().set_float_gb_value Wrapper().set_href Wrapper().set_parm_value Wrapper().toxmlstring Wrapper().traits Wrapper().uuid Wrapper().uuid Wrapper.xag_property WrapperElemList WrapperElemList().append WrapperElemList().extend WrapperElemList().index WrapperElemList().remove WrapperSetUUIDMixin WrapperSetUUIDMixin().set_uuid","title":"EntryWrapper"},{"location":"pypowervm/wrappers/entry_wrapper/#actionablelist","text":"Show source in entry_wrapper.py:1410 Provides a List that will call back to a function on modification. Does not support lower level modifications (ex. list[5] = other_elem), but does support extend, append, remove, insert and pop.","title":"ActionableList"},{"location":"pypowervm/wrappers/entry_wrapper/#signature","text":"class ActionableList(list): def __init__(self, list_data, action): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#actionablelistappend","text":"Show source in entry_wrapper.py:1431","title":"ActionableList().append"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_1","text":"def append(self, elem): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#actionablelistextend","text":"Show source in entry_wrapper.py:1427","title":"ActionableList().extend"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_2","text":"def extend(self, seq): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#actionablelistinsert","text":"Show source in entry_wrapper.py:1439","title":"ActionableList().insert"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_3","text":"def insert(self, index, obj): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#actionablelistpop","text":"Show source in entry_wrapper.py:1443","title":"ActionableList().pop"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_4","text":"def pop(self, index=-1): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#actionablelistremove","text":"Show source in entry_wrapper.py:1435","title":"ActionableList().remove"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_5","text":"def remove(self, elem): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#elementwrapper","text":"Show source in entry_wrapper.py:1200","title":"ElementWrapper"},{"location":"pypowervm/wrappers/entry_wrapper/#attributes","text":"has_metadata - If it's an Element, it's probably a DETAIL. (Redundant assignment, but prefer to be explicit.): False Base wrapper for Elements.","title":"Attributes"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_6","text":"class ElementWrapper(Wrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#see-also","text":"Wrapper","title":"See also"},{"location":"pypowervm/wrappers/entry_wrapper/#elementwrappereq","text":"Show source in entry_wrapper.py:1260 Tests equality.","title":"ElementWrapper().eq"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_7","text":"def __eq__(self, other): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#elementwrapperhash","text":"Show source in entry_wrapper.py:1264 Hash value. Necessary to be overwritten because of the side effect in Python 3.x of overwriting the eq method causing an object to be unhashable.","title":"ElementWrapper().hash"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_8","text":"def __hash__(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#elementwrapperwrap","text":"Show source in entry_wrapper.py:1222 Wrap an existing adapter.Element OR construct a fresh one. This method should usually be invoked from an ElementWrapper subclass decorated by Wrapper.pvm_type, and an instance of that subclass will be returned. If invoked directly from ElementWrapper, we attempt to detect whether an appropriate subclass exists based on the Element's tag. If so, that subclass is used; otherwise a generic ElementWrapper is used.","title":"ElementWrapper.wrap"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments","text":"element - An existing adapter.Element to wrap. :param **kwargs: Arbitrary attributes to set on the new ElementWrapper.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns","text":"An ElementWrapper (subclass) instance containing the element.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_9","text":"@classmethod def wrap(cls, element, **kwargs): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapper_1","text":"Show source in entry_wrapper.py:682","title":"EntryWrapper"},{"location":"pypowervm/wrappers/entry_wrapper/#attributes_1","text":"has_metadata - If it's an Entry, it must be a ROOT or CHILD: True Base Wrapper for the Entry object types.","title":"Attributes"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_10","text":"class EntryWrapper(Wrapper): def __init__(self, entry, etag=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#see-also_1","text":"Wrapper","title":"See also"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrappercreate","text":"Show source in entry_wrapper.py:1080 Performs an adapter.create (REST API PUT) with this wrapper.","title":"EntryWrapper().create"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_1","text":"parent_type - If creating a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter may be either the schema_type or the EntryWrapper subclass of the parent ROOT object. parent_uuid - If creating a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter indicates the UUID of the parent ROOT object. timeout - (Optional) Integer number of seconds after which to time out the PUT request. -1, the default, causes the request to use the timeout value configured on the Session belonging to the Adapter. parent - If creating a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter is an EntryWrapper representing the parent ROOT object of the CHILD to be created.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_1","text":"New EntryWrapper of the invoking class representing the PUT response.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_11","text":"def create(self, parent_type=None, parent_uuid=None, timeout=-1, parent=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapperdelete","text":"Show source in entry_wrapper.py:1117 Performs an adapter.delete (REST API DELETE) with this wrapper.","title":"EntryWrapper().delete"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_12","text":"def delete(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapperelement","text":"Show source in entry_wrapper.py:1153","title":"EntryWrapper().element"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_13","text":"@property def element(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapperetag","text":"Show source in entry_wrapper.py:1157","title":"EntryWrapper().etag"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_14","text":"@property def etag(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapperget","text":"Show source in entry_wrapper.py:801 GET and wrap an entry or feed of this type. Shortcut to EntryWrapper.wrap(adapter.read(...)). For example, retrieving a ROOT object: resp = adapter.read(VIOS.schema_type, root_id=v_uuid, xag=xags) vwrap = VIOS.wrap(resp) Becomes: vwrap = VIOS.get(adapter, uuid=v_uuid, xag=xags) Or retrieving a CHILD feed: resp = adapter.read(System.schema_type, root_id=sys_uuid, child_type=VSwitch.schema_type) vswfeed = VSwitch.wrap(resp) Becomes: vswfeed = VSwitch.get(adapter, parent=sys) Or: vswfeed = VSwitch.get(adapter, parent_type=System, parent_uuid=sys_uuid)","title":"EntryWrapper.get"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_2","text":"cls - A subclass of EntryWrapper. Its schema_type will be used as the first argument to adapter.read() adapter - The pypowervm.adapter.Adapter instance through which to perform the GET. uuid - If retrieving a single entry, specify its string UUID. For ROOT objects, you may specify either uuid or root_id; for CHILD objects, you may specify either uuid or child_id. parent_type - If the invoking class represents a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter may be either the schema_type or the EntryWrapper subclass of the parent ROOT object. parent_uuid - If the invoking class represents a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter indicates the UUID of the parent ROOT object. Do not use the root_id parameter. parent - If the invoking class represents a CHILD, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter is an EntryWrapper representing the parent ROOT object of the CHILD to be retrieved. read_kwargs - Any arguments to be passed directly through to Adapter.read().","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_2","text":"An EntryWrapper (or list thereof) around the requested REST object. (Note that this may not be of the type from which the method was invoked, e.g. if the child_type parameter is used.)","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_15","text":"@classmethod def get( cls, adapter, uuid=None, parent_type=None, parent_uuid=None, parent=None, **read_kwargs ): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapperget_by_href","text":"Show source in entry_wrapper.py:895 Get a wrapper or feed given a URI. This can be useful for retrieving wrappers \"associated\" with other wrappers, where the association is provided via an atom link. Some examples are TrunkAdapter.associated_vswitch_uri and VNICBackDev.vios_href.","title":"EntryWrapper.get_by_href"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_3","text":"adapter - A pypowervm.adapter.Adapter instance for REST API communication. EntryWrapper().href - The string URI (including scheme://host:port/) of the entry or feed to retrieve. rbh_kwargs - Keyword arguments to be passed directly to Adapter's read_by_href method.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_3","text":"EntryWrapper subclass of the appropriate type, or a list thereof, representing the entry/feed associated with the href parameter.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_16","text":"@classmethod def get_by_href(cls, adapter, href, **rbh_kwargs): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrappergetter","text":"Show source in entry_wrapper.py:691 Return EntryWrapperGetter or FeedGetter for this EntryWrapper type. Parameters are the same as described by EntryWrapperGetter. init If entry_uuid is None, a FeedGetter is returned. Otherwise, an EntryWrapperGetter is returned.","title":"EntryWrapper.getter"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_17","text":"@classmethod def getter( cls, adapter, entry_uuid=None, parent_class=None, parent_uuid=None, xag=None, parent=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapperhref","text":"Show source in entry_wrapper.py:1161 Finds the reference to the entity. Assumes that the entity has a link element that references self. If it does not, returns None.","title":"EntryWrapper().href"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_18","text":"@property def href(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapperrefresh","text":"Show source in entry_wrapper.py:777 Fetch the latest version of the entry from the REST API server. If the entry has not been updated on the server, self is returned unchanged. Otherwise a new, fresh wrapper instance is returned. Generally, this should be used as: wrapper_instance = wrapper_instance.refresh()","title":"EntryWrapper().refresh"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_4","text":"use_etag - (Optional) If False, the object's etag will not be sent with the request, ensuring that the object is retrieved afresh from the server.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_4","text":"EntryWrapper representing the latest data from the REST API server. If the input wrapper contains etag information and the server responds 304 (Not Modified), the original wrapper is returned. Otherwise, a fresh EntryWrapper of the appropriate type is returned.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_19","text":"def refresh(self, use_etag=True): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapperrelated_href","text":"Show source in entry_wrapper.py:1170 Returns the URI to be used for references in other elements. This will return a root URI (no extended attributes, no fragments). This should be used as needed to support entries/elements that have relationships to others.","title":"EntryWrapper().related_href"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_20","text":"@property def related_href(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrappersearch","text":"Show source in entry_wrapper.py:916 Performs a REST API search. Searches for object(s) of the type indicated by cls having (or not having) the key/value indicated by the (single) kwarg. Regular expressions, comparators, and logical operators are not supported.","title":"EntryWrapper.search"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_5","text":"cls - A subclass of EntryWrapper. The wrapper class may define a search_keys member, which is a dictionary mapping a @property getter method name to a search key supported by the REST API for that object type. To retrieve an XML report of the supported search keys for object Foo, perform: read('Foo', suffix_type='search'). If the wrapper class does not define a search_keys member, OR if xag is None, the fallback search algorithm performs a GET of the entire feed of the object type and loops through it looking for (mis)matches on the @property indicated by the search key. adapter - The pypowervm.adapter.Adapter instance through which to perform the search. negate - If True, the search is negated - we find all objects of the indicated type where the search key does not equal the search value. xag - List of extended attribute group names. parent_type - If searching for CHILD objects, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter indicates the parent ROOT object. It may be either the string schema type or the corresponding EntryWrapper subclass. parent_uuid - If searching for CHILD objects, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter specifies the UUID of the parent ROOT object. If parent_type is specified, but parent_uuid is None, all parents of the ROOT type will be searched. This may result in a slow response time. one_result - Use when expecting (at most) one search result. If True, this method will return the first element of the search result list, or None if the search produced no results. parent - If searching for CHILD objects, specify either the parent parameter or BOTH parent_type and parent_uuid. This parameter is an EntryWrapper instance indicating the parent ROOT object. kwargs - Exactly one key=value. The key must correspond to a key in cls.search_keys and/or the name of a getter @property on the EntryWrapper subclass. Due to limitations of the REST API, if specifying xags or searching for a CHILD, the key must be the name of a getter @property. The value is the value to match.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_5","text":"If one_result=False (the default), a list of instances of the cls. The list may be empty (no results were found). It may contain more than one instance (e.g. for a negated search, or for one where the key does not represent a unique property of the object). If one_result=True, returns a single instance of cls, or None if the search produced no results.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_21","text":"@classmethod def search( cls, adapter, negate=False, xag=None, parent_type=None, parent_uuid=None, one_result=False, parent=None, **kwargs ): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapperupdate","text":"Show source in entry_wrapper.py:1122 Performs adapter.update of this wrapper.","title":"EntryWrapper().update"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_6","text":"xag - DEPRECATED - do not use. timeout - (Optional) Integer number of seconds after which to time out the POST request. -1, the default, causes the request to use the timeout value configured on the Session belonging to the Adapter. force - True if this is called as part of force resize.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_6","text":"The updated wrapper, per the response from the Adapter.update.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_22","text":"def update(self, xag=\"__DEPRECATED__\", timeout=-1, force=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrapperwrap","text":"Show source in entry_wrapper.py:724 Creates an entry (or list) from an adapter.Response or Entry. If response is specified and is a feed, a list of EntryWrapper will be returned. The entries within the feed are not guaranteed to have etags (e.g. from non-uom elements). Otherwise, a single EntryWrapper will be returned. This is NOT a list. This method should usually be invoked from an EntryWrapper subclass decorated by Wrapper.pvm_type, and an instance of that subclass will be returned. If invoked directly from EntryWrapper, we attempt to detect whether an appropriate subclass exists based on the Entry's Element's tag. If so, that subclass is used; otherwise a generic EntryWrapper is used.","title":"EntryWrapper.wrap"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_7","text":"response_or_entry - The Response from an adapter.Adapter.read request, or an existing adapter.Entry to wrap.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_7","text":"A list of wrappers if response_or_entry is a Response with a Feed. A single wrapper if response_or_entry is an Entry or a Response with an Entry.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_23","text":"@classmethod def wrap(cls, response_or_entry, etag=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrappergetter_1","text":"Show source in entry_wrapper.py:1492 Attribute container with enough information to GET an EntryWrapper. An instance of this class can be used to defer the REST call which fetches a PowerVM object. This will typically be used to initialize a pypowervm.utils.transaction.WrapperTask, or as the first parameter to a method decorated as pypowervm.utils.transaction.entry_transaction, allowing that method to acquire a lock before performing the GET, thus minimizing the probability of out-of-band changes resulting in etag mismatch and requiring a retry.","title":"EntryWrapperGetter"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_24","text":"class EntryWrapperGetter(object): def __init__( self, adapter, entry_class, entry_uuid, parent_class=None, parent_uuid=None, xag=None, parent=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrappergetterget","text":"Show source in entry_wrapper.py:1543 Return the EntryWrapper indicated by this instance. If the EntryWrapper has not yet been retrieved, it is fetched via GET from the REST API. Thereafter, it is cached. Subsequent calls to this method will return the cached copy unless refresh=True, in which case the cached copy is refreshed before returning.","title":"EntryWrapperGetter().get"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_8","text":"refresh - (Optional) If True, and the specified EntryWrapper was previously retrieved, it is refreshed before being returned. If False (the default), it is returned without refreshing. If the specified EntryWrapper had not yet been retrieved, this parameter has no effect.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_8","text":"The EntryWrapper specified by this EntryWrapperGetter instance.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_25","text":"def get(self, refresh=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#entrywrappergetteruuid","text":"Show source in entry_wrapper.py:1577 Return the UUID of the entry for which this spec was created. This mainly exists so we can ask for wrapper_or_spec.uuid.","title":"EntryWrapperGetter().uuid"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_26","text":"@property def uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#feedgetter","text":"Show source in entry_wrapper.py:1586 Attribute container with enough information to GET an EntryWrapper feed. An instance of this class can be used to defer the REST call which fetches a feed of PowerVM objects (a list of EntryWrapper). This will typically be used to initialize a pypowervm.utils.transaction.FeedTask, allowing the FeedTask to defer the GET as long as possible, thus minimizing the probability of out-of-band changes resulting in etag mismatch and requiring a retry.","title":"FeedGetter"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_27","text":"class FeedGetter(EntryWrapperGetter): def __init__( self, adapter, entry_class, parent_class=None, parent_uuid=None, xag=None, parent=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#see-also_2","text":"EntryWrapperGetter","title":"See also"},{"location":"pypowervm/wrappers/entry_wrapper/#feedgetterget","text":"Show source in entry_wrapper.py:1622 Return the feed (list of EntryWrappers) indicated by this instance. If the feed has not yet been retrieved, it is fetched via GET from the REST API. Thereafter, it is cached. Subsequent calls to this method will return the cached copy unless refresh or refetch is specified. The refresh option, if True, will cause each entry in the feed to be refreshed if previously cached. The refetch option, if True, will cause the feed to be refetched as a whole. Note: due to the design of the REST server, refetch will generally perform better than refresh.","title":"FeedGetter().get"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_9","text":"refresh - (Optional) If True, and the specified feed was previously retrieved, each entry therein is refreshed before the feed is returned. If the specified feed had not yet been retrieved, this parameter has no effect. If both refresh and refetch are True, refresh takes precedence. refetch - (Optional) If True, a fresh GET of the entire feed is performed, regardless of whether the feed was fetched and cached previously. If both refresh and refetch are True, refresh takes precedence.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_9","text":"The feed (list of EntryWrappers) specified by this FeedGetter instance.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_28","text":"def get(self, refresh=False, refetch=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#uuidfeedgetter","text":"Show source in entry_wrapper.py:1668 Quasi-FeedGetter that builds its \"feed\" based on a list of UUIDs. This is expected to be useful for building FeedTasks when, for example: - The FeedTask is operating on an SSP (the VIOSes aren't necessarily all in the same feed); - The operation is only concerned with one REST object, but a WrapperTask is not sufficient.","title":"UUIDFeedGetter"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_29","text":"class UUIDFeedGetter(FeedGetter): def __init__( self, adapter, entry_class, uuid_list, parent_class=None, parent_uuid=None, xag=None, parent=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#see-also_3","text":"FeedGetter","title":"See also"},{"location":"pypowervm/wrappers/entry_wrapper/#uuidfeedgetterget","text":"Show source in entry_wrapper.py:1702 Get the individual wrappers for each UUID and put them in a 'feed'.","title":"UUIDFeedGetter().get"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_10","text":"refresh - See FeedGetter.get. refetch - See FeedGetter.get.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_30","text":"def get(self, refresh=False, refetch=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapper","text":"Show source in entry_wrapper.py:44","title":"Wrapper"},{"location":"pypowervm/wrappers/entry_wrapper/#attributes_2","text":"schema_type - See pvm_type decorator: None Base wrapper object that subclasses should extend. Provides base support for operations. Will define a few methods that need to be overridden by subclasses.","title":"Attributes"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_31","text":"class Wrapper(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapper__get_val","text":"Show source in entry_wrapper.py:413 Retrieve the value of an element within this wrapper's ElementTree. This is the baseline for all the get_val {type} methods.","title":"Wrapper().__get_val"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_11","text":"property_name - The name (XPath) of the property to find. default - The default value to return if the property is not found OR if type conversion fails. converter - Optional callable accepting a single string parameter and returning a value of some other type. The converter callable should raise ValueError if conversion fails.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_10","text":"The (possibly converted) value corresponding to the identified property.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_32","text":"def __get_val(self, property_name, default=None, converter=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperadapter","text":"Show source in entry_wrapper.py:221","title":"Wrapper().adapter"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_33","text":"@property def adapter(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperbase_pvm_type","text":"Show source in entry_wrapper.py:82 Decorator/method to register a PowerVM base class. Use this instead of @pvm_type on Wrapper subclasses which are not to be instantiated, but are themselves bases for real Wrappers. For example, use @base_pvm_type for BasePartition; and @pvm_type for LogicalPartition and VirtualIOServer. Use as a decorator with no arguments: @Wrapper.base_pvm_type class SomeBaseClass(Wrapper): ... Or use as a method to register a base class explicitly after it has been defined: Wrapper.base_pvm_type(SomeBaseClass)","title":"Wrapper.base_pvm_type"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_12","text":"cls_ - The Wrapper subclass to be decorated/registered.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_11","text":"cls_","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_34","text":"@classmethod def base_pvm_type(cls, cls_): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperchild_order","text":"Show source in entry_wrapper.py:217","title":"Wrapper().child_order"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_35","text":"@property def child_order(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperget_href","text":"Show source in entry_wrapper.py:543 Returns the hrefs from AtomLink elements.","title":"Wrapper().get_href"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_13","text":"propname - The name of the schema element containing the 'href' attribute. one_result - If True, we are expecting exactly one result, and will return that one (string) result, or None. If False (the default), we will return a tuple of strings which may be empty.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_36","text":"def get_href(self, propname, one_result=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperget_xag_for_prop","text":"Show source in entry_wrapper.py:204 The extended attribute group name for a property of this Wrapper.","title":"Wrapper.get_xag_for_prop"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_14","text":"propname - Short (unqualified) name of a property of this Wrapper, as a string.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_12","text":"String indicating the name of the extended attribute group for the given property. Should be a pypowervm.const.XAG enum value. None (not 'None') if there is no xag associated with the specified property.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_37","text":"@classmethod def get_xag_for_prop(cls, propname): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperinject","text":"Show source in entry_wrapper.py:253 Injects subelement as a child element, possibly replacing it. This is pypowervm.adapter.Element.inject, with ordering_list always set to self.child_order.","title":"Wrapper().inject"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_38","text":"def inject(self, subelement, replace=True): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperlog_missing_value","text":"Show source in entry_wrapper.py:538","title":"Wrapper().log_missing_value"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_39","text":"def log_missing_value(self, param): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperpvm_type","text":"Show source in entry_wrapper.py:130 Decorator for {Entry|Element}Wrappers of PowerVM objects. Sets foundational fields used for construction of new wrapper instances and pieces thereof. Registers the decorated class, keyed by its schema_type, This enables the wrap method to return the correct subclass even if invoked directly from ElementWrapper or EntryWrapper.","title":"Wrapper.pvm_type"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_15","text":"schema_type - PowerVM REST API Schema type of the subclass (str). has_metadata - Indicates whether, when creating and wrapping a fresh adapter.Element, it should have a child element. ns - PowerVM REST API Schema namespace of the subclass. attrib - Default attributes for fresh Element when factory constructor is used. Wrapper().child_order - Ordered list of the element names of the first- level children of this element/entry. Used for order-agnostic construction/setting of values.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_40","text":"@classmethod def pvm_type( cls, schema_type, has_metadata=None, ns=pc.UOM_NS, attrib=pc.DEFAULT_SCHEMA_ATTR, child_order=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperreplace_list","text":"Show source in entry_wrapper.py:319 Replaces a property on this Entry that contains a children list. The prop_children represent the new elements for the property. If the property does not already exist, this will simply append the new children.","title":"Wrapper().replace_list"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_16","text":"prop_name - The property name to replace with the new value. prop_children - A list of ElementWrapper objects that represent the new children for the property list. attrib - The attributes to use if the property. Defaults to the DEFAULT_SCHEM_ATTR. indirect - Name of a schema element which should wrap each of the prop_children. For example, VNIC backing devices look like: ... ... ... ... In this case, invoke this method as: replace_list( 'AssociatedBackingDevices', [ ], indirect='VirtualNICBackingDeviceChoice')","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_41","text":"def replace_list( self, prop_name, prop_children, attrib=pc.DEFAULT_SCHEMA_ATTR, indirect=None ): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperset_float_gb_value","text":"Show source in entry_wrapper.py:390 Special case of set_parm_value for floats of Gigabyte.Type. Gigabyte.Type can't handle more than 6dp. Floating point representation issues can mean that e.g. 0.1 + 0.2 produces 0.30000000000000004. str() rounds to 12dp. So this method converts a float (or float string) to a string with exactly 6dp before storing it in the property.","title":"Wrapper().set_float_gb_value"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_17","text":"property_name - The schema name of the property to set (see set_parm_value). value - The floating point number or floating point string to be set. create - If True, and the property is not found, it will be created. Otherwise this method will throw an exception. (See set_parm_value.)","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_42","text":"def set_float_gb_value(self, property_name, value, create=True): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperset_href","text":"Show source in entry_wrapper.py:573 Finds or creates the (single) named property and sets its href. If the indicated element does not exist, it (and any necessary interim parent elements) will be created. If any intervening path is non- unique, any new element paths will be created under the first one.","title":"Wrapper().set_href"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_18","text":"propname - XPath to the property. href - The URI value to assign to the href attribute. rel=related is automatically assigned.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_43","text":"def set_href(self, propname, href): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperset_parm_value","text":"Show source in entry_wrapper.py:370 Set a child element value, possibly creating the child.","title":"Wrapper().set_parm_value"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_19","text":"property_name - The schema name of the property to set. value - The (string) value to assign to the property's 'text'. create - If True, and the property is not found, it will be created. Otherwise this method will throw an exception. attrib - The element attributes to use if the element is created.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_44","text":"def set_parm_value(self, property_name, value, create=True, attrib=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrappertoxmlstring","text":"Show source in entry_wrapper.py:610 Produce an XML dump of this Wrapper's Element.","title":"Wrapper().toxmlstring"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_20","text":"pretty - If True, format the XML in a visually-pleasing manner.","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#returns_13","text":"An XML string representing this Element.","title":"Returns"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_45","text":"def toxmlstring(self, pretty=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrappertraits","text":"Show source in entry_wrapper.py:225","title":"Wrapper().traits"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_46","text":"@property def traits(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperuuid","text":"Show source in entry_wrapper.py:229 Returns the uuid of the entry or element.","title":"Wrapper().uuid"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_47","text":"@property def uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperuuid_1","text":"Show source in entry_wrapper.py:241 Sets the UUID (if supported).","title":"Wrapper().uuid"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_21","text":"value - A valid PowerVM UUID value in either uuid format or string format","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_48","text":"@uuid.setter def uuid(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperxag_property","text":"Show source in entry_wrapper.py:172 Decorator to tag a @property with an extended attribute group. Use this decorator in place of (not in addition to) @property. Within class Foo: @xag_property('bar') def some_prop(self): ... confers the same property-ness on 'some_prop' as would @property def some_prop(self): ... but it also associates some_prop with extended attribute group name 'bar' such that Foo.get_xag_for_prop('some_prop') returns the value 'bar'.","title":"Wrapper.xag_property"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_22","text":"xag - String name of the extended attribute group with which the decorated property is associated. May either be one of the pypowervm.const.XAG enum values; or a member of one of the pypowervm.entities.*XAGs collections (for example, see pypowervm.wrappers.virtual_io_server.phys_vols).","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_49","text":"@classmethod def xag_property(cls, xag): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperelemlist","text":"Show source in entry_wrapper.py:1273 The wrappers can create complex Lists (from a Group from the response). The lists that they wrap tend to be generated on each 'get' from the property. This list allows for modification of the 'wrappers' that get returned, which update the backing elements. This is not a full implementation of a list. Only the 'common use' methods are supported Functions that are provided: - Getting via index (ex. list[1]) - Obtaining the length (ex. len(list)) - Extending the list (ex. list.extend(other_list)) - Appending to the list (ex. list.append(other_elem)) - Removing from the list (ex. list.remove(other_elem))","title":"WrapperElemList"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_50","text":"class WrapperElemList(list): def __init__(self, root_elem, child_class=None, indirect=None, **kwargs): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperelemlistappend","text":"Show source in entry_wrapper.py:1387","title":"WrapperElemList().append"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_51","text":"def append(self, elem): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperelemlistextend","text":"Show source in entry_wrapper.py:1383","title":"WrapperElemList().extend"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_52","text":"def extend(self, seq): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperelemlistindex","text":"Show source in entry_wrapper.py:1354","title":"WrapperElemList().index"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_53","text":"def index(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrapperelemlistremove","text":"Show source in entry_wrapper.py:1391","title":"WrapperElemList().remove"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_54","text":"def remove(self, elem): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrappersetuuidmixin","text":"Show source in entry_wrapper.py:1450 Abstract mixin to enable a Wrapper instance to set its UUID. USE WITH CAUTION. Caveats: This will only work on Wrappers with has_metadata=True. Not all elements accept a consumer-set UUID. Of those that do, some only accept it at creation, not on update.","title":"WrapperSetUUIDMixin"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_55","text":"class WrapperSetUUIDMixin(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/entry_wrapper/#wrappersetuuidmixinset_uuid","text":"Show source in entry_wrapper.py:1459 Set the UUID of the XML entity represented by this Wrapper.","title":"WrapperSetUUIDMixin().set_uuid"},{"location":"pypowervm/wrappers/entry_wrapper/#arguments_23","text":"new_uuid - The UUID to set. Must valid uuid type or string properly formatted (e.g. 8-4-4-4-12)","title":"Arguments"},{"location":"pypowervm/wrappers/entry_wrapper/#signature_56","text":"def set_uuid(self, new_uuid): ...","title":"Signature"},{"location":"pypowervm/wrappers/event/","text":"Event Pypowervm Index / Pypowervm / Wrappers / Event Auto-generated documentation for pypowervm.wrappers.event module. Event Event Event.bld Event().data Event().detail Event().eid Event().etype Event.get EventType Event Show source in event.py:73 Signature class Event(ewrap.EntryWrapper): ... Event.bld Show source in event.py:94 Construct a custom Event. Invoke .create() on the resulting Event to broadcast it to active listeners. Arguments adapter - pypowervm.adapter.Adapter for REST API communication. Event().data - Any desired string to be included in the 'data' field of the Event. May be None. Event().detail - Any desired string to be included in the 'detail' field of the Event. May be None. Returns An Event wrapper suitable for sending to the REST server via the .create() method. Signature @classmethod def bld(cls, adapter, data, detail): ... Event().data Show source in event.py:126 Event data; for *_URI EventType, the URI of the affected object. Signature @property def data(self): ... Event().detail Show source in event.py:131 Custom Event detail; semantics dependent on type & data. Signature @property def detail(self): ... Event().eid Show source in event.py:121 Unique sequence identifier of this Event. Signature @property def eid(self): ... Event().etype Show source in event.py:116 The Event type, one of the EventType enum values. Signature @property def etype(self): ... Event.get Show source in event.py:75 Retrieve the latest Event feed for a given application ID. Note: This request may block for a finite amount of time (on the order of 10s) while the server is waiting for new events to occur. Arguments adapter - pypowervm.adapter.Adapter for REST API communication. appid - A hex string identifying the unique consumer. Consumers pulling Event feeds will see the same events duplicated in each request that uses a different appid. To see a single stream of unique events, a consumer should make repeated requests with the same appid. Returns Feed of Event EntryWrapper objects (may be empty). Signature @classmethod def get(cls, adapter, appid): ... EventType Show source in event.py:58 Enumeration of event types (from EventType.Enum). Signature class EventType(object): ...","title":"Event"},{"location":"pypowervm/wrappers/event/#event","text":"Pypowervm Index / Pypowervm / Wrappers / Event Auto-generated documentation for pypowervm.wrappers.event module. Event Event Event.bld Event().data Event().detail Event().eid Event().etype Event.get EventType","title":"Event"},{"location":"pypowervm/wrappers/event/#event_1","text":"Show source in event.py:73","title":"Event"},{"location":"pypowervm/wrappers/event/#signature","text":"class Event(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/event/#eventbld","text":"Show source in event.py:94 Construct a custom Event. Invoke .create() on the resulting Event to broadcast it to active listeners.","title":"Event.bld"},{"location":"pypowervm/wrappers/event/#arguments","text":"adapter - pypowervm.adapter.Adapter for REST API communication. Event().data - Any desired string to be included in the 'data' field of the Event. May be None. Event().detail - Any desired string to be included in the 'detail' field of the Event. May be None.","title":"Arguments"},{"location":"pypowervm/wrappers/event/#returns","text":"An Event wrapper suitable for sending to the REST server via the .create() method.","title":"Returns"},{"location":"pypowervm/wrappers/event/#signature_1","text":"@classmethod def bld(cls, adapter, data, detail): ...","title":"Signature"},{"location":"pypowervm/wrappers/event/#eventdata","text":"Show source in event.py:126 Event data; for *_URI EventType, the URI of the affected object.","title":"Event().data"},{"location":"pypowervm/wrappers/event/#signature_2","text":"@property def data(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/event/#eventdetail","text":"Show source in event.py:131 Custom Event detail; semantics dependent on type & data.","title":"Event().detail"},{"location":"pypowervm/wrappers/event/#signature_3","text":"@property def detail(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/event/#eventeid","text":"Show source in event.py:121 Unique sequence identifier of this Event.","title":"Event().eid"},{"location":"pypowervm/wrappers/event/#signature_4","text":"@property def eid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/event/#eventetype","text":"Show source in event.py:116 The Event type, one of the EventType enum values.","title":"Event().etype"},{"location":"pypowervm/wrappers/event/#signature_5","text":"@property def etype(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/event/#eventget","text":"Show source in event.py:75 Retrieve the latest Event feed for a given application ID. Note: This request may block for a finite amount of time (on the order of 10s) while the server is waiting for new events to occur.","title":"Event.get"},{"location":"pypowervm/wrappers/event/#arguments_1","text":"adapter - pypowervm.adapter.Adapter for REST API communication. appid - A hex string identifying the unique consumer. Consumers pulling Event feeds will see the same events duplicated in each request that uses a different appid. To see a single stream of unique events, a consumer should make repeated requests with the same appid.","title":"Arguments"},{"location":"pypowervm/wrappers/event/#returns_1","text":"Feed of Event EntryWrapper objects (may be empty).","title":"Returns"},{"location":"pypowervm/wrappers/event/#signature_6","text":"@classmethod def get(cls, adapter, appid): ...","title":"Signature"},{"location":"pypowervm/wrappers/event/#eventtype","text":"Show source in event.py:58 Enumeration of event types (from EventType.Enum).","title":"EventType"},{"location":"pypowervm/wrappers/event/#signature_7","text":"class EventType(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/http_error/","text":"HttpError Pypowervm Index / Pypowervm / Wrappers / HttpError Auto-generated documentation for pypowervm.wrappers.http_error module. HttpError HttpError HttpError().is_vios_busy HttpError().message HttpError().reason_code HttpError().status HttpError Show source in http_error.py:35 Signature class HttpError(ewrap.EntryWrapper): ... HttpError().is_vios_busy Show source in http_error.py:49 Signature def is_vios_busy(self): ... HttpError().message Show source in http_error.py:45 Signature @property def message(self): ... HttpError().reason_code Show source in http_error.py:41 Signature @property def reason_code(self): ... HttpError().status Show source in http_error.py:37 Signature @property def status(self): ...","title":"HttpError"},{"location":"pypowervm/wrappers/http_error/#httperror","text":"Pypowervm Index / Pypowervm / Wrappers / HttpError Auto-generated documentation for pypowervm.wrappers.http_error module. HttpError HttpError HttpError().is_vios_busy HttpError().message HttpError().reason_code HttpError().status","title":"HttpError"},{"location":"pypowervm/wrappers/http_error/#httperror_1","text":"Show source in http_error.py:35","title":"HttpError"},{"location":"pypowervm/wrappers/http_error/#signature","text":"class HttpError(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/http_error/#httperroris_vios_busy","text":"Show source in http_error.py:49","title":"HttpError().is_vios_busy"},{"location":"pypowervm/wrappers/http_error/#signature_1","text":"def is_vios_busy(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/http_error/#httperrormessage","text":"Show source in http_error.py:45","title":"HttpError().message"},{"location":"pypowervm/wrappers/http_error/#signature_2","text":"@property def message(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/http_error/#httperrorreason_code","text":"Show source in http_error.py:41","title":"HttpError().reason_code"},{"location":"pypowervm/wrappers/http_error/#signature_3","text":"@property def reason_code(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/http_error/#httperrorstatus","text":"Show source in http_error.py:37","title":"HttpError().status"},{"location":"pypowervm/wrappers/http_error/#signature_4","text":"@property def status(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/","text":"Iocard Pypowervm Index / Pypowervm / Wrappers / Iocard Auto-generated documentation for pypowervm.wrappers.iocard module. Attributes IO_ADPT_ROOT - Constants for generic I/O Adapter: 'IOAdapter' Iocard IOAdapter IOAdapter().description IOAdapter().dev_name IOAdapter().dev_type IOAdapter().drc_name IOAdapter().id IOAdapter().phys_loc_code IOAdapter().udid LinkAggrIOAdapterChoice LinkAggrIOAdapterChoice().__get_prop LinkAggrIOAdapterChoice().description LinkAggrIOAdapterChoice().dev_name LinkAggrIOAdapterChoice().dev_type LinkAggrIOAdapterChoice().drc_name LinkAggrIOAdapterChoice().id LinkAggrIOAdapterChoice().phys_loc_code LinkAggrIOAdapterChoice().udid PhysFCAdapter PhysFCAdapter().fc_ports PhysFCPort PhysFCPort.bld_ref PhysFCPort().loc_code PhysFCPort().name PhysFCPort().npiv_available_ports PhysFCPort().npiv_total_ports PhysFCPort().udid PhysFCPort().wwpn SRIOVAdapter SRIOVAdapter().mode SRIOVAdapter().mode SRIOVAdapter().personality SRIOVAdapter().phys_ports SRIOVAdapter().sriov_adap_id SRIOVAdapter().state SRIOVAdapterMode SRIOVAdapterPersonality SRIOVAdapterState SRIOVConvPPort SRIOVEthLPort SRIOVEthLPort().allowed_macs SRIOVEthLPort().allowed_macs SRIOVEthLPort().allowed_vlans SRIOVEthLPort().allowed_vlans SRIOVEthLPort.bld SRIOVEthLPort().cfg_capacity SRIOVEthLPort().cfg_max_capacity SRIOVEthLPort().cur_mac SRIOVEthLPort().dev_name SRIOVEthLPort().is_promisc SRIOVEthLPort().loc_code SRIOVEthLPort().lport_id SRIOVEthLPort().mac SRIOVEthLPort().pport_id SRIOVEthLPort().pvid SRIOVEthLPort().pvid SRIOVEthLPort().sriov_adap_id SRIOVEthLPort().vnic_port_usage SRIOVEthPPort SRIOVEthPPort().allocated_capacity SRIOVEthPPort().cfg_lps SRIOVEthPPort().cfg_max_lps SRIOVEthPPort().cfg_max_lps SRIOVEthPPort().curr_speed SRIOVEthPPort().flow_ctl SRIOVEthPPort().flow_ctl SRIOVEthPPort().label SRIOVEthPPort().label SRIOVEthPPort().link_status SRIOVEthPPort().loc_code SRIOVEthPPort().min_granularity SRIOVEthPPort().mtu SRIOVEthPPort().mtu SRIOVEthPPort().port_id SRIOVEthPPort().sriov_adap SRIOVEthPPort().sriov_adap_id SRIOVEthPPort().sublabel SRIOVEthPPort().sublabel SRIOVEthPPort().supp_max_lps SRIOVEthPPort().switch_mode SRIOVEthPPort().switch_mode SRIOVPPMTU SRIOVRoCEPPort SRIOVSpeed VNIC VNIC().allowed_macs VNIC().allowed_macs VNIC().allowed_vlans VNIC().allowed_vlans VNIC().auto_pri_failover VNIC().auto_pri_failover VNIC().back_devs VNIC().back_devs VNIC.bld VNIC().capacity VNIC().drc_name VNIC().gateway VNIC().ip_address VNIC().lpar_id VNIC().mac VNIC().pvid VNIC().pvid VNIC().slot VNIC().subnet_mask VNICBackDev VNICBackDev.bld VNICBackDev().capacity VNICBackDev().desired_max_capacity VNICBackDev().failover_pri VNICBackDev().failover_pri VNICBackDev().is_active VNICBackDev().lport_href VNICBackDev().max_capacity VNICBackDev().pport_id VNICBackDev().sriov_adap_id VNICBackDev().status VNICBackDev().vios_href VNICBackDevStatus VNICPortUsage IOAdapter Show source in iocard.py:303 A generic IO Adapter. This is a device plugged in to the system. The location code indicates where it is plugged into the system. Signature class IOAdapter(ewrap.ElementWrapper): ... IOAdapter().description Show source in iocard.py:315 Signature @property def description(self): ... IOAdapter().dev_name Show source in iocard.py:319 Signature @property def dev_name(self): ... IOAdapter().dev_type Show source in iocard.py:323 Signature @property def dev_type(self): ... IOAdapter().drc_name Show source in iocard.py:327 Signature @property def drc_name(self): ... IOAdapter().id Show source in iocard.py:310 The adapter system id. Signature @property def id(self): ... IOAdapter().phys_loc_code Show source in iocard.py:331 Signature @property def phys_loc_code(self): ... IOAdapter().udid Show source in iocard.py:335 Signature @property def udid(self): ... LinkAggrIOAdapterChoice Show source in iocard.py:1220 A free I/O Adapter link aggregation choice. Flattens this two step hierarchy to pull the information needed directly from the IOAdapter element. Signature class LinkAggrIOAdapterChoice(ewrap.ElementWrapper): ... LinkAggrIOAdapterChoice().__get_prop Show source in iocard.py:1226 Thin wrapper to get the IOAdapter and get a property. Signature def __get_prop(self, func): ... LinkAggrIOAdapterChoice().description Show source in iocard.py:1239 Signature @property def description(self): ... LinkAggrIOAdapterChoice().dev_name Show source in iocard.py:1243 Signature @property def dev_name(self): ... LinkAggrIOAdapterChoice().dev_type Show source in iocard.py:1247 Signature @property def dev_type(self): ... LinkAggrIOAdapterChoice().drc_name Show source in iocard.py:1251 Signature @property def drc_name(self): ... LinkAggrIOAdapterChoice().id Show source in iocard.py:1235 Signature @property def id(self): ... LinkAggrIOAdapterChoice().phys_loc_code Show source in iocard.py:1255 Signature @property def phys_loc_code(self): ... LinkAggrIOAdapterChoice().udid Show source in iocard.py:1259 Signature @property def udid(self): ... PhysFCAdapter Show source in iocard.py:342 A Physical Fibre Channel I/O Adapter. Extends the generic I/O Adapter, but provides port detail as well. The adapter has a set of Physical Fibre Channel Ports (PhysFCPort). Signature class PhysFCAdapter(IOAdapter): ... See also IOAdapter PhysFCAdapter().fc_ports Show source in iocard.py:349 A set of Physical Fibre Channel Ports. The set of PhysFCPort's that are attached to this adapter. The data on this should be considered read only. Signature @property def fc_ports(self): ... PhysFCPort Show source in iocard.py:362 A Physical Fibre Channel Port. Signature class PhysFCPort(ewrap.ElementWrapper): ... PhysFCPort.bld_ref Show source in iocard.py:365 Create a wrapper that serves as a reference to a port. This is typically used when another element (ex. Virtual FC Mapping) requires a port to be specified in it. Rather than query to find the port, one can simply be built and referenced as a child element. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) PhysFCPort().name - The name of the physical FC port. End users need to verify the port name. Typically starts with 'fcs'. ref_tag - (Optional, Default=None) If set, override the default 'PhysicalFibreChannelPort' tag/label in the element with the string specified. Signature @classmethod def bld_ref(cls, adapter, name, ref_tag=None): ... PhysFCPort().loc_code Show source in iocard.py:385 Signature @property def loc_code(self): ... PhysFCPort().name Show source in iocard.py:389 Signature @property def name(self): ... PhysFCPort().npiv_available_ports Show source in iocard.py:404 Signature @property def npiv_available_ports(self): ... PhysFCPort().npiv_total_ports Show source in iocard.py:408 Signature @property def npiv_total_ports(self): ... PhysFCPort().udid Show source in iocard.py:396 Signature @property def udid(self): ... PhysFCPort().wwpn Show source in iocard.py:400 Signature @property def wwpn(self): ... SRIOVAdapter Show source in iocard.py:414 The SR-IOV adapters for this system. Signature class SRIOVAdapter(IOAdapter): ... See also IOAdapter SRIOVAdapter().mode Show source in iocard.py:422 Signature @property def mode(self): ... SRIOVAdapter().mode Show source in iocard.py:426 Signature @mode.setter def mode(self, value): ... SRIOVAdapter().personality Show source in iocard.py:430 Signature @property def personality(self): ... SRIOVAdapter().phys_ports Show source in iocard.py:459 Retrieve Combined list of all physical ports. Returns a list of converged and ethernet physical ports. This list is not modifiable, cannot insert or remove items from it, however, individual item can be updated. For example, label and sublabels can be updated. Signature @property def phys_ports(self): ... SRIOVAdapter().sriov_adap_id Show source in iocard.py:417 Not to be confused with the 'id' property (IOAdapter.AdapterID). Signature @property def sriov_adap_id(self): ... SRIOVAdapter().state Show source in iocard.py:434 Signature @property def state(self): ... SRIOVAdapterMode Show source in iocard.py:236 Enumeration for SR-IOV adapter modes (from SRIOVAdapterMode.Enum). Signature class SRIOVAdapterMode(object): ... SRIOVAdapterPersonality Show source in iocard.py:244 Enum for SR-IOV adapter personalities (from SRIOVPersonality.Enum). Signature class SRIOVAdapterPersonality(object): ... SRIOVAdapterState Show source in iocard.py:252 Enumeration for SR-IOV adapter states (from SRIOVAdapterState.Enum). Signature class SRIOVAdapterState(object): ... SRIOVConvPPort Show source in iocard.py:606 The SR-IOV Converged Physical port. Signature class SRIOVConvPPort(SRIOVEthPPort): ... See also SRIOVEthPPort SRIOVEthLPort Show source in iocard.py:621 The SR-IOV Ethernet Logical port. Signature class SRIOVEthLPort(ewrap.EntryWrapper): ... SRIOVEthLPort().allowed_macs Show source in iocard.py:780 Signature @property def allowed_macs(self): ... SRIOVEthLPort().allowed_macs Show source in iocard.py:785 Signature @allowed_macs.setter def allowed_macs(self, maclist): ... SRIOVEthLPort().allowed_vlans Show source in iocard.py:758 Signature @property def allowed_vlans(self): ... SRIOVEthLPort().allowed_vlans Show source in iocard.py:763 Signature @allowed_vlans.setter def allowed_vlans(self, vlans): ... SRIOVEthLPort.bld Show source in iocard.py:624 Create a wrapper used to create a logical port on the server. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) SRIOVEthLPort().sriov_adap_id - Corresponds to SRIOVAdapter.SRIOVAdapterID, not SRIOVAdapter.AdapterID SRIOVEthLPort().pport_id - The physical port ID this logical port is part of. SRIOVEthLPort().pvid - The port VLAN identifier for this logical port. Any untagged traffic passing through this port will have this VLAN tag added. SRIOVEthLPort().mac - The MAC address to assign to the logical port. SRIOVEthLPort().allowed_vlans - An integer list of VLANS allowed on this logical port. Specify pypowervm.util.VLANList.ALL to allow all VLANs or .NONE to allow no VLANs on this logical port. Default: ALL. SRIOVEthLPort().allowed_macs - List of string MAC addresses allowed on this logical port. Specify pypowervm.util.MACList.ALL to allow all MAC addresses, or .NONE to allow no MAC addresses on this logical port. Default: ALL. SRIOVEthLPort().is_promisc - Set to True if using the logical port for bridging (e.g. SEA, OVS, etc.); False if assigning directly to an LPAR. Only one logical port per physical port may be promiscuous. SRIOVEthLPort().cfg_capacity - The configured capacity of the logical port as a percentage. This represents the minimum bandwidth this logical port will receive, as a percentage of bandwidth available from the physical port. The valid values are 0.0 <= x <= 1.0 up to 2 decimal places. This will be interpreted as a percentage, where 0.02 == 2%. max_capacity - The configured max capacity of the logical port as a percentage. This represents the maximum bandwidth this logical port will receive. The valid values are 0.0 <= x <= 1.0 up to 2 decimal places. This will be interpreted as a percentage, where 0.02 == 2%. Signature @classmethod def bld( cls, adapter, sriov_adap_id, pport_id, pvid=None, mac=None, allowed_vlans=u.VLANList.ALL, allowed_macs=u.MACList.ALL, is_promisc=False, cfg_capacity=None, max_capacity=None, ): ... SRIOVEthLPort().cfg_capacity Show source in iocard.py:703 Gets the configured capacity in a float-percentage format. Returns If the property is say \"2.45%\", a value of .0245 will be returned. Signature @property def cfg_capacity(self): ... SRIOVEthLPort().cfg_max_capacity Show source in iocard.py:722 Gets the configured maximum capacity in a float-percentage format. Returns If the property is say \"2.45%\", a value of .0245 will be returned. Signature @property def cfg_max_capacity(self): ... SRIOVEthLPort().cur_mac Show source in iocard.py:789 MAC address of the format XXXXXXXXXXXX (12 uppercase hex digits). This is the real value set on the interface, possibly by the VM's OS. Note that some SR-IOV cards are broken and don't report the OS-assigned value correctly. In such cases, cur_mac will report the same as mac. Signature @property def cur_mac(self): ... SRIOVEthLPort().dev_name Show source in iocard.py:699 Signature @property def dev_name(self): ... SRIOVEthLPort().is_promisc Show source in iocard.py:691 Signature @property def is_promisc(self): ... SRIOVEthLPort().loc_code Show source in iocard.py:800 Signature @property def loc_code(self): ... SRIOVEthLPort().lport_id Show source in iocard.py:680 Signature @property def lport_id(self): ... SRIOVEthLPort().mac Show source in iocard.py:767 MAC address of the format XXXXXXXXXXXX (12 uppercase hex digits). This is the MAC address \"burned into\" the logical port. The actual MAC address on the interface (cur_mac) may be this value or the value set from within the OS on the VM. Signature @property def mac(self): ... SRIOVEthLPort().pport_id Show source in iocard.py:741 Gets the physical port short ID. Signature @property def pport_id(self): ... SRIOVEthLPort().pvid Show source in iocard.py:750 Signature @property def pvid(self): ... SRIOVEthLPort().pvid Show source in iocard.py:754 Signature @pvid.setter def pvid(self, value): ... SRIOVEthLPort().sriov_adap_id Show source in iocard.py:684 Signature @property def sriov_adap_id(self): ... SRIOVEthLPort().vnic_port_usage Show source in iocard.py:804 Signature @property def vnic_port_usage(self): ... SRIOVEthPPort Show source in iocard.py:487 The SR-IOV Ethernet Physical port. Signature class SRIOVEthPPort(ewrap.ElementWrapper): def __init__(self): ... SRIOVEthPPort().allocated_capacity Show source in iocard.py:561 Gets the allocated capacity in a float-percentage format. Returns If the property is say \"2.45%\", a value of .0245 will be returned. Signature @property def allocated_capacity(self): ... SRIOVEthPPort().cfg_lps Show source in iocard.py:544 Signature @property def cfg_lps(self): ... SRIOVEthPPort().cfg_max_lps Show source in iocard.py:536 Signature @property def cfg_max_lps(self): ... SRIOVEthPPort().cfg_max_lps Show source in iocard.py:540 Signature @cfg_max_lps.setter def cfg_max_lps(self, value): ... SRIOVEthPPort().curr_speed Show source in iocard.py:570 Signature @property def curr_speed(self): ... SRIOVEthPPort().flow_ctl Show source in iocard.py:594 Signature @property def flow_ctl(self): ... SRIOVEthPPort().flow_ctl Show source in iocard.py:598 Signature @flow_ctl.setter def flow_ctl(self, val): ... SRIOVEthPPort().label Show source in iocard.py:508 Signature @property def label(self): ... SRIOVEthPPort().label Show source in iocard.py:512 Signature @label.setter def label(self, value): ... SRIOVEthPPort().link_status Show source in iocard.py:532 Signature @property def link_status(self): ... SRIOVEthPPort().loc_code Show source in iocard.py:516 Signature @property def loc_code(self): ... SRIOVEthPPort().min_granularity Show source in iocard.py:548 Gets the minimum granularity in a float-percentage format. Returns If the property is say \"2.45%\", a value of .0245 will be returned. Signature @property def min_granularity(self): ... SRIOVEthPPort().mtu Show source in iocard.py:574 Result should be a SRIOVPPMTU value. Signature @property def mtu(self): ... SRIOVEthPPort().mtu Show source in iocard.py:579 Input val should be a SRIOVPPMTU value. Signature @mtu.setter def mtu(self, val): ... SRIOVEthPPort().port_id Show source in iocard.py:520 Signature @property def port_id(self): ... SRIOVEthPPort().sriov_adap Show source in iocard.py:495 Backpointer to the SRIOVAdapter owning this physical port. Signature @property def sriov_adap(self): ... SRIOVEthPPort().sriov_adap_id Show source in iocard.py:503 The integer sriov_adap_id of the SRIOVAdapter owning this port. Signature @property def sriov_adap_id(self): ... SRIOVEthPPort().sublabel Show source in iocard.py:524 Signature @property def sublabel(self): ... SRIOVEthPPort().sublabel Show source in iocard.py:528 Signature @sublabel.setter def sublabel(self, value): ... SRIOVEthPPort().supp_max_lps Show source in iocard.py:557 Signature @property def supp_max_lps(self): ... SRIOVEthPPort().switch_mode Show source in iocard.py:584 Result should be a network.VSwitchMode value. Signature @property def switch_mode(self): ... SRIOVEthPPort().switch_mode Show source in iocard.py:589 Input val should be a network.VSwitchMode value. Signature @switch_mode.setter def switch_mode(self, val): ... SRIOVPPMTU Show source in iocard.py:277 SR-IOV Phys Port Max Transmission Unit (SRIOVPhysicalPortMTU.Enum). Signature class SRIOVPPMTU(object): ... SRIOVRoCEPPort Show source in iocard.py:614 The SR-IOV RoCE Physical Ethernet port. Signature class SRIOVRoCEPPort(SRIOVEthPPort): ... See also SRIOVEthPPort SRIOVSpeed Show source in iocard.py:265 Enumeration for SR-IOV speed (from SRIOVConnectionSpeed.Enum). Signature class SRIOVSpeed(object): ... VNIC Show source in iocard.py:810 A dedicated, possibly-redundant Virtual NIC. Signature class VNIC(ewrap.EntryWrapper): ... VNIC().allowed_macs Show source in iocard.py:923 Signature @property def allowed_macs(self): ... VNIC().allowed_macs Show source in iocard.py:927 Signature @allowed_macs.setter def allowed_macs(self, maclist): ... VNIC().allowed_vlans Show source in iocard.py:907 Signature @property def allowed_vlans(self): ... VNIC().allowed_vlans Show source in iocard.py:911 Signature @allowed_vlans.setter def allowed_vlans(self, vlans): ... VNIC().auto_pri_failover Show source in iocard.py:954 Signature @property def auto_pri_failover(self): ... VNIC().auto_pri_failover Show source in iocard.py:958 Signature @auto_pri_failover.setter def auto_pri_failover(self, val): ... VNIC().back_devs Show source in iocard.py:944 Signature @property def back_devs(self): ... VNIC().back_devs Show source in iocard.py:950 Signature @back_devs.setter def back_devs(self, new_devs): ... VNIC.bld Show source in iocard.py:813 Build a new VNIC wrapper suitable for .create() A VNIC is a CHILD object on a LogicalPartition. Usage models: vnic = VNIC.bld(...) vnic.back_devs.append(back_dev1) ... or vnic = VNIC.bld(..., back_devs=[back_dev1, back_dev2, ...]) then vnic.create(parent=lpar_wrap) Arguments adapter - pypowervm.adapter.Adapter for REST API communication. VNIC().pvid - Port VLAN ID for this vNIC. If not specified, the vNIC's traffic is untagged. slot_num - Desired virtual slot number on the owning LPAR. VNIC().allowed_vlans - An integer list of VLANS allowed on this vNIC. Specify pypowervm.util.VLANList.ALL to allow all VLANs or .NONE to allow no VLANs on this vNIC. Default: ALL. mac_addr - MAC address for the vNIC. VNIC().allowed_macs - List of string MAC addresses allowed on this vNIC. Specify pypowervm.util.MACList.ALL to allow all MAC addresses, or .NONE to allow no MAC addresses on this vNIC. Default: ALL. VNIC().back_devs - List of VNICBackDev wrappers each indicating a combination of VIOS, SR-IOV adapter and physical port on which to create the VF for the backing device. See VNICBackDev.bld. If not specified to bld, at least one must be added before the VNIC can be created. Returns A new VNIC wrapper. Signature @classmethod def bld( cls, adapter, pvid=None, slot_num=None, allowed_vlans=u.VLANList.ALL, mac_addr=None, allowed_macs=u.MACList.ALL, back_devs=None, ): ... VNIC().capacity Show source in iocard.py:931 The capacity (float, 0.0-1.0) of the active backing logical port. Signature @property def capacity(self): ... VNIC().drc_name Show source in iocard.py:863 Signature @property def drc_name(self): ... VNIC().gateway Show source in iocard.py:972 Returns the gateway of the network interface. Signature @ewrap.Wrapper.xag_property(pc.XAG.ADV) def gateway(self): ... VNIC().ip_address Show source in iocard.py:962 Returns the IP Address of the network interface. Signature @ewrap.Wrapper.xag_property(pc.XAG.ADV) def ip_address(self): ... VNIC().lpar_id Show source in iocard.py:867 The integer ID, not UUID, of the LPAR owning this VNIC. Signature @property def lpar_id(self): ... VNIC().mac Show source in iocard.py:915 MAC address of the format XXXXXXXXXXXX (12 uppercase hex digits). Signature @property def mac(self): ... VNIC().pvid Show source in iocard.py:898 The integer port VLAN ID, or None if the vNIC has no PVID. Signature @property def pvid(self): ... VNIC().pvid Show source in iocard.py:903 Signature @pvid.setter def pvid(self, val): ... VNIC().slot Show source in iocard.py:872 Signature @property def slot(self): ... VNIC().subnet_mask Show source in iocard.py:967 Returns the subnet mask of the network interface. Signature @ewrap.Wrapper.xag_property(pc.XAG.ADV) def subnet_mask(self): ... VNICBackDev Show source in iocard.py:1094 SR-IOV backing device for a vNIC. Signature class VNICBackDev(ewrap.ElementWrapper): ... VNICBackDev.bld Show source in iocard.py:1097 Create a new VNICBackDev, suitable for inclusion in a VNIC wrapper. Arguments adapter - pypowervm.adapter.Adapter for REST API communication. vios_uuid - String UUID of the Virtual I/O Server to host the vNIC server for this backing device. VNICBackDev().sriov_adap_id - Integer SR-IOV Adapter ID of the SR-IOV adapter owning the physical port on which the backing VF is to be created: SRIOVAdapter.sriov_adap_id. VNICBackDev().pport_id - Integer physical port ID of SR-IOV physical port on which the VF is to be created: SRIOVEthPPort.port_id VNICBackDev().capacity - Float value between 0.0 and 1.0 indicating the minimum fraction of the physical port's bandwidth allocated to traffic over this backing device. Must be a multiple of SRIOVEthPPort.min_granularity for the physical port indicated by pport_id. If not specified, SRIOVEthPPort.min_granularity is used by the platform. VNICBackDev().failover_pri - Positive integer value representing the failover priority of this backing device. VNICBackDev().max_capacity - Float value between 0.0 and 1.0 indicating the maximum fraction of the physical port's bandwidth allocated to traffic over this backing device. Returns A new VNICBackDev, suitable for inclusion in a VNIC wrapper. Signature @classmethod def bld( cls, adapter, vios_uuid, sriov_adap_id, pport_id, capacity=None, failover_pri=None, max_capacity=None, ): ... VNICBackDev().capacity Show source in iocard.py:1161 Gets the allocated capacity in a float-percentage format. Returns If the property is say \"2.45%\", a value of .0245 will be returned. Signature @property def capacity(self): ... VNICBackDev().desired_max_capacity Show source in iocard.py:1187 Gets the desired max capacity in a float-percentage format. Returns If the property is say \"2.45%\", a value of .0245 will be returned. Signature @property def desired_max_capacity(self): ... VNICBackDev().failover_pri Show source in iocard.py:1196 The failover priority value for this backing device. Returns A value between 1 and 100, inclusive, with a lower number indicating the higher priority (i.e. the backingdevice with priority 1 will take precedence over that with priority 2). Signature @property def failover_pri(self): ... VNICBackDev().failover_pri Show source in iocard.py:1206 Signature @failover_pri.setter def failover_pri(self, val): ... VNICBackDev().is_active Show source in iocard.py:1210 Signature @property def is_active(self): ... VNICBackDev().lport_href Show source in iocard.py:1157 Signature @property def lport_href(self): ... VNICBackDev().max_capacity Show source in iocard.py:1174 Gets the max capacity in a float-percentage format. Returns If the property is say \"2.45%\", a value of .0245 will be returned. Signature @property def max_capacity(self): ... VNICBackDev().pport_id Show source in iocard.py:1150 Signature @property def pport_id(self): ... VNICBackDev().sriov_adap_id Show source in iocard.py:1143 Signature @property def sriov_adap_id(self): ... VNICBackDev().status Show source in iocard.py:1214 Signature @property def status(self): ... VNICBackDev().vios_href Show source in iocard.py:1136 Signature @property def vios_href(self): ... VNICBackDevStatus Show source in iocard.py:284 Enumeration of possible VNIC backing device statuses. Signature class VNICBackDevStatus(object): ... VNICPortUsage Show source in iocard.py:295 Enumeration of possible VNIC port usages. Signature class VNICPortUsage(object): ...","title":"Iocard"},{"location":"pypowervm/wrappers/iocard/#iocard","text":"Pypowervm Index / Pypowervm / Wrappers / Iocard Auto-generated documentation for pypowervm.wrappers.iocard module.","title":"Iocard"},{"location":"pypowervm/wrappers/iocard/#attributes","text":"IO_ADPT_ROOT - Constants for generic I/O Adapter: 'IOAdapter' Iocard IOAdapter IOAdapter().description IOAdapter().dev_name IOAdapter().dev_type IOAdapter().drc_name IOAdapter().id IOAdapter().phys_loc_code IOAdapter().udid LinkAggrIOAdapterChoice LinkAggrIOAdapterChoice().__get_prop LinkAggrIOAdapterChoice().description LinkAggrIOAdapterChoice().dev_name LinkAggrIOAdapterChoice().dev_type LinkAggrIOAdapterChoice().drc_name LinkAggrIOAdapterChoice().id LinkAggrIOAdapterChoice().phys_loc_code LinkAggrIOAdapterChoice().udid PhysFCAdapter PhysFCAdapter().fc_ports PhysFCPort PhysFCPort.bld_ref PhysFCPort().loc_code PhysFCPort().name PhysFCPort().npiv_available_ports PhysFCPort().npiv_total_ports PhysFCPort().udid PhysFCPort().wwpn SRIOVAdapter SRIOVAdapter().mode SRIOVAdapter().mode SRIOVAdapter().personality SRIOVAdapter().phys_ports SRIOVAdapter().sriov_adap_id SRIOVAdapter().state SRIOVAdapterMode SRIOVAdapterPersonality SRIOVAdapterState SRIOVConvPPort SRIOVEthLPort SRIOVEthLPort().allowed_macs SRIOVEthLPort().allowed_macs SRIOVEthLPort().allowed_vlans SRIOVEthLPort().allowed_vlans SRIOVEthLPort.bld SRIOVEthLPort().cfg_capacity SRIOVEthLPort().cfg_max_capacity SRIOVEthLPort().cur_mac SRIOVEthLPort().dev_name SRIOVEthLPort().is_promisc SRIOVEthLPort().loc_code SRIOVEthLPort().lport_id SRIOVEthLPort().mac SRIOVEthLPort().pport_id SRIOVEthLPort().pvid SRIOVEthLPort().pvid SRIOVEthLPort().sriov_adap_id SRIOVEthLPort().vnic_port_usage SRIOVEthPPort SRIOVEthPPort().allocated_capacity SRIOVEthPPort().cfg_lps SRIOVEthPPort().cfg_max_lps SRIOVEthPPort().cfg_max_lps SRIOVEthPPort().curr_speed SRIOVEthPPort().flow_ctl SRIOVEthPPort().flow_ctl SRIOVEthPPort().label SRIOVEthPPort().label SRIOVEthPPort().link_status SRIOVEthPPort().loc_code SRIOVEthPPort().min_granularity SRIOVEthPPort().mtu SRIOVEthPPort().mtu SRIOVEthPPort().port_id SRIOVEthPPort().sriov_adap SRIOVEthPPort().sriov_adap_id SRIOVEthPPort().sublabel SRIOVEthPPort().sublabel SRIOVEthPPort().supp_max_lps SRIOVEthPPort().switch_mode SRIOVEthPPort().switch_mode SRIOVPPMTU SRIOVRoCEPPort SRIOVSpeed VNIC VNIC().allowed_macs VNIC().allowed_macs VNIC().allowed_vlans VNIC().allowed_vlans VNIC().auto_pri_failover VNIC().auto_pri_failover VNIC().back_devs VNIC().back_devs VNIC.bld VNIC().capacity VNIC().drc_name VNIC().gateway VNIC().ip_address VNIC().lpar_id VNIC().mac VNIC().pvid VNIC().pvid VNIC().slot VNIC().subnet_mask VNICBackDev VNICBackDev.bld VNICBackDev().capacity VNICBackDev().desired_max_capacity VNICBackDev().failover_pri VNICBackDev().failover_pri VNICBackDev().is_active VNICBackDev().lport_href VNICBackDev().max_capacity VNICBackDev().pport_id VNICBackDev().sriov_adap_id VNICBackDev().status VNICBackDev().vios_href VNICBackDevStatus VNICPortUsage","title":"Attributes"},{"location":"pypowervm/wrappers/iocard/#ioadapter","text":"Show source in iocard.py:303 A generic IO Adapter. This is a device plugged in to the system. The location code indicates where it is plugged into the system.","title":"IOAdapter"},{"location":"pypowervm/wrappers/iocard/#signature","text":"class IOAdapter(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#ioadapterdescription","text":"Show source in iocard.py:315","title":"IOAdapter().description"},{"location":"pypowervm/wrappers/iocard/#signature_1","text":"@property def description(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#ioadapterdev_name","text":"Show source in iocard.py:319","title":"IOAdapter().dev_name"},{"location":"pypowervm/wrappers/iocard/#signature_2","text":"@property def dev_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#ioadapterdev_type","text":"Show source in iocard.py:323","title":"IOAdapter().dev_type"},{"location":"pypowervm/wrappers/iocard/#signature_3","text":"@property def dev_type(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#ioadapterdrc_name","text":"Show source in iocard.py:327","title":"IOAdapter().drc_name"},{"location":"pypowervm/wrappers/iocard/#signature_4","text":"@property def drc_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#ioadapterid","text":"Show source in iocard.py:310 The adapter system id.","title":"IOAdapter().id"},{"location":"pypowervm/wrappers/iocard/#signature_5","text":"@property def id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#ioadapterphys_loc_code","text":"Show source in iocard.py:331","title":"IOAdapter().phys_loc_code"},{"location":"pypowervm/wrappers/iocard/#signature_6","text":"@property def phys_loc_code(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#ioadapterudid","text":"Show source in iocard.py:335","title":"IOAdapter().udid"},{"location":"pypowervm/wrappers/iocard/#signature_7","text":"@property def udid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#linkaggrioadapterchoice","text":"Show source in iocard.py:1220 A free I/O Adapter link aggregation choice. Flattens this two step hierarchy to pull the information needed directly from the IOAdapter element.","title":"LinkAggrIOAdapterChoice"},{"location":"pypowervm/wrappers/iocard/#signature_8","text":"class LinkAggrIOAdapterChoice(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#linkaggrioadapterchoice__get_prop","text":"Show source in iocard.py:1226 Thin wrapper to get the IOAdapter and get a property.","title":"LinkAggrIOAdapterChoice().__get_prop"},{"location":"pypowervm/wrappers/iocard/#signature_9","text":"def __get_prop(self, func): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#linkaggrioadapterchoicedescription","text":"Show source in iocard.py:1239","title":"LinkAggrIOAdapterChoice().description"},{"location":"pypowervm/wrappers/iocard/#signature_10","text":"@property def description(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#linkaggrioadapterchoicedev_name","text":"Show source in iocard.py:1243","title":"LinkAggrIOAdapterChoice().dev_name"},{"location":"pypowervm/wrappers/iocard/#signature_11","text":"@property def dev_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#linkaggrioadapterchoicedev_type","text":"Show source in iocard.py:1247","title":"LinkAggrIOAdapterChoice().dev_type"},{"location":"pypowervm/wrappers/iocard/#signature_12","text":"@property def dev_type(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#linkaggrioadapterchoicedrc_name","text":"Show source in iocard.py:1251","title":"LinkAggrIOAdapterChoice().drc_name"},{"location":"pypowervm/wrappers/iocard/#signature_13","text":"@property def drc_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#linkaggrioadapterchoiceid","text":"Show source in iocard.py:1235","title":"LinkAggrIOAdapterChoice().id"},{"location":"pypowervm/wrappers/iocard/#signature_14","text":"@property def id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#linkaggrioadapterchoicephys_loc_code","text":"Show source in iocard.py:1255","title":"LinkAggrIOAdapterChoice().phys_loc_code"},{"location":"pypowervm/wrappers/iocard/#signature_15","text":"@property def phys_loc_code(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#linkaggrioadapterchoiceudid","text":"Show source in iocard.py:1259","title":"LinkAggrIOAdapterChoice().udid"},{"location":"pypowervm/wrappers/iocard/#signature_16","text":"@property def udid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#physfcadapter","text":"Show source in iocard.py:342 A Physical Fibre Channel I/O Adapter. Extends the generic I/O Adapter, but provides port detail as well. The adapter has a set of Physical Fibre Channel Ports (PhysFCPort).","title":"PhysFCAdapter"},{"location":"pypowervm/wrappers/iocard/#signature_17","text":"class PhysFCAdapter(IOAdapter): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#see-also","text":"IOAdapter","title":"See also"},{"location":"pypowervm/wrappers/iocard/#physfcadapterfc_ports","text":"Show source in iocard.py:349 A set of Physical Fibre Channel Ports. The set of PhysFCPort's that are attached to this adapter. The data on this should be considered read only.","title":"PhysFCAdapter().fc_ports"},{"location":"pypowervm/wrappers/iocard/#signature_18","text":"@property def fc_ports(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#physfcport","text":"Show source in iocard.py:362 A Physical Fibre Channel Port.","title":"PhysFCPort"},{"location":"pypowervm/wrappers/iocard/#signature_19","text":"class PhysFCPort(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#physfcportbld_ref","text":"Show source in iocard.py:365 Create a wrapper that serves as a reference to a port. This is typically used when another element (ex. Virtual FC Mapping) requires a port to be specified in it. Rather than query to find the port, one can simply be built and referenced as a child element.","title":"PhysFCPort.bld_ref"},{"location":"pypowervm/wrappers/iocard/#arguments","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) PhysFCPort().name - The name of the physical FC port. End users need to verify the port name. Typically starts with 'fcs'. ref_tag - (Optional, Default=None) If set, override the default 'PhysicalFibreChannelPort' tag/label in the element with the string specified.","title":"Arguments"},{"location":"pypowervm/wrappers/iocard/#signature_20","text":"@classmethod def bld_ref(cls, adapter, name, ref_tag=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#physfcportloc_code","text":"Show source in iocard.py:385","title":"PhysFCPort().loc_code"},{"location":"pypowervm/wrappers/iocard/#signature_21","text":"@property def loc_code(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#physfcportname","text":"Show source in iocard.py:389","title":"PhysFCPort().name"},{"location":"pypowervm/wrappers/iocard/#signature_22","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#physfcportnpiv_available_ports","text":"Show source in iocard.py:404","title":"PhysFCPort().npiv_available_ports"},{"location":"pypowervm/wrappers/iocard/#signature_23","text":"@property def npiv_available_ports(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#physfcportnpiv_total_ports","text":"Show source in iocard.py:408","title":"PhysFCPort().npiv_total_ports"},{"location":"pypowervm/wrappers/iocard/#signature_24","text":"@property def npiv_total_ports(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#physfcportudid","text":"Show source in iocard.py:396","title":"PhysFCPort().udid"},{"location":"pypowervm/wrappers/iocard/#signature_25","text":"@property def udid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#physfcportwwpn","text":"Show source in iocard.py:400","title":"PhysFCPort().wwpn"},{"location":"pypowervm/wrappers/iocard/#signature_26","text":"@property def wwpn(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovadapter","text":"Show source in iocard.py:414 The SR-IOV adapters for this system.","title":"SRIOVAdapter"},{"location":"pypowervm/wrappers/iocard/#signature_27","text":"class SRIOVAdapter(IOAdapter): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#see-also_1","text":"IOAdapter","title":"See also"},{"location":"pypowervm/wrappers/iocard/#sriovadaptermode","text":"Show source in iocard.py:422","title":"SRIOVAdapter().mode"},{"location":"pypowervm/wrappers/iocard/#signature_28","text":"@property def mode(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovadaptermode_1","text":"Show source in iocard.py:426","title":"SRIOVAdapter().mode"},{"location":"pypowervm/wrappers/iocard/#signature_29","text":"@mode.setter def mode(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovadapterpersonality","text":"Show source in iocard.py:430","title":"SRIOVAdapter().personality"},{"location":"pypowervm/wrappers/iocard/#signature_30","text":"@property def personality(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovadapterphys_ports","text":"Show source in iocard.py:459 Retrieve Combined list of all physical ports. Returns a list of converged and ethernet physical ports. This list is not modifiable, cannot insert or remove items from it, however, individual item can be updated. For example, label and sublabels can be updated.","title":"SRIOVAdapter().phys_ports"},{"location":"pypowervm/wrappers/iocard/#signature_31","text":"@property def phys_ports(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovadaptersriov_adap_id","text":"Show source in iocard.py:417 Not to be confused with the 'id' property (IOAdapter.AdapterID).","title":"SRIOVAdapter().sriov_adap_id"},{"location":"pypowervm/wrappers/iocard/#signature_32","text":"@property def sriov_adap_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovadapterstate","text":"Show source in iocard.py:434","title":"SRIOVAdapter().state"},{"location":"pypowervm/wrappers/iocard/#signature_33","text":"@property def state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovadaptermode_2","text":"Show source in iocard.py:236 Enumeration for SR-IOV adapter modes (from SRIOVAdapterMode.Enum).","title":"SRIOVAdapterMode"},{"location":"pypowervm/wrappers/iocard/#signature_34","text":"class SRIOVAdapterMode(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovadapterpersonality_1","text":"Show source in iocard.py:244 Enum for SR-IOV adapter personalities (from SRIOVPersonality.Enum).","title":"SRIOVAdapterPersonality"},{"location":"pypowervm/wrappers/iocard/#signature_35","text":"class SRIOVAdapterPersonality(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovadapterstate_1","text":"Show source in iocard.py:252 Enumeration for SR-IOV adapter states (from SRIOVAdapterState.Enum).","title":"SRIOVAdapterState"},{"location":"pypowervm/wrappers/iocard/#signature_36","text":"class SRIOVAdapterState(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovconvpport","text":"Show source in iocard.py:606 The SR-IOV Converged Physical port.","title":"SRIOVConvPPort"},{"location":"pypowervm/wrappers/iocard/#signature_37","text":"class SRIOVConvPPort(SRIOVEthPPort): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#see-also_2","text":"SRIOVEthPPort","title":"See also"},{"location":"pypowervm/wrappers/iocard/#sriovethlport","text":"Show source in iocard.py:621 The SR-IOV Ethernet Logical port.","title":"SRIOVEthLPort"},{"location":"pypowervm/wrappers/iocard/#signature_38","text":"class SRIOVEthLPort(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportallowed_macs","text":"Show source in iocard.py:780","title":"SRIOVEthLPort().allowed_macs"},{"location":"pypowervm/wrappers/iocard/#signature_39","text":"@property def allowed_macs(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportallowed_macs_1","text":"Show source in iocard.py:785","title":"SRIOVEthLPort().allowed_macs"},{"location":"pypowervm/wrappers/iocard/#signature_40","text":"@allowed_macs.setter def allowed_macs(self, maclist): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportallowed_vlans","text":"Show source in iocard.py:758","title":"SRIOVEthLPort().allowed_vlans"},{"location":"pypowervm/wrappers/iocard/#signature_41","text":"@property def allowed_vlans(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportallowed_vlans_1","text":"Show source in iocard.py:763","title":"SRIOVEthLPort().allowed_vlans"},{"location":"pypowervm/wrappers/iocard/#signature_42","text":"@allowed_vlans.setter def allowed_vlans(self, vlans): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportbld","text":"Show source in iocard.py:624 Create a wrapper used to create a logical port on the server.","title":"SRIOVEthLPort.bld"},{"location":"pypowervm/wrappers/iocard/#arguments_1","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) SRIOVEthLPort().sriov_adap_id - Corresponds to SRIOVAdapter.SRIOVAdapterID, not SRIOVAdapter.AdapterID SRIOVEthLPort().pport_id - The physical port ID this logical port is part of. SRIOVEthLPort().pvid - The port VLAN identifier for this logical port. Any untagged traffic passing through this port will have this VLAN tag added. SRIOVEthLPort().mac - The MAC address to assign to the logical port. SRIOVEthLPort().allowed_vlans - An integer list of VLANS allowed on this logical port. Specify pypowervm.util.VLANList.ALL to allow all VLANs or .NONE to allow no VLANs on this logical port. Default: ALL. SRIOVEthLPort().allowed_macs - List of string MAC addresses allowed on this logical port. Specify pypowervm.util.MACList.ALL to allow all MAC addresses, or .NONE to allow no MAC addresses on this logical port. Default: ALL. SRIOVEthLPort().is_promisc - Set to True if using the logical port for bridging (e.g. SEA, OVS, etc.); False if assigning directly to an LPAR. Only one logical port per physical port may be promiscuous. SRIOVEthLPort().cfg_capacity - The configured capacity of the logical port as a percentage. This represents the minimum bandwidth this logical port will receive, as a percentage of bandwidth available from the physical port. The valid values are 0.0 <= x <= 1.0 up to 2 decimal places. This will be interpreted as a percentage, where 0.02 == 2%. max_capacity - The configured max capacity of the logical port as a percentage. This represents the maximum bandwidth this logical port will receive. The valid values are 0.0 <= x <= 1.0 up to 2 decimal places. This will be interpreted as a percentage, where 0.02 == 2%.","title":"Arguments"},{"location":"pypowervm/wrappers/iocard/#signature_43","text":"@classmethod def bld( cls, adapter, sriov_adap_id, pport_id, pvid=None, mac=None, allowed_vlans=u.VLANList.ALL, allowed_macs=u.MACList.ALL, is_promisc=False, cfg_capacity=None, max_capacity=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportcfg_capacity","text":"Show source in iocard.py:703 Gets the configured capacity in a float-percentage format.","title":"SRIOVEthLPort().cfg_capacity"},{"location":"pypowervm/wrappers/iocard/#returns","text":"If the property is say \"2.45%\", a value of .0245 will be returned.","title":"Returns"},{"location":"pypowervm/wrappers/iocard/#signature_44","text":"@property def cfg_capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportcfg_max_capacity","text":"Show source in iocard.py:722 Gets the configured maximum capacity in a float-percentage format.","title":"SRIOVEthLPort().cfg_max_capacity"},{"location":"pypowervm/wrappers/iocard/#returns_1","text":"If the property is say \"2.45%\", a value of .0245 will be returned.","title":"Returns"},{"location":"pypowervm/wrappers/iocard/#signature_45","text":"@property def cfg_max_capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportcur_mac","text":"Show source in iocard.py:789 MAC address of the format XXXXXXXXXXXX (12 uppercase hex digits). This is the real value set on the interface, possibly by the VM's OS. Note that some SR-IOV cards are broken and don't report the OS-assigned value correctly. In such cases, cur_mac will report the same as mac.","title":"SRIOVEthLPort().cur_mac"},{"location":"pypowervm/wrappers/iocard/#signature_46","text":"@property def cur_mac(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportdev_name","text":"Show source in iocard.py:699","title":"SRIOVEthLPort().dev_name"},{"location":"pypowervm/wrappers/iocard/#signature_47","text":"@property def dev_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportis_promisc","text":"Show source in iocard.py:691","title":"SRIOVEthLPort().is_promisc"},{"location":"pypowervm/wrappers/iocard/#signature_48","text":"@property def is_promisc(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportloc_code","text":"Show source in iocard.py:800","title":"SRIOVEthLPort().loc_code"},{"location":"pypowervm/wrappers/iocard/#signature_49","text":"@property def loc_code(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportlport_id","text":"Show source in iocard.py:680","title":"SRIOVEthLPort().lport_id"},{"location":"pypowervm/wrappers/iocard/#signature_50","text":"@property def lport_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportmac","text":"Show source in iocard.py:767 MAC address of the format XXXXXXXXXXXX (12 uppercase hex digits). This is the MAC address \"burned into\" the logical port. The actual MAC address on the interface (cur_mac) may be this value or the value set from within the OS on the VM.","title":"SRIOVEthLPort().mac"},{"location":"pypowervm/wrappers/iocard/#signature_51","text":"@property def mac(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportpport_id","text":"Show source in iocard.py:741 Gets the physical port short ID.","title":"SRIOVEthLPort().pport_id"},{"location":"pypowervm/wrappers/iocard/#signature_52","text":"@property def pport_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportpvid","text":"Show source in iocard.py:750","title":"SRIOVEthLPort().pvid"},{"location":"pypowervm/wrappers/iocard/#signature_53","text":"@property def pvid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportpvid_1","text":"Show source in iocard.py:754","title":"SRIOVEthLPort().pvid"},{"location":"pypowervm/wrappers/iocard/#signature_54","text":"@pvid.setter def pvid(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportsriov_adap_id","text":"Show source in iocard.py:684","title":"SRIOVEthLPort().sriov_adap_id"},{"location":"pypowervm/wrappers/iocard/#signature_55","text":"@property def sriov_adap_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethlportvnic_port_usage","text":"Show source in iocard.py:804","title":"SRIOVEthLPort().vnic_port_usage"},{"location":"pypowervm/wrappers/iocard/#signature_56","text":"@property def vnic_port_usage(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpport","text":"Show source in iocard.py:487 The SR-IOV Ethernet Physical port.","title":"SRIOVEthPPort"},{"location":"pypowervm/wrappers/iocard/#signature_57","text":"class SRIOVEthPPort(ewrap.ElementWrapper): def __init__(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportallocated_capacity","text":"Show source in iocard.py:561 Gets the allocated capacity in a float-percentage format.","title":"SRIOVEthPPort().allocated_capacity"},{"location":"pypowervm/wrappers/iocard/#returns_2","text":"If the property is say \"2.45%\", a value of .0245 will be returned.","title":"Returns"},{"location":"pypowervm/wrappers/iocard/#signature_58","text":"@property def allocated_capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportcfg_lps","text":"Show source in iocard.py:544","title":"SRIOVEthPPort().cfg_lps"},{"location":"pypowervm/wrappers/iocard/#signature_59","text":"@property def cfg_lps(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportcfg_max_lps","text":"Show source in iocard.py:536","title":"SRIOVEthPPort().cfg_max_lps"},{"location":"pypowervm/wrappers/iocard/#signature_60","text":"@property def cfg_max_lps(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportcfg_max_lps_1","text":"Show source in iocard.py:540","title":"SRIOVEthPPort().cfg_max_lps"},{"location":"pypowervm/wrappers/iocard/#signature_61","text":"@cfg_max_lps.setter def cfg_max_lps(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportcurr_speed","text":"Show source in iocard.py:570","title":"SRIOVEthPPort().curr_speed"},{"location":"pypowervm/wrappers/iocard/#signature_62","text":"@property def curr_speed(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportflow_ctl","text":"Show source in iocard.py:594","title":"SRIOVEthPPort().flow_ctl"},{"location":"pypowervm/wrappers/iocard/#signature_63","text":"@property def flow_ctl(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportflow_ctl_1","text":"Show source in iocard.py:598","title":"SRIOVEthPPort().flow_ctl"},{"location":"pypowervm/wrappers/iocard/#signature_64","text":"@flow_ctl.setter def flow_ctl(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportlabel","text":"Show source in iocard.py:508","title":"SRIOVEthPPort().label"},{"location":"pypowervm/wrappers/iocard/#signature_65","text":"@property def label(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportlabel_1","text":"Show source in iocard.py:512","title":"SRIOVEthPPort().label"},{"location":"pypowervm/wrappers/iocard/#signature_66","text":"@label.setter def label(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportlink_status","text":"Show source in iocard.py:532","title":"SRIOVEthPPort().link_status"},{"location":"pypowervm/wrappers/iocard/#signature_67","text":"@property def link_status(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportloc_code","text":"Show source in iocard.py:516","title":"SRIOVEthPPort().loc_code"},{"location":"pypowervm/wrappers/iocard/#signature_68","text":"@property def loc_code(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportmin_granularity","text":"Show source in iocard.py:548 Gets the minimum granularity in a float-percentage format.","title":"SRIOVEthPPort().min_granularity"},{"location":"pypowervm/wrappers/iocard/#returns_3","text":"If the property is say \"2.45%\", a value of .0245 will be returned.","title":"Returns"},{"location":"pypowervm/wrappers/iocard/#signature_69","text":"@property def min_granularity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportmtu","text":"Show source in iocard.py:574 Result should be a SRIOVPPMTU value.","title":"SRIOVEthPPort().mtu"},{"location":"pypowervm/wrappers/iocard/#signature_70","text":"@property def mtu(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportmtu_1","text":"Show source in iocard.py:579 Input val should be a SRIOVPPMTU value.","title":"SRIOVEthPPort().mtu"},{"location":"pypowervm/wrappers/iocard/#signature_71","text":"@mtu.setter def mtu(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportport_id","text":"Show source in iocard.py:520","title":"SRIOVEthPPort().port_id"},{"location":"pypowervm/wrappers/iocard/#signature_72","text":"@property def port_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportsriov_adap","text":"Show source in iocard.py:495 Backpointer to the SRIOVAdapter owning this physical port.","title":"SRIOVEthPPort().sriov_adap"},{"location":"pypowervm/wrappers/iocard/#signature_73","text":"@property def sriov_adap(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportsriov_adap_id","text":"Show source in iocard.py:503 The integer sriov_adap_id of the SRIOVAdapter owning this port.","title":"SRIOVEthPPort().sriov_adap_id"},{"location":"pypowervm/wrappers/iocard/#signature_74","text":"@property def sriov_adap_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportsublabel","text":"Show source in iocard.py:524","title":"SRIOVEthPPort().sublabel"},{"location":"pypowervm/wrappers/iocard/#signature_75","text":"@property def sublabel(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportsublabel_1","text":"Show source in iocard.py:528","title":"SRIOVEthPPort().sublabel"},{"location":"pypowervm/wrappers/iocard/#signature_76","text":"@sublabel.setter def sublabel(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportsupp_max_lps","text":"Show source in iocard.py:557","title":"SRIOVEthPPort().supp_max_lps"},{"location":"pypowervm/wrappers/iocard/#signature_77","text":"@property def supp_max_lps(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportswitch_mode","text":"Show source in iocard.py:584 Result should be a network.VSwitchMode value.","title":"SRIOVEthPPort().switch_mode"},{"location":"pypowervm/wrappers/iocard/#signature_78","text":"@property def switch_mode(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovethpportswitch_mode_1","text":"Show source in iocard.py:589 Input val should be a network.VSwitchMode value.","title":"SRIOVEthPPort().switch_mode"},{"location":"pypowervm/wrappers/iocard/#signature_79","text":"@switch_mode.setter def switch_mode(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovppmtu","text":"Show source in iocard.py:277 SR-IOV Phys Port Max Transmission Unit (SRIOVPhysicalPortMTU.Enum).","title":"SRIOVPPMTU"},{"location":"pypowervm/wrappers/iocard/#signature_80","text":"class SRIOVPPMTU(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#sriovrocepport","text":"Show source in iocard.py:614 The SR-IOV RoCE Physical Ethernet port.","title":"SRIOVRoCEPPort"},{"location":"pypowervm/wrappers/iocard/#signature_81","text":"class SRIOVRoCEPPort(SRIOVEthPPort): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#see-also_3","text":"SRIOVEthPPort","title":"See also"},{"location":"pypowervm/wrappers/iocard/#sriovspeed","text":"Show source in iocard.py:265 Enumeration for SR-IOV speed (from SRIOVConnectionSpeed.Enum).","title":"SRIOVSpeed"},{"location":"pypowervm/wrappers/iocard/#signature_82","text":"class SRIOVSpeed(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnic","text":"Show source in iocard.py:810 A dedicated, possibly-redundant Virtual NIC.","title":"VNIC"},{"location":"pypowervm/wrappers/iocard/#signature_83","text":"class VNIC(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicallowed_macs","text":"Show source in iocard.py:923","title":"VNIC().allowed_macs"},{"location":"pypowervm/wrappers/iocard/#signature_84","text":"@property def allowed_macs(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicallowed_macs_1","text":"Show source in iocard.py:927","title":"VNIC().allowed_macs"},{"location":"pypowervm/wrappers/iocard/#signature_85","text":"@allowed_macs.setter def allowed_macs(self, maclist): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicallowed_vlans","text":"Show source in iocard.py:907","title":"VNIC().allowed_vlans"},{"location":"pypowervm/wrappers/iocard/#signature_86","text":"@property def allowed_vlans(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicallowed_vlans_1","text":"Show source in iocard.py:911","title":"VNIC().allowed_vlans"},{"location":"pypowervm/wrappers/iocard/#signature_87","text":"@allowed_vlans.setter def allowed_vlans(self, vlans): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicauto_pri_failover","text":"Show source in iocard.py:954","title":"VNIC().auto_pri_failover"},{"location":"pypowervm/wrappers/iocard/#signature_88","text":"@property def auto_pri_failover(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicauto_pri_failover_1","text":"Show source in iocard.py:958","title":"VNIC().auto_pri_failover"},{"location":"pypowervm/wrappers/iocard/#signature_89","text":"@auto_pri_failover.setter def auto_pri_failover(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicback_devs","text":"Show source in iocard.py:944","title":"VNIC().back_devs"},{"location":"pypowervm/wrappers/iocard/#signature_90","text":"@property def back_devs(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicback_devs_1","text":"Show source in iocard.py:950","title":"VNIC().back_devs"},{"location":"pypowervm/wrappers/iocard/#signature_91","text":"@back_devs.setter def back_devs(self, new_devs): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbld","text":"Show source in iocard.py:813 Build a new VNIC wrapper suitable for .create() A VNIC is a CHILD object on a LogicalPartition. Usage models: vnic = VNIC.bld(...) vnic.back_devs.append(back_dev1) ... or vnic = VNIC.bld(..., back_devs=[back_dev1, back_dev2, ...]) then vnic.create(parent=lpar_wrap)","title":"VNIC.bld"},{"location":"pypowervm/wrappers/iocard/#arguments_2","text":"adapter - pypowervm.adapter.Adapter for REST API communication. VNIC().pvid - Port VLAN ID for this vNIC. If not specified, the vNIC's traffic is untagged. slot_num - Desired virtual slot number on the owning LPAR. VNIC().allowed_vlans - An integer list of VLANS allowed on this vNIC. Specify pypowervm.util.VLANList.ALL to allow all VLANs or .NONE to allow no VLANs on this vNIC. Default: ALL. mac_addr - MAC address for the vNIC. VNIC().allowed_macs - List of string MAC addresses allowed on this vNIC. Specify pypowervm.util.MACList.ALL to allow all MAC addresses, or .NONE to allow no MAC addresses on this vNIC. Default: ALL. VNIC().back_devs - List of VNICBackDev wrappers each indicating a combination of VIOS, SR-IOV adapter and physical port on which to create the VF for the backing device. See VNICBackDev.bld. If not specified to bld, at least one must be added before the VNIC can be created.","title":"Arguments"},{"location":"pypowervm/wrappers/iocard/#returns_4","text":"A new VNIC wrapper.","title":"Returns"},{"location":"pypowervm/wrappers/iocard/#signature_92","text":"@classmethod def bld( cls, adapter, pvid=None, slot_num=None, allowed_vlans=u.VLANList.ALL, mac_addr=None, allowed_macs=u.MACList.ALL, back_devs=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vniccapacity","text":"Show source in iocard.py:931 The capacity (float, 0.0-1.0) of the active backing logical port.","title":"VNIC().capacity"},{"location":"pypowervm/wrappers/iocard/#signature_93","text":"@property def capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicdrc_name","text":"Show source in iocard.py:863","title":"VNIC().drc_name"},{"location":"pypowervm/wrappers/iocard/#signature_94","text":"@property def drc_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicgateway","text":"Show source in iocard.py:972 Returns the gateway of the network interface.","title":"VNIC().gateway"},{"location":"pypowervm/wrappers/iocard/#signature_95","text":"@ewrap.Wrapper.xag_property(pc.XAG.ADV) def gateway(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicip_address","text":"Show source in iocard.py:962 Returns the IP Address of the network interface.","title":"VNIC().ip_address"},{"location":"pypowervm/wrappers/iocard/#signature_96","text":"@ewrap.Wrapper.xag_property(pc.XAG.ADV) def ip_address(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vniclpar_id","text":"Show source in iocard.py:867 The integer ID, not UUID, of the LPAR owning this VNIC.","title":"VNIC().lpar_id"},{"location":"pypowervm/wrappers/iocard/#signature_97","text":"@property def lpar_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicmac","text":"Show source in iocard.py:915 MAC address of the format XXXXXXXXXXXX (12 uppercase hex digits).","title":"VNIC().mac"},{"location":"pypowervm/wrappers/iocard/#signature_98","text":"@property def mac(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicpvid","text":"Show source in iocard.py:898 The integer port VLAN ID, or None if the vNIC has no PVID.","title":"VNIC().pvid"},{"location":"pypowervm/wrappers/iocard/#signature_99","text":"@property def pvid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicpvid_1","text":"Show source in iocard.py:903","title":"VNIC().pvid"},{"location":"pypowervm/wrappers/iocard/#signature_100","text":"@pvid.setter def pvid(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicslot","text":"Show source in iocard.py:872","title":"VNIC().slot"},{"location":"pypowervm/wrappers/iocard/#signature_101","text":"@property def slot(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicsubnet_mask","text":"Show source in iocard.py:967 Returns the subnet mask of the network interface.","title":"VNIC().subnet_mask"},{"location":"pypowervm/wrappers/iocard/#signature_102","text":"@ewrap.Wrapper.xag_property(pc.XAG.ADV) def subnet_mask(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdev","text":"Show source in iocard.py:1094 SR-IOV backing device for a vNIC.","title":"VNICBackDev"},{"location":"pypowervm/wrappers/iocard/#signature_103","text":"class VNICBackDev(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevbld","text":"Show source in iocard.py:1097 Create a new VNICBackDev, suitable for inclusion in a VNIC wrapper.","title":"VNICBackDev.bld"},{"location":"pypowervm/wrappers/iocard/#arguments_3","text":"adapter - pypowervm.adapter.Adapter for REST API communication. vios_uuid - String UUID of the Virtual I/O Server to host the vNIC server for this backing device. VNICBackDev().sriov_adap_id - Integer SR-IOV Adapter ID of the SR-IOV adapter owning the physical port on which the backing VF is to be created: SRIOVAdapter.sriov_adap_id. VNICBackDev().pport_id - Integer physical port ID of SR-IOV physical port on which the VF is to be created: SRIOVEthPPort.port_id VNICBackDev().capacity - Float value between 0.0 and 1.0 indicating the minimum fraction of the physical port's bandwidth allocated to traffic over this backing device. Must be a multiple of SRIOVEthPPort.min_granularity for the physical port indicated by pport_id. If not specified, SRIOVEthPPort.min_granularity is used by the platform. VNICBackDev().failover_pri - Positive integer value representing the failover priority of this backing device. VNICBackDev().max_capacity - Float value between 0.0 and 1.0 indicating the maximum fraction of the physical port's bandwidth allocated to traffic over this backing device.","title":"Arguments"},{"location":"pypowervm/wrappers/iocard/#returns_5","text":"A new VNICBackDev, suitable for inclusion in a VNIC wrapper.","title":"Returns"},{"location":"pypowervm/wrappers/iocard/#signature_104","text":"@classmethod def bld( cls, adapter, vios_uuid, sriov_adap_id, pport_id, capacity=None, failover_pri=None, max_capacity=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevcapacity","text":"Show source in iocard.py:1161 Gets the allocated capacity in a float-percentage format.","title":"VNICBackDev().capacity"},{"location":"pypowervm/wrappers/iocard/#returns_6","text":"If the property is say \"2.45%\", a value of .0245 will be returned.","title":"Returns"},{"location":"pypowervm/wrappers/iocard/#signature_105","text":"@property def capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevdesired_max_capacity","text":"Show source in iocard.py:1187 Gets the desired max capacity in a float-percentage format.","title":"VNICBackDev().desired_max_capacity"},{"location":"pypowervm/wrappers/iocard/#returns_7","text":"If the property is say \"2.45%\", a value of .0245 will be returned.","title":"Returns"},{"location":"pypowervm/wrappers/iocard/#signature_106","text":"@property def desired_max_capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevfailover_pri","text":"Show source in iocard.py:1196 The failover priority value for this backing device.","title":"VNICBackDev().failover_pri"},{"location":"pypowervm/wrappers/iocard/#returns_8","text":"A value between 1 and 100, inclusive, with a lower number indicating the higher priority (i.e. the backingdevice with priority 1 will take precedence over that with priority 2).","title":"Returns"},{"location":"pypowervm/wrappers/iocard/#signature_107","text":"@property def failover_pri(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevfailover_pri_1","text":"Show source in iocard.py:1206","title":"VNICBackDev().failover_pri"},{"location":"pypowervm/wrappers/iocard/#signature_108","text":"@failover_pri.setter def failover_pri(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevis_active","text":"Show source in iocard.py:1210","title":"VNICBackDev().is_active"},{"location":"pypowervm/wrappers/iocard/#signature_109","text":"@property def is_active(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevlport_href","text":"Show source in iocard.py:1157","title":"VNICBackDev().lport_href"},{"location":"pypowervm/wrappers/iocard/#signature_110","text":"@property def lport_href(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevmax_capacity","text":"Show source in iocard.py:1174 Gets the max capacity in a float-percentage format.","title":"VNICBackDev().max_capacity"},{"location":"pypowervm/wrappers/iocard/#returns_9","text":"If the property is say \"2.45%\", a value of .0245 will be returned.","title":"Returns"},{"location":"pypowervm/wrappers/iocard/#signature_111","text":"@property def max_capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevpport_id","text":"Show source in iocard.py:1150","title":"VNICBackDev().pport_id"},{"location":"pypowervm/wrappers/iocard/#signature_112","text":"@property def pport_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevsriov_adap_id","text":"Show source in iocard.py:1143","title":"VNICBackDev().sriov_adap_id"},{"location":"pypowervm/wrappers/iocard/#signature_113","text":"@property def sriov_adap_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevstatus","text":"Show source in iocard.py:1214","title":"VNICBackDev().status"},{"location":"pypowervm/wrappers/iocard/#signature_114","text":"@property def status(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevvios_href","text":"Show source in iocard.py:1136","title":"VNICBackDev().vios_href"},{"location":"pypowervm/wrappers/iocard/#signature_115","text":"@property def vios_href(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicbackdevstatus_1","text":"Show source in iocard.py:284 Enumeration of possible VNIC backing device statuses.","title":"VNICBackDevStatus"},{"location":"pypowervm/wrappers/iocard/#signature_116","text":"class VNICBackDevStatus(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/iocard/#vnicportusage","text":"Show source in iocard.py:295 Enumeration of possible VNIC port usages.","title":"VNICPortUsage"},{"location":"pypowervm/wrappers/iocard/#signature_117","text":"class VNICPortUsage(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/","text":"Job Pypowervm Index / Pypowervm / Wrappers / Job Auto-generated documentation for pypowervm.wrappers.job module. Job CancelJobThread CancelJobThread().run Job Job().add_job_parameters_to_existing Job().cancel_job Job.create_job_parameter Job().delete_job Job().get_job_message Job().get_job_resp_exception_msg Job().get_job_results_as_dict Job().get_job_results_message Job().job_id Job().job_status Job().poll_while_status Job().run_job Job.wrap JobStatus PollAndDeleteThread PollAndDeleteThread().run CancelJobThread Show source in job.py:75 Signature class CancelJobThread(threading.Thread): def __init__(self, job, sensitive): ... CancelJobThread().run Show source in job.py:81 Signature def run(self): ... Job Show source in job.py:87 Wrapper object for job response schema. Signature class Job(ewrap.EntryWrapper): ... Job().add_job_parameters_to_existing Show source in job.py:117 Adds JobParameter Elements to existing JobParameters xml. Must be a job response entry. Arguments add_parms - list of JobParamters to add Signature def add_job_parameters_to_existing(self, *add_parms): ... Job().cancel_job Show source in job.py:317 Cancels and deletes incomplete/running jobs. This method spawns a thread to monitor the job being cancelled and delete it. Arguments sensitive - If True, payload will be hidden in the logs Signature def cancel_job(self, sensitive=False): ... Job.create_job_parameter Show source in job.py:96 Creates a JobParameter Element. Arguments name - ParameterName text value value - ParameterValue text value cdata - If True, the value text will be wrapped in CDATA tags Returns JobParameter Element Signature @staticmethod def create_job_parameter(name, value, cdata=False): ... Job().delete_job Show source in job.py:337 Cleans this Job off of the REST server, if it is completed. Raises JobRequestFailed - if the Job is detected to be running. Signature def delete_job(self): ... Job().get_job_message Show source in job.py:186 Gets the job message string. It checks job results message first, if results message is not found, it checks for a ResponseException message. If neither is found, it returns the default. Returns String containing the job message or default (defaults to empty string) if not found Signature def get_job_message(self, default=\"\"): ... Job().get_job_resp_exception_msg Show source in job.py:143 Gets the job message string from the ResponseException. Returns String containing the job message or default (defaults to empty string) if not found Signature def get_job_resp_exception_msg(self, default=\"\"): ... Job().get_job_results_as_dict Show source in job.py:173 Gets the job results as a dictionary. Returns Dictionary with result parm names and parm values as key, value pairs. Signature def get_job_results_as_dict(self, default=None): ... Job().get_job_results_message Show source in job.py:158 Gets the job result message string. Returns String containing the job result message or default (defaults to empty string) if not found Signature def get_job_results_message(self, default=\"\"): ... Job().job_id Show source in job.py:127 Gets the job ID string. Returns String containing the job ID Signature @property def job_id(self): ... Job().job_status Show source in job.py:135 Gets the job status string. Returns String containing the job status Signature @property def job_status(self): ... Job().poll_while_status Show source in job.py:253 Poll the Job as long as its status is in the specified list. Arguments statuses - Iterable of JobStatus enum values. This method continues to poll the Job as long as its status is in the specified list, or until the timeout is reached (whichever comes first). timeout - Maximum number of seconds to keep checking job status. If zero, poll indefinitely. sensitive - If True, mask the Job payload in the logs. Returns timed_out: True if the timeout was reached before the Job left the specified set of states. Signature def poll_while_status(self, statuses, timeout, sensitive): ... Job().run_job Show source in job.py:201 Invokes and polls a job. Adds job parameters to the job element if specified and calls the create_job method. It then monitors the job for completion and sends a JobRequestFailed exception if it did not complete successfully. Arguments uuid - uuid of the target job_parms - list of JobParamters to add timeout - maximum number of seconds for job to complete sensitive - If True, mask the Job payload in the logs. synchronous - If True (the default), wait for the Job to complete or time out. If False, return as soon as the Job starts. Note that this may still involve polling (if the Job is waiting in queue to start), and may still time out (if the Job hasn't started within the requested timeout.) Raises JobRequestFailed - if the job did not complete successfully. JobRequestTimedOut - if the job timed out. Signature def run_job( self, uuid, job_parms=None, timeout=CONF.pypowervm_job_request_timeout, sensitive=False, synchronous=True, ): ... Job.wrap Show source in job.py:90 Signature @classmethod def wrap(cls, response_or_entry, etag=None): ... JobStatus Show source in job.py:51 Signature class JobStatus(object): ... PollAndDeleteThread Show source in job.py:59 Signature class PollAndDeleteThread(threading.Thread): def __init__(self, job, sensitive): ... PollAndDeleteThread().run Show source in job.py:65 Signature def run(self): ...","title":"Job"},{"location":"pypowervm/wrappers/job/#job","text":"Pypowervm Index / Pypowervm / Wrappers / Job Auto-generated documentation for pypowervm.wrappers.job module. Job CancelJobThread CancelJobThread().run Job Job().add_job_parameters_to_existing Job().cancel_job Job.create_job_parameter Job().delete_job Job().get_job_message Job().get_job_resp_exception_msg Job().get_job_results_as_dict Job().get_job_results_message Job().job_id Job().job_status Job().poll_while_status Job().run_job Job.wrap JobStatus PollAndDeleteThread PollAndDeleteThread().run","title":"Job"},{"location":"pypowervm/wrappers/job/#canceljobthread","text":"Show source in job.py:75","title":"CancelJobThread"},{"location":"pypowervm/wrappers/job/#signature","text":"class CancelJobThread(threading.Thread): def __init__(self, job, sensitive): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#canceljobthreadrun","text":"Show source in job.py:81","title":"CancelJobThread().run"},{"location":"pypowervm/wrappers/job/#signature_1","text":"def run(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#job_1","text":"Show source in job.py:87 Wrapper object for job response schema.","title":"Job"},{"location":"pypowervm/wrappers/job/#signature_2","text":"class Job(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobadd_job_parameters_to_existing","text":"Show source in job.py:117 Adds JobParameter Elements to existing JobParameters xml. Must be a job response entry.","title":"Job().add_job_parameters_to_existing"},{"location":"pypowervm/wrappers/job/#arguments","text":"add_parms - list of JobParamters to add","title":"Arguments"},{"location":"pypowervm/wrappers/job/#signature_3","text":"def add_job_parameters_to_existing(self, *add_parms): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobcancel_job","text":"Show source in job.py:317 Cancels and deletes incomplete/running jobs. This method spawns a thread to monitor the job being cancelled and delete it.","title":"Job().cancel_job"},{"location":"pypowervm/wrappers/job/#arguments_1","text":"sensitive - If True, payload will be hidden in the logs","title":"Arguments"},{"location":"pypowervm/wrappers/job/#signature_4","text":"def cancel_job(self, sensitive=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobcreate_job_parameter","text":"Show source in job.py:96 Creates a JobParameter Element.","title":"Job.create_job_parameter"},{"location":"pypowervm/wrappers/job/#arguments_2","text":"name - ParameterName text value value - ParameterValue text value cdata - If True, the value text will be wrapped in CDATA tags","title":"Arguments"},{"location":"pypowervm/wrappers/job/#returns","text":"JobParameter Element","title":"Returns"},{"location":"pypowervm/wrappers/job/#signature_5","text":"@staticmethod def create_job_parameter(name, value, cdata=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobdelete_job","text":"Show source in job.py:337 Cleans this Job off of the REST server, if it is completed.","title":"Job().delete_job"},{"location":"pypowervm/wrappers/job/#raises","text":"JobRequestFailed - if the Job is detected to be running.","title":"Raises"},{"location":"pypowervm/wrappers/job/#signature_6","text":"def delete_job(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobget_job_message","text":"Show source in job.py:186 Gets the job message string. It checks job results message first, if results message is not found, it checks for a ResponseException message. If neither is found, it returns the default.","title":"Job().get_job_message"},{"location":"pypowervm/wrappers/job/#returns_1","text":"String containing the job message or default (defaults to empty string) if not found","title":"Returns"},{"location":"pypowervm/wrappers/job/#signature_7","text":"def get_job_message(self, default=\"\"): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobget_job_resp_exception_msg","text":"Show source in job.py:143 Gets the job message string from the ResponseException.","title":"Job().get_job_resp_exception_msg"},{"location":"pypowervm/wrappers/job/#returns_2","text":"String containing the job message or default (defaults to empty string) if not found","title":"Returns"},{"location":"pypowervm/wrappers/job/#signature_8","text":"def get_job_resp_exception_msg(self, default=\"\"): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobget_job_results_as_dict","text":"Show source in job.py:173 Gets the job results as a dictionary.","title":"Job().get_job_results_as_dict"},{"location":"pypowervm/wrappers/job/#returns_3","text":"Dictionary with result parm names and parm values as key, value pairs.","title":"Returns"},{"location":"pypowervm/wrappers/job/#signature_9","text":"def get_job_results_as_dict(self, default=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobget_job_results_message","text":"Show source in job.py:158 Gets the job result message string.","title":"Job().get_job_results_message"},{"location":"pypowervm/wrappers/job/#returns_4","text":"String containing the job result message or default (defaults to empty string) if not found","title":"Returns"},{"location":"pypowervm/wrappers/job/#signature_10","text":"def get_job_results_message(self, default=\"\"): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobjob_id","text":"Show source in job.py:127 Gets the job ID string.","title":"Job().job_id"},{"location":"pypowervm/wrappers/job/#returns_5","text":"String containing the job ID","title":"Returns"},{"location":"pypowervm/wrappers/job/#signature_11","text":"@property def job_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobjob_status","text":"Show source in job.py:135 Gets the job status string.","title":"Job().job_status"},{"location":"pypowervm/wrappers/job/#returns_6","text":"String containing the job status","title":"Returns"},{"location":"pypowervm/wrappers/job/#signature_12","text":"@property def job_status(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobpoll_while_status","text":"Show source in job.py:253 Poll the Job as long as its status is in the specified list.","title":"Job().poll_while_status"},{"location":"pypowervm/wrappers/job/#arguments_3","text":"statuses - Iterable of JobStatus enum values. This method continues to poll the Job as long as its status is in the specified list, or until the timeout is reached (whichever comes first). timeout - Maximum number of seconds to keep checking job status. If zero, poll indefinitely. sensitive - If True, mask the Job payload in the logs.","title":"Arguments"},{"location":"pypowervm/wrappers/job/#returns_7","text":"timed_out: True if the timeout was reached before the Job left the specified set of states.","title":"Returns"},{"location":"pypowervm/wrappers/job/#signature_13","text":"def poll_while_status(self, statuses, timeout, sensitive): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobrun_job","text":"Show source in job.py:201 Invokes and polls a job. Adds job parameters to the job element if specified and calls the create_job method. It then monitors the job for completion and sends a JobRequestFailed exception if it did not complete successfully.","title":"Job().run_job"},{"location":"pypowervm/wrappers/job/#arguments_4","text":"uuid - uuid of the target job_parms - list of JobParamters to add timeout - maximum number of seconds for job to complete sensitive - If True, mask the Job payload in the logs. synchronous - If True (the default), wait for the Job to complete or time out. If False, return as soon as the Job starts. Note that this may still involve polling (if the Job is waiting in queue to start), and may still time out (if the Job hasn't started within the requested timeout.)","title":"Arguments"},{"location":"pypowervm/wrappers/job/#raises_1","text":"JobRequestFailed - if the job did not complete successfully. JobRequestTimedOut - if the job timed out.","title":"Raises"},{"location":"pypowervm/wrappers/job/#signature_14","text":"def run_job( self, uuid, job_parms=None, timeout=CONF.pypowervm_job_request_timeout, sensitive=False, synchronous=True, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobwrap","text":"Show source in job.py:90","title":"Job.wrap"},{"location":"pypowervm/wrappers/job/#signature_15","text":"@classmethod def wrap(cls, response_or_entry, etag=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#jobstatus","text":"Show source in job.py:51","title":"JobStatus"},{"location":"pypowervm/wrappers/job/#signature_16","text":"class JobStatus(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#pollanddeletethread","text":"Show source in job.py:59","title":"PollAndDeleteThread"},{"location":"pypowervm/wrappers/job/#signature_17","text":"class PollAndDeleteThread(threading.Thread): def __init__(self, job, sensitive): ...","title":"Signature"},{"location":"pypowervm/wrappers/job/#pollanddeletethreadrun","text":"Show source in job.py:65","title":"PollAndDeleteThread().run"},{"location":"pypowervm/wrappers/job/#signature_18","text":"def run(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/","text":"Logical Partition Pypowervm Index / Pypowervm / Wrappers / Logical Partition Auto-generated documentation for pypowervm.wrappers.logical_partition module. Logical Partition BootStorageType IPLSrc LPAR LPAR.bld LPAR().can_lpm LPAR().desig_ipl_src LPAR().desig_ipl_src LPAR().migration_state LPAR().restrictedio LPAR().restrictedio LPAR().rr_enabled LPAR().rr_enabled LPAR().rr_state LPAR().set_uuid LPAR().srr_enabled LPAR().srr_enabled RRState BootStorageType Show source in logical_partition.py:108 Enumeration of possible storage connection methods for devices. Signature class BootStorageType(object): ... IPLSrc Show source in logical_partition.py:61 Mirror of IPLSource.Enum (relevant to IBMi partitions only). Valid values for: - LPAR.desig_ipl_src - 'iIPLsource' param in pypowervm.power.power_on. Example usage: - ilpar.desig_ipl_src = IPLSrc.C ilpar.update() - power_on(..., add_parms={IPLSrc.KEY: IPLSrc.A, ...}) Signature class IPLSrc(object): ... LPAR Show source in logical_partition.py:118 Signature class LPAR(bp.BasePartition, ewrap.WrapperSetUUIDMixin): ... LPAR.bld Show source in logical_partition.py:120 Creates an LPAR wrapper. Thin wrapper around BasePartition._bld_base, defaulting env. Signature @classmethod def bld(cls, adapter, name, mem_cfg, proc_cfg, env=bp.LPARType.AIXLINUX, io_cfg=None): ... LPAR().can_lpm Show source in logical_partition.py:147 Determines if a LPAR is ready for Live Partition Migration. This check validates that the target system is capable of handling the LPAR if the LPAR is an IBMi. It simply validates that the LPAR has the essential capabilities in place for a LPM operation. Arguments host_w - The host wrapper for the system. migr_data - The dictionary of migration data for the target host. If parameters are not passed in, will skip the check and let the low levels surface related error. The supported key today is: - ibmi_lpar_mobility_capable: Boolean TODO(IBM): add more destination checks here. Ex. migrate an AIX or IBMi VM to a Linux only host. Returns Type: capable True if the LPAR is LPM capable. False otherwise. Type: reason A translated message that will indicate why it was not capable of LPM. If capable is True, the reason will be None. Signature def can_lpm(self, host_w, migr_data=None): ... LPAR().desig_ipl_src Show source in logical_partition.py:258 Designated IPL Source - see IPLSrc enumeration. Signature @property def desig_ipl_src(self): ... LPAR().desig_ipl_src Show source in logical_partition.py:263 Designated IPL Source - see IPLSrc enumeration. Signature @desig_ipl_src.setter def desig_ipl_src(self, value): ... LPAR().migration_state Show source in logical_partition.py:201 See PartitionMigrationStateEnum. e.g. 'Not_Migrating', 'Migration_Starting', 'Migration_Failed', etc. Defaults to 'Not_Migrating' Signature @property def migration_state(self): ... LPAR().restrictedio Show source in logical_partition.py:249 Signature @property def restrictedio(self): ... LPAR().restrictedio Show source in logical_partition.py:253 Signature @restrictedio.setter def restrictedio(self, value): ... LPAR().rr_enabled Show source in logical_partition.py:210 Deprecated (n/a for NovaLink) - use srr_enabled instead. Signature @property def rr_enabled(self): ... LPAR().rr_enabled Show source in logical_partition.py:219 Deprecated (n/a for NovaLink) - use srr_enabled instead. Signature @rr_enabled.setter def rr_enabled(self, value): ... LPAR().rr_state Show source in logical_partition.py:227 Deprecated (n/a for NovaLink) - use srr_enabled instead. Signature @property def rr_state(self): ... LPAR().set_uuid Show source in logical_partition.py:270 Signature def set_uuid(self, value): ... LPAR().srr_enabled Show source in logical_partition.py:236 Simplied remote restart. Returns Returns SRR config boolean Signature @property def srr_enabled(self): ... LPAR().srr_enabled Show source in logical_partition.py:244 Signature @srr_enabled.setter def srr_enabled(self, value): ... RRState Show source in logical_partition.py:82 Remote Restart states - mirror of PartitionRemoteRestart.Enum. Signature class RRState(object): ...","title":"Logical Partition"},{"location":"pypowervm/wrappers/logical_partition/#logical-partition","text":"Pypowervm Index / Pypowervm / Wrappers / Logical Partition Auto-generated documentation for pypowervm.wrappers.logical_partition module. Logical Partition BootStorageType IPLSrc LPAR LPAR.bld LPAR().can_lpm LPAR().desig_ipl_src LPAR().desig_ipl_src LPAR().migration_state LPAR().restrictedio LPAR().restrictedio LPAR().rr_enabled LPAR().rr_enabled LPAR().rr_state LPAR().set_uuid LPAR().srr_enabled LPAR().srr_enabled RRState","title":"Logical Partition"},{"location":"pypowervm/wrappers/logical_partition/#bootstoragetype","text":"Show source in logical_partition.py:108 Enumeration of possible storage connection methods for devices.","title":"BootStorageType"},{"location":"pypowervm/wrappers/logical_partition/#signature","text":"class BootStorageType(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#iplsrc","text":"Show source in logical_partition.py:61 Mirror of IPLSource.Enum (relevant to IBMi partitions only). Valid values for: - LPAR.desig_ipl_src - 'iIPLsource' param in pypowervm.power.power_on. Example usage: - ilpar.desig_ipl_src = IPLSrc.C ilpar.update() - power_on(..., add_parms={IPLSrc.KEY: IPLSrc.A, ...})","title":"IPLSrc"},{"location":"pypowervm/wrappers/logical_partition/#signature_1","text":"class IPLSrc(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lpar","text":"Show source in logical_partition.py:118","title":"LPAR"},{"location":"pypowervm/wrappers/logical_partition/#signature_2","text":"class LPAR(bp.BasePartition, ewrap.WrapperSetUUIDMixin): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparbld","text":"Show source in logical_partition.py:120 Creates an LPAR wrapper. Thin wrapper around BasePartition._bld_base, defaulting env.","title":"LPAR.bld"},{"location":"pypowervm/wrappers/logical_partition/#signature_3","text":"@classmethod def bld(cls, adapter, name, mem_cfg, proc_cfg, env=bp.LPARType.AIXLINUX, io_cfg=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparcan_lpm","text":"Show source in logical_partition.py:147 Determines if a LPAR is ready for Live Partition Migration. This check validates that the target system is capable of handling the LPAR if the LPAR is an IBMi. It simply validates that the LPAR has the essential capabilities in place for a LPM operation.","title":"LPAR().can_lpm"},{"location":"pypowervm/wrappers/logical_partition/#arguments","text":"host_w - The host wrapper for the system. migr_data - The dictionary of migration data for the target host. If parameters are not passed in, will skip the check and let the low levels surface related error. The supported key today is: - ibmi_lpar_mobility_capable: Boolean TODO(IBM): add more destination checks here. Ex. migrate an AIX or IBMi VM to a Linux only host.","title":"Arguments"},{"location":"pypowervm/wrappers/logical_partition/#returns","text":"Type: capable True if the LPAR is LPM capable. False otherwise. Type: reason A translated message that will indicate why it was not capable of LPM. If capable is True, the reason will be None.","title":"Returns"},{"location":"pypowervm/wrappers/logical_partition/#signature_4","text":"def can_lpm(self, host_w, migr_data=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lpardesig_ipl_src","text":"Show source in logical_partition.py:258 Designated IPL Source - see IPLSrc enumeration.","title":"LPAR().desig_ipl_src"},{"location":"pypowervm/wrappers/logical_partition/#signature_5","text":"@property def desig_ipl_src(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lpardesig_ipl_src_1","text":"Show source in logical_partition.py:263 Designated IPL Source - see IPLSrc enumeration.","title":"LPAR().desig_ipl_src"},{"location":"pypowervm/wrappers/logical_partition/#signature_6","text":"@desig_ipl_src.setter def desig_ipl_src(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparmigration_state","text":"Show source in logical_partition.py:201 See PartitionMigrationStateEnum. e.g. 'Not_Migrating', 'Migration_Starting', 'Migration_Failed', etc. Defaults to 'Not_Migrating'","title":"LPAR().migration_state"},{"location":"pypowervm/wrappers/logical_partition/#signature_7","text":"@property def migration_state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparrestrictedio","text":"Show source in logical_partition.py:249","title":"LPAR().restrictedio"},{"location":"pypowervm/wrappers/logical_partition/#signature_8","text":"@property def restrictedio(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparrestrictedio_1","text":"Show source in logical_partition.py:253","title":"LPAR().restrictedio"},{"location":"pypowervm/wrappers/logical_partition/#signature_9","text":"@restrictedio.setter def restrictedio(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparrr_enabled","text":"Show source in logical_partition.py:210 Deprecated (n/a for NovaLink) - use srr_enabled instead.","title":"LPAR().rr_enabled"},{"location":"pypowervm/wrappers/logical_partition/#signature_10","text":"@property def rr_enabled(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparrr_enabled_1","text":"Show source in logical_partition.py:219 Deprecated (n/a for NovaLink) - use srr_enabled instead.","title":"LPAR().rr_enabled"},{"location":"pypowervm/wrappers/logical_partition/#signature_11","text":"@rr_enabled.setter def rr_enabled(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparrr_state","text":"Show source in logical_partition.py:227 Deprecated (n/a for NovaLink) - use srr_enabled instead.","title":"LPAR().rr_state"},{"location":"pypowervm/wrappers/logical_partition/#signature_12","text":"@property def rr_state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparset_uuid","text":"Show source in logical_partition.py:270","title":"LPAR().set_uuid"},{"location":"pypowervm/wrappers/logical_partition/#signature_13","text":"def set_uuid(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparsrr_enabled","text":"Show source in logical_partition.py:236 Simplied remote restart.","title":"LPAR().srr_enabled"},{"location":"pypowervm/wrappers/logical_partition/#returns_1","text":"Returns SRR config boolean","title":"Returns"},{"location":"pypowervm/wrappers/logical_partition/#signature_14","text":"@property def srr_enabled(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#lparsrr_enabled_1","text":"Show source in logical_partition.py:244","title":"LPAR().srr_enabled"},{"location":"pypowervm/wrappers/logical_partition/#signature_15","text":"@srr_enabled.setter def srr_enabled(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/logical_partition/#rrstate","text":"Show source in logical_partition.py:82 Remote Restart states - mirror of PartitionRemoteRestart.Enum.","title":"RRState"},{"location":"pypowervm/wrappers/logical_partition/#signature_16","text":"class RRState(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/","text":"Managed System Pypowervm Index / Pypowervm / Wrappers / Managed System Auto-generated documentation for pypowervm.wrappers.managed_system module. Managed System ASIOConfig ASIOConfig().avail_wwpns ASIOConfig().io_slots ASIOConfig().sriov_adapters ASIOConfig().wwpn_prefix IOSlot IOSlot().bus_grp_required IOSlot().description IOSlot().drc_index IOSlot().drc_name IOSlot().dyn_reconfig_conn_index IOSlot().dyn_reconfig_conn_name IOSlot().feat_codes IOSlot().part_id IOSlot().part_name IOSlot().part_type IOSlot().part_uuid IOSlot().pci_class IOSlot().pci_dev_id IOSlot().pci_rev_id IOSlot().pci_revision_id IOSlot().pci_sub_dev_id IOSlot().pci_sub_vendor_id IOSlot().pci_subsys_dev_id IOSlot().pci_subsys_vendor_id IOSlot().pci_vendor_id System System().asio_config System().cur_pmem_volumes System().default_ppt_ratio System().dram_pmem_vol_blksize System().dram_pmem_vol_cursize System().dram_pmem_vol_size System().firmware_memory System().get_capabilities System().get_capability System().highest_compat_mode System().host_ip_address System().max_aix_lnx_pmem_volumes System().max_os400_pmem_volumes System().max_pmem_volumes System().max_procs_per_aix_linux_lpar System().max_procs_per_aix_linux_lpar System().max_sys_procs_limit System().max_sys_vcpus_limit System().max_vcpus_per_aix_linux_lpar System().max_vcpus_per_aix_linux_lpar System().max_vios_pmem_volumes System().memory_configurable System().memory_free System().memory_region_size System().memory_total System().metered_pool_id System().migration_data System().min_proc_units System().mtms System().page_table_ratio System().proc_compat_modes System().proc_units System().proc_units_avail System().proc_units_configurable System().processor_is_throttled System().session_is_master System().supported_ibmi_console_codepage System().supported_pmem_vol_devtypes System().system_name System().system_state System().vios_links ASIOConfig Show source in managed_system.py:479 The associated system IO configuration for this system. Signature class ASIOConfig(ewrap.ElementWrapper): ... ASIOConfig().avail_wwpns Show source in managed_system.py:482 Signature @property def avail_wwpns(self): ... ASIOConfig().io_slots Show source in managed_system.py:486 Signature @property def io_slots(self): ... ASIOConfig().sriov_adapters Show source in managed_system.py:495 Signature @property def sriov_adapters(self): ... ASIOConfig().wwpn_prefix Show source in managed_system.py:491 Signature @property def wwpn_prefix(self): ... IOSlot Show source in managed_system.py:504 An I/O Slot represents a device bus on the system. It may contain a piece of hardware within it. Signature class IOSlot(ewrap.ElementWrapper): ... IOSlot().bus_grp_required Show source in managed_system.py:510 Signature @property def bus_grp_required(self): ... IOSlot().description Show source in managed_system.py:514 Signature @property def description(self): ... IOSlot().drc_index Show source in managed_system.py:604 Signature @property def drc_index(self): ... IOSlot().drc_name Show source in managed_system.py:616 Signature @property def drc_name(self): ... IOSlot().dyn_reconfig_conn_index Show source in managed_system.py:608 Deprecated - use drc_index instead. Signature @property def dyn_reconfig_conn_index(self): ... IOSlot().dyn_reconfig_conn_name Show source in managed_system.py:620 Deprecated - use drc_name instead. Signature @property def dyn_reconfig_conn_name(self): ... IOSlot().feat_codes Show source in managed_system.py:518 Signature @property def feat_codes(self): ... IOSlot().part_id Show source in managed_system.py:522 Short ID of the partition to which the slot is assigned. None if the slot is unassigned. Signature @property def part_id(self): ... IOSlot().part_name Show source in managed_system.py:538 String name of the partition to which the slot is assigned. None if the slot is unassigned. Signature @property def part_name(self): ... IOSlot().part_type Show source in managed_system.py:546 String type of the partition to which the slot is assigned. May be compared with base_partition.LPARType enum values. None if the slot is unassigned. Signature @property def part_type(self): ... IOSlot().part_uuid Show source in managed_system.py:530 UUID of the partition to which the slot is assigned. None if the slot is unassigned. Signature @property def part_uuid(self): ... IOSlot().pci_class Show source in managed_system.py:556 Signature @property def pci_class(self): ... IOSlot().pci_dev_id Show source in managed_system.py:560 Signature @property def pci_dev_id(self): ... IOSlot().pci_rev_id Show source in managed_system.py:576 Signature @property def pci_rev_id(self): ... IOSlot().pci_revision_id Show source in managed_system.py:580 Deprecated - use pci_rev_id instead. Signature @property def pci_revision_id(self): ... IOSlot().pci_sub_dev_id Show source in managed_system.py:568 Deprecated - use pci_subsys_dev_id instead. Signature @property def pci_sub_dev_id(self): ... IOSlot().pci_sub_vendor_id Show source in managed_system.py:596 Deprecated - use pci_subsys_vendor_id instead. Signature @property def pci_sub_vendor_id(self): ... IOSlot().pci_subsys_dev_id Show source in managed_system.py:564 Signature @property def pci_subsys_dev_id(self): ... IOSlot().pci_subsys_vendor_id Show source in managed_system.py:592 Signature @property def pci_subsys_vendor_id(self): ... IOSlot().pci_vendor_id Show source in managed_system.py:588 Signature @property def pci_vendor_id(self): ... System Show source in managed_system.py:227 The PowerVM system that is being managed. Signature class System(ewrap.EntryWrapper): ... System().asio_config Show source in managed_system.py:238 Signature @property def asio_config(self): ... System().cur_pmem_volumes Show source in managed_system.py:445 Signature @property def cur_pmem_volumes(self): ... System().default_ppt_ratio Show source in managed_system.py:322 Signature @property def default_ppt_ratio(self): ... System().dram_pmem_vol_blksize Show source in managed_system.py:461 Signature @property def dram_pmem_vol_blksize(self): ... System().dram_pmem_vol_cursize Show source in managed_system.py:469 Signature @property def dram_pmem_vol_cursize(self): ... System().dram_pmem_vol_size Show source in managed_system.py:465 Signature @property def dram_pmem_vol_size(self): ... System().firmware_memory Show source in managed_system.py:314 Signature @property def firmware_memory(self): ... System().get_capabilities Show source in managed_system.py:350 returns: The system capabilities from Power. Signature def get_capabilities(self): ... System().get_capability Show source in managed_system.py:335 returns: The requested system capability from Power. Signature def get_capability(self, key): ... System().highest_compat_mode Show source in managed_system.py:362 This method returns the highest compatibility mode of the host. Signature def highest_compat_mode(self): ... System().host_ip_address Show source in managed_system.py:328 Signature @property def host_ip_address(self): ... System().max_aix_lnx_pmem_volumes Show source in managed_system.py:449 Signature @property def max_aix_lnx_pmem_volumes(self): ... System().max_os400_pmem_volumes Show source in managed_system.py:453 Signature @property def max_os400_pmem_volumes(self): ... System().max_pmem_volumes Show source in managed_system.py:441 Signature @property def max_pmem_volumes(self): ... System().max_procs_per_aix_linux_lpar Show source in managed_system.py:266 Signature @property def max_procs_per_aix_linux_lpar(self): ... System().max_procs_per_aix_linux_lpar Show source in managed_system.py:276 Signature @max_procs_per_aix_linux_lpar.setter def max_procs_per_aix_linux_lpar(self, value): ... System().max_sys_procs_limit Show source in managed_system.py:262 Signature @property def max_sys_procs_limit(self): ... System().max_sys_vcpus_limit Show source in managed_system.py:280 Signature @property def max_sys_vcpus_limit(self): ... System().max_vcpus_per_aix_linux_lpar Show source in managed_system.py:284 Signature @property def max_vcpus_per_aix_linux_lpar(self): ... System().max_vcpus_per_aix_linux_lpar Show source in managed_system.py:294 Signature @max_vcpus_per_aix_linux_lpar.setter def max_vcpus_per_aix_linux_lpar(self, value): ... System().max_vios_pmem_volumes Show source in managed_system.py:457 Signature @property def max_vios_pmem_volumes(self): ... System().memory_configurable Show source in managed_system.py:306 Signature @property def memory_configurable(self): ... System().memory_free Show source in managed_system.py:302 Signature @property def memory_free(self): ... System().memory_region_size Show source in managed_system.py:310 Signature @property def memory_region_size(self): ... System().memory_total Show source in managed_system.py:298 Signature @property def memory_total(self): ... System().metered_pool_id Show source in managed_system.py:429 Signature @property def metered_pool_id(self): ... System().migration_data Show source in managed_system.py:376 returns: The migration properties from PowerVM. This information should not be changed and should be treated as read only. Signature @property def migration_data(self): ... System().min_proc_units Show source in managed_system.py:250 Signature @property def min_proc_units(self): ... System().mtms Show source in managed_system.py:234 Signature @property def mtms(self): ... System().page_table_ratio Show source in managed_system.py:318 Signature @property def page_table_ratio(self): ... System().proc_compat_modes Show source in managed_system.py:354 List of strings containing the processor compatibility modes. This is a READ-ONLY list. Signature @property def proc_compat_modes(self): ... System().proc_units Show source in managed_system.py:246 Signature @property def proc_units(self): ... System().proc_units_avail Show source in managed_system.py:258 Signature @property def proc_units_avail(self): ... System().proc_units_configurable Show source in managed_system.py:254 Signature @property def proc_units_configurable(self): ... System().processor_is_throttled Show source in managed_system.py:437 Signature @property def processor_is_throttled(self): ... System().session_is_master Show source in managed_system.py:419 The master mode state of this managed system. Use pypowervm.tasks.master_mode.request_master to request master mode Returns True if the management node of this System's adapter.session is the master. Signature @property def session_is_master(self): ... System().supported_ibmi_console_codepage Show source in managed_system.py:433 Signature @property def supported_ibmi_console_codepage(self): ... System().supported_pmem_vol_devtypes Show source in managed_system.py:473 Signature @property def supported_pmem_vol_devtypes(self): ... System().system_name Show source in managed_system.py:230 Signature @property def system_name(self): ... System().system_state Show source in managed_system.py:242 Signature @property def system_state(self): ... System().vios_links Show source in managed_system.py:411 List of hrefs from AssociatedVirtualIOServers. This is a READ-ONLY list. Signature @property def vios_links(self): ...","title":"Managed System"},{"location":"pypowervm/wrappers/managed_system/#managed-system","text":"Pypowervm Index / Pypowervm / Wrappers / Managed System Auto-generated documentation for pypowervm.wrappers.managed_system module. Managed System ASIOConfig ASIOConfig().avail_wwpns ASIOConfig().io_slots ASIOConfig().sriov_adapters ASIOConfig().wwpn_prefix IOSlot IOSlot().bus_grp_required IOSlot().description IOSlot().drc_index IOSlot().drc_name IOSlot().dyn_reconfig_conn_index IOSlot().dyn_reconfig_conn_name IOSlot().feat_codes IOSlot().part_id IOSlot().part_name IOSlot().part_type IOSlot().part_uuid IOSlot().pci_class IOSlot().pci_dev_id IOSlot().pci_rev_id IOSlot().pci_revision_id IOSlot().pci_sub_dev_id IOSlot().pci_sub_vendor_id IOSlot().pci_subsys_dev_id IOSlot().pci_subsys_vendor_id IOSlot().pci_vendor_id System System().asio_config System().cur_pmem_volumes System().default_ppt_ratio System().dram_pmem_vol_blksize System().dram_pmem_vol_cursize System().dram_pmem_vol_size System().firmware_memory System().get_capabilities System().get_capability System().highest_compat_mode System().host_ip_address System().max_aix_lnx_pmem_volumes System().max_os400_pmem_volumes System().max_pmem_volumes System().max_procs_per_aix_linux_lpar System().max_procs_per_aix_linux_lpar System().max_sys_procs_limit System().max_sys_vcpus_limit System().max_vcpus_per_aix_linux_lpar System().max_vcpus_per_aix_linux_lpar System().max_vios_pmem_volumes System().memory_configurable System().memory_free System().memory_region_size System().memory_total System().metered_pool_id System().migration_data System().min_proc_units System().mtms System().page_table_ratio System().proc_compat_modes System().proc_units System().proc_units_avail System().proc_units_configurable System().processor_is_throttled System().session_is_master System().supported_ibmi_console_codepage System().supported_pmem_vol_devtypes System().system_name System().system_state System().vios_links","title":"Managed System"},{"location":"pypowervm/wrappers/managed_system/#asioconfig","text":"Show source in managed_system.py:479 The associated system IO configuration for this system.","title":"ASIOConfig"},{"location":"pypowervm/wrappers/managed_system/#signature","text":"class ASIOConfig(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#asioconfigavail_wwpns","text":"Show source in managed_system.py:482","title":"ASIOConfig().avail_wwpns"},{"location":"pypowervm/wrappers/managed_system/#signature_1","text":"@property def avail_wwpns(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#asioconfigio_slots","text":"Show source in managed_system.py:486","title":"ASIOConfig().io_slots"},{"location":"pypowervm/wrappers/managed_system/#signature_2","text":"@property def io_slots(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#asioconfigsriov_adapters","text":"Show source in managed_system.py:495","title":"ASIOConfig().sriov_adapters"},{"location":"pypowervm/wrappers/managed_system/#signature_3","text":"@property def sriov_adapters(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#asioconfigwwpn_prefix","text":"Show source in managed_system.py:491","title":"ASIOConfig().wwpn_prefix"},{"location":"pypowervm/wrappers/managed_system/#signature_4","text":"@property def wwpn_prefix(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslot","text":"Show source in managed_system.py:504 An I/O Slot represents a device bus on the system. It may contain a piece of hardware within it.","title":"IOSlot"},{"location":"pypowervm/wrappers/managed_system/#signature_5","text":"class IOSlot(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotbus_grp_required","text":"Show source in managed_system.py:510","title":"IOSlot().bus_grp_required"},{"location":"pypowervm/wrappers/managed_system/#signature_6","text":"@property def bus_grp_required(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotdescription","text":"Show source in managed_system.py:514","title":"IOSlot().description"},{"location":"pypowervm/wrappers/managed_system/#signature_7","text":"@property def description(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotdrc_index","text":"Show source in managed_system.py:604","title":"IOSlot().drc_index"},{"location":"pypowervm/wrappers/managed_system/#signature_8","text":"@property def drc_index(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotdrc_name","text":"Show source in managed_system.py:616","title":"IOSlot().drc_name"},{"location":"pypowervm/wrappers/managed_system/#signature_9","text":"@property def drc_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotdyn_reconfig_conn_index","text":"Show source in managed_system.py:608 Deprecated - use drc_index instead.","title":"IOSlot().dyn_reconfig_conn_index"},{"location":"pypowervm/wrappers/managed_system/#signature_10","text":"@property def dyn_reconfig_conn_index(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotdyn_reconfig_conn_name","text":"Show source in managed_system.py:620 Deprecated - use drc_name instead.","title":"IOSlot().dyn_reconfig_conn_name"},{"location":"pypowervm/wrappers/managed_system/#signature_11","text":"@property def dyn_reconfig_conn_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotfeat_codes","text":"Show source in managed_system.py:518","title":"IOSlot().feat_codes"},{"location":"pypowervm/wrappers/managed_system/#signature_12","text":"@property def feat_codes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpart_id","text":"Show source in managed_system.py:522 Short ID of the partition to which the slot is assigned. None if the slot is unassigned.","title":"IOSlot().part_id"},{"location":"pypowervm/wrappers/managed_system/#signature_13","text":"@property def part_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpart_name","text":"Show source in managed_system.py:538 String name of the partition to which the slot is assigned. None if the slot is unassigned.","title":"IOSlot().part_name"},{"location":"pypowervm/wrappers/managed_system/#signature_14","text":"@property def part_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpart_type","text":"Show source in managed_system.py:546 String type of the partition to which the slot is assigned. May be compared with base_partition.LPARType enum values. None if the slot is unassigned.","title":"IOSlot().part_type"},{"location":"pypowervm/wrappers/managed_system/#signature_15","text":"@property def part_type(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpart_uuid","text":"Show source in managed_system.py:530 UUID of the partition to which the slot is assigned. None if the slot is unassigned.","title":"IOSlot().part_uuid"},{"location":"pypowervm/wrappers/managed_system/#signature_16","text":"@property def part_uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpci_class","text":"Show source in managed_system.py:556","title":"IOSlot().pci_class"},{"location":"pypowervm/wrappers/managed_system/#signature_17","text":"@property def pci_class(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpci_dev_id","text":"Show source in managed_system.py:560","title":"IOSlot().pci_dev_id"},{"location":"pypowervm/wrappers/managed_system/#signature_18","text":"@property def pci_dev_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpci_rev_id","text":"Show source in managed_system.py:576","title":"IOSlot().pci_rev_id"},{"location":"pypowervm/wrappers/managed_system/#signature_19","text":"@property def pci_rev_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpci_revision_id","text":"Show source in managed_system.py:580 Deprecated - use pci_rev_id instead.","title":"IOSlot().pci_revision_id"},{"location":"pypowervm/wrappers/managed_system/#signature_20","text":"@property def pci_revision_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpci_sub_dev_id","text":"Show source in managed_system.py:568 Deprecated - use pci_subsys_dev_id instead.","title":"IOSlot().pci_sub_dev_id"},{"location":"pypowervm/wrappers/managed_system/#signature_21","text":"@property def pci_sub_dev_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpci_sub_vendor_id","text":"Show source in managed_system.py:596 Deprecated - use pci_subsys_vendor_id instead.","title":"IOSlot().pci_sub_vendor_id"},{"location":"pypowervm/wrappers/managed_system/#signature_22","text":"@property def pci_sub_vendor_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpci_subsys_dev_id","text":"Show source in managed_system.py:564","title":"IOSlot().pci_subsys_dev_id"},{"location":"pypowervm/wrappers/managed_system/#signature_23","text":"@property def pci_subsys_dev_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpci_subsys_vendor_id","text":"Show source in managed_system.py:592","title":"IOSlot().pci_subsys_vendor_id"},{"location":"pypowervm/wrappers/managed_system/#signature_24","text":"@property def pci_subsys_vendor_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#ioslotpci_vendor_id","text":"Show source in managed_system.py:588","title":"IOSlot().pci_vendor_id"},{"location":"pypowervm/wrappers/managed_system/#signature_25","text":"@property def pci_vendor_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#system","text":"Show source in managed_system.py:227 The PowerVM system that is being managed.","title":"System"},{"location":"pypowervm/wrappers/managed_system/#signature_26","text":"class System(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemasio_config","text":"Show source in managed_system.py:238","title":"System().asio_config"},{"location":"pypowervm/wrappers/managed_system/#signature_27","text":"@property def asio_config(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemcur_pmem_volumes","text":"Show source in managed_system.py:445","title":"System().cur_pmem_volumes"},{"location":"pypowervm/wrappers/managed_system/#signature_28","text":"@property def cur_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemdefault_ppt_ratio","text":"Show source in managed_system.py:322","title":"System().default_ppt_ratio"},{"location":"pypowervm/wrappers/managed_system/#signature_29","text":"@property def default_ppt_ratio(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemdram_pmem_vol_blksize","text":"Show source in managed_system.py:461","title":"System().dram_pmem_vol_blksize"},{"location":"pypowervm/wrappers/managed_system/#signature_30","text":"@property def dram_pmem_vol_blksize(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemdram_pmem_vol_cursize","text":"Show source in managed_system.py:469","title":"System().dram_pmem_vol_cursize"},{"location":"pypowervm/wrappers/managed_system/#signature_31","text":"@property def dram_pmem_vol_cursize(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemdram_pmem_vol_size","text":"Show source in managed_system.py:465","title":"System().dram_pmem_vol_size"},{"location":"pypowervm/wrappers/managed_system/#signature_32","text":"@property def dram_pmem_vol_size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemfirmware_memory","text":"Show source in managed_system.py:314","title":"System().firmware_memory"},{"location":"pypowervm/wrappers/managed_system/#signature_33","text":"@property def firmware_memory(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemget_capabilities","text":"Show source in managed_system.py:350 returns: The system capabilities from Power.","title":"System().get_capabilities"},{"location":"pypowervm/wrappers/managed_system/#signature_34","text":"def get_capabilities(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemget_capability","text":"Show source in managed_system.py:335 returns: The requested system capability from Power.","title":"System().get_capability"},{"location":"pypowervm/wrappers/managed_system/#signature_35","text":"def get_capability(self, key): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemhighest_compat_mode","text":"Show source in managed_system.py:362 This method returns the highest compatibility mode of the host.","title":"System().highest_compat_mode"},{"location":"pypowervm/wrappers/managed_system/#signature_36","text":"def highest_compat_mode(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemhost_ip_address","text":"Show source in managed_system.py:328","title":"System().host_ip_address"},{"location":"pypowervm/wrappers/managed_system/#signature_37","text":"@property def host_ip_address(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmax_aix_lnx_pmem_volumes","text":"Show source in managed_system.py:449","title":"System().max_aix_lnx_pmem_volumes"},{"location":"pypowervm/wrappers/managed_system/#signature_38","text":"@property def max_aix_lnx_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmax_os400_pmem_volumes","text":"Show source in managed_system.py:453","title":"System().max_os400_pmem_volumes"},{"location":"pypowervm/wrappers/managed_system/#signature_39","text":"@property def max_os400_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmax_pmem_volumes","text":"Show source in managed_system.py:441","title":"System().max_pmem_volumes"},{"location":"pypowervm/wrappers/managed_system/#signature_40","text":"@property def max_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmax_procs_per_aix_linux_lpar","text":"Show source in managed_system.py:266","title":"System().max_procs_per_aix_linux_lpar"},{"location":"pypowervm/wrappers/managed_system/#signature_41","text":"@property def max_procs_per_aix_linux_lpar(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmax_procs_per_aix_linux_lpar_1","text":"Show source in managed_system.py:276","title":"System().max_procs_per_aix_linux_lpar"},{"location":"pypowervm/wrappers/managed_system/#signature_42","text":"@max_procs_per_aix_linux_lpar.setter def max_procs_per_aix_linux_lpar(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmax_sys_procs_limit","text":"Show source in managed_system.py:262","title":"System().max_sys_procs_limit"},{"location":"pypowervm/wrappers/managed_system/#signature_43","text":"@property def max_sys_procs_limit(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmax_sys_vcpus_limit","text":"Show source in managed_system.py:280","title":"System().max_sys_vcpus_limit"},{"location":"pypowervm/wrappers/managed_system/#signature_44","text":"@property def max_sys_vcpus_limit(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmax_vcpus_per_aix_linux_lpar","text":"Show source in managed_system.py:284","title":"System().max_vcpus_per_aix_linux_lpar"},{"location":"pypowervm/wrappers/managed_system/#signature_45","text":"@property def max_vcpus_per_aix_linux_lpar(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmax_vcpus_per_aix_linux_lpar_1","text":"Show source in managed_system.py:294","title":"System().max_vcpus_per_aix_linux_lpar"},{"location":"pypowervm/wrappers/managed_system/#signature_46","text":"@max_vcpus_per_aix_linux_lpar.setter def max_vcpus_per_aix_linux_lpar(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmax_vios_pmem_volumes","text":"Show source in managed_system.py:457","title":"System().max_vios_pmem_volumes"},{"location":"pypowervm/wrappers/managed_system/#signature_47","text":"@property def max_vios_pmem_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmemory_configurable","text":"Show source in managed_system.py:306","title":"System().memory_configurable"},{"location":"pypowervm/wrappers/managed_system/#signature_48","text":"@property def memory_configurable(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmemory_free","text":"Show source in managed_system.py:302","title":"System().memory_free"},{"location":"pypowervm/wrappers/managed_system/#signature_49","text":"@property def memory_free(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmemory_region_size","text":"Show source in managed_system.py:310","title":"System().memory_region_size"},{"location":"pypowervm/wrappers/managed_system/#signature_50","text":"@property def memory_region_size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmemory_total","text":"Show source in managed_system.py:298","title":"System().memory_total"},{"location":"pypowervm/wrappers/managed_system/#signature_51","text":"@property def memory_total(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmetered_pool_id","text":"Show source in managed_system.py:429","title":"System().metered_pool_id"},{"location":"pypowervm/wrappers/managed_system/#signature_52","text":"@property def metered_pool_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmigration_data","text":"Show source in managed_system.py:376 returns: The migration properties from PowerVM. This information should not be changed and should be treated as read only.","title":"System().migration_data"},{"location":"pypowervm/wrappers/managed_system/#signature_53","text":"@property def migration_data(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmin_proc_units","text":"Show source in managed_system.py:250","title":"System().min_proc_units"},{"location":"pypowervm/wrappers/managed_system/#signature_54","text":"@property def min_proc_units(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemmtms","text":"Show source in managed_system.py:234","title":"System().mtms"},{"location":"pypowervm/wrappers/managed_system/#signature_55","text":"@property def mtms(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systempage_table_ratio","text":"Show source in managed_system.py:318","title":"System().page_table_ratio"},{"location":"pypowervm/wrappers/managed_system/#signature_56","text":"@property def page_table_ratio(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemproc_compat_modes","text":"Show source in managed_system.py:354 List of strings containing the processor compatibility modes. This is a READ-ONLY list.","title":"System().proc_compat_modes"},{"location":"pypowervm/wrappers/managed_system/#signature_57","text":"@property def proc_compat_modes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemproc_units","text":"Show source in managed_system.py:246","title":"System().proc_units"},{"location":"pypowervm/wrappers/managed_system/#signature_58","text":"@property def proc_units(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemproc_units_avail","text":"Show source in managed_system.py:258","title":"System().proc_units_avail"},{"location":"pypowervm/wrappers/managed_system/#signature_59","text":"@property def proc_units_avail(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemproc_units_configurable","text":"Show source in managed_system.py:254","title":"System().proc_units_configurable"},{"location":"pypowervm/wrappers/managed_system/#signature_60","text":"@property def proc_units_configurable(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemprocessor_is_throttled","text":"Show source in managed_system.py:437","title":"System().processor_is_throttled"},{"location":"pypowervm/wrappers/managed_system/#signature_61","text":"@property def processor_is_throttled(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemsession_is_master","text":"Show source in managed_system.py:419 The master mode state of this managed system. Use pypowervm.tasks.master_mode.request_master to request master mode","title":"System().session_is_master"},{"location":"pypowervm/wrappers/managed_system/#returns","text":"True if the management node of this System's adapter.session is the master.","title":"Returns"},{"location":"pypowervm/wrappers/managed_system/#signature_62","text":"@property def session_is_master(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemsupported_ibmi_console_codepage","text":"Show source in managed_system.py:433","title":"System().supported_ibmi_console_codepage"},{"location":"pypowervm/wrappers/managed_system/#signature_63","text":"@property def supported_ibmi_console_codepage(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemsupported_pmem_vol_devtypes","text":"Show source in managed_system.py:473","title":"System().supported_pmem_vol_devtypes"},{"location":"pypowervm/wrappers/managed_system/#signature_64","text":"@property def supported_pmem_vol_devtypes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemsystem_name","text":"Show source in managed_system.py:230","title":"System().system_name"},{"location":"pypowervm/wrappers/managed_system/#signature_65","text":"@property def system_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemsystem_state","text":"Show source in managed_system.py:242","title":"System().system_state"},{"location":"pypowervm/wrappers/managed_system/#signature_66","text":"@property def system_state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/managed_system/#systemvios_links","text":"Show source in managed_system.py:411 List of hrefs from AssociatedVirtualIOServers. This is a READ-ONLY list.","title":"System().vios_links"},{"location":"pypowervm/wrappers/managed_system/#signature_67","text":"@property def vios_links(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/","text":"ManagementConsole Pypowervm Index / Pypowervm / Wrappers / ManagementConsole Auto-generated documentation for pypowervm.wrappers.management_console module. ManagementConsole AuthorizedKey AuthorizedKey.bld AuthorizedKey().key AuthorizedKey().key ConsoleNetworkInterfaces ConsoleNetworkInterfaces().address ConsoleNetworkInterfaces().name ManagementConsole ManagementConsole().mtms ManagementConsole().name ManagementConsole().network_interfaces ManagementConsole().ssh_authorized_keys ManagementConsole().ssh_authorized_keys ManagementConsole().ssh_public_key NetworkInterfaces NetworkInterfaces().console_interface AuthorizedKey Show source in management_console.py:100 The Authorized Key wrapper. Signature class AuthorizedKey(ewrap.ElementWrapper): ... AuthorizedKey.bld Show source in management_console.py:103 Signature @classmethod def bld(cls, adapter, key): ... AuthorizedKey().key Show source in management_console.py:109 Signature @property def key(self): ... AuthorizedKey().key Show source in management_console.py:113 Signature @key.setter def key(self, val): ... ConsoleNetworkInterfaces Show source in management_console.py:129 The Console Network Interfaces wrapper. Signature class ConsoleNetworkInterfaces(ewrap.ElementWrapper): ... ConsoleNetworkInterfaces().address Show source in management_console.py:136 Signature @property def address(self): ... ConsoleNetworkInterfaces().name Show source in management_console.py:132 Signature @property def name(self): ... ManagementConsole Show source in management_console.py:59 The PowerVM ManagementConsole. This refers to the console that is managing PowerVM system. It's the one providing the REST API interface. Signature class ManagementConsole(ewrap.EntryWrapper): ... ManagementConsole().mtms Show source in management_console.py:69 Signature @property def mtms(self): ... ManagementConsole().name Show source in management_console.py:65 Signature @property def name(self): ... ManagementConsole().network_interfaces Show source in management_console.py:73 Signature @property def network_interfaces(self): ... ManagementConsole().ssh_authorized_keys Show source in management_console.py:81 Returns a list of keys. The returned tuple contains the keys as plain strings. Signature @property def ssh_authorized_keys(self): ... ManagementConsole().ssh_authorized_keys Show source in management_console.py:91 Sets the keys given a list of key strings. Signature @ssh_authorized_keys.setter def ssh_authorized_keys(self, keys): ... ManagementConsole().ssh_public_key Show source in management_console.py:77 Signature @property def ssh_public_key(self): ... NetworkInterfaces Show source in management_console.py:119 The Network Interfaces wrapper. Signature class NetworkInterfaces(ewrap.ElementWrapper): ... NetworkInterfaces().console_interface Show source in management_console.py:122 Signature @property def console_interface(self): ...","title":"ManagementConsole"},{"location":"pypowervm/wrappers/management_console/#managementconsole","text":"Pypowervm Index / Pypowervm / Wrappers / ManagementConsole Auto-generated documentation for pypowervm.wrappers.management_console module. ManagementConsole AuthorizedKey AuthorizedKey.bld AuthorizedKey().key AuthorizedKey().key ConsoleNetworkInterfaces ConsoleNetworkInterfaces().address ConsoleNetworkInterfaces().name ManagementConsole ManagementConsole().mtms ManagementConsole().name ManagementConsole().network_interfaces ManagementConsole().ssh_authorized_keys ManagementConsole().ssh_authorized_keys ManagementConsole().ssh_public_key NetworkInterfaces NetworkInterfaces().console_interface","title":"ManagementConsole"},{"location":"pypowervm/wrappers/management_console/#authorizedkey","text":"Show source in management_console.py:100 The Authorized Key wrapper.","title":"AuthorizedKey"},{"location":"pypowervm/wrappers/management_console/#signature","text":"class AuthorizedKey(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#authorizedkeybld","text":"Show source in management_console.py:103","title":"AuthorizedKey.bld"},{"location":"pypowervm/wrappers/management_console/#signature_1","text":"@classmethod def bld(cls, adapter, key): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#authorizedkeykey","text":"Show source in management_console.py:109","title":"AuthorizedKey().key"},{"location":"pypowervm/wrappers/management_console/#signature_2","text":"@property def key(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#authorizedkeykey_1","text":"Show source in management_console.py:113","title":"AuthorizedKey().key"},{"location":"pypowervm/wrappers/management_console/#signature_3","text":"@key.setter def key(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#consolenetworkinterfaces","text":"Show source in management_console.py:129 The Console Network Interfaces wrapper.","title":"ConsoleNetworkInterfaces"},{"location":"pypowervm/wrappers/management_console/#signature_4","text":"class ConsoleNetworkInterfaces(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#consolenetworkinterfacesaddress","text":"Show source in management_console.py:136","title":"ConsoleNetworkInterfaces().address"},{"location":"pypowervm/wrappers/management_console/#signature_5","text":"@property def address(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#consolenetworkinterfacesname","text":"Show source in management_console.py:132","title":"ConsoleNetworkInterfaces().name"},{"location":"pypowervm/wrappers/management_console/#signature_6","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#managementconsole_1","text":"Show source in management_console.py:59 The PowerVM ManagementConsole. This refers to the console that is managing PowerVM system. It's the one providing the REST API interface.","title":"ManagementConsole"},{"location":"pypowervm/wrappers/management_console/#signature_7","text":"class ManagementConsole(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#managementconsolemtms","text":"Show source in management_console.py:69","title":"ManagementConsole().mtms"},{"location":"pypowervm/wrappers/management_console/#signature_8","text":"@property def mtms(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#managementconsolename","text":"Show source in management_console.py:65","title":"ManagementConsole().name"},{"location":"pypowervm/wrappers/management_console/#signature_9","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#managementconsolenetwork_interfaces","text":"Show source in management_console.py:73","title":"ManagementConsole().network_interfaces"},{"location":"pypowervm/wrappers/management_console/#signature_10","text":"@property def network_interfaces(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#managementconsolessh_authorized_keys","text":"Show source in management_console.py:81 Returns a list of keys. The returned tuple contains the keys as plain strings.","title":"ManagementConsole().ssh_authorized_keys"},{"location":"pypowervm/wrappers/management_console/#signature_11","text":"@property def ssh_authorized_keys(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#managementconsolessh_authorized_keys_1","text":"Show source in management_console.py:91 Sets the keys given a list of key strings.","title":"ManagementConsole().ssh_authorized_keys"},{"location":"pypowervm/wrappers/management_console/#signature_12","text":"@ssh_authorized_keys.setter def ssh_authorized_keys(self, keys): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#managementconsolessh_public_key","text":"Show source in management_console.py:77","title":"ManagementConsole().ssh_public_key"},{"location":"pypowervm/wrappers/management_console/#signature_13","text":"@property def ssh_public_key(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#networkinterfaces","text":"Show source in management_console.py:119 The Network Interfaces wrapper.","title":"NetworkInterfaces"},{"location":"pypowervm/wrappers/management_console/#signature_14","text":"class NetworkInterfaces(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/management_console/#networkinterfacesconsole_interface","text":"Show source in management_console.py:122","title":"NetworkInterfaces().console_interface"},{"location":"pypowervm/wrappers/management_console/#signature_15","text":"@property def console_interface(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/","text":"Monitor Pypowervm Index / Pypowervm / Wrappers / Monitor Auto-generated documentation for pypowervm.wrappers.monitor module. Attributes PREFERENCES - Constants that make up the http path: 'preferences' Monitor LTMMetrics MonitorMetrics MonitorMetrics().category MonitorMetrics().id MonitorMetrics().link MonitorMetrics().published MonitorMetrics().published_datetime MonitorMetrics().title MonitorMetrics().updated MonitorMetrics().updated_datetime MonitorMetrics.wrap PcmPref PcmPref().aggregation_enabled PcmPref().aggregation_enabled PcmPref().compute_ltm_enabled PcmPref().compute_ltm_enabled PcmPref().ltm_enabled PcmPref().ltm_enabled PcmPref().stm_enabled PcmPref().stm_enabled PcmPref().system_name STMMetrics LTMMetrics Show source in monitor.py:184 A pseudo wrapper for Long Term Monitor metrics. The standard pattern of wrapping a response or entry and accessing properties for the data can be used, even though this isn't a traditional EntryWrapper. Signature class LTMMetrics(MonitorMetrics): ... See also MonitorMetrics MonitorMetrics Show source in monitor.py:108 A pseudo wrapper for Monitor metrics. The standard pattern of wrapping a response or entry and accessing properties for the data can be used, even though this isn't a traditional EntryWrapper. Signature class MonitorMetrics(object): def __init__(self, entry): ... MonitorMetrics().category Show source in monitor.py:175 Signature @property def category(self): ... MonitorMetrics().id Show source in monitor.py:151 Signature @property def id(self): ... MonitorMetrics().link Show source in monitor.py:179 Signature @property def link(self): ... MonitorMetrics().published Show source in monitor.py:155 Signature @property def published(self): ... MonitorMetrics().published_datetime Show source in monitor.py:159 Signature @property def published_datetime(self): ... MonitorMetrics().title Show source in monitor.py:163 Signature @property def title(self): ... MonitorMetrics().updated Show source in monitor.py:167 Signature @property def updated(self): ... MonitorMetrics().updated_datetime Show source in monitor.py:171 Signature @property def updated_datetime(self): ... MonitorMetrics.wrap Show source in monitor.py:144 Signature @classmethod def wrap(cls, response_or_entry): ... PcmPref Show source in monitor.py:55 Wraps the Performance and Capacity Monitoring preferences. Signature class PcmPref(ewrap.EntryWrapper): ... PcmPref().aggregation_enabled Show source in monitor.py:72 Metrics Aggregation. Signature @property def aggregation_enabled(self): ... PcmPref().aggregation_enabled Show source in monitor.py:77 Metrics Aggregation. Signature @aggregation_enabled.setter def aggregation_enabled(self, value): ... PcmPref().compute_ltm_enabled Show source in monitor.py:96 Compute Long Term Monitoring. Signature @property def compute_ltm_enabled(self): ... PcmPref().compute_ltm_enabled Show source in monitor.py:101 Compute Long Term Monitoring. Signature @compute_ltm_enabled.setter def compute_ltm_enabled(self, value): ... PcmPref().ltm_enabled Show source in monitor.py:62 Long Term Monitoring. Signature @property def ltm_enabled(self): ... PcmPref().ltm_enabled Show source in monitor.py:67 Long Term Monitoring. Signature @ltm_enabled.setter def ltm_enabled(self, value): ... PcmPref().stm_enabled Show source in monitor.py:82 Short Term Monitoring. Signature @property def stm_enabled(self): ... PcmPref().stm_enabled Show source in monitor.py:87 Short Term Monitoring. Short Term metrics can affect the performance of workloads. Not recommended for production workload. Signature @stm_enabled.setter def stm_enabled(self, value): ... PcmPref().system_name Show source in monitor.py:58 Signature @property def system_name(self): ... STMMetrics Show source in monitor.py:194 A pseudo wrapper for Short Term Monitor metrics. The standard pattern of wrapping a response or entry and accessing properties for the data can be used, even though this isn't a traditional EntryWrapper. Signature class STMMetrics(MonitorMetrics): ... See also MonitorMetrics","title":"Monitor"},{"location":"pypowervm/wrappers/monitor/#monitor","text":"Pypowervm Index / Pypowervm / Wrappers / Monitor Auto-generated documentation for pypowervm.wrappers.monitor module.","title":"Monitor"},{"location":"pypowervm/wrappers/monitor/#attributes","text":"PREFERENCES - Constants that make up the http path: 'preferences' Monitor LTMMetrics MonitorMetrics MonitorMetrics().category MonitorMetrics().id MonitorMetrics().link MonitorMetrics().published MonitorMetrics().published_datetime MonitorMetrics().title MonitorMetrics().updated MonitorMetrics().updated_datetime MonitorMetrics.wrap PcmPref PcmPref().aggregation_enabled PcmPref().aggregation_enabled PcmPref().compute_ltm_enabled PcmPref().compute_ltm_enabled PcmPref().ltm_enabled PcmPref().ltm_enabled PcmPref().stm_enabled PcmPref().stm_enabled PcmPref().system_name STMMetrics","title":"Attributes"},{"location":"pypowervm/wrappers/monitor/#ltmmetrics","text":"Show source in monitor.py:184 A pseudo wrapper for Long Term Monitor metrics. The standard pattern of wrapping a response or entry and accessing properties for the data can be used, even though this isn't a traditional EntryWrapper.","title":"LTMMetrics"},{"location":"pypowervm/wrappers/monitor/#signature","text":"class LTMMetrics(MonitorMetrics): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#see-also","text":"MonitorMetrics","title":"See also"},{"location":"pypowervm/wrappers/monitor/#monitormetrics","text":"Show source in monitor.py:108 A pseudo wrapper for Monitor metrics. The standard pattern of wrapping a response or entry and accessing properties for the data can be used, even though this isn't a traditional EntryWrapper.","title":"MonitorMetrics"},{"location":"pypowervm/wrappers/monitor/#signature_1","text":"class MonitorMetrics(object): def __init__(self, entry): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#monitormetricscategory","text":"Show source in monitor.py:175","title":"MonitorMetrics().category"},{"location":"pypowervm/wrappers/monitor/#signature_2","text":"@property def category(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#monitormetricsid","text":"Show source in monitor.py:151","title":"MonitorMetrics().id"},{"location":"pypowervm/wrappers/monitor/#signature_3","text":"@property def id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#monitormetricslink","text":"Show source in monitor.py:179","title":"MonitorMetrics().link"},{"location":"pypowervm/wrappers/monitor/#signature_4","text":"@property def link(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#monitormetricspublished","text":"Show source in monitor.py:155","title":"MonitorMetrics().published"},{"location":"pypowervm/wrappers/monitor/#signature_5","text":"@property def published(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#monitormetricspublished_datetime","text":"Show source in monitor.py:159","title":"MonitorMetrics().published_datetime"},{"location":"pypowervm/wrappers/monitor/#signature_6","text":"@property def published_datetime(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#monitormetricstitle","text":"Show source in monitor.py:163","title":"MonitorMetrics().title"},{"location":"pypowervm/wrappers/monitor/#signature_7","text":"@property def title(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#monitormetricsupdated","text":"Show source in monitor.py:167","title":"MonitorMetrics().updated"},{"location":"pypowervm/wrappers/monitor/#signature_8","text":"@property def updated(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#monitormetricsupdated_datetime","text":"Show source in monitor.py:171","title":"MonitorMetrics().updated_datetime"},{"location":"pypowervm/wrappers/monitor/#signature_9","text":"@property def updated_datetime(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#monitormetricswrap","text":"Show source in monitor.py:144","title":"MonitorMetrics.wrap"},{"location":"pypowervm/wrappers/monitor/#signature_10","text":"@classmethod def wrap(cls, response_or_entry): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#pcmpref","text":"Show source in monitor.py:55 Wraps the Performance and Capacity Monitoring preferences.","title":"PcmPref"},{"location":"pypowervm/wrappers/monitor/#signature_11","text":"class PcmPref(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#pcmprefaggregation_enabled","text":"Show source in monitor.py:72 Metrics Aggregation.","title":"PcmPref().aggregation_enabled"},{"location":"pypowervm/wrappers/monitor/#signature_12","text":"@property def aggregation_enabled(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#pcmprefaggregation_enabled_1","text":"Show source in monitor.py:77 Metrics Aggregation.","title":"PcmPref().aggregation_enabled"},{"location":"pypowervm/wrappers/monitor/#signature_13","text":"@aggregation_enabled.setter def aggregation_enabled(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#pcmprefcompute_ltm_enabled","text":"Show source in monitor.py:96 Compute Long Term Monitoring.","title":"PcmPref().compute_ltm_enabled"},{"location":"pypowervm/wrappers/monitor/#signature_14","text":"@property def compute_ltm_enabled(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#pcmprefcompute_ltm_enabled_1","text":"Show source in monitor.py:101 Compute Long Term Monitoring.","title":"PcmPref().compute_ltm_enabled"},{"location":"pypowervm/wrappers/monitor/#signature_15","text":"@compute_ltm_enabled.setter def compute_ltm_enabled(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#pcmprefltm_enabled","text":"Show source in monitor.py:62 Long Term Monitoring.","title":"PcmPref().ltm_enabled"},{"location":"pypowervm/wrappers/monitor/#signature_16","text":"@property def ltm_enabled(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#pcmprefltm_enabled_1","text":"Show source in monitor.py:67 Long Term Monitoring.","title":"PcmPref().ltm_enabled"},{"location":"pypowervm/wrappers/monitor/#signature_17","text":"@ltm_enabled.setter def ltm_enabled(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#pcmprefstm_enabled","text":"Show source in monitor.py:82 Short Term Monitoring.","title":"PcmPref().stm_enabled"},{"location":"pypowervm/wrappers/monitor/#signature_18","text":"@property def stm_enabled(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#pcmprefstm_enabled_1","text":"Show source in monitor.py:87 Short Term Monitoring. Short Term metrics can affect the performance of workloads. Not recommended for production workload.","title":"PcmPref().stm_enabled"},{"location":"pypowervm/wrappers/monitor/#signature_19","text":"@stm_enabled.setter def stm_enabled(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#pcmprefsystem_name","text":"Show source in monitor.py:58","title":"PcmPref().system_name"},{"location":"pypowervm/wrappers/monitor/#signature_20","text":"@property def system_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#stmmetrics","text":"Show source in monitor.py:194 A pseudo wrapper for Short Term Monitor metrics. The standard pattern of wrapping a response or entry and accessing properties for the data can be used, even though this isn't a traditional EntryWrapper.","title":"STMMetrics"},{"location":"pypowervm/wrappers/monitor/#signature_21","text":"class STMMetrics(MonitorMetrics): ...","title":"Signature"},{"location":"pypowervm/wrappers/monitor/#see-also_1","text":"MonitorMetrics","title":"See also"},{"location":"pypowervm/wrappers/mtms/","text":"MTMS Pypowervm Index / Pypowervm / Wrappers / MTMS Auto-generated documentation for pypowervm.wrappers.mtms module. Attributes MTMS_ROOT - MTMS XPath constants: 'MachineTypeModelAndSerialNumber' MTMS MTMS MTMS.bld MTMS().machine_type MTMS().machine_type MTMS().model MTMS().model MTMS().mtms_str MTMS().serial MTMS().serial MTMS Show source in mtms.py:27 The Machine Type, Model and Serial Number wrapper. Signature class MTMS(ewrap.ElementWrapper): ... MTMS.bld Show source in mtms.py:30 Creates a new MTMS ElementWrapper. If mtms_str is specified, it is parsed first. If machine_type, model, and/or serial is specified, their values are used, overriding any parsed values from mtms_str. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) MTMS().mtms_str - String representation of Machine Type, Model, and Serial Number. The format is Machine Type - Model Number * Serial Example: 8247-22L*1234567 Signature @classmethod def bld(cls, adapter, mtms_str): ... MTMS().machine_type Show source in mtms.py:56 Signature @property def machine_type(self): ... MTMS().machine_type Show source in mtms.py:60 Signature @machine_type.setter def machine_type(self, mt): ... MTMS().model Show source in mtms.py:64 Signature @property def model(self): ... MTMS().model Show source in mtms.py:68 Signature @model.setter def model(self, md): ... MTMS().mtms_str Show source in mtms.py:80 Builds a string representation of the MTMS. Does not override default str as that is useful for debug purposes. Signature @property def mtms_str(self): ... MTMS().serial Show source in mtms.py:72 Signature @property def serial(self): ... MTMS().serial Show source in mtms.py:76 Signature @serial.setter def serial(self, sn): ...","title":"MTMS"},{"location":"pypowervm/wrappers/mtms/#mtms","text":"Pypowervm Index / Pypowervm / Wrappers / MTMS Auto-generated documentation for pypowervm.wrappers.mtms module.","title":"MTMS"},{"location":"pypowervm/wrappers/mtms/#attributes","text":"MTMS_ROOT - MTMS XPath constants: 'MachineTypeModelAndSerialNumber' MTMS MTMS MTMS.bld MTMS().machine_type MTMS().machine_type MTMS().model MTMS().model MTMS().mtms_str MTMS().serial MTMS().serial","title":"Attributes"},{"location":"pypowervm/wrappers/mtms/#mtms_1","text":"Show source in mtms.py:27 The Machine Type, Model and Serial Number wrapper.","title":"MTMS"},{"location":"pypowervm/wrappers/mtms/#signature","text":"class MTMS(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/mtms/#mtmsbld","text":"Show source in mtms.py:30 Creates a new MTMS ElementWrapper. If mtms_str is specified, it is parsed first. If machine_type, model, and/or serial is specified, their values are used, overriding any parsed values from mtms_str.","title":"MTMS.bld"},{"location":"pypowervm/wrappers/mtms/#arguments","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) MTMS().mtms_str - String representation of Machine Type, Model, and Serial Number. The format is Machine Type - Model Number * Serial Example: 8247-22L*1234567","title":"Arguments"},{"location":"pypowervm/wrappers/mtms/#signature_1","text":"@classmethod def bld(cls, adapter, mtms_str): ...","title":"Signature"},{"location":"pypowervm/wrappers/mtms/#mtmsmachine_type","text":"Show source in mtms.py:56","title":"MTMS().machine_type"},{"location":"pypowervm/wrappers/mtms/#signature_2","text":"@property def machine_type(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/mtms/#mtmsmachine_type_1","text":"Show source in mtms.py:60","title":"MTMS().machine_type"},{"location":"pypowervm/wrappers/mtms/#signature_3","text":"@machine_type.setter def machine_type(self, mt): ...","title":"Signature"},{"location":"pypowervm/wrappers/mtms/#mtmsmodel","text":"Show source in mtms.py:64","title":"MTMS().model"},{"location":"pypowervm/wrappers/mtms/#signature_4","text":"@property def model(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/mtms/#mtmsmodel_1","text":"Show source in mtms.py:68","title":"MTMS().model"},{"location":"pypowervm/wrappers/mtms/#signature_5","text":"@model.setter def model(self, md): ...","title":"Signature"},{"location":"pypowervm/wrappers/mtms/#mtmsmtms_str","text":"Show source in mtms.py:80 Builds a string representation of the MTMS. Does not override default str as that is useful for debug purposes.","title":"MTMS().mtms_str"},{"location":"pypowervm/wrappers/mtms/#signature_6","text":"@property def mtms_str(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/mtms/#mtmsserial","text":"Show source in mtms.py:72","title":"MTMS().serial"},{"location":"pypowervm/wrappers/mtms/#signature_7","text":"@property def serial(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/mtms/#mtmsserial_1","text":"Show source in mtms.py:76","title":"MTMS().serial"},{"location":"pypowervm/wrappers/mtms/#signature_8","text":"@serial.setter def serial(self, sn): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/","text":"Network Pypowervm Index / Pypowervm / Wrappers / Network Auto-generated documentation for pypowervm.wrappers.network module. Network CNA CNA.bld CNA().configured_mtu CNA().configured_mtu CNA().create CNA().dev_name CNA().enabled CNA().enabled CNA().gateway CNA().ip_address CNA().is_tagged_vlan_supported CNA().is_tagged_vlan_supported CNA().is_trunk CNA().loc_code CNA().lpar_id CNA().mac CNA().mac CNA().ovs_bridge CNA().ovs_bridge CNA().ovs_ext_ids CNA().ovs_ext_ids CNA().pvid CNA().pvid CNA().slot CNA().subnet_mask CNA().tagged_vlans CNA().tagged_vlans CNA().trunk_pri CNA().vsi_type_id CNA().vsi_type_manager_id CNA().vsi_type_version CNA().vswitch_id CNA().vswitch_uri CNA().vswitch_uri EthernetBackingDevice EthernetBackingDevice().adapter_id EthernetBackingDevice.bld EthernetBackingDevice().dev_name HAMode LoadGroup LoadGroup.bld LoadGroup().pvid LoadGroup().tagged_vlans LoadGroup().trunk_adapters LoadGroup().trunk_adapters LoadGroup().vnet_uri_list LoadGroup().vnet_uri_list LoadGroup.wrap NetBridge NetBridge().arbitrary_pvids NetBridge.bld NetBridge().control_channel_id NetBridge().list_vlans NetBridge().load_balance NetBridge().load_balance NetBridge().load_grps NetBridge().load_grps NetBridge().pvid NetBridge().seas NetBridge().seas NetBridge().supports_vlan NetBridge().vnet_uri_list NetBridge().vswitch_id SEA SEA().addl_adpts SEA().addl_adpts SEA().backing_device SEA.bld SEA().configuration_state SEA().contains_device SEA().control_channel SEA().dev_name SEA().ha_mode SEA().is_primary SEA().primary_adpt SEA().pvid SEA().vio_uri SEAState TrunkAdapter TrunkAdapter().associated_vswitch_uri TrunkAdapter.bld TrunkAdapter().dev_name TrunkAdapter().has_tag_support TrunkAdapter().has_tag_support TrunkAdapter().loc_code TrunkAdapter().pvid TrunkAdapter().pvid TrunkAdapter().tagged_vlans TrunkAdapter().tagged_vlans TrunkAdapter().trunk_pri TrunkAdapter().varied_on TrunkAdapter().vios_id TrunkAdapter().virtual_slot_number TrunkAdapter().vswitch_id VNet VNet().associated_switch_uri VNet().associated_switch_uri VNet.bld VNet().name VNet().name VNet().tagged VNet().tagged VNet().vlan VNet().vlan VNet().vswitch_id VSwitch VSwitch.bld VSwitch().mode VSwitch().mode VSwitch().name VSwitch().name VSwitch().switch_id VSwitch().vnet_uri_list VSwitch().vnet_uri_list VSwitchMode CNA Show source in network.py:1035 Wrapper object for ClientNetworkAdapter schema. Signature class CNA(ewrap.EntryWrapper): ... CNA.bld Show source in network.py:1038 Creates a fresh CNA EntryWrapper. This is used when creating a new CNA for a partition. This can be PUT to LogicalPartition/ /ClientNetworkAdapter or to VirtualIOServer/ /ClientNetworkAdapter. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) CNA().pvid - The Primary VLAN ID to use. vswitch_href - The URI that points to the Virtual Switch that will support this adapter. slot_num - The Slot on the Client LPAR that should be used. This defaults to 'None', which means the next available high slot will be used (the API will attempt to assign the next available slot number that's higher than all the existing assigned slot numbers. mac_addr - Optional user specified mac address to use. If left as None, the system will generate one. addl_tagged_vlans - A set of additional tagged VLANs that can be passed through this adapter (with client VLAN adapters). Input should be a list of int (or int string) Example: [51, 52, 53] Note: The limit is ~18 additional VLANs CNA().trunk_pri - Optional TrunkPriority integer that, if specified, will create this wrapper as a trunk. CNA().dev_name - (Optional, Default: None) Can only be set if the CNA is being created against the Management VM. Can be used to specify what the device name should be for the CNA on the Management VM. Ignored for all other LPAR types. CNA().ovs_bridge - (Optional, Default: None) If hosting through mgmt partition, this attribute specifies which Open vSwitch to connect to. This assumes that Open vSwitch is installed and active on the mgmt partition. CNA().ovs_ext_ids - (Optional, Default: None) A comma-delimited list of key=value pairs in string format. Ex. iface-id=abc123,iface-status=active This sets a dictionary of values on the Interface element within Open vSwitch. This assumes that Open vSwitch is installed and active on the mgmt partition. CNA().configured_mtu - (Optional, Default: None) Sets the MTU on the adapter. May only be valid if adapter is being created against mgmt partition. Returns A CNA EntryWrapper that can be used for create. Signature @classmethod def bld( cls, adapter, pvid, vswitch_href, slot_num=None, mac_addr=None, addl_tagged_vlans=None, trunk_pri=None, dev_name=None, ovs_bridge=None, ovs_ext_ids=None, configured_mtu=None, ): ... CNA().configured_mtu Show source in network.py:1359 The MTU of the adapter. May only be valid if adapter is being created against mgmt partition. Signature @property def configured_mtu(self): ... CNA().configured_mtu Show source in network.py:1367 Signature @configured_mtu.setter def configured_mtu(self, value): ... CNA().create Show source in network.py:1134 Override to ensure default slot setting is correct. Create the CNA as specified except : If UseNextAvailableHighSlot is True (i.e. slot number was not given); and the parent is a VIOS or the management partition; then change to UseNextAvailableSlot (not High). This is because VIOS and the management partition don't care about slot ordering, and their longevity increases the probability of running out of slot space if we use 'High'. Arguments parent_type - See superclass. parent_uuid - See superclass. timeout - See superclass. parent - See superclass. Signature def create(self, parent_type=None, parent_uuid=None, timeout=-1, parent=None, **kwargs): ... CNA().dev_name Show source in network.py:1320 Returns the name of the device (if available). If RMC is down, will not be available. Signature @property def dev_name(self): ... CNA().enabled Show source in network.py:1252 Returns the enabled state (boolean value). A CNA is always created enabled=true. However, certain migration operations of an LPAR (ex. migration via OpenStack when using Open vSwitch) will cause the client's CNA to be disabled. This method can be used to check the state of the adapter. Signature @property def enabled(self): ... CNA().enabled Show source in network.py:1263 Signature @enabled.setter def enabled(self, new_val): ... CNA().gateway Show source in network.py:1417 Returns the gateway of the network interface. Typical format would be: 10.0.0.1 (IPv4) and cafe::1 (IPv6) or other forms of IPv6 address Signature @ewrap.Wrapper.xag_property(c.XAG.ADV) def gateway(self): ... CNA().ip_address Show source in network.py:1397 Returns the IP Address of the network interface. Typical format would be: 255.255.255.255 (IPv4) and ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff (IPv6) or other short forms of IPv6 address Signature @ewrap.Wrapper.xag_property(c.XAG.ADV) def ip_address(self): ... CNA().is_tagged_vlan_supported Show source in network.py:1295 Returns if addl tagged VLANs are supported (bool value). Signature @property def is_tagged_vlan_supported(self): ... CNA().is_tagged_vlan_supported Show source in network.py:1300 Parameter new_val is a bool (True or False). Signature @is_tagged_vlan_supported.setter def is_tagged_vlan_supported(self, new_val): ... CNA().is_trunk Show source in network.py:1349 Returns if this adapter was created with a trunk priority. If the adapter was created without a trunk priority, it is just a client network adapter. However, if it was given a trunk priority on creation, it is a wrapper for a trunk adapter. Signature @property def is_trunk(self): ... CNA().loc_code Show source in network.py:1268 The device's location code. Signature @property def loc_code(self): ... CNA().lpar_id Show source in network.py:1187 Returns the Local Partition ID for this adapter. Signature @property def lpar_id(self): ... CNA().mac Show source in network.py:1214 Returns the Mac Address for the adapter. Typical format would be: AABBCCDDEEFF The API returns a format with no colons and is upper cased. Signature @property def mac(self): ... CNA().mac Show source in network.py:1238 Signature @mac.setter def mac(self, new_val): ... CNA().ovs_bridge Show source in network.py:1371 The Open vSwitch bridge it is connected to. Otherwise None. Signature @property def ovs_bridge(self): ... CNA().ovs_bridge Show source in network.py:1376 Signature @ovs_bridge.setter def ovs_bridge(self, value): ... CNA().ovs_ext_ids Show source in network.py:1380 If connected to an Open vSwitch, returns the external ids. This is a comma-delimited list of key=value pairs. Ex: 'iface-id=123asdf,iface-status=active' This maps directly to the Open vSwitch Interface object's 'external_id' field. Signature @property def ovs_ext_ids(self): ... CNA().ovs_ext_ids Show source in network.py:1393 Signature @ovs_ext_ids.setter def ovs_ext_ids(self, value): ... CNA().pvid Show source in network.py:1243 Returns the Port VLAN ID (int value). Signature @property def pvid(self): ... CNA().pvid Show source in network.py:1248 Signature @pvid.setter def pvid(self, new_val): ... CNA().slot Show source in network.py:1180 Signature @property def slot(self): ... CNA().subnet_mask Show source in network.py:1407 Returns the subnet mask of the network interface. Typical format would be: 255.255.255.0 (IPv4) and ffff:ffff:ffff:ffff:: (IPv6) or other forms of IPv6 address Signature @ewrap.Wrapper.xag_property(c.XAG.ADV) def subnet_mask(self): ... CNA().tagged_vlans Show source in network.py:1273 Returns a list of additional VLANs on this adapter. Only valid if tagged vlan support is on. Signature @property def tagged_vlans(self): ... CNA().tagged_vlans Show source in network.py:1290 Signature @tagged_vlans.setter def tagged_vlans(self, new_list): ... CNA().trunk_pri Show source in network.py:1338 Returns the Trunk Priority for the adapter. Returns None if this is not a Trunk Adapter, priority otherwise. Signature @property def trunk_pri(self): ... CNA().vsi_type_id Show source in network.py:1223 Returns the virtual station interface type id. Signature @property def vsi_type_id(self): ... CNA().vsi_type_manager_id Show source in network.py:1233 Returns the virtual station interface manager id. Signature @property def vsi_type_manager_id(self): ... CNA().vsi_type_version Show source in network.py:1228 Returns the virtual station interface version. Signature @property def vsi_type_version(self): ... CNA().vswitch_id Show source in network.py:1315 Returns the ID (typically 0-15) for the virtual switch. Signature @property def vswitch_id(self): ... CNA().vswitch_uri Show source in network.py:1306 Returns the URI for the associated vSwitch. Signature @property def vswitch_uri(self): ... CNA().vswitch_uri Show source in network.py:1311 Signature @vswitch_uri.setter def vswitch_uri(self, new_val): ... EthernetBackingDevice Show source in network.py:1430 Represents the SEA EthernetBackingDevice. Signature class EthernetBackingDevice(ewrap.ElementWrapper): ... EthernetBackingDevice().adapter_id Show source in network.py:1457 Signature @property def adapter_id(self): ... EthernetBackingDevice.bld Show source in network.py:1433 Creates the EthernetBackingDevice element. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) EthernetBackingDevice().dev_name - The device name (e.g. eth0). Returns The EthernetBackingDevice element for SEAs. Signature @classmethod def bld(cls, adapter, dev_name): ... EthernetBackingDevice().dev_name Show source in network.py:1450 Signature @property def dev_name(self): ... HAMode Show source in network.py:185 Signature class HAMode(object): ... LoadGroup Show source in network.py:859 Load Group (how the I/O load should be distributed) for a Network Bridge. If using failover or load balancing, then the Load Group will have pairs of Trunk Adapters, each with their own unique Trunk Priority. Signature class LoadGroup(ewrap.ElementWrapper): ... LoadGroup.bld Show source in network.py:866 Create the LoadGroup element that can be used for a create operation. This is used when adding a Load Group to a NetBridge. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) LoadGroup().pvid - The primary VLAN ID (ex. 1) for the Load Group. vnet_uris - The virtual network URI list (mapping to each additional VLAN/vswitch combo). Returns A new LoadGroup ElementWrapper that represents the new LoadGroup. Signature @classmethod def bld(cls, adapter, pvid, vnet_uris): ... LoadGroup().pvid Show source in network.py:893 Returns the Primary VLAN ID of the Load Group. Signature @property def pvid(self): ... LoadGroup().tagged_vlans Show source in network.py:957 The VLANs supported by this Load Group. Does not include PVID. Signature @property def tagged_vlans(self): ... LoadGroup().trunk_adapters Show source in network.py:901 Returns the Trunk Adapters for the Load Group. There is either one (no redundancy/wrap balancing) or two (typically the case in a multi VIOS scenario). Returns list of TrunkAdapter objects. Signature @property def trunk_adapters(self): ... LoadGroup().trunk_adapters Show source in network.py:913 Signature @trunk_adapters.setter def trunk_adapters(self, new_list): ... LoadGroup().vnet_uri_list Show source in network.py:917 Returns a list of the Virtual Network URIs. If the vnet_aware trait (see traits.py) is set, then the addition of VLANs is driven via virtual networks rather than straight VLAN modification. This uri list is what drives the modification. If the trait is set to false, then the modification should be driven via the trunk adapters on the SEA directly. This list will also be empty. The task classes (cna.py and network_bridger.py) should abstract the user away from these deviations in traits. Signature @property def vnet_uri_list(self): ... LoadGroup().vnet_uri_list Show source in network.py:935 Signature @vnet_uri_list.setter def vnet_uri_list(self, new_list): ... LoadGroup.wrap Show source in network.py:884 Signature @classmethod def wrap(cls, element, **kwargs): ... NetBridge Show source in network.py:299 Wrapper object for the NetBridge entry. A NetworkBridge represents an aggregate entity comprising Shared Ethernet Adapters. If Failover or Load-Balancing is in use, the Network Bridge will have two identically structured Shared Ethernet Adapters belonging to different Virtual I/O Servers. Signature class NetBridge(ewrap.EntryWrapper): ... NetBridge().arbitrary_pvids Show source in network.py:436 Lists all of the network bridges' arbitrary PVIDs. An arbitrary PVID is a 'primary VLAN ID' attached to an additional Load Group or Trunk Adapter. These typically do not send traffic through them, and are placeholder VLANs required by the backing 'additional' Trunk Adapters. Returns List of arbitrary PVIDs Signature @property def arbitrary_pvids(self): ... NetBridge.bld Show source in network.py:308 Create the NetBridge entry that can be used for a create operation. This is used when creating a NetBridge. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) NetBridge().pvid - The primary VLAN ID (ex. 1) for the Network Bridge. vios_to_backing_adpts - An argument containing a list of tuples between VIOS href and the VIOS backing trunk adapter names for 1 or 2 VIOS servers, depending whether failover is required. vswitch - The vswitch wrapper to retrieve ID and href. NetBridge().load_balance - (Optional) If set to True, the load balancing will be enabled across the two SEAs. This does require multiple backing adapters (two SEAs). Returns A new NetBridge EntryWrapper that represents the new NetBridge. Signature @classmethod def bld(cls, adapter, pvid, vios_to_backing_adpts, vswitch, load_balance=False): ... NetBridge().control_channel_id Show source in network.py:519 Returns the control channel interface ID. Can be None. Signature @property def control_channel_id(self): ... NetBridge().list_vlans Show source in network.py:452 Lists all of the VLANs on the Network Bridge. Arguments NetBridge().pvid - True if the primary VLAN ID should be included in the response. Defaults to True. arbitrary - If True, the arbitrary PVIDs (see arbitrary_pvids property) will be included in the response. :response: A list of all the VLANs. Signature def list_vlans(self, pvid=True, arbitrary=False): ... NetBridge().load_balance Show source in network.py:405 If set to True, the Load Balancing is enabled on the bridge. Requires two SEAs (sharing is done across the SEAs). Signature @property def load_balance(self): ... NetBridge().load_balance Show source in network.py:413 Signature @load_balance.setter def load_balance(self, value): ... NetBridge().load_grps Show source in network.py:417 Returns the load groups. The first in the list is the primary. Signature @property def load_grps(self): ... NetBridge().load_grps Show source in network.py:425 Signature @load_grps.setter def load_grps(self, new_list): ... NetBridge().pvid Show source in network.py:361 Returns the Primary VLAN ID of the Network Bridge. Signature @property def pvid(self): ... NetBridge().seas Show source in network.py:396 Returns a list of SEA wrappers. Signature @property def seas(self): ... NetBridge().seas Show source in network.py:401 Signature @seas.setter def seas(self, new_list): ... NetBridge().supports_vlan Show source in network.py:492 Determines if the VLAN can flow through the Network Bridge. The VLAN can flow through if either of the following applies: - It is the primary VLAN of the primary Load Group - It is an additional VLAN on any Load Group Therefore, the inverse is true and the VLAN is not supported by the Network Bridge if the following: - The VLAN is not on the Network Bridge - The VLAN is a primary VLAN on a NON-primary Load Group Arguments vlan - The VLAN to query for. Can be a string or a number. Returns True or False based on the previous criteria. Signature def supports_vlan(self, vlan): ... NetBridge().vnet_uri_list Show source in network.py:370 Returns a list of the Virtual Network URIs. This is a READ-ONLY list. Modification should take place through the LoadGroup vnet_uri_list. As the LoadGroups are modified, this list will be dynamically updated. Signature @property def vnet_uri_list(self): ... NetBridge().vswitch_id Show source in network.py:432 Signature @property def vswitch_id(self): ... SEA Show source in network.py:527 Represents the Shared Ethernet Adapter within a NetworkBridge. Signature class SEA(ewrap.ElementWrapper): ... SEA().addl_adpts Show source in network.py:606 Non-primary TrunkAdapters on this Shared Ethernet Adapter. If the vnet_aware trait (see traits.py) is set to True, then the modification of a Network Bridge should be driven via the LoadGroup. If set to False, the LoadGroups simply reflect the state of the system and can't be used for modification. In those scenarios, modification should be done directly against the Trunk Adapters. Returns List of TrunkAdapter wrappers. May be the empty list. Signature @property def addl_adpts(self): ... SEA().addl_adpts Show source in network.py:625 Signature @addl_adpts.setter def addl_adpts(self, value): ... SEA().backing_device Show source in network.py:664 The BackingDeviceChoice for this SEA. Signature @property def backing_device(self): ... SEA.bld Show source in network.py:530 Create the SEA entry that can be used for NetBridge creation. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) SEA().pvid - The primary VLAN ID (ex. 1) for the Network Bridge. vios_href - The Assigned VIOS href. adpt_name - Name of the physical adapter or ether channel that will back the SEA. vswitch - The vswitch wrapper to retrieve ID and href. primary - Used in a dual Virtual I/O Server environment. If set to True, indicates it is running on the I/O Server that the traffic should run through by default. False indicates it is the SEA on the fail over Virtual I/O Server. If single Virtual I/O Server environment, always set this to True. Returns A new SEA ElementWrapper that represents the new SEA. Signature @classmethod def bld(cls, adapter, pvid, vios_href, adpt_name, vswitch, primary=True): ... SEA().configuration_state Show source in network.py:692 Returns the configuration state. May be None. Refer to SEAState for valid values. Signature @property def configuration_state(self): ... SEA().contains_device Show source in network.py:700 Returns if one of the child adapters is owned by this SEA. A child adapter is either the primary adapter, control channel, or is one of the additional adapters. Arguments SEA().dev_name - The name of the child device. Returns True if owned by this SEA, False otherwise. Signature def contains_device(self, dev_name): ... SEA().control_channel Show source in network.py:683 Returns the control channel interface name. This may be None, indicating the lack of a control channel. Control channels are no longer required for a network bridge to be redundant. Signature @property def control_channel(self): ... SEA().dev_name Show source in network.py:569 Signature @property def dev_name(self): ... SEA().ha_mode Show source in network.py:581 Returns the high availability mode of the SEA. See the HAMode Enumeration. Signature @property def ha_mode(self): ... SEA().is_primary Show source in network.py:593 Returns if this is the primary SEA. Only valuable in dual Virtual I/O Server environments where a NetBridge spans multiple I/O Servers. The primary SEA is the one the traffic runs through by default unless in a fail over scenario. Signature @property def is_primary(self): ... SEA().primary_adpt Show source in network.py:636 Returns the primary TrunkAdapter for this SEA. Signature @property def primary_adpt(self): ... SEA().pvid Show source in network.py:561 Returns the Primary VLAN ID of the Shared Ethernet Adapter. Signature @property def pvid(self): ... SEA().vio_uri Show source in network.py:573 The URI to the corresponding VIOS. Signature @property def vio_uri(self): ... SEAState Show source in network.py:191 Signature class SEAState(object): ... TrunkAdapter Show source in network.py:720 Represents a Trunk Adapter, either within a LoadGroup or a SEA. Signature class TrunkAdapter(ewrap.ElementWrapper): ... TrunkAdapter().associated_vswitch_uri Show source in network.py:830 Returns the associated vswitch href. Signature @property def associated_vswitch_uri(self): ... TrunkAdapter.bld Show source in network.py:723 Create the TrunkAdapter element that can be used for SEA creation. The returned adapter uses the \"next available high slot\" option, meaning that the API will attempt to assign the next available slot number that's higher than all the existing assigned slot numbers. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) TrunkAdapter().pvid - The primary VLAN ID (ex. 1) for the Network Bridge. vlan_ids - Additional VLAN ids for the trunk adapters. vswitch - The vswitch wrapper to retrieve ID and href. TrunkAdapter().trunk_pri - Trunk priority of this adapter. Defaults to 1. Returns A new TrunkAdapter ElementWrapper that represents the new TrunkAdapter. Signature @classmethod def bld(cls, adapter, pvid, vlan_ids, vswitch, trunk_pri=1): ... TrunkAdapter().dev_name Show source in network.py:766 Returns the name of the device as represented by the hosting VIOS. If RMC is down, will not be available. Signature @property def dev_name(self): ... TrunkAdapter().has_tag_support Show source in network.py:774 Does this Trunk Adapter support Tagged VLANs passing through it? Signature @property def has_tag_support(self): ... TrunkAdapter().has_tag_support Show source in network.py:779 Signature @has_tag_support.setter def has_tag_support(self, new_val): ... TrunkAdapter().loc_code Show source in network.py:844 Returns the LocationCode property. Signature @property def loc_code(self): ... TrunkAdapter().pvid Show source in network.py:757 Returns the Primary VLAN ID of the Trunk Adapter. Signature @property def pvid(self): ... TrunkAdapter().pvid Show source in network.py:762 Signature @pvid.setter def pvid(self, value): ... TrunkAdapter().tagged_vlans Show source in network.py:783 Returns the tagged VLAN IDs that are allowed to pass through. Assumes has_tag_support() returns True. If not, an empty list will be returned. Signature @property def tagged_vlans(self): ... TrunkAdapter().tagged_vlans Show source in network.py:801 Signature @tagged_vlans.setter def tagged_vlans(self, new_list): ... TrunkAdapter().trunk_pri Show source in network.py:814 Returns the trunk priority of the adapter. Signature @property def trunk_pri(self): ... TrunkAdapter().varied_on Show source in network.py:839 Returns the VariedOn property. Signature @property def varied_on(self): ... TrunkAdapter().vios_id Show source in network.py:849 Determines and returns the VIOS ID from the loc_code. Returns int representing the short ID of the associated VIOS. Signature @property def vios_id(self): ... TrunkAdapter().virtual_slot_number Show source in network.py:825 Returns the virtual slot number for this adapter. Signature @property def virtual_slot_number(self): ... TrunkAdapter().vswitch_id Show source in network.py:806 Returns the virtual switch identifier. Signature @property def vswitch_id(self): ... VNet Show source in network.py:964 The overall definition of a VLAN network within the hypervisor. Signature class VNet(ewrap.EntryWrapper): ... VNet().associated_switch_uri Show source in network.py:991 Signature @property def associated_switch_uri(self): ... VNet().associated_switch_uri Show source in network.py:995 Signature @associated_switch_uri.setter def associated_switch_uri(self, uri): ... VNet.bld Show source in network.py:967 Creates a VirtualNetwork that can be used for a create operation. This is used when creating a new Virtual Network within the system Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) VNet().name - The name for the virtual network. vlan_id - The VLAN identifier (1 to 4094) for the network. vswitch_uri - The URI that points to the appropriate vSwitch. VNet().tagged - True if packets should have VLAN tags when they leave the system. False if tags should only be on the packets while in the system (but tag-less when on the physical network). Returns The ElementWrapper that represents the new VirtualNetwork. Signature @classmethod def bld(cls, adapter, name, vlan_id, vswitch_uri, tagged): ... VNet().name Show source in network.py:999 Signature @property def name(self): ... VNet().name Show source in network.py:1003 Signature @name.setter def name(self, value): ... VNet().tagged Show source in network.py:1023 If True, the VLAN tag is preserved when the packet leaves system. Signature @property def tagged(self): ... VNet().tagged Show source in network.py:1028 Signature @tagged.setter def tagged(self, is_tagged): ... VNet().vlan Show source in network.py:1007 Signature @property def vlan(self): ... VNet().vlan Show source in network.py:1011 Signature @vlan.setter def vlan(self, vlan_id): ... VNet().vswitch_id Show source in network.py:1015 The vSwitch identifier (int). 0 through 15 (max number vSwitches). Is not a UUID. Signature @property def vswitch_id(self): ... VSwitch Show source in network.py:219 Wraps the Virtual Switch entries. The virtual switch in PowerVM is an independent plane of traffic. If Ethernet packets are traveling on different virtual switches, the only time they can communicate is on the physical network plane (or if two logical adapters are bridged together). They are important for data plane segregation. Signature class VSwitch(ewrap.EntryWrapper): ... VSwitch.bld Show source in network.py:229 Creates a VSwitch that can be used for a create operation. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) VSwitch().name - The name for the virtual switch. Must be unique. switch_mode - The mode of virtual switch (see VSwitchMode). Returns The ElementWrapper that represents the new VSwitch. Signature @classmethod def bld(cls, adapter, name, switch_mode=VSwitchMode.VEB): ... VSwitch().mode Show source in network.py:261 The mode that the switch is in (ex. Veb). This is a string value that represents one of the values in the VSwitchMode enumeration. Signature @property def mode(self): ... VSwitch().mode Show source in network.py:270 Signature @mode.setter def mode(self, new_mode): ... VSwitch().name Show source in network.py:244 The name associated with the Virtual Switch. Signature @property def name(self): ... VSwitch().name Show source in network.py:252 Signature @name.setter def name(self, new_name): ... VSwitch().switch_id Show source in network.py:256 The internal ID (not UUID) for the Virtual Switch. Signature @property def switch_id(self): ... VSwitch().vnet_uri_list Show source in network.py:274 Returns a list of the Virtual Network URIs. If the vnet_aware trait (see traits.py) is set to False, the user should not modify this. Virtual Networks become 'realized' off of the system's VLANs/vSwitches. However, if set to True, one can add a Virtual Network to the vSwitch before it is used. The task classes (cna.py and network_bridger.py) should abstract the user away from these deviations in traits. Signature @property def vnet_uri_list(self): ... VSwitch().vnet_uri_list Show source in network.py:289 Signature @vnet_uri_list.setter def vnet_uri_list(self, new_list): ... VSwitchMode Show source in network.py:180 Signature class VSwitchMode(object): ...","title":"Network"},{"location":"pypowervm/wrappers/network/#network","text":"Pypowervm Index / Pypowervm / Wrappers / Network Auto-generated documentation for pypowervm.wrappers.network module. Network CNA CNA.bld CNA().configured_mtu CNA().configured_mtu CNA().create CNA().dev_name CNA().enabled CNA().enabled CNA().gateway CNA().ip_address CNA().is_tagged_vlan_supported CNA().is_tagged_vlan_supported CNA().is_trunk CNA().loc_code CNA().lpar_id CNA().mac CNA().mac CNA().ovs_bridge CNA().ovs_bridge CNA().ovs_ext_ids CNA().ovs_ext_ids CNA().pvid CNA().pvid CNA().slot CNA().subnet_mask CNA().tagged_vlans CNA().tagged_vlans CNA().trunk_pri CNA().vsi_type_id CNA().vsi_type_manager_id CNA().vsi_type_version CNA().vswitch_id CNA().vswitch_uri CNA().vswitch_uri EthernetBackingDevice EthernetBackingDevice().adapter_id EthernetBackingDevice.bld EthernetBackingDevice().dev_name HAMode LoadGroup LoadGroup.bld LoadGroup().pvid LoadGroup().tagged_vlans LoadGroup().trunk_adapters LoadGroup().trunk_adapters LoadGroup().vnet_uri_list LoadGroup().vnet_uri_list LoadGroup.wrap NetBridge NetBridge().arbitrary_pvids NetBridge.bld NetBridge().control_channel_id NetBridge().list_vlans NetBridge().load_balance NetBridge().load_balance NetBridge().load_grps NetBridge().load_grps NetBridge().pvid NetBridge().seas NetBridge().seas NetBridge().supports_vlan NetBridge().vnet_uri_list NetBridge().vswitch_id SEA SEA().addl_adpts SEA().addl_adpts SEA().backing_device SEA.bld SEA().configuration_state SEA().contains_device SEA().control_channel SEA().dev_name SEA().ha_mode SEA().is_primary SEA().primary_adpt SEA().pvid SEA().vio_uri SEAState TrunkAdapter TrunkAdapter().associated_vswitch_uri TrunkAdapter.bld TrunkAdapter().dev_name TrunkAdapter().has_tag_support TrunkAdapter().has_tag_support TrunkAdapter().loc_code TrunkAdapter().pvid TrunkAdapter().pvid TrunkAdapter().tagged_vlans TrunkAdapter().tagged_vlans TrunkAdapter().trunk_pri TrunkAdapter().varied_on TrunkAdapter().vios_id TrunkAdapter().virtual_slot_number TrunkAdapter().vswitch_id VNet VNet().associated_switch_uri VNet().associated_switch_uri VNet.bld VNet().name VNet().name VNet().tagged VNet().tagged VNet().vlan VNet().vlan VNet().vswitch_id VSwitch VSwitch.bld VSwitch().mode VSwitch().mode VSwitch().name VSwitch().name VSwitch().switch_id VSwitch().vnet_uri_list VSwitch().vnet_uri_list VSwitchMode","title":"Network"},{"location":"pypowervm/wrappers/network/#cna","text":"Show source in network.py:1035 Wrapper object for ClientNetworkAdapter schema.","title":"CNA"},{"location":"pypowervm/wrappers/network/#signature","text":"class CNA(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnabld","text":"Show source in network.py:1038 Creates a fresh CNA EntryWrapper. This is used when creating a new CNA for a partition. This can be PUT to LogicalPartition/ /ClientNetworkAdapter or to VirtualIOServer/ /ClientNetworkAdapter.","title":"CNA.bld"},{"location":"pypowervm/wrappers/network/#arguments","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) CNA().pvid - The Primary VLAN ID to use. vswitch_href - The URI that points to the Virtual Switch that will support this adapter. slot_num - The Slot on the Client LPAR that should be used. This defaults to 'None', which means the next available high slot will be used (the API will attempt to assign the next available slot number that's higher than all the existing assigned slot numbers. mac_addr - Optional user specified mac address to use. If left as None, the system will generate one. addl_tagged_vlans - A set of additional tagged VLANs that can be passed through this adapter (with client VLAN adapters). Input should be a list of int (or int string) Example: [51, 52, 53] Note: The limit is ~18 additional VLANs CNA().trunk_pri - Optional TrunkPriority integer that, if specified, will create this wrapper as a trunk. CNA().dev_name - (Optional, Default: None) Can only be set if the CNA is being created against the Management VM. Can be used to specify what the device name should be for the CNA on the Management VM. Ignored for all other LPAR types. CNA().ovs_bridge - (Optional, Default: None) If hosting through mgmt partition, this attribute specifies which Open vSwitch to connect to. This assumes that Open vSwitch is installed and active on the mgmt partition. CNA().ovs_ext_ids - (Optional, Default: None) A comma-delimited list of key=value pairs in string format. Ex. iface-id=abc123,iface-status=active This sets a dictionary of values on the Interface element within Open vSwitch. This assumes that Open vSwitch is installed and active on the mgmt partition. CNA().configured_mtu - (Optional, Default: None) Sets the MTU on the adapter. May only be valid if adapter is being created against mgmt partition.","title":"Arguments"},{"location":"pypowervm/wrappers/network/#returns","text":"A CNA EntryWrapper that can be used for create.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_1","text":"@classmethod def bld( cls, adapter, pvid, vswitch_href, slot_num=None, mac_addr=None, addl_tagged_vlans=None, trunk_pri=None, dev_name=None, ovs_bridge=None, ovs_ext_ids=None, configured_mtu=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaconfigured_mtu","text":"Show source in network.py:1359 The MTU of the adapter. May only be valid if adapter is being created against mgmt partition.","title":"CNA().configured_mtu"},{"location":"pypowervm/wrappers/network/#signature_2","text":"@property def configured_mtu(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaconfigured_mtu_1","text":"Show source in network.py:1367","title":"CNA().configured_mtu"},{"location":"pypowervm/wrappers/network/#signature_3","text":"@configured_mtu.setter def configured_mtu(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnacreate","text":"Show source in network.py:1134 Override to ensure default slot setting is correct. Create the CNA as specified except : If UseNextAvailableHighSlot is True (i.e. slot number was not given); and the parent is a VIOS or the management partition; then change to UseNextAvailableSlot (not High). This is because VIOS and the management partition don't care about slot ordering, and their longevity increases the probability of running out of slot space if we use 'High'.","title":"CNA().create"},{"location":"pypowervm/wrappers/network/#arguments_1","text":"parent_type - See superclass. parent_uuid - See superclass. timeout - See superclass. parent - See superclass.","title":"Arguments"},{"location":"pypowervm/wrappers/network/#signature_4","text":"def create(self, parent_type=None, parent_uuid=None, timeout=-1, parent=None, **kwargs): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnadev_name","text":"Show source in network.py:1320 Returns the name of the device (if available). If RMC is down, will not be available.","title":"CNA().dev_name"},{"location":"pypowervm/wrappers/network/#signature_5","text":"@property def dev_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaenabled","text":"Show source in network.py:1252 Returns the enabled state (boolean value). A CNA is always created enabled=true. However, certain migration operations of an LPAR (ex. migration via OpenStack when using Open vSwitch) will cause the client's CNA to be disabled. This method can be used to check the state of the adapter.","title":"CNA().enabled"},{"location":"pypowervm/wrappers/network/#signature_6","text":"@property def enabled(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaenabled_1","text":"Show source in network.py:1263","title":"CNA().enabled"},{"location":"pypowervm/wrappers/network/#signature_7","text":"@enabled.setter def enabled(self, new_val): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnagateway","text":"Show source in network.py:1417 Returns the gateway of the network interface. Typical format would be: 10.0.0.1 (IPv4) and cafe::1 (IPv6) or other forms of IPv6 address","title":"CNA().gateway"},{"location":"pypowervm/wrappers/network/#signature_8","text":"@ewrap.Wrapper.xag_property(c.XAG.ADV) def gateway(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaip_address","text":"Show source in network.py:1397 Returns the IP Address of the network interface. Typical format would be: 255.255.255.255 (IPv4) and ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff (IPv6) or other short forms of IPv6 address","title":"CNA().ip_address"},{"location":"pypowervm/wrappers/network/#signature_9","text":"@ewrap.Wrapper.xag_property(c.XAG.ADV) def ip_address(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnais_tagged_vlan_supported","text":"Show source in network.py:1295 Returns if addl tagged VLANs are supported (bool value).","title":"CNA().is_tagged_vlan_supported"},{"location":"pypowervm/wrappers/network/#signature_10","text":"@property def is_tagged_vlan_supported(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnais_tagged_vlan_supported_1","text":"Show source in network.py:1300 Parameter new_val is a bool (True or False).","title":"CNA().is_tagged_vlan_supported"},{"location":"pypowervm/wrappers/network/#signature_11","text":"@is_tagged_vlan_supported.setter def is_tagged_vlan_supported(self, new_val): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnais_trunk","text":"Show source in network.py:1349 Returns if this adapter was created with a trunk priority. If the adapter was created without a trunk priority, it is just a client network adapter. However, if it was given a trunk priority on creation, it is a wrapper for a trunk adapter.","title":"CNA().is_trunk"},{"location":"pypowervm/wrappers/network/#signature_12","text":"@property def is_trunk(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaloc_code","text":"Show source in network.py:1268 The device's location code.","title":"CNA().loc_code"},{"location":"pypowervm/wrappers/network/#signature_13","text":"@property def loc_code(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnalpar_id","text":"Show source in network.py:1187 Returns the Local Partition ID for this adapter.","title":"CNA().lpar_id"},{"location":"pypowervm/wrappers/network/#signature_14","text":"@property def lpar_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnamac","text":"Show source in network.py:1214 Returns the Mac Address for the adapter. Typical format would be: AABBCCDDEEFF The API returns a format with no colons and is upper cased.","title":"CNA().mac"},{"location":"pypowervm/wrappers/network/#signature_15","text":"@property def mac(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnamac_1","text":"Show source in network.py:1238","title":"CNA().mac"},{"location":"pypowervm/wrappers/network/#signature_16","text":"@mac.setter def mac(self, new_val): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaovs_bridge","text":"Show source in network.py:1371 The Open vSwitch bridge it is connected to. Otherwise None.","title":"CNA().ovs_bridge"},{"location":"pypowervm/wrappers/network/#signature_17","text":"@property def ovs_bridge(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaovs_bridge_1","text":"Show source in network.py:1376","title":"CNA().ovs_bridge"},{"location":"pypowervm/wrappers/network/#signature_18","text":"@ovs_bridge.setter def ovs_bridge(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaovs_ext_ids","text":"Show source in network.py:1380 If connected to an Open vSwitch, returns the external ids. This is a comma-delimited list of key=value pairs. Ex: 'iface-id=123asdf,iface-status=active' This maps directly to the Open vSwitch Interface object's 'external_id' field.","title":"CNA().ovs_ext_ids"},{"location":"pypowervm/wrappers/network/#signature_19","text":"@property def ovs_ext_ids(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaovs_ext_ids_1","text":"Show source in network.py:1393","title":"CNA().ovs_ext_ids"},{"location":"pypowervm/wrappers/network/#signature_20","text":"@ovs_ext_ids.setter def ovs_ext_ids(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnapvid","text":"Show source in network.py:1243 Returns the Port VLAN ID (int value).","title":"CNA().pvid"},{"location":"pypowervm/wrappers/network/#signature_21","text":"@property def pvid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnapvid_1","text":"Show source in network.py:1248","title":"CNA().pvid"},{"location":"pypowervm/wrappers/network/#signature_22","text":"@pvid.setter def pvid(self, new_val): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnaslot","text":"Show source in network.py:1180","title":"CNA().slot"},{"location":"pypowervm/wrappers/network/#signature_23","text":"@property def slot(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnasubnet_mask","text":"Show source in network.py:1407 Returns the subnet mask of the network interface. Typical format would be: 255.255.255.0 (IPv4) and ffff:ffff:ffff:ffff:: (IPv6) or other forms of IPv6 address","title":"CNA().subnet_mask"},{"location":"pypowervm/wrappers/network/#signature_24","text":"@ewrap.Wrapper.xag_property(c.XAG.ADV) def subnet_mask(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnatagged_vlans","text":"Show source in network.py:1273 Returns a list of additional VLANs on this adapter. Only valid if tagged vlan support is on.","title":"CNA().tagged_vlans"},{"location":"pypowervm/wrappers/network/#signature_25","text":"@property def tagged_vlans(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnatagged_vlans_1","text":"Show source in network.py:1290","title":"CNA().tagged_vlans"},{"location":"pypowervm/wrappers/network/#signature_26","text":"@tagged_vlans.setter def tagged_vlans(self, new_list): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnatrunk_pri","text":"Show source in network.py:1338 Returns the Trunk Priority for the adapter.","title":"CNA().trunk_pri"},{"location":"pypowervm/wrappers/network/#returns_1","text":"None if this is not a Trunk Adapter, priority otherwise.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_27","text":"@property def trunk_pri(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnavsi_type_id","text":"Show source in network.py:1223 Returns the virtual station interface type id.","title":"CNA().vsi_type_id"},{"location":"pypowervm/wrappers/network/#signature_28","text":"@property def vsi_type_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnavsi_type_manager_id","text":"Show source in network.py:1233 Returns the virtual station interface manager id.","title":"CNA().vsi_type_manager_id"},{"location":"pypowervm/wrappers/network/#signature_29","text":"@property def vsi_type_manager_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnavsi_type_version","text":"Show source in network.py:1228 Returns the virtual station interface version.","title":"CNA().vsi_type_version"},{"location":"pypowervm/wrappers/network/#signature_30","text":"@property def vsi_type_version(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnavswitch_id","text":"Show source in network.py:1315 Returns the ID (typically 0-15) for the virtual switch.","title":"CNA().vswitch_id"},{"location":"pypowervm/wrappers/network/#signature_31","text":"@property def vswitch_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnavswitch_uri","text":"Show source in network.py:1306 Returns the URI for the associated vSwitch.","title":"CNA().vswitch_uri"},{"location":"pypowervm/wrappers/network/#signature_32","text":"@property def vswitch_uri(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#cnavswitch_uri_1","text":"Show source in network.py:1311","title":"CNA().vswitch_uri"},{"location":"pypowervm/wrappers/network/#signature_33","text":"@vswitch_uri.setter def vswitch_uri(self, new_val): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#ethernetbackingdevice","text":"Show source in network.py:1430 Represents the SEA EthernetBackingDevice.","title":"EthernetBackingDevice"},{"location":"pypowervm/wrappers/network/#signature_34","text":"class EthernetBackingDevice(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#ethernetbackingdeviceadapter_id","text":"Show source in network.py:1457","title":"EthernetBackingDevice().adapter_id"},{"location":"pypowervm/wrappers/network/#signature_35","text":"@property def adapter_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#ethernetbackingdevicebld","text":"Show source in network.py:1433 Creates the EthernetBackingDevice element.","title":"EthernetBackingDevice.bld"},{"location":"pypowervm/wrappers/network/#arguments_2","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) EthernetBackingDevice().dev_name - The device name (e.g. eth0).","title":"Arguments"},{"location":"pypowervm/wrappers/network/#returns_2","text":"The EthernetBackingDevice element for SEAs.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_36","text":"@classmethod def bld(cls, adapter, dev_name): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#ethernetbackingdevicedev_name","text":"Show source in network.py:1450","title":"EthernetBackingDevice().dev_name"},{"location":"pypowervm/wrappers/network/#signature_37","text":"@property def dev_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#hamode","text":"Show source in network.py:185","title":"HAMode"},{"location":"pypowervm/wrappers/network/#signature_38","text":"class HAMode(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#loadgroup","text":"Show source in network.py:859 Load Group (how the I/O load should be distributed) for a Network Bridge. If using failover or load balancing, then the Load Group will have pairs of Trunk Adapters, each with their own unique Trunk Priority.","title":"LoadGroup"},{"location":"pypowervm/wrappers/network/#signature_39","text":"class LoadGroup(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#loadgroupbld","text":"Show source in network.py:866 Create the LoadGroup element that can be used for a create operation. This is used when adding a Load Group to a NetBridge.","title":"LoadGroup.bld"},{"location":"pypowervm/wrappers/network/#arguments_3","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) LoadGroup().pvid - The primary VLAN ID (ex. 1) for the Load Group. vnet_uris - The virtual network URI list (mapping to each additional VLAN/vswitch combo).","title":"Arguments"},{"location":"pypowervm/wrappers/network/#returns_3","text":"A new LoadGroup ElementWrapper that represents the new LoadGroup.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_40","text":"@classmethod def bld(cls, adapter, pvid, vnet_uris): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#loadgrouppvid","text":"Show source in network.py:893 Returns the Primary VLAN ID of the Load Group.","title":"LoadGroup().pvid"},{"location":"pypowervm/wrappers/network/#signature_41","text":"@property def pvid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#loadgrouptagged_vlans","text":"Show source in network.py:957 The VLANs supported by this Load Group. Does not include PVID.","title":"LoadGroup().tagged_vlans"},{"location":"pypowervm/wrappers/network/#signature_42","text":"@property def tagged_vlans(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#loadgrouptrunk_adapters","text":"Show source in network.py:901 Returns the Trunk Adapters for the Load Group. There is either one (no redundancy/wrap balancing) or two (typically the case in a multi VIOS scenario).","title":"LoadGroup().trunk_adapters"},{"location":"pypowervm/wrappers/network/#returns_4","text":"list of TrunkAdapter objects.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_43","text":"@property def trunk_adapters(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#loadgrouptrunk_adapters_1","text":"Show source in network.py:913","title":"LoadGroup().trunk_adapters"},{"location":"pypowervm/wrappers/network/#signature_44","text":"@trunk_adapters.setter def trunk_adapters(self, new_list): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#loadgroupvnet_uri_list","text":"Show source in network.py:917 Returns a list of the Virtual Network URIs. If the vnet_aware trait (see traits.py) is set, then the addition of VLANs is driven via virtual networks rather than straight VLAN modification. This uri list is what drives the modification. If the trait is set to false, then the modification should be driven via the trunk adapters on the SEA directly. This list will also be empty. The task classes (cna.py and network_bridger.py) should abstract the user away from these deviations in traits.","title":"LoadGroup().vnet_uri_list"},{"location":"pypowervm/wrappers/network/#signature_45","text":"@property def vnet_uri_list(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#loadgroupvnet_uri_list_1","text":"Show source in network.py:935","title":"LoadGroup().vnet_uri_list"},{"location":"pypowervm/wrappers/network/#signature_46","text":"@vnet_uri_list.setter def vnet_uri_list(self, new_list): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#loadgroupwrap","text":"Show source in network.py:884","title":"LoadGroup.wrap"},{"location":"pypowervm/wrappers/network/#signature_47","text":"@classmethod def wrap(cls, element, **kwargs): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridge","text":"Show source in network.py:299 Wrapper object for the NetBridge entry. A NetworkBridge represents an aggregate entity comprising Shared Ethernet Adapters. If Failover or Load-Balancing is in use, the Network Bridge will have two identically structured Shared Ethernet Adapters belonging to different Virtual I/O Servers.","title":"NetBridge"},{"location":"pypowervm/wrappers/network/#signature_48","text":"class NetBridge(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgearbitrary_pvids","text":"Show source in network.py:436 Lists all of the network bridges' arbitrary PVIDs. An arbitrary PVID is a 'primary VLAN ID' attached to an additional Load Group or Trunk Adapter. These typically do not send traffic through them, and are placeholder VLANs required by the backing 'additional' Trunk Adapters.","title":"NetBridge().arbitrary_pvids"},{"location":"pypowervm/wrappers/network/#returns_5","text":"List of arbitrary PVIDs","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_49","text":"@property def arbitrary_pvids(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgebld","text":"Show source in network.py:308 Create the NetBridge entry that can be used for a create operation. This is used when creating a NetBridge.","title":"NetBridge.bld"},{"location":"pypowervm/wrappers/network/#arguments_4","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) NetBridge().pvid - The primary VLAN ID (ex. 1) for the Network Bridge. vios_to_backing_adpts - An argument containing a list of tuples between VIOS href and the VIOS backing trunk adapter names for 1 or 2 VIOS servers, depending whether failover is required. vswitch - The vswitch wrapper to retrieve ID and href. NetBridge().load_balance - (Optional) If set to True, the load balancing will be enabled across the two SEAs. This does require multiple backing adapters (two SEAs).","title":"Arguments"},{"location":"pypowervm/wrappers/network/#returns_6","text":"A new NetBridge EntryWrapper that represents the new NetBridge.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_50","text":"@classmethod def bld(cls, adapter, pvid, vios_to_backing_adpts, vswitch, load_balance=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgecontrol_channel_id","text":"Show source in network.py:519 Returns the control channel interface ID. Can be None.","title":"NetBridge().control_channel_id"},{"location":"pypowervm/wrappers/network/#signature_51","text":"@property def control_channel_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgelist_vlans","text":"Show source in network.py:452 Lists all of the VLANs on the Network Bridge.","title":"NetBridge().list_vlans"},{"location":"pypowervm/wrappers/network/#arguments_5","text":"NetBridge().pvid - True if the primary VLAN ID should be included in the response. Defaults to True. arbitrary - If True, the arbitrary PVIDs (see arbitrary_pvids property) will be included in the response. :response: A list of all the VLANs.","title":"Arguments"},{"location":"pypowervm/wrappers/network/#signature_52","text":"def list_vlans(self, pvid=True, arbitrary=False): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgeload_balance","text":"Show source in network.py:405 If set to True, the Load Balancing is enabled on the bridge. Requires two SEAs (sharing is done across the SEAs).","title":"NetBridge().load_balance"},{"location":"pypowervm/wrappers/network/#signature_53","text":"@property def load_balance(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgeload_balance_1","text":"Show source in network.py:413","title":"NetBridge().load_balance"},{"location":"pypowervm/wrappers/network/#signature_54","text":"@load_balance.setter def load_balance(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgeload_grps","text":"Show source in network.py:417 Returns the load groups. The first in the list is the primary.","title":"NetBridge().load_grps"},{"location":"pypowervm/wrappers/network/#signature_55","text":"@property def load_grps(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgeload_grps_1","text":"Show source in network.py:425","title":"NetBridge().load_grps"},{"location":"pypowervm/wrappers/network/#signature_56","text":"@load_grps.setter def load_grps(self, new_list): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgepvid","text":"Show source in network.py:361 Returns the Primary VLAN ID of the Network Bridge.","title":"NetBridge().pvid"},{"location":"pypowervm/wrappers/network/#signature_57","text":"@property def pvid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgeseas","text":"Show source in network.py:396 Returns a list of SEA wrappers.","title":"NetBridge().seas"},{"location":"pypowervm/wrappers/network/#signature_58","text":"@property def seas(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgeseas_1","text":"Show source in network.py:401","title":"NetBridge().seas"},{"location":"pypowervm/wrappers/network/#signature_59","text":"@seas.setter def seas(self, new_list): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgesupports_vlan","text":"Show source in network.py:492 Determines if the VLAN can flow through the Network Bridge. The VLAN can flow through if either of the following applies: - It is the primary VLAN of the primary Load Group - It is an additional VLAN on any Load Group Therefore, the inverse is true and the VLAN is not supported by the Network Bridge if the following: - The VLAN is not on the Network Bridge - The VLAN is a primary VLAN on a NON-primary Load Group","title":"NetBridge().supports_vlan"},{"location":"pypowervm/wrappers/network/#arguments_6","text":"vlan - The VLAN to query for. Can be a string or a number.","title":"Arguments"},{"location":"pypowervm/wrappers/network/#returns_7","text":"True or False based on the previous criteria.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_60","text":"def supports_vlan(self, vlan): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgevnet_uri_list","text":"Show source in network.py:370 Returns a list of the Virtual Network URIs. This is a READ-ONLY list. Modification should take place through the LoadGroup vnet_uri_list. As the LoadGroups are modified, this list will be dynamically updated.","title":"NetBridge().vnet_uri_list"},{"location":"pypowervm/wrappers/network/#signature_61","text":"@property def vnet_uri_list(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#netbridgevswitch_id","text":"Show source in network.py:432","title":"NetBridge().vswitch_id"},{"location":"pypowervm/wrappers/network/#signature_62","text":"@property def vswitch_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#sea","text":"Show source in network.py:527 Represents the Shared Ethernet Adapter within a NetworkBridge.","title":"SEA"},{"location":"pypowervm/wrappers/network/#signature_63","text":"class SEA(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seaaddl_adpts","text":"Show source in network.py:606 Non-primary TrunkAdapters on this Shared Ethernet Adapter. If the vnet_aware trait (see traits.py) is set to True, then the modification of a Network Bridge should be driven via the LoadGroup. If set to False, the LoadGroups simply reflect the state of the system and can't be used for modification. In those scenarios, modification should be done directly against the Trunk Adapters.","title":"SEA().addl_adpts"},{"location":"pypowervm/wrappers/network/#returns_8","text":"List of TrunkAdapter wrappers. May be the empty list.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_64","text":"@property def addl_adpts(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seaaddl_adpts_1","text":"Show source in network.py:625","title":"SEA().addl_adpts"},{"location":"pypowervm/wrappers/network/#signature_65","text":"@addl_adpts.setter def addl_adpts(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seabacking_device","text":"Show source in network.py:664 The BackingDeviceChoice for this SEA.","title":"SEA().backing_device"},{"location":"pypowervm/wrappers/network/#signature_66","text":"@property def backing_device(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seabld","text":"Show source in network.py:530 Create the SEA entry that can be used for NetBridge creation.","title":"SEA.bld"},{"location":"pypowervm/wrappers/network/#arguments_7","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) SEA().pvid - The primary VLAN ID (ex. 1) for the Network Bridge. vios_href - The Assigned VIOS href. adpt_name - Name of the physical adapter or ether channel that will back the SEA. vswitch - The vswitch wrapper to retrieve ID and href. primary - Used in a dual Virtual I/O Server environment. If set to True, indicates it is running on the I/O Server that the traffic should run through by default. False indicates it is the SEA on the fail over Virtual I/O Server. If single Virtual I/O Server environment, always set this to True.","title":"Arguments"},{"location":"pypowervm/wrappers/network/#returns_9","text":"A new SEA ElementWrapper that represents the new SEA.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_67","text":"@classmethod def bld(cls, adapter, pvid, vios_href, adpt_name, vswitch, primary=True): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seaconfiguration_state","text":"Show source in network.py:692 Returns the configuration state. May be None. Refer to SEAState for valid values.","title":"SEA().configuration_state"},{"location":"pypowervm/wrappers/network/#signature_68","text":"@property def configuration_state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seacontains_device","text":"Show source in network.py:700 Returns if one of the child adapters is owned by this SEA. A child adapter is either the primary adapter, control channel, or is one of the additional adapters.","title":"SEA().contains_device"},{"location":"pypowervm/wrappers/network/#arguments_8","text":"SEA().dev_name - The name of the child device.","title":"Arguments"},{"location":"pypowervm/wrappers/network/#returns_10","text":"True if owned by this SEA, False otherwise.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_69","text":"def contains_device(self, dev_name): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seacontrol_channel","text":"Show source in network.py:683 Returns the control channel interface name. This may be None, indicating the lack of a control channel. Control channels are no longer required for a network bridge to be redundant.","title":"SEA().control_channel"},{"location":"pypowervm/wrappers/network/#signature_70","text":"@property def control_channel(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seadev_name","text":"Show source in network.py:569","title":"SEA().dev_name"},{"location":"pypowervm/wrappers/network/#signature_71","text":"@property def dev_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seaha_mode","text":"Show source in network.py:581 Returns the high availability mode of the SEA. See the HAMode Enumeration.","title":"SEA().ha_mode"},{"location":"pypowervm/wrappers/network/#signature_72","text":"@property def ha_mode(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seais_primary","text":"Show source in network.py:593 Returns if this is the primary SEA. Only valuable in dual Virtual I/O Server environments where a NetBridge spans multiple I/O Servers. The primary SEA is the one the traffic runs through by default unless in a fail over scenario.","title":"SEA().is_primary"},{"location":"pypowervm/wrappers/network/#signature_73","text":"@property def is_primary(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seaprimary_adpt","text":"Show source in network.py:636 Returns the primary TrunkAdapter for this SEA.","title":"SEA().primary_adpt"},{"location":"pypowervm/wrappers/network/#signature_74","text":"@property def primary_adpt(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seapvid","text":"Show source in network.py:561 Returns the Primary VLAN ID of the Shared Ethernet Adapter.","title":"SEA().pvid"},{"location":"pypowervm/wrappers/network/#signature_75","text":"@property def pvid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seavio_uri","text":"Show source in network.py:573 The URI to the corresponding VIOS.","title":"SEA().vio_uri"},{"location":"pypowervm/wrappers/network/#signature_76","text":"@property def vio_uri(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#seastate","text":"Show source in network.py:191","title":"SEAState"},{"location":"pypowervm/wrappers/network/#signature_77","text":"class SEAState(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadapter","text":"Show source in network.py:720 Represents a Trunk Adapter, either within a LoadGroup or a SEA.","title":"TrunkAdapter"},{"location":"pypowervm/wrappers/network/#signature_78","text":"class TrunkAdapter(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadapterassociated_vswitch_uri","text":"Show source in network.py:830 Returns the associated vswitch href.","title":"TrunkAdapter().associated_vswitch_uri"},{"location":"pypowervm/wrappers/network/#signature_79","text":"@property def associated_vswitch_uri(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadapterbld","text":"Show source in network.py:723 Create the TrunkAdapter element that can be used for SEA creation. The returned adapter uses the \"next available high slot\" option, meaning that the API will attempt to assign the next available slot number that's higher than all the existing assigned slot numbers.","title":"TrunkAdapter.bld"},{"location":"pypowervm/wrappers/network/#arguments_9","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) TrunkAdapter().pvid - The primary VLAN ID (ex. 1) for the Network Bridge. vlan_ids - Additional VLAN ids for the trunk adapters. vswitch - The vswitch wrapper to retrieve ID and href. TrunkAdapter().trunk_pri - Trunk priority of this adapter. Defaults to 1.","title":"Arguments"},{"location":"pypowervm/wrappers/network/#returns_11","text":"A new TrunkAdapter ElementWrapper that represents the new TrunkAdapter.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_80","text":"@classmethod def bld(cls, adapter, pvid, vlan_ids, vswitch, trunk_pri=1): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadapterdev_name","text":"Show source in network.py:766 Returns the name of the device as represented by the hosting VIOS. If RMC is down, will not be available.","title":"TrunkAdapter().dev_name"},{"location":"pypowervm/wrappers/network/#signature_81","text":"@property def dev_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadapterhas_tag_support","text":"Show source in network.py:774 Does this Trunk Adapter support Tagged VLANs passing through it?","title":"TrunkAdapter().has_tag_support"},{"location":"pypowervm/wrappers/network/#signature_82","text":"@property def has_tag_support(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadapterhas_tag_support_1","text":"Show source in network.py:779","title":"TrunkAdapter().has_tag_support"},{"location":"pypowervm/wrappers/network/#signature_83","text":"@has_tag_support.setter def has_tag_support(self, new_val): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadapterloc_code","text":"Show source in network.py:844 Returns the LocationCode property.","title":"TrunkAdapter().loc_code"},{"location":"pypowervm/wrappers/network/#signature_84","text":"@property def loc_code(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadapterpvid","text":"Show source in network.py:757 Returns the Primary VLAN ID of the Trunk Adapter.","title":"TrunkAdapter().pvid"},{"location":"pypowervm/wrappers/network/#signature_85","text":"@property def pvid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadapterpvid_1","text":"Show source in network.py:762","title":"TrunkAdapter().pvid"},{"location":"pypowervm/wrappers/network/#signature_86","text":"@pvid.setter def pvid(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadaptertagged_vlans","text":"Show source in network.py:783 Returns the tagged VLAN IDs that are allowed to pass through. Assumes has_tag_support() returns True. If not, an empty list will be returned.","title":"TrunkAdapter().tagged_vlans"},{"location":"pypowervm/wrappers/network/#signature_87","text":"@property def tagged_vlans(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadaptertagged_vlans_1","text":"Show source in network.py:801","title":"TrunkAdapter().tagged_vlans"},{"location":"pypowervm/wrappers/network/#signature_88","text":"@tagged_vlans.setter def tagged_vlans(self, new_list): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadaptertrunk_pri","text":"Show source in network.py:814 Returns the trunk priority of the adapter.","title":"TrunkAdapter().trunk_pri"},{"location":"pypowervm/wrappers/network/#signature_89","text":"@property def trunk_pri(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadaptervaried_on","text":"Show source in network.py:839 Returns the VariedOn property.","title":"TrunkAdapter().varied_on"},{"location":"pypowervm/wrappers/network/#signature_90","text":"@property def varied_on(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadaptervios_id","text":"Show source in network.py:849 Determines and returns the VIOS ID from the loc_code.","title":"TrunkAdapter().vios_id"},{"location":"pypowervm/wrappers/network/#returns_12","text":"int representing the short ID of the associated VIOS.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_91","text":"@property def vios_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadaptervirtual_slot_number","text":"Show source in network.py:825 Returns the virtual slot number for this adapter.","title":"TrunkAdapter().virtual_slot_number"},{"location":"pypowervm/wrappers/network/#signature_92","text":"@property def virtual_slot_number(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#trunkadaptervswitch_id","text":"Show source in network.py:806 Returns the virtual switch identifier.","title":"TrunkAdapter().vswitch_id"},{"location":"pypowervm/wrappers/network/#signature_93","text":"@property def vswitch_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnet","text":"Show source in network.py:964 The overall definition of a VLAN network within the hypervisor.","title":"VNet"},{"location":"pypowervm/wrappers/network/#signature_94","text":"class VNet(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnetassociated_switch_uri","text":"Show source in network.py:991","title":"VNet().associated_switch_uri"},{"location":"pypowervm/wrappers/network/#signature_95","text":"@property def associated_switch_uri(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnetassociated_switch_uri_1","text":"Show source in network.py:995","title":"VNet().associated_switch_uri"},{"location":"pypowervm/wrappers/network/#signature_96","text":"@associated_switch_uri.setter def associated_switch_uri(self, uri): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnetbld","text":"Show source in network.py:967 Creates a VirtualNetwork that can be used for a create operation. This is used when creating a new Virtual Network within the system","title":"VNet.bld"},{"location":"pypowervm/wrappers/network/#arguments_10","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) VNet().name - The name for the virtual network. vlan_id - The VLAN identifier (1 to 4094) for the network. vswitch_uri - The URI that points to the appropriate vSwitch. VNet().tagged - True if packets should have VLAN tags when they leave the system. False if tags should only be on the packets while in the system (but tag-less when on the physical network).","title":"Arguments"},{"location":"pypowervm/wrappers/network/#returns_13","text":"The ElementWrapper that represents the new VirtualNetwork.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_97","text":"@classmethod def bld(cls, adapter, name, vlan_id, vswitch_uri, tagged): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnetname","text":"Show source in network.py:999","title":"VNet().name"},{"location":"pypowervm/wrappers/network/#signature_98","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnetname_1","text":"Show source in network.py:1003","title":"VNet().name"},{"location":"pypowervm/wrappers/network/#signature_99","text":"@name.setter def name(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnettagged","text":"Show source in network.py:1023 If True, the VLAN tag is preserved when the packet leaves system.","title":"VNet().tagged"},{"location":"pypowervm/wrappers/network/#signature_100","text":"@property def tagged(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnettagged_1","text":"Show source in network.py:1028","title":"VNet().tagged"},{"location":"pypowervm/wrappers/network/#signature_101","text":"@tagged.setter def tagged(self, is_tagged): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnetvlan","text":"Show source in network.py:1007","title":"VNet().vlan"},{"location":"pypowervm/wrappers/network/#signature_102","text":"@property def vlan(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnetvlan_1","text":"Show source in network.py:1011","title":"VNet().vlan"},{"location":"pypowervm/wrappers/network/#signature_103","text":"@vlan.setter def vlan(self, vlan_id): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vnetvswitch_id","text":"Show source in network.py:1015 The vSwitch identifier (int). 0 through 15 (max number vSwitches). Is not a UUID.","title":"VNet().vswitch_id"},{"location":"pypowervm/wrappers/network/#signature_104","text":"@property def vswitch_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vswitch","text":"Show source in network.py:219 Wraps the Virtual Switch entries. The virtual switch in PowerVM is an independent plane of traffic. If Ethernet packets are traveling on different virtual switches, the only time they can communicate is on the physical network plane (or if two logical adapters are bridged together). They are important for data plane segregation.","title":"VSwitch"},{"location":"pypowervm/wrappers/network/#signature_105","text":"class VSwitch(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vswitchbld","text":"Show source in network.py:229 Creates a VSwitch that can be used for a create operation.","title":"VSwitch.bld"},{"location":"pypowervm/wrappers/network/#arguments_11","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) VSwitch().name - The name for the virtual switch. Must be unique. switch_mode - The mode of virtual switch (see VSwitchMode).","title":"Arguments"},{"location":"pypowervm/wrappers/network/#returns_14","text":"The ElementWrapper that represents the new VSwitch.","title":"Returns"},{"location":"pypowervm/wrappers/network/#signature_106","text":"@classmethod def bld(cls, adapter, name, switch_mode=VSwitchMode.VEB): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vswitchmode","text":"Show source in network.py:261 The mode that the switch is in (ex. Veb). This is a string value that represents one of the values in the VSwitchMode enumeration.","title":"VSwitch().mode"},{"location":"pypowervm/wrappers/network/#signature_107","text":"@property def mode(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vswitchmode_1","text":"Show source in network.py:270","title":"VSwitch().mode"},{"location":"pypowervm/wrappers/network/#signature_108","text":"@mode.setter def mode(self, new_mode): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vswitchname","text":"Show source in network.py:244 The name associated with the Virtual Switch.","title":"VSwitch().name"},{"location":"pypowervm/wrappers/network/#signature_109","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vswitchname_1","text":"Show source in network.py:252","title":"VSwitch().name"},{"location":"pypowervm/wrappers/network/#signature_110","text":"@name.setter def name(self, new_name): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vswitchswitch_id","text":"Show source in network.py:256 The internal ID (not UUID) for the Virtual Switch.","title":"VSwitch().switch_id"},{"location":"pypowervm/wrappers/network/#signature_111","text":"@property def switch_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vswitchvnet_uri_list","text":"Show source in network.py:274 Returns a list of the Virtual Network URIs. If the vnet_aware trait (see traits.py) is set to False, the user should not modify this. Virtual Networks become 'realized' off of the system's VLANs/vSwitches. However, if set to True, one can add a Virtual Network to the vSwitch before it is used. The task classes (cna.py and network_bridger.py) should abstract the user away from these deviations in traits.","title":"VSwitch().vnet_uri_list"},{"location":"pypowervm/wrappers/network/#signature_112","text":"@property def vnet_uri_list(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vswitchvnet_uri_list_1","text":"Show source in network.py:289","title":"VSwitch().vnet_uri_list"},{"location":"pypowervm/wrappers/network/#signature_113","text":"@vnet_uri_list.setter def vnet_uri_list(self, new_list): ...","title":"Signature"},{"location":"pypowervm/wrappers/network/#vswitchmode_2","text":"Show source in network.py:180","title":"VSwitchMode"},{"location":"pypowervm/wrappers/network/#signature_114","text":"class VSwitchMode(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/","text":"Pmem Pypowervm Index / Pypowervm / Wrappers / Pmem Auto-generated documentation for pypowervm.wrappers.pmem module. Pmem PersistentMemoryDevice PersistentMemoryDevice().blocksize PersistentMemoryDevice().cur_num_volumes PersistentMemoryDevice().drc_index PersistentMemoryDevice().freesize PersistentMemoryDevice().max_num_volumes PersistentMemoryDevice().pys_loc PersistentMemoryDevice().serial_number PersistentMemoryDevice().status PersistentMemoryDevice().totalsize PersistentMemoryDevice().type PersistentMemoryVolume PersistentMemoryVolume().drc_index PersistentMemoryVolume().name PersistentMemoryVolume().size PersistentMemoryVolume().uuid PersistentMemoryVolume().volume_id VirtualPMEMVolume VirtualPMEMVolume().affinity VirtualPMEMVolume().affinity VirtualPMEMVolume().assoc_partition VirtualPMEMVolume().assoc_partition_id VirtualPMEMVolume().assoc_partition_id VirtualPMEMVolume().assoc_partition_name VirtualPMEMVolume.bld VirtualPMEMVolume().cur_size VirtualPMEMVolume().name VirtualPMEMVolume().name VirtualPMEMVolume().pmem_vol_uuid VirtualPMEMVolume().set_uuid VirtualPMEMVolume().size VirtualPMEMVolume().size VirtualPMEMVolume().volume_id PersistentMemoryDevice Show source in pmem.py:60 Class PersistentMemoryDevice. This corresponds to the abstract PersistentMemoryDevice object in the PowerVM schema. Signature class PersistentMemoryDevice(ewrap.EntryWrapper): ... PersistentMemoryDevice().blocksize Show source in pmem.py:82 Signature @property def blocksize(self): ... PersistentMemoryDevice().cur_num_volumes Show source in pmem.py:98 Signature @property def cur_num_volumes(self): ... PersistentMemoryDevice().drc_index Show source in pmem.py:67 Signature @property def drc_index(self): ... PersistentMemoryDevice().freesize Show source in pmem.py:90 Signature @property def freesize(self): ... PersistentMemoryDevice().max_num_volumes Show source in pmem.py:94 Signature @property def max_num_volumes(self): ... PersistentMemoryDevice().pys_loc Show source in pmem.py:102 Signature @property def pys_loc(self): ... PersistentMemoryDevice().serial_number Show source in pmem.py:106 Signature @property def serial_number(self): ... PersistentMemoryDevice().status Show source in pmem.py:78 Signature @property def status(self): ... PersistentMemoryDevice().totalsize Show source in pmem.py:86 Signature @property def totalsize(self): ... PersistentMemoryDevice().type Show source in pmem.py:74 Signature @property def type(self): ... PersistentMemoryVolume Show source in pmem.py:128 Class VirtualPersistentMemoryVolume. This corresponds to the abstract PersistentMemoryVolume object in the PowerVM schema. Signature class PersistentMemoryVolume(PersistentMemoryDevice): ... See also PersistentMemoryDevice PersistentMemoryVolume().drc_index Show source in pmem.py:135 Signature @property def drc_index(self): ... PersistentMemoryVolume().name Show source in pmem.py:143 Signature @property def name(self): ... PersistentMemoryVolume().size Show source in pmem.py:147 Signature @property def size(self): ... PersistentMemoryVolume().uuid Show source in pmem.py:139 Signature @property def uuid(self): ... PersistentMemoryVolume().volume_id Show source in pmem.py:151 Signature @property def volume_id(self): ... VirtualPMEMVolume Show source in pmem.py:184 Class VirtualPersistentMemoryVolume. This corresponds to the abstract VirtualPersistentMemoryVolume object in the PowerVM schema. Signature class VirtualPMEMVolume(ewrap.EntryWrapper, ewrap.WrapperSetUUIDMixin): ... VirtualPMEMVolume().affinity Show source in pmem.py:240 Signature @property def affinity(self): ... VirtualPMEMVolume().affinity Show source in pmem.py:244 Signature @affinity.setter def affinity(self, value): ... VirtualPMEMVolume().assoc_partition Show source in pmem.py:263 Signature @property def assoc_partition(self): ... VirtualPMEMVolume().assoc_partition_id Show source in pmem.py:254 Signature @property def assoc_partition_id(self): ... VirtualPMEMVolume().assoc_partition_id Show source in pmem.py:258 Signature @assoc_partition_id.setter def assoc_partition_id(self, value): ... VirtualPMEMVolume().assoc_partition_name Show source in pmem.py:250 Signature @property def assoc_partition_name(self): ... VirtualPMEMVolume.bld Show source in pmem.py:191 Creates a VirtualPersistentMemoryVolume. Signature @classmethod def bld(cls, adapter, lpar_id, name, size, affinity=True): ... VirtualPMEMVolume().cur_size Show source in pmem.py:232 Signature @property def cur_size(self): ... VirtualPMEMVolume().name Show source in pmem.py:214 Signature @property def name(self): ... VirtualPMEMVolume().name Show source in pmem.py:218 Signature @name.setter def name(self, value): ... VirtualPMEMVolume().pmem_vol_uuid Show source in pmem.py:210 Signature @property def pmem_vol_uuid(self): ... VirtualPMEMVolume().set_uuid Show source in pmem.py:204 Signature def set_uuid(self, value): ... VirtualPMEMVolume().size Show source in pmem.py:223 Signature @property def size(self): ... VirtualPMEMVolume().size Show source in pmem.py:227 Signature @size.setter def size(self, value): ... VirtualPMEMVolume().volume_id Show source in pmem.py:236 Signature @property def volume_id(self): ...","title":"Pmem"},{"location":"pypowervm/wrappers/pmem/#pmem","text":"Pypowervm Index / Pypowervm / Wrappers / Pmem Auto-generated documentation for pypowervm.wrappers.pmem module. Pmem PersistentMemoryDevice PersistentMemoryDevice().blocksize PersistentMemoryDevice().cur_num_volumes PersistentMemoryDevice().drc_index PersistentMemoryDevice().freesize PersistentMemoryDevice().max_num_volumes PersistentMemoryDevice().pys_loc PersistentMemoryDevice().serial_number PersistentMemoryDevice().status PersistentMemoryDevice().totalsize PersistentMemoryDevice().type PersistentMemoryVolume PersistentMemoryVolume().drc_index PersistentMemoryVolume().name PersistentMemoryVolume().size PersistentMemoryVolume().uuid PersistentMemoryVolume().volume_id VirtualPMEMVolume VirtualPMEMVolume().affinity VirtualPMEMVolume().affinity VirtualPMEMVolume().assoc_partition VirtualPMEMVolume().assoc_partition_id VirtualPMEMVolume().assoc_partition_id VirtualPMEMVolume().assoc_partition_name VirtualPMEMVolume.bld VirtualPMEMVolume().cur_size VirtualPMEMVolume().name VirtualPMEMVolume().name VirtualPMEMVolume().pmem_vol_uuid VirtualPMEMVolume().set_uuid VirtualPMEMVolume().size VirtualPMEMVolume().size VirtualPMEMVolume().volume_id","title":"Pmem"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydevice","text":"Show source in pmem.py:60 Class PersistentMemoryDevice. This corresponds to the abstract PersistentMemoryDevice object in the PowerVM schema.","title":"PersistentMemoryDevice"},{"location":"pypowervm/wrappers/pmem/#signature","text":"class PersistentMemoryDevice(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydeviceblocksize","text":"Show source in pmem.py:82","title":"PersistentMemoryDevice().blocksize"},{"location":"pypowervm/wrappers/pmem/#signature_1","text":"@property def blocksize(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydevicecur_num_volumes","text":"Show source in pmem.py:98","title":"PersistentMemoryDevice().cur_num_volumes"},{"location":"pypowervm/wrappers/pmem/#signature_2","text":"@property def cur_num_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydevicedrc_index","text":"Show source in pmem.py:67","title":"PersistentMemoryDevice().drc_index"},{"location":"pypowervm/wrappers/pmem/#signature_3","text":"@property def drc_index(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydevicefreesize","text":"Show source in pmem.py:90","title":"PersistentMemoryDevice().freesize"},{"location":"pypowervm/wrappers/pmem/#signature_4","text":"@property def freesize(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydevicemax_num_volumes","text":"Show source in pmem.py:94","title":"PersistentMemoryDevice().max_num_volumes"},{"location":"pypowervm/wrappers/pmem/#signature_5","text":"@property def max_num_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydevicepys_loc","text":"Show source in pmem.py:102","title":"PersistentMemoryDevice().pys_loc"},{"location":"pypowervm/wrappers/pmem/#signature_6","text":"@property def pys_loc(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydeviceserial_number","text":"Show source in pmem.py:106","title":"PersistentMemoryDevice().serial_number"},{"location":"pypowervm/wrappers/pmem/#signature_7","text":"@property def serial_number(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydevicestatus","text":"Show source in pmem.py:78","title":"PersistentMemoryDevice().status"},{"location":"pypowervm/wrappers/pmem/#signature_8","text":"@property def status(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydevicetotalsize","text":"Show source in pmem.py:86","title":"PersistentMemoryDevice().totalsize"},{"location":"pypowervm/wrappers/pmem/#signature_9","text":"@property def totalsize(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemorydevicetype","text":"Show source in pmem.py:74","title":"PersistentMemoryDevice().type"},{"location":"pypowervm/wrappers/pmem/#signature_10","text":"@property def type(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemoryvolume","text":"Show source in pmem.py:128 Class VirtualPersistentMemoryVolume. This corresponds to the abstract PersistentMemoryVolume object in the PowerVM schema.","title":"PersistentMemoryVolume"},{"location":"pypowervm/wrappers/pmem/#signature_11","text":"class PersistentMemoryVolume(PersistentMemoryDevice): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#see-also","text":"PersistentMemoryDevice","title":"See also"},{"location":"pypowervm/wrappers/pmem/#persistentmemoryvolumedrc_index","text":"Show source in pmem.py:135","title":"PersistentMemoryVolume().drc_index"},{"location":"pypowervm/wrappers/pmem/#signature_12","text":"@property def drc_index(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemoryvolumename","text":"Show source in pmem.py:143","title":"PersistentMemoryVolume().name"},{"location":"pypowervm/wrappers/pmem/#signature_13","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemoryvolumesize","text":"Show source in pmem.py:147","title":"PersistentMemoryVolume().size"},{"location":"pypowervm/wrappers/pmem/#signature_14","text":"@property def size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemoryvolumeuuid","text":"Show source in pmem.py:139","title":"PersistentMemoryVolume().uuid"},{"location":"pypowervm/wrappers/pmem/#signature_15","text":"@property def uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#persistentmemoryvolumevolume_id","text":"Show source in pmem.py:151","title":"PersistentMemoryVolume().volume_id"},{"location":"pypowervm/wrappers/pmem/#signature_16","text":"@property def volume_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolume","text":"Show source in pmem.py:184 Class VirtualPersistentMemoryVolume. This corresponds to the abstract VirtualPersistentMemoryVolume object in the PowerVM schema.","title":"VirtualPMEMVolume"},{"location":"pypowervm/wrappers/pmem/#signature_17","text":"class VirtualPMEMVolume(ewrap.EntryWrapper, ewrap.WrapperSetUUIDMixin): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumeaffinity","text":"Show source in pmem.py:240","title":"VirtualPMEMVolume().affinity"},{"location":"pypowervm/wrappers/pmem/#signature_18","text":"@property def affinity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumeaffinity_1","text":"Show source in pmem.py:244","title":"VirtualPMEMVolume().affinity"},{"location":"pypowervm/wrappers/pmem/#signature_19","text":"@affinity.setter def affinity(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumeassoc_partition","text":"Show source in pmem.py:263","title":"VirtualPMEMVolume().assoc_partition"},{"location":"pypowervm/wrappers/pmem/#signature_20","text":"@property def assoc_partition(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumeassoc_partition_id","text":"Show source in pmem.py:254","title":"VirtualPMEMVolume().assoc_partition_id"},{"location":"pypowervm/wrappers/pmem/#signature_21","text":"@property def assoc_partition_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumeassoc_partition_id_1","text":"Show source in pmem.py:258","title":"VirtualPMEMVolume().assoc_partition_id"},{"location":"pypowervm/wrappers/pmem/#signature_22","text":"@assoc_partition_id.setter def assoc_partition_id(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumeassoc_partition_name","text":"Show source in pmem.py:250","title":"VirtualPMEMVolume().assoc_partition_name"},{"location":"pypowervm/wrappers/pmem/#signature_23","text":"@property def assoc_partition_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumebld","text":"Show source in pmem.py:191 Creates a VirtualPersistentMemoryVolume.","title":"VirtualPMEMVolume.bld"},{"location":"pypowervm/wrappers/pmem/#signature_24","text":"@classmethod def bld(cls, adapter, lpar_id, name, size, affinity=True): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumecur_size","text":"Show source in pmem.py:232","title":"VirtualPMEMVolume().cur_size"},{"location":"pypowervm/wrappers/pmem/#signature_25","text":"@property def cur_size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumename","text":"Show source in pmem.py:214","title":"VirtualPMEMVolume().name"},{"location":"pypowervm/wrappers/pmem/#signature_26","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumename_1","text":"Show source in pmem.py:218","title":"VirtualPMEMVolume().name"},{"location":"pypowervm/wrappers/pmem/#signature_27","text":"@name.setter def name(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumepmem_vol_uuid","text":"Show source in pmem.py:210","title":"VirtualPMEMVolume().pmem_vol_uuid"},{"location":"pypowervm/wrappers/pmem/#signature_28","text":"@property def pmem_vol_uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumeset_uuid","text":"Show source in pmem.py:204","title":"VirtualPMEMVolume().set_uuid"},{"location":"pypowervm/wrappers/pmem/#signature_29","text":"def set_uuid(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumesize","text":"Show source in pmem.py:223","title":"VirtualPMEMVolume().size"},{"location":"pypowervm/wrappers/pmem/#signature_30","text":"@property def size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumesize_1","text":"Show source in pmem.py:227","title":"VirtualPMEMVolume().size"},{"location":"pypowervm/wrappers/pmem/#signature_31","text":"@size.setter def size(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/pmem/#virtualpmemvolumevolume_id","text":"Show source in pmem.py:236","title":"VirtualPMEMVolume().volume_id"},{"location":"pypowervm/wrappers/pmem/#signature_32","text":"@property def volume_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/","text":"SharedProcPool Pypowervm Index / Pypowervm / Wrappers / SharedProcPool Auto-generated documentation for pypowervm.wrappers.shared_proc_pool module. SharedProcPool SharedProcPool SharedProcPool().avail_proc_units SharedProcPool().curr_rsrv_proc_units SharedProcPool().id SharedProcPool().is_default SharedProcPool().max_proc_units SharedProcPool().max_proc_units SharedProcPool().name SharedProcPool().name SharedProcPool().pend_rsrv_proc_units SharedProcPool().pend_rsrv_proc_units SharedProcPool Show source in shared_proc_pool.py:43 Signature class SharedProcPool(ewrap.EntryWrapper): ... SharedProcPool().avail_proc_units Show source in shared_proc_pool.py:88 Returns the available proc units in the pool. If the default pool, will return 0. Signature @property def avail_proc_units(self): ... SharedProcPool().curr_rsrv_proc_units Show source in shared_proc_pool.py:50 Floating point number of reserved processing units. Signature @property def curr_rsrv_proc_units(self): ... SharedProcPool().id Show source in shared_proc_pool.py:45 Integer shared processor pool ID. Signature @property def id(self): ... SharedProcPool().is_default Show source in shared_proc_pool.py:55 If true, is the default processor pool. Signature @property def is_default(self): ... SharedProcPool().max_proc_units Show source in shared_proc_pool.py:69 Floating point number of the max processing units. Signature @property def max_proc_units(self): ... SharedProcPool().max_proc_units Show source in shared_proc_pool.py:74 Signature @max_proc_units.setter def max_proc_units(self, value): ... SharedProcPool().name Show source in shared_proc_pool.py:60 The name of the processor pool. Signature @property def name(self): ... SharedProcPool().name Show source in shared_proc_pool.py:65 Signature @name.setter def name(self, value): ... SharedProcPool().pend_rsrv_proc_units Show source in shared_proc_pool.py:78 Floating point number of pending reserved proc units. Signature @property def pend_rsrv_proc_units(self): ... SharedProcPool().pend_rsrv_proc_units Show source in shared_proc_pool.py:83 Signature @pend_rsrv_proc_units.setter def pend_rsrv_proc_units(self, value): ...","title":"SharedProcPool"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpool","text":"Pypowervm Index / Pypowervm / Wrappers / SharedProcPool Auto-generated documentation for pypowervm.wrappers.shared_proc_pool module. SharedProcPool SharedProcPool SharedProcPool().avail_proc_units SharedProcPool().curr_rsrv_proc_units SharedProcPool().id SharedProcPool().is_default SharedProcPool().max_proc_units SharedProcPool().max_proc_units SharedProcPool().name SharedProcPool().name SharedProcPool().pend_rsrv_proc_units SharedProcPool().pend_rsrv_proc_units","title":"SharedProcPool"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpool_1","text":"Show source in shared_proc_pool.py:43","title":"SharedProcPool"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature","text":"class SharedProcPool(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpoolavail_proc_units","text":"Show source in shared_proc_pool.py:88 Returns the available proc units in the pool. If the default pool, will return 0.","title":"SharedProcPool().avail_proc_units"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature_1","text":"@property def avail_proc_units(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpoolcurr_rsrv_proc_units","text":"Show source in shared_proc_pool.py:50 Floating point number of reserved processing units.","title":"SharedProcPool().curr_rsrv_proc_units"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature_2","text":"@property def curr_rsrv_proc_units(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpoolid","text":"Show source in shared_proc_pool.py:45 Integer shared processor pool ID.","title":"SharedProcPool().id"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature_3","text":"@property def id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpoolis_default","text":"Show source in shared_proc_pool.py:55 If true, is the default processor pool.","title":"SharedProcPool().is_default"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature_4","text":"@property def is_default(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpoolmax_proc_units","text":"Show source in shared_proc_pool.py:69 Floating point number of the max processing units.","title":"SharedProcPool().max_proc_units"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature_5","text":"@property def max_proc_units(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpoolmax_proc_units_1","text":"Show source in shared_proc_pool.py:74","title":"SharedProcPool().max_proc_units"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature_6","text":"@max_proc_units.setter def max_proc_units(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpoolname","text":"Show source in shared_proc_pool.py:60 The name of the processor pool.","title":"SharedProcPool().name"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature_7","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpoolname_1","text":"Show source in shared_proc_pool.py:65","title":"SharedProcPool().name"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature_8","text":"@name.setter def name(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpoolpend_rsrv_proc_units","text":"Show source in shared_proc_pool.py:78 Floating point number of pending reserved proc units.","title":"SharedProcPool().pend_rsrv_proc_units"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature_9","text":"@property def pend_rsrv_proc_units(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/shared_proc_pool/#sharedprocpoolpend_rsrv_proc_units_1","text":"Show source in shared_proc_pool.py:83","title":"SharedProcPool().pend_rsrv_proc_units"},{"location":"pypowervm/wrappers/shared_proc_pool/#signature_10","text":"@pend_rsrv_proc_units.setter def pend_rsrv_proc_units(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/","text":"Storage Pypowervm Index / Pypowervm / Wrappers / Storage Auto-generated documentation for pypowervm.wrappers.storage module. Attributes ANY_SLOT - \"Any\" server adapters are SCSI adapters without client adapters that map to remote LPAR slot number 65535. They can map to any client and are not recommended but are still supported.: 65535 DISK_ROOT - Virtual Disk Constants: 'VirtualDisk' PVS - Physical Volume Constants: 'PhysicalVolumes' VOPT_ROOT - Virtual Optical Media Constants: 'VirtualOpticalMedia' CLIENT_ADPT - Virtual Adapter Constants: 'ClientAdapter' LV - Alias for VDisk making it explicit that it's a Logical Volume type: VDisk Storage BackStoreType FileFormatType FileIO FileIO.bld_ref FileIO().path LU LUEnt LUTargetDev LUType PV PV().avail_for_use PV.bld PV().capacity PV().description PV().emulate_model PV().emulate_model PV().is_fc_backed PV().loc_code PV().name PV().name PV().pg83 PV().state PV().tag PV().tag PV().udid PV().udid PVState PVTargetDev RBD RBD.bld_ref SSP SSP.bld SSP().capacity SSP().free_space SSP().logical_units SSP().logical_units SSP().name SSP().name SSP().over_commit_space SSP().physical_volumes SSP().physical_volumes SSP().total_lu_size SSP().udid Tier Tier().capacity Tier().is_default Tier().name Tier().ssp_uuid Tier().udid VClientStorageAdapterElement VDisk VDisk.bld VDisk.bld_ref VDisk().vg_uri VDiskTargetDev VDiskType VFCClientAdapter VFCClientAdapterElement VFCClientAdapterElement.bld VFCServerAdapterElement VFCServerAdapterElement().lpar_id VFCServerAdapterElement().lpar_slot_num VFCServerAdapterElement().map_port VFCServerAdapterElement().vios_id VFCServerAdapterElement().vios_slot_num VG VG().available_size VG.bld VG().capacity VG().free_space VG().name VG().name VG().phys_vols VG().phys_vols VG().serial_id VG().virtual_disks VG().virtual_disks VG().vmedia_repos VG().vmedia_repos VMediaRepos VMediaRepos.bld VMediaRepos().name VMediaRepos().optical_media VMediaRepos().optical_media VMediaRepos().size VOptMedia VOptMedia.bld VOptMedia.bld_ref VOptMedia().media_name VOptMedia().mount_type VOptMedia().name VOptMedia().size VOptMedia().udid VOptTargetDev VSCSIClientAdapterElement VSCSIClientAdapterElement().vios_id VSCSIClientAdapterElement().vios_slot_num VSCSIServerAdapterElement VSCSIServerAdapterElement().backing_dev_name VSCSIServerAdapterElement().lpar_id VSCSIServerAdapterElement().lpar_slot_num VSCSIServerAdapterElement().vios_id VSCSIServerAdapterElement().vios_slot_num VServerStorageAdapterElement VServerStorageAdapterElement.bld VServerStorageAdapterElement().name VServerStorageAdapterElement().udid BackStoreType Show source in storage.py:107 Attributes FILE_IO - A kernel-space handler that supports raw files.: 'fileio' USER_QCOW - A user-space handler that supports RAW, QCOW or QCOW2 files.: 'user:qcow' LOOP - Create a loop device for the file, and use the kernel-space block handler. LOOP has higher performance than FILE_IO.: 'loop' USER_RBD - A user-space handler that supports rbd. (Used with RBD): 'user:rbd' From BackStoreType.Enum Desribes the type of backstore handler to use for VDisks. FILE_IO, USER_QCOW, and LOOP are used with the FileIO VDisk type. USER_RBD is used with the RBD VDisk type. Signature class BackStoreType(object): ... FileFormatType Show source in storage.py:125 From FileFormatType.Enum The format type of the image that will be stored in the VDisk (aka LV). Signature class FileFormatType(object): ... FileIO Show source in storage.py:1015 Attributes bld - Maintained for backward compatibility. FileIOs aren't created by REST.: bld_ref A special case of VirtualDisk representing a File I/O object. Do not PUT (.create) this wrapper directly. Attach it to a VSCSIMapping and PUT that instead. Signature class FileIO(_VDisk): ... FileIO.bld_ref Show source in storage.py:1023 Creates a FileIO reference for inclusion in a VSCSIMapping. Arguments adapter - A pypowervm.adapter.Adapter for the REST API. FileIO().path - The file system path of the File I/O object. backstore_type - The type of backing storage, one of the BackStoreType enum values. tag - String with which to tag the device upon mapping. emulate_model - Boolean emulate model alias flag to set on the physical device upon mapping. Returns An Element that can be attached to a VSCSIMapping to create a File I/O mapping on the server. Signature @classmethod def bld_ref(cls, adapter, path, backstore_type=None, tag=None, emulate_model=None): ... FileIO().path Show source in storage.py:1053 Alias for 'label'. Signature @property def path(self): ... LU Show source in storage.py:1337 ElementWrapper representing a LogicalUnit DETAIL object. LogicalUnit exists as a DETAIL object e.g. within a SharedStoragePool (accessed via SSP.logical_units[n]) or a SCSI mapping (accessed via VIOS.scsi_mappings[n].backing_storage). Signature class LU(_LUBase, ewrap.ElementWrapper): ... LUEnt Show source in storage.py:1348 EntryWrapper representing a LogicalUnit as a first-class REST object. LogicalUnit exists as a CHILD REST object under Tier. This class provides the ability to perform e.g. LUEnt.get(adapter, parent=tier) Signature class LUEnt(_LUBase, ewrap.EntryWrapper): ... LUTargetDev Show source in storage.py:533 SSP Logical Unit Virtual Target Device for a VSCSIMapping. Signature class LUTargetDev(_VTargetDevMethods, ewrap.ElementWrapper): ... LUType Show source in storage.py:216 Signature class LUType(object): ... PV Show source in storage.py:769 A physical volume that backs a Volume Group. Signature class PV(ewrap.ElementWrapper, _StorageQoS, _StorageEncryption): ... PV().avail_for_use Show source in storage.py:842 Signature @property def avail_for_use(self): ... PV.bld Show source in storage.py:773 Creates the a fresh PV wrapper. This should be used when wishing to add physical volumes to a Volume Group. Only the name is required. The other attributes are generated from the system. The name matches the device name on the system. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) PV().name - The name of the physical volume on the Virtual I/O Server to add to the Volume Group. Ex. 'hdisk1'. PV().udid - Universal Disk Identifier. PV().tag - String with which to tag the physical device upon mapping. PV().emulate_model - Boolean emulate model alias flag to set on the physical device upon mapping. Returns An Element that can be used for a PhysicalVolume create or mapping. Signature @classmethod def bld(cls, adapter, name, udid=None, tag=None, emulate_model=None): ... PV().capacity Show source in storage.py:813 Returns the capacity as an int in MB. Signature @property def capacity(self): ... PV().description Show source in storage.py:834 Signature @property def description(self): ... PV().emulate_model Show source in storage.py:904 Signature @property def emulate_model(self): ... PV().emulate_model Show source in storage.py:908 Set the emulate model alias flag on the storage element. NOTE: This is only to be used when adding the storage element to a VSCSI mapping. It is ignored by .update(). Signature @emulate_model.setter def emulate_model(self, em): ... PV().is_fc_backed Show source in storage.py:830 Signature @property def is_fc_backed(self): ... PV().loc_code Show source in storage.py:838 Signature @property def loc_code(self): ... PV().name Show source in storage.py:818 Signature @property def name(self): ... PV().name Show source in storage.py:822 Signature @name.setter def name(self, newname): ... PV().pg83 Show source in storage.py:846 Signature @property def pg83(self): ... PV().state Show source in storage.py:826 Signature @property def state(self): ... PV().tag Show source in storage.py:891 Signature @property def tag(self): ... PV().tag Show source in storage.py:895 Set the tag on the storage element. NOTE: This is only to be used when adding the storage element to a VSCSI mapping. It is ignored by .update(). Signature @tag.setter def tag(self, tag): ... PV().udid Show source in storage.py:804 The unique device id. Signature @property def udid(self): ... PV().udid Show source in storage.py:809 Signature @udid.setter def udid(self, new_udid): ... PVState Show source in storage.py:160 Signature class PVState(object): ... PVTargetDev Show source in storage.py:539 Physical Volume Virtual Target Device for a VSCSIMapping. Signature class PVTargetDev(_VTargetDevMethods, ewrap.ElementWrapper): ... RBD Show source in storage.py:1061 A special case of VirtualDisk representing an RBD object. Do not PUT (.create) this wrapper directly. Attach it to a VSCSIMapping and PUT that instead. Signature class RBD(_VDisk): ... RBD.bld_ref Show source in storage.py:1069 Creates a RBD reference for inclusion in a VSCSIMapping. Arguments adapter - A pypowervm.adapter.Adapter for the REST API. name - The name of the RBD object. Also used as the label. tag - String with which to tag the device upon mapping. emulate_model - Boolean emulate model alias flag to set on the physical device upon mapping. user - The user id used to access the rbd cluster. Returns An Element that can be attached to a VSCSIMapping to create a RBD mapping on the server. Signature @classmethod def bld_ref(cls, adapter, name, tag=None, emulate_model=None, user=None): ... SSP Show source in storage.py:1387 A Shared Storage Pool containing PVs and LUs. Signature class SSP(ewrap.EntryWrapper): ... SSP.bld Show source in storage.py:1392 Create a fresh SSP EntryWrapper. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) SSP().name - String name for the SharedStoragePool. data_pv_list - Iterable of storage.PV instances representing the data volumes for the SharedStoragePool. Signature @classmethod def bld(cls, adapter, name, data_pv_list): ... SSP().capacity Show source in storage.py:1420 Capacity in GB as a float. Signature @property def capacity(self): ... SSP().free_space Show source in storage.py:1425 Free space in GB as a float. Signature @property def free_space(self): ... SSP().logical_units Show source in storage.py:1440 WrapperElemList of LU wrappers. Signature @property def logical_units(self): ... SSP().logical_units Show source in storage.py:1445 Signature @logical_units.setter def logical_units(self, lus): ... SSP().name Show source in storage.py:1408 Signature @property def name(self): ... SSP().name Show source in storage.py:1412 Signature @name.setter def name(self, newname): ... SSP().over_commit_space Show source in storage.py:1430 Over commit space in GB as a float. Signature @property def over_commit_space(self): ... SSP().physical_volumes Show source in storage.py:1449 WrapperElemList of PV wrappers. Signature @property def physical_volumes(self): ... SSP().physical_volumes Show source in storage.py:1454 Signature @physical_volumes.setter def physical_volumes(self, pvs): ... SSP().total_lu_size Show source in storage.py:1435 Total LU size in GB as a float. Signature @property def total_lu_size(self): ... SSP().udid Show source in storage.py:1416 Signature @property def udid(self): ... Tier Show source in storage.py:1360 A storage grouping within a SharedStoragePool. Signature class Tier(ewrap.EntryWrapper): ... Tier().capacity Show source in storage.py:1375 Signature @property def capacity(self): ... Tier().is_default Show source in storage.py:1371 Signature @property def is_default(self): ... Tier().name Show source in storage.py:1363 Signature @property def name(self): ... Tier().ssp_uuid Show source in storage.py:1379 The UUID of this Tier's parent SharedStoragePool. Signature @property def ssp_uuid(self): ... Tier().udid Show source in storage.py:1367 Signature @property def udid(self): ... VClientStorageAdapterElement Show source in storage.py:1578 Parent class for Client Virtual Storage Adapter Elements. Signature class VClientStorageAdapterElement(_VClientAdapterMethods, _VStorageAdapterElement): ... VDisk Show source in storage.py:1101 A Logical Volume virtual disk that can be attached to a VM. Signature class VDisk(_VDisk, _StorageQoS, _StorageEncryption): ... VDisk.bld Show source in storage.py:1105 Creates a VDisk Wrapper for creating a new VDisk. This should be used when the user wishes to add a new Virtual Disk to the Volume Group. The flow is to use this method to lay out the attributes of the new Virtual Disk. Then add it to the Volume Group's virtual disks. Then perform an update of the Volume Group. The disk should be created by the update operation. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) name - The name of the virtual disk capacity - A float number that defines the GB of the disk. label - The generic label for the disk. Not required. base_image - UDID of virtual disk that contains source data Not required. file_format - (Optional) File format of VDisk. See FileFormatType enumeration for valid formats. tag - String with which to tag the device upon mapping. emulate_model - Boolean emulate model alias flag to set on the physical device upon mapping. Returns An Element that can be used for a VirtualDisk create. Signature @classmethod def bld( cls, adapter, name, capacity, label=None, base_image=None, file_format=None, tag=None, emulate_model=None, ): ... VDisk.bld_ref Show source in storage.py:1145 Creates a VDisk Wrapper for referring to an existing VDisk. Signature @classmethod def bld_ref(cls, adapter, name, tag=None, emulate_model=None): ... VDisk().vg_uri Show source in storage.py:1157 Signature @property def vg_uri(self): ... VDiskTargetDev Show source in storage.py:545 Virtual Disk (Logical Volume) Target Device for a VSCSIMapping. Signature class VDiskTargetDev(_VTargetDevMethods, ewrap.ElementWrapper): ... VDiskType Show source in storage.py:100 From VirtualDiskType.Enum. Signature class VDiskType(object): ... VFCClientAdapter Show source in storage.py:1728 EntryWrapper for VirtualFibreChannelClientAdapter CHILD. Use this to wrap LogicalPartition/{uuid}/VirtualFibreChannelClientAdapter. Signature class VFCClientAdapter( _VStorageAdapterEntry, _VClientAdapterMethods, _VFCClientAdapterMethods ): ... VFCClientAdapterElement Show source in storage.py:1700 The Virtual Fibre Channel Client Adapter within a VFC mapping. Paired with a VFCServerAdapterElement. Signature class VFCClientAdapterElement(VClientStorageAdapterElement, _VFCClientAdapterMethods): ... See also VClientStorageAdapterElement VFCClientAdapterElement.bld Show source in storage.py:1707 Create a fresh Virtual Fibre Channel Client Adapter. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) wwpns - An optional set of two client WWPNs to set on the adapter. slot_num - An optional integer to be set as the Virtual slot number. Signature @classmethod def bld(cls, adapter, wwpns=None, slot_num=None): ... VFCServerAdapterElement Show source in storage.py:1738 The Virtual Fibre Channel Server Adapter within a VFC mapping. Paired with a VFCClientAdapterElement. Signature class VFCServerAdapterElement(VServerStorageAdapterElement): ... See also VServerStorageAdapterElement VFCServerAdapterElement().lpar_id Show source in storage.py:1749 The short ID (not UUID) of the LPAR side of this adapter. Signature @property def lpar_id(self): ... VFCServerAdapterElement().lpar_slot_num Show source in storage.py:1759 The (int) slot number that the LPAR side of the adapter. Signature @property def lpar_slot_num(self): ... VFCServerAdapterElement().map_port Show source in storage.py:1744 The physical FC port name that this virtual port is connect to. Signature @property def map_port(self): ... VFCServerAdapterElement().vios_id Show source in storage.py:1754 The short ID (not UUID) of the VIOS side of this adapter. Signature @property def vios_id(self): ... VFCServerAdapterElement().vios_slot_num Show source in storage.py:1764 The (int) slot number of the VIOS side of the adapter. Signature @property def vios_slot_num(self): ... VG Show source in storage.py:343 Represents a Volume Group that resides on the Virtual I/O Server. Signature class VG(ewrap.EntryWrapper): ... VG().available_size Show source in storage.py:366 Available size for new volumes in GB (float). Signature @property def available_size(self): ... VG.bld Show source in storage.py:346 Signature @classmethod def bld(cls, adapter, name, pv_list): ... VG().capacity Show source in storage.py:361 Overall capacity in GB (float). Signature @property def capacity(self): ... VG().free_space Show source in storage.py:371 Current free space in GB (float). Signature @property def free_space(self): ... VG().name Show source in storage.py:353 Signature @property def name(self): ... VG().name Show source in storage.py:357 Signature @name.setter def name(self, val): ... VG().phys_vols Show source in storage.py:396 Returns a list of the Physical Volumes that back this repo. Signature @property def phys_vols(self): ... VG().phys_vols Show source in storage.py:405 Replaces the physical volumes with the new value. Arguments phys_vols - A list of PV objects that will replace the existing Physcial Volumes. Signature @phys_vols.setter def phys_vols(self, phys_vols): ... VG().serial_id Show source in storage.py:376 Signature @property def serial_id(self): ... VG().virtual_disks Show source in storage.py:414 Returns a list of the Virtual Disks that are in the repo. Signature @property def virtual_disks(self): ... VG().virtual_disks Show source in storage.py:420 Replaces the virtual disks with the new value. Arguments virt_disks - A list of VDisk objects that will replace the existing Virtual Disks. Signature @virtual_disks.setter def virtual_disks(self, virt_disks): ... VG().vmedia_repos Show source in storage.py:380 Returns a list of wrappers. Signature @property def vmedia_repos(self): ... VG().vmedia_repos Show source in storage.py:387 Replaces the VirtualMediaRepositories with the new value. Arguments repos - A list of VMediaRepos objects that will replace the existing repositories. Signature @vmedia_repos.setter def vmedia_repos(self, repos): ... VMediaRepos Show source in storage.py:432 A Virtual Media Repository for a VIOS. Typically used to store an ISO file for image building. Signature class VMediaRepos(ewrap.ElementWrapper): ... VMediaRepos.bld Show source in storage.py:438 Creates a fresh VMediaRepos wrapper. This should be used when adding a new Virtual Media Repository to a Volume Group. The name and size for the media repository is required. The other attributes are generated from the system. Additionally, once created, specific VirtualOpticalMedia can be added onto the object. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) VMediaRepos().name - The name of the Virtual Media Repository. VMediaRepos().size - The size of the repository in GB (float). Returns A VMediaRepos wrapper that can be used for create. Signature @classmethod def bld(cls, adapter, name, size): ... VMediaRepos().name Show source in storage.py:473 Signature @property def name(self): ... VMediaRepos().optical_media Show source in storage.py:459 Returns a list of the VirtualOpticalMedia devices in the repo. Signature @property def optical_media(self): ... VMediaRepos().optical_media Show source in storage.py:465 Sets the list of VirtualOpticalMedia devices in the repo. Arguments new_media - The list of new VOptMedia. Signature @optical_media.setter def optical_media(self, new_media): ... VMediaRepos().size Show source in storage.py:480 Returns the size in GB (float). Signature @property def size(self): ... VOptMedia Show source in storage.py:558 A virtual optical piece of media. Signature class VOptMedia(ewrap.ElementWrapper): ... VOptMedia.bld Show source in storage.py:562 Creates a fresh VOptMedia wrapper. This should be used when adding a new VirtualOpticalMedia device to a VirtualMediaRepository. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) VOptMedia().name - The device name. VOptMedia().size - The device size in GB, decimal precision. VOptMedia().mount_type - The type of mount. Defaults to RW. Can be set to R Returns A VOptMedia wrapper that can be used for create. Signature @classmethod def bld(cls, adapter, name, size=None, mount_type=\"rw\"): ... VOptMedia.bld_ref Show source in storage.py:582 Creates a VOptMedia wrapper for referencing an existing VOpt. Signature @classmethod def bld_ref(cls, adapter, name): ... VOptMedia().media_name Show source in storage.py:589 Signature @property def media_name(self): ... VOptMedia().mount_type Show source in storage.py:613 Signature @property def mount_type(self): ... VOptMedia().name Show source in storage.py:593 Same as media_name - for consistency with other storage types. Signature @property def name(self): ... VOptMedia().size Show source in storage.py:601 Size is a float represented in GB. Signature @property def size(self): ... VOptMedia().udid Show source in storage.py:609 Signature @property def udid(self): ... VOptTargetDev Show source in storage.py:551 Virtual Optical Media Target Device for a VSCSIMapping. Signature class VOptTargetDev(_VTargetDevMethods, ewrap.ElementWrapper): ... VSCSIClientAdapterElement Show source in storage.py:1607 The Virtual SCSI Client Adapter within a VSCSI mapping. Paired with a VSCSIServerAdapterElement. Signature class VSCSIClientAdapterElement(VClientStorageAdapterElement): ... See also VClientStorageAdapterElement VSCSIClientAdapterElement().vios_id Show source in storage.py:1612 The short ID (not UUID) of the VIOS side of this adapter. Note that the VIOS ID is RemoteLogicalPartitionID on the client side, and LocalPartitionID on the server side. Signature @property def vios_id(self): ... VSCSIClientAdapterElement().vios_slot_num Show source in storage.py:1621 The (int) remote slot number of the paired adapter. Signature @property def vios_slot_num(self): ... VSCSIServerAdapterElement Show source in storage.py:1628 The Virtual SCSI Server Adapter within a VSCSI mapping. Paired with a VSCSIClientAdapterElement. Signature class VSCSIServerAdapterElement(VServerStorageAdapterElement): ... See also VServerStorageAdapterElement VSCSIServerAdapterElement().backing_dev_name Show source in storage.py:1634 The backing device name that this virtual adapter is hooked into. Signature @property def backing_dev_name(self): ... VSCSIServerAdapterElement().lpar_id Show source in storage.py:1639 The short ID (not UUID) of the LPAR side of this adapter. Note that the LPAR ID is LocalPartitionID on the client side, and RemoteLogicalPartitionID on the server side. Signature @property def lpar_id(self): ... VSCSIServerAdapterElement().lpar_slot_num Show source in storage.py:1657 The (int) slot number that the LPAR side of the adapter. Signature @property def lpar_slot_num(self): ... VSCSIServerAdapterElement().vios_id Show source in storage.py:1648 The short ID (not UUID) of the VIOS side of this adapter. Note that the VIOS ID is RemoteLogicalPartitionID on the client side, and LocalPartitionID on the server side. Signature @property def vios_id(self): ... VSCSIServerAdapterElement().vios_slot_num Show source in storage.py:1662 The (int) slot number of the VIOS side of the adapter. Signature @property def vios_slot_num(self): ... VServerStorageAdapterElement Show source in storage.py:1587 Parent class for Server Virtual Storage Adapters. Signature class VServerStorageAdapterElement(_VStorageAdapterElement): ... VServerStorageAdapterElement.bld Show source in storage.py:1590 Signature @classmethod def bld(cls, adapter): ... VServerStorageAdapterElement().name Show source in storage.py:1595 The adapter's name on the Virtual I/O Server. Signature @property def name(self): ... VServerStorageAdapterElement().udid Show source in storage.py:1600 The device's Unique Device Identifier. Signature @property def udid(self): ...","title":"Storage"},{"location":"pypowervm/wrappers/storage/#storage","text":"Pypowervm Index / Pypowervm / Wrappers / Storage Auto-generated documentation for pypowervm.wrappers.storage module.","title":"Storage"},{"location":"pypowervm/wrappers/storage/#attributes","text":"ANY_SLOT - \"Any\" server adapters are SCSI adapters without client adapters that map to remote LPAR slot number 65535. They can map to any client and are not recommended but are still supported.: 65535 DISK_ROOT - Virtual Disk Constants: 'VirtualDisk' PVS - Physical Volume Constants: 'PhysicalVolumes' VOPT_ROOT - Virtual Optical Media Constants: 'VirtualOpticalMedia' CLIENT_ADPT - Virtual Adapter Constants: 'ClientAdapter' LV - Alias for VDisk making it explicit that it's a Logical Volume type: VDisk Storage BackStoreType FileFormatType FileIO FileIO.bld_ref FileIO().path LU LUEnt LUTargetDev LUType PV PV().avail_for_use PV.bld PV().capacity PV().description PV().emulate_model PV().emulate_model PV().is_fc_backed PV().loc_code PV().name PV().name PV().pg83 PV().state PV().tag PV().tag PV().udid PV().udid PVState PVTargetDev RBD RBD.bld_ref SSP SSP.bld SSP().capacity SSP().free_space SSP().logical_units SSP().logical_units SSP().name SSP().name SSP().over_commit_space SSP().physical_volumes SSP().physical_volumes SSP().total_lu_size SSP().udid Tier Tier().capacity Tier().is_default Tier().name Tier().ssp_uuid Tier().udid VClientStorageAdapterElement VDisk VDisk.bld VDisk.bld_ref VDisk().vg_uri VDiskTargetDev VDiskType VFCClientAdapter VFCClientAdapterElement VFCClientAdapterElement.bld VFCServerAdapterElement VFCServerAdapterElement().lpar_id VFCServerAdapterElement().lpar_slot_num VFCServerAdapterElement().map_port VFCServerAdapterElement().vios_id VFCServerAdapterElement().vios_slot_num VG VG().available_size VG.bld VG().capacity VG().free_space VG().name VG().name VG().phys_vols VG().phys_vols VG().serial_id VG().virtual_disks VG().virtual_disks VG().vmedia_repos VG().vmedia_repos VMediaRepos VMediaRepos.bld VMediaRepos().name VMediaRepos().optical_media VMediaRepos().optical_media VMediaRepos().size VOptMedia VOptMedia.bld VOptMedia.bld_ref VOptMedia().media_name VOptMedia().mount_type VOptMedia().name VOptMedia().size VOptMedia().udid VOptTargetDev VSCSIClientAdapterElement VSCSIClientAdapterElement().vios_id VSCSIClientAdapterElement().vios_slot_num VSCSIServerAdapterElement VSCSIServerAdapterElement().backing_dev_name VSCSIServerAdapterElement().lpar_id VSCSIServerAdapterElement().lpar_slot_num VSCSIServerAdapterElement().vios_id VSCSIServerAdapterElement().vios_slot_num VServerStorageAdapterElement VServerStorageAdapterElement.bld VServerStorageAdapterElement().name VServerStorageAdapterElement().udid","title":"Attributes"},{"location":"pypowervm/wrappers/storage/#backstoretype","text":"Show source in storage.py:107","title":"BackStoreType"},{"location":"pypowervm/wrappers/storage/#attributes_1","text":"FILE_IO - A kernel-space handler that supports raw files.: 'fileio' USER_QCOW - A user-space handler that supports RAW, QCOW or QCOW2 files.: 'user:qcow' LOOP - Create a loop device for the file, and use the kernel-space block handler. LOOP has higher performance than FILE_IO.: 'loop' USER_RBD - A user-space handler that supports rbd. (Used with RBD): 'user:rbd' From BackStoreType.Enum Desribes the type of backstore handler to use for VDisks. FILE_IO, USER_QCOW, and LOOP are used with the FileIO VDisk type. USER_RBD is used with the RBD VDisk type.","title":"Attributes"},{"location":"pypowervm/wrappers/storage/#signature","text":"class BackStoreType(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#fileformattype","text":"Show source in storage.py:125 From FileFormatType.Enum The format type of the image that will be stored in the VDisk (aka LV).","title":"FileFormatType"},{"location":"pypowervm/wrappers/storage/#signature_1","text":"class FileFormatType(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#fileio","text":"Show source in storage.py:1015","title":"FileIO"},{"location":"pypowervm/wrappers/storage/#attributes_2","text":"bld - Maintained for backward compatibility. FileIOs aren't created by REST.: bld_ref A special case of VirtualDisk representing a File I/O object. Do not PUT (.create) this wrapper directly. Attach it to a VSCSIMapping and PUT that instead.","title":"Attributes"},{"location":"pypowervm/wrappers/storage/#signature_2","text":"class FileIO(_VDisk): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#fileiobld_ref","text":"Show source in storage.py:1023 Creates a FileIO reference for inclusion in a VSCSIMapping.","title":"FileIO.bld_ref"},{"location":"pypowervm/wrappers/storage/#arguments","text":"adapter - A pypowervm.adapter.Adapter for the REST API. FileIO().path - The file system path of the File I/O object. backstore_type - The type of backing storage, one of the BackStoreType enum values. tag - String with which to tag the device upon mapping. emulate_model - Boolean emulate model alias flag to set on the physical device upon mapping.","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#returns","text":"An Element that can be attached to a VSCSIMapping to create a File I/O mapping on the server.","title":"Returns"},{"location":"pypowervm/wrappers/storage/#signature_3","text":"@classmethod def bld_ref(cls, adapter, path, backstore_type=None, tag=None, emulate_model=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#fileiopath","text":"Show source in storage.py:1053 Alias for 'label'.","title":"FileIO().path"},{"location":"pypowervm/wrappers/storage/#signature_4","text":"@property def path(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#lu","text":"Show source in storage.py:1337 ElementWrapper representing a LogicalUnit DETAIL object. LogicalUnit exists as a DETAIL object e.g. within a SharedStoragePool (accessed via SSP.logical_units[n]) or a SCSI mapping (accessed via VIOS.scsi_mappings[n].backing_storage).","title":"LU"},{"location":"pypowervm/wrappers/storage/#signature_5","text":"class LU(_LUBase, ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#luent","text":"Show source in storage.py:1348 EntryWrapper representing a LogicalUnit as a first-class REST object. LogicalUnit exists as a CHILD REST object under Tier. This class provides the ability to perform e.g. LUEnt.get(adapter, parent=tier)","title":"LUEnt"},{"location":"pypowervm/wrappers/storage/#signature_6","text":"class LUEnt(_LUBase, ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#lutargetdev","text":"Show source in storage.py:533 SSP Logical Unit Virtual Target Device for a VSCSIMapping.","title":"LUTargetDev"},{"location":"pypowervm/wrappers/storage/#signature_7","text":"class LUTargetDev(_VTargetDevMethods, ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#lutype","text":"Show source in storage.py:216","title":"LUType"},{"location":"pypowervm/wrappers/storage/#signature_8","text":"class LUType(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pv","text":"Show source in storage.py:769 A physical volume that backs a Volume Group.","title":"PV"},{"location":"pypowervm/wrappers/storage/#signature_9","text":"class PV(ewrap.ElementWrapper, _StorageQoS, _StorageEncryption): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvavail_for_use","text":"Show source in storage.py:842","title":"PV().avail_for_use"},{"location":"pypowervm/wrappers/storage/#signature_10","text":"@property def avail_for_use(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvbld","text":"Show source in storage.py:773 Creates the a fresh PV wrapper. This should be used when wishing to add physical volumes to a Volume Group. Only the name is required. The other attributes are generated from the system. The name matches the device name on the system.","title":"PV.bld"},{"location":"pypowervm/wrappers/storage/#arguments_1","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) PV().name - The name of the physical volume on the Virtual I/O Server to add to the Volume Group. Ex. 'hdisk1'. PV().udid - Universal Disk Identifier. PV().tag - String with which to tag the physical device upon mapping. PV().emulate_model - Boolean emulate model alias flag to set on the physical device upon mapping.","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#returns_1","text":"An Element that can be used for a PhysicalVolume create or mapping.","title":"Returns"},{"location":"pypowervm/wrappers/storage/#signature_11","text":"@classmethod def bld(cls, adapter, name, udid=None, tag=None, emulate_model=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvcapacity","text":"Show source in storage.py:813 Returns the capacity as an int in MB.","title":"PV().capacity"},{"location":"pypowervm/wrappers/storage/#signature_12","text":"@property def capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvdescription","text":"Show source in storage.py:834","title":"PV().description"},{"location":"pypowervm/wrappers/storage/#signature_13","text":"@property def description(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvemulate_model","text":"Show source in storage.py:904","title":"PV().emulate_model"},{"location":"pypowervm/wrappers/storage/#signature_14","text":"@property def emulate_model(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvemulate_model_1","text":"Show source in storage.py:908 Set the emulate model alias flag on the storage element. NOTE: This is only to be used when adding the storage element to a VSCSI mapping. It is ignored by .update().","title":"PV().emulate_model"},{"location":"pypowervm/wrappers/storage/#signature_15","text":"@emulate_model.setter def emulate_model(self, em): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvis_fc_backed","text":"Show source in storage.py:830","title":"PV().is_fc_backed"},{"location":"pypowervm/wrappers/storage/#signature_16","text":"@property def is_fc_backed(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvloc_code","text":"Show source in storage.py:838","title":"PV().loc_code"},{"location":"pypowervm/wrappers/storage/#signature_17","text":"@property def loc_code(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvname","text":"Show source in storage.py:818","title":"PV().name"},{"location":"pypowervm/wrappers/storage/#signature_18","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvname_1","text":"Show source in storage.py:822","title":"PV().name"},{"location":"pypowervm/wrappers/storage/#signature_19","text":"@name.setter def name(self, newname): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvpg83","text":"Show source in storage.py:846","title":"PV().pg83"},{"location":"pypowervm/wrappers/storage/#signature_20","text":"@property def pg83(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvstate","text":"Show source in storage.py:826","title":"PV().state"},{"location":"pypowervm/wrappers/storage/#signature_21","text":"@property def state(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvtag","text":"Show source in storage.py:891","title":"PV().tag"},{"location":"pypowervm/wrappers/storage/#signature_22","text":"@property def tag(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvtag_1","text":"Show source in storage.py:895 Set the tag on the storage element. NOTE: This is only to be used when adding the storage element to a VSCSI mapping. It is ignored by .update().","title":"PV().tag"},{"location":"pypowervm/wrappers/storage/#signature_23","text":"@tag.setter def tag(self, tag): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvudid","text":"Show source in storage.py:804 The unique device id.","title":"PV().udid"},{"location":"pypowervm/wrappers/storage/#signature_24","text":"@property def udid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvudid_1","text":"Show source in storage.py:809","title":"PV().udid"},{"location":"pypowervm/wrappers/storage/#signature_25","text":"@udid.setter def udid(self, new_udid): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvstate_1","text":"Show source in storage.py:160","title":"PVState"},{"location":"pypowervm/wrappers/storage/#signature_26","text":"class PVState(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#pvtargetdev","text":"Show source in storage.py:539 Physical Volume Virtual Target Device for a VSCSIMapping.","title":"PVTargetDev"},{"location":"pypowervm/wrappers/storage/#signature_27","text":"class PVTargetDev(_VTargetDevMethods, ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#rbd","text":"Show source in storage.py:1061 A special case of VirtualDisk representing an RBD object. Do not PUT (.create) this wrapper directly. Attach it to a VSCSIMapping and PUT that instead.","title":"RBD"},{"location":"pypowervm/wrappers/storage/#signature_28","text":"class RBD(_VDisk): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#rbdbld_ref","text":"Show source in storage.py:1069 Creates a RBD reference for inclusion in a VSCSIMapping.","title":"RBD.bld_ref"},{"location":"pypowervm/wrappers/storage/#arguments_2","text":"adapter - A pypowervm.adapter.Adapter for the REST API. name - The name of the RBD object. Also used as the label. tag - String with which to tag the device upon mapping. emulate_model - Boolean emulate model alias flag to set on the physical device upon mapping. user - The user id used to access the rbd cluster.","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#returns_2","text":"An Element that can be attached to a VSCSIMapping to create a RBD mapping on the server.","title":"Returns"},{"location":"pypowervm/wrappers/storage/#signature_29","text":"@classmethod def bld_ref(cls, adapter, name, tag=None, emulate_model=None, user=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#ssp","text":"Show source in storage.py:1387 A Shared Storage Pool containing PVs and LUs.","title":"SSP"},{"location":"pypowervm/wrappers/storage/#signature_30","text":"class SSP(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#sspbld","text":"Show source in storage.py:1392 Create a fresh SSP EntryWrapper.","title":"SSP.bld"},{"location":"pypowervm/wrappers/storage/#arguments_3","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) SSP().name - String name for the SharedStoragePool. data_pv_list - Iterable of storage.PV instances representing the data volumes for the SharedStoragePool.","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#signature_31","text":"@classmethod def bld(cls, adapter, name, data_pv_list): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#sspcapacity","text":"Show source in storage.py:1420 Capacity in GB as a float.","title":"SSP().capacity"},{"location":"pypowervm/wrappers/storage/#signature_32","text":"@property def capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#sspfree_space","text":"Show source in storage.py:1425 Free space in GB as a float.","title":"SSP().free_space"},{"location":"pypowervm/wrappers/storage/#signature_33","text":"@property def free_space(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#ssplogical_units","text":"Show source in storage.py:1440 WrapperElemList of LU wrappers.","title":"SSP().logical_units"},{"location":"pypowervm/wrappers/storage/#signature_34","text":"@property def logical_units(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#ssplogical_units_1","text":"Show source in storage.py:1445","title":"SSP().logical_units"},{"location":"pypowervm/wrappers/storage/#signature_35","text":"@logical_units.setter def logical_units(self, lus): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#sspname","text":"Show source in storage.py:1408","title":"SSP().name"},{"location":"pypowervm/wrappers/storage/#signature_36","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#sspname_1","text":"Show source in storage.py:1412","title":"SSP().name"},{"location":"pypowervm/wrappers/storage/#signature_37","text":"@name.setter def name(self, newname): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#sspover_commit_space","text":"Show source in storage.py:1430 Over commit space in GB as a float.","title":"SSP().over_commit_space"},{"location":"pypowervm/wrappers/storage/#signature_38","text":"@property def over_commit_space(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#sspphysical_volumes","text":"Show source in storage.py:1449 WrapperElemList of PV wrappers.","title":"SSP().physical_volumes"},{"location":"pypowervm/wrappers/storage/#signature_39","text":"@property def physical_volumes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#sspphysical_volumes_1","text":"Show source in storage.py:1454","title":"SSP().physical_volumes"},{"location":"pypowervm/wrappers/storage/#signature_40","text":"@physical_volumes.setter def physical_volumes(self, pvs): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#ssptotal_lu_size","text":"Show source in storage.py:1435 Total LU size in GB as a float.","title":"SSP().total_lu_size"},{"location":"pypowervm/wrappers/storage/#signature_41","text":"@property def total_lu_size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#sspudid","text":"Show source in storage.py:1416","title":"SSP().udid"},{"location":"pypowervm/wrappers/storage/#signature_42","text":"@property def udid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#tier","text":"Show source in storage.py:1360 A storage grouping within a SharedStoragePool.","title":"Tier"},{"location":"pypowervm/wrappers/storage/#signature_43","text":"class Tier(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#tiercapacity","text":"Show source in storage.py:1375","title":"Tier().capacity"},{"location":"pypowervm/wrappers/storage/#signature_44","text":"@property def capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#tieris_default","text":"Show source in storage.py:1371","title":"Tier().is_default"},{"location":"pypowervm/wrappers/storage/#signature_45","text":"@property def is_default(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#tiername","text":"Show source in storage.py:1363","title":"Tier().name"},{"location":"pypowervm/wrappers/storage/#signature_46","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#tierssp_uuid","text":"Show source in storage.py:1379 The UUID of this Tier's parent SharedStoragePool.","title":"Tier().ssp_uuid"},{"location":"pypowervm/wrappers/storage/#signature_47","text":"@property def ssp_uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#tierudid","text":"Show source in storage.py:1367","title":"Tier().udid"},{"location":"pypowervm/wrappers/storage/#signature_48","text":"@property def udid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vclientstorageadapterelement","text":"Show source in storage.py:1578 Parent class for Client Virtual Storage Adapter Elements.","title":"VClientStorageAdapterElement"},{"location":"pypowervm/wrappers/storage/#signature_49","text":"class VClientStorageAdapterElement(_VClientAdapterMethods, _VStorageAdapterElement): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vdisk","text":"Show source in storage.py:1101 A Logical Volume virtual disk that can be attached to a VM.","title":"VDisk"},{"location":"pypowervm/wrappers/storage/#signature_50","text":"class VDisk(_VDisk, _StorageQoS, _StorageEncryption): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vdiskbld","text":"Show source in storage.py:1105 Creates a VDisk Wrapper for creating a new VDisk. This should be used when the user wishes to add a new Virtual Disk to the Volume Group. The flow is to use this method to lay out the attributes of the new Virtual Disk. Then add it to the Volume Group's virtual disks. Then perform an update of the Volume Group. The disk should be created by the update operation.","title":"VDisk.bld"},{"location":"pypowervm/wrappers/storage/#arguments_4","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) name - The name of the virtual disk capacity - A float number that defines the GB of the disk. label - The generic label for the disk. Not required. base_image - UDID of virtual disk that contains source data Not required. file_format - (Optional) File format of VDisk. See FileFormatType enumeration for valid formats. tag - String with which to tag the device upon mapping. emulate_model - Boolean emulate model alias flag to set on the physical device upon mapping.","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#returns_3","text":"An Element that can be used for a VirtualDisk create.","title":"Returns"},{"location":"pypowervm/wrappers/storage/#signature_51","text":"@classmethod def bld( cls, adapter, name, capacity, label=None, base_image=None, file_format=None, tag=None, emulate_model=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vdiskbld_ref","text":"Show source in storage.py:1145 Creates a VDisk Wrapper for referring to an existing VDisk.","title":"VDisk.bld_ref"},{"location":"pypowervm/wrappers/storage/#signature_52","text":"@classmethod def bld_ref(cls, adapter, name, tag=None, emulate_model=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vdiskvg_uri","text":"Show source in storage.py:1157","title":"VDisk().vg_uri"},{"location":"pypowervm/wrappers/storage/#signature_53","text":"@property def vg_uri(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vdisktargetdev","text":"Show source in storage.py:545 Virtual Disk (Logical Volume) Target Device for a VSCSIMapping.","title":"VDiskTargetDev"},{"location":"pypowervm/wrappers/storage/#signature_54","text":"class VDiskTargetDev(_VTargetDevMethods, ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vdisktype","text":"Show source in storage.py:100 From VirtualDiskType.Enum.","title":"VDiskType"},{"location":"pypowervm/wrappers/storage/#signature_55","text":"class VDiskType(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vfcclientadapter","text":"Show source in storage.py:1728 EntryWrapper for VirtualFibreChannelClientAdapter CHILD. Use this to wrap LogicalPartition/{uuid}/VirtualFibreChannelClientAdapter.","title":"VFCClientAdapter"},{"location":"pypowervm/wrappers/storage/#signature_56","text":"class VFCClientAdapter( _VStorageAdapterEntry, _VClientAdapterMethods, _VFCClientAdapterMethods ): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vfcclientadapterelement","text":"Show source in storage.py:1700 The Virtual Fibre Channel Client Adapter within a VFC mapping. Paired with a VFCServerAdapterElement.","title":"VFCClientAdapterElement"},{"location":"pypowervm/wrappers/storage/#signature_57","text":"class VFCClientAdapterElement(VClientStorageAdapterElement, _VFCClientAdapterMethods): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#see-also","text":"VClientStorageAdapterElement","title":"See also"},{"location":"pypowervm/wrappers/storage/#vfcclientadapterelementbld","text":"Show source in storage.py:1707 Create a fresh Virtual Fibre Channel Client Adapter.","title":"VFCClientAdapterElement.bld"},{"location":"pypowervm/wrappers/storage/#arguments_5","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) wwpns - An optional set of two client WWPNs to set on the adapter. slot_num - An optional integer to be set as the Virtual slot number.","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#signature_58","text":"@classmethod def bld(cls, adapter, wwpns=None, slot_num=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vfcserveradapterelement","text":"Show source in storage.py:1738 The Virtual Fibre Channel Server Adapter within a VFC mapping. Paired with a VFCClientAdapterElement.","title":"VFCServerAdapterElement"},{"location":"pypowervm/wrappers/storage/#signature_59","text":"class VFCServerAdapterElement(VServerStorageAdapterElement): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#see-also_1","text":"VServerStorageAdapterElement","title":"See also"},{"location":"pypowervm/wrappers/storage/#vfcserveradapterelementlpar_id","text":"Show source in storage.py:1749 The short ID (not UUID) of the LPAR side of this adapter.","title":"VFCServerAdapterElement().lpar_id"},{"location":"pypowervm/wrappers/storage/#signature_60","text":"@property def lpar_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vfcserveradapterelementlpar_slot_num","text":"Show source in storage.py:1759 The (int) slot number that the LPAR side of the adapter.","title":"VFCServerAdapterElement().lpar_slot_num"},{"location":"pypowervm/wrappers/storage/#signature_61","text":"@property def lpar_slot_num(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vfcserveradapterelementmap_port","text":"Show source in storage.py:1744 The physical FC port name that this virtual port is connect to.","title":"VFCServerAdapterElement().map_port"},{"location":"pypowervm/wrappers/storage/#signature_62","text":"@property def map_port(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vfcserveradapterelementvios_id","text":"Show source in storage.py:1754 The short ID (not UUID) of the VIOS side of this adapter.","title":"VFCServerAdapterElement().vios_id"},{"location":"pypowervm/wrappers/storage/#signature_63","text":"@property def vios_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vfcserveradapterelementvios_slot_num","text":"Show source in storage.py:1764 The (int) slot number of the VIOS side of the adapter.","title":"VFCServerAdapterElement().vios_slot_num"},{"location":"pypowervm/wrappers/storage/#signature_64","text":"@property def vios_slot_num(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vg","text":"Show source in storage.py:343 Represents a Volume Group that resides on the Virtual I/O Server.","title":"VG"},{"location":"pypowervm/wrappers/storage/#signature_65","text":"class VG(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgavailable_size","text":"Show source in storage.py:366 Available size for new volumes in GB (float).","title":"VG().available_size"},{"location":"pypowervm/wrappers/storage/#signature_66","text":"@property def available_size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgbld","text":"Show source in storage.py:346","title":"VG.bld"},{"location":"pypowervm/wrappers/storage/#signature_67","text":"@classmethod def bld(cls, adapter, name, pv_list): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgcapacity","text":"Show source in storage.py:361 Overall capacity in GB (float).","title":"VG().capacity"},{"location":"pypowervm/wrappers/storage/#signature_68","text":"@property def capacity(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgfree_space","text":"Show source in storage.py:371 Current free space in GB (float).","title":"VG().free_space"},{"location":"pypowervm/wrappers/storage/#signature_69","text":"@property def free_space(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgname","text":"Show source in storage.py:353","title":"VG().name"},{"location":"pypowervm/wrappers/storage/#signature_70","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgname_1","text":"Show source in storage.py:357","title":"VG().name"},{"location":"pypowervm/wrappers/storage/#signature_71","text":"@name.setter def name(self, val): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgphys_vols","text":"Show source in storage.py:396 Returns a list of the Physical Volumes that back this repo.","title":"VG().phys_vols"},{"location":"pypowervm/wrappers/storage/#signature_72","text":"@property def phys_vols(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgphys_vols_1","text":"Show source in storage.py:405 Replaces the physical volumes with the new value.","title":"VG().phys_vols"},{"location":"pypowervm/wrappers/storage/#arguments_6","text":"phys_vols - A list of PV objects that will replace the existing Physcial Volumes.","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#signature_73","text":"@phys_vols.setter def phys_vols(self, phys_vols): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgserial_id","text":"Show source in storage.py:376","title":"VG().serial_id"},{"location":"pypowervm/wrappers/storage/#signature_74","text":"@property def serial_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgvirtual_disks","text":"Show source in storage.py:414 Returns a list of the Virtual Disks that are in the repo.","title":"VG().virtual_disks"},{"location":"pypowervm/wrappers/storage/#signature_75","text":"@property def virtual_disks(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgvirtual_disks_1","text":"Show source in storage.py:420 Replaces the virtual disks with the new value.","title":"VG().virtual_disks"},{"location":"pypowervm/wrappers/storage/#arguments_7","text":"virt_disks - A list of VDisk objects that will replace the existing Virtual Disks.","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#signature_76","text":"@virtual_disks.setter def virtual_disks(self, virt_disks): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgvmedia_repos","text":"Show source in storage.py:380 Returns a list of wrappers.","title":"VG().vmedia_repos"},{"location":"pypowervm/wrappers/storage/#signature_77","text":"@property def vmedia_repos(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vgvmedia_repos_1","text":"Show source in storage.py:387 Replaces the VirtualMediaRepositories with the new value.","title":"VG().vmedia_repos"},{"location":"pypowervm/wrappers/storage/#arguments_8","text":"repos - A list of VMediaRepos objects that will replace the existing repositories.","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#signature_78","text":"@vmedia_repos.setter def vmedia_repos(self, repos): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vmediarepos","text":"Show source in storage.py:432 A Virtual Media Repository for a VIOS. Typically used to store an ISO file for image building.","title":"VMediaRepos"},{"location":"pypowervm/wrappers/storage/#signature_79","text":"class VMediaRepos(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vmediareposbld","text":"Show source in storage.py:438 Creates a fresh VMediaRepos wrapper. This should be used when adding a new Virtual Media Repository to a Volume Group. The name and size for the media repository is required. The other attributes are generated from the system. Additionally, once created, specific VirtualOpticalMedia can be added onto the object.","title":"VMediaRepos.bld"},{"location":"pypowervm/wrappers/storage/#arguments_9","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) VMediaRepos().name - The name of the Virtual Media Repository. VMediaRepos().size - The size of the repository in GB (float).","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#returns_4","text":"A VMediaRepos wrapper that can be used for create.","title":"Returns"},{"location":"pypowervm/wrappers/storage/#signature_80","text":"@classmethod def bld(cls, adapter, name, size): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vmediareposname","text":"Show source in storage.py:473","title":"VMediaRepos().name"},{"location":"pypowervm/wrappers/storage/#signature_81","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vmediareposoptical_media","text":"Show source in storage.py:459 Returns a list of the VirtualOpticalMedia devices in the repo.","title":"VMediaRepos().optical_media"},{"location":"pypowervm/wrappers/storage/#signature_82","text":"@property def optical_media(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vmediareposoptical_media_1","text":"Show source in storage.py:465 Sets the list of VirtualOpticalMedia devices in the repo.","title":"VMediaRepos().optical_media"},{"location":"pypowervm/wrappers/storage/#arguments_10","text":"new_media - The list of new VOptMedia.","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#signature_83","text":"@optical_media.setter def optical_media(self, new_media): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vmediarepossize","text":"Show source in storage.py:480 Returns the size in GB (float).","title":"VMediaRepos().size"},{"location":"pypowervm/wrappers/storage/#signature_84","text":"@property def size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#voptmedia","text":"Show source in storage.py:558 A virtual optical piece of media.","title":"VOptMedia"},{"location":"pypowervm/wrappers/storage/#signature_85","text":"class VOptMedia(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#voptmediabld","text":"Show source in storage.py:562 Creates a fresh VOptMedia wrapper. This should be used when adding a new VirtualOpticalMedia device to a VirtualMediaRepository.","title":"VOptMedia.bld"},{"location":"pypowervm/wrappers/storage/#arguments_11","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) VOptMedia().name - The device name. VOptMedia().size - The device size in GB, decimal precision. VOptMedia().mount_type - The type of mount. Defaults to RW. Can be set to R","title":"Arguments"},{"location":"pypowervm/wrappers/storage/#returns_5","text":"A VOptMedia wrapper that can be used for create.","title":"Returns"},{"location":"pypowervm/wrappers/storage/#signature_86","text":"@classmethod def bld(cls, adapter, name, size=None, mount_type=\"rw\"): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#voptmediabld_ref","text":"Show source in storage.py:582 Creates a VOptMedia wrapper for referencing an existing VOpt.","title":"VOptMedia.bld_ref"},{"location":"pypowervm/wrappers/storage/#signature_87","text":"@classmethod def bld_ref(cls, adapter, name): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#voptmediamedia_name","text":"Show source in storage.py:589","title":"VOptMedia().media_name"},{"location":"pypowervm/wrappers/storage/#signature_88","text":"@property def media_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#voptmediamount_type","text":"Show source in storage.py:613","title":"VOptMedia().mount_type"},{"location":"pypowervm/wrappers/storage/#signature_89","text":"@property def mount_type(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#voptmedianame","text":"Show source in storage.py:593 Same as media_name - for consistency with other storage types.","title":"VOptMedia().name"},{"location":"pypowervm/wrappers/storage/#signature_90","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#voptmediasize","text":"Show source in storage.py:601 Size is a float represented in GB.","title":"VOptMedia().size"},{"location":"pypowervm/wrappers/storage/#signature_91","text":"@property def size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#voptmediaudid","text":"Show source in storage.py:609","title":"VOptMedia().udid"},{"location":"pypowervm/wrappers/storage/#signature_92","text":"@property def udid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vopttargetdev","text":"Show source in storage.py:551 Virtual Optical Media Target Device for a VSCSIMapping.","title":"VOptTargetDev"},{"location":"pypowervm/wrappers/storage/#signature_93","text":"class VOptTargetDev(_VTargetDevMethods, ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vscsiclientadapterelement","text":"Show source in storage.py:1607 The Virtual SCSI Client Adapter within a VSCSI mapping. Paired with a VSCSIServerAdapterElement.","title":"VSCSIClientAdapterElement"},{"location":"pypowervm/wrappers/storage/#signature_94","text":"class VSCSIClientAdapterElement(VClientStorageAdapterElement): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#see-also_2","text":"VClientStorageAdapterElement","title":"See also"},{"location":"pypowervm/wrappers/storage/#vscsiclientadapterelementvios_id","text":"Show source in storage.py:1612 The short ID (not UUID) of the VIOS side of this adapter. Note that the VIOS ID is RemoteLogicalPartitionID on the client side, and LocalPartitionID on the server side.","title":"VSCSIClientAdapterElement().vios_id"},{"location":"pypowervm/wrappers/storage/#signature_95","text":"@property def vios_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vscsiclientadapterelementvios_slot_num","text":"Show source in storage.py:1621 The (int) remote slot number of the paired adapter.","title":"VSCSIClientAdapterElement().vios_slot_num"},{"location":"pypowervm/wrappers/storage/#signature_96","text":"@property def vios_slot_num(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vscsiserveradapterelement","text":"Show source in storage.py:1628 The Virtual SCSI Server Adapter within a VSCSI mapping. Paired with a VSCSIClientAdapterElement.","title":"VSCSIServerAdapterElement"},{"location":"pypowervm/wrappers/storage/#signature_97","text":"class VSCSIServerAdapterElement(VServerStorageAdapterElement): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#see-also_3","text":"VServerStorageAdapterElement","title":"See also"},{"location":"pypowervm/wrappers/storage/#vscsiserveradapterelementbacking_dev_name","text":"Show source in storage.py:1634 The backing device name that this virtual adapter is hooked into.","title":"VSCSIServerAdapterElement().backing_dev_name"},{"location":"pypowervm/wrappers/storage/#signature_98","text":"@property def backing_dev_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vscsiserveradapterelementlpar_id","text":"Show source in storage.py:1639 The short ID (not UUID) of the LPAR side of this adapter. Note that the LPAR ID is LocalPartitionID on the client side, and RemoteLogicalPartitionID on the server side.","title":"VSCSIServerAdapterElement().lpar_id"},{"location":"pypowervm/wrappers/storage/#signature_99","text":"@property def lpar_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vscsiserveradapterelementlpar_slot_num","text":"Show source in storage.py:1657 The (int) slot number that the LPAR side of the adapter.","title":"VSCSIServerAdapterElement().lpar_slot_num"},{"location":"pypowervm/wrappers/storage/#signature_100","text":"@property def lpar_slot_num(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vscsiserveradapterelementvios_id","text":"Show source in storage.py:1648 The short ID (not UUID) of the VIOS side of this adapter. Note that the VIOS ID is RemoteLogicalPartitionID on the client side, and LocalPartitionID on the server side.","title":"VSCSIServerAdapterElement().vios_id"},{"location":"pypowervm/wrappers/storage/#signature_101","text":"@property def vios_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vscsiserveradapterelementvios_slot_num","text":"Show source in storage.py:1662 The (int) slot number of the VIOS side of the adapter.","title":"VSCSIServerAdapterElement().vios_slot_num"},{"location":"pypowervm/wrappers/storage/#signature_102","text":"@property def vios_slot_num(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vserverstorageadapterelement","text":"Show source in storage.py:1587 Parent class for Server Virtual Storage Adapters.","title":"VServerStorageAdapterElement"},{"location":"pypowervm/wrappers/storage/#signature_103","text":"class VServerStorageAdapterElement(_VStorageAdapterElement): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vserverstorageadapterelementbld","text":"Show source in storage.py:1590","title":"VServerStorageAdapterElement.bld"},{"location":"pypowervm/wrappers/storage/#signature_104","text":"@classmethod def bld(cls, adapter): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vserverstorageadapterelementname","text":"Show source in storage.py:1595 The adapter's name on the Virtual I/O Server.","title":"VServerStorageAdapterElement().name"},{"location":"pypowervm/wrappers/storage/#signature_105","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/storage/#vserverstorageadapterelementudid","text":"Show source in storage.py:1600 The device's Unique Device Identifier.","title":"VServerStorageAdapterElement().udid"},{"location":"pypowervm/wrappers/storage/#signature_106","text":"@property def udid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/","text":"Vios File Pypowervm Index / Pypowervm / Wrappers / Vios File Auto-generated documentation for pypowervm.wrappers.vios_file module. Vios File File File().asset_file File.bld File().current_file_size File().date_modified File().enum_type File().expected_file_size File().file_name File().file_uuid File().internet_media_type File().tdev_udid File().vios_uuid FileType File Show source in vios_file.py:47 Wraps the File Metadata for files on the VIOS. The API supports passing a File up to devices on the Virtual I/O Server. This object wraps the metadata for the Files. Signature class File(ewrap.EntryWrapper): ... File().asset_file Show source in vios_file.py:154 Used to identify the asset file on upload. Only used in conjunction with DISK_IMAGE_COORDINATED. Provides the path to a file on the local system where data can be sent during an upload operation. This is used for significant speed improvements as the REST API server does not need to be involved with the upload. Signature @property def asset_file(self): ... File.bld Show source in vios_file.py:54 Creates a fresh File wrapper that can be used for a create action. Arguments adapter - A pypowervm.adapter.Adapter (for traits, etc.) f_name - The name for the file. f_type - The type of the file. One of the FileType values. v_uuid - The UUID for the Virtual I/O Server that the file will reside on. sha_chksum - (OPTIONAL) The SHA256 checksum for the file. Useful for integrity checks. f_size - (OPTIONAL) The size in bytes of the file to upload. Can be an int or a String (that represents an integer number). Useful for integrity checks. File().tdev_udid - The device UDID that the file will back into. Returns The newly created File wrapper. Signature @classmethod def bld( cls, adapter, f_name, f_type, v_uuid, sha_chksum=None, f_size=None, tdev_udid=None ): ... File().current_file_size Show source in vios_file.py:125 Signature @property def current_file_size(self): ... File().date_modified Show source in vios_file.py:101 Signature @property def date_modified(self): ... File().enum_type Show source in vios_file.py:129 The type of the file. One of the FileType values. Signature @property def enum_type(self): ... File().expected_file_size Show source in vios_file.py:118 Signature @property def expected_file_size(self): ... File().file_name Show source in vios_file.py:94 Signature @property def file_name(self): ... File().file_uuid Show source in vios_file.py:113 The file's UUID (different from the entries). Signature @property def file_uuid(self): ... File().internet_media_type Show source in vios_file.py:105 Typically 'application/octet-stream'. Signature @property def internet_media_type(self): ... File().tdev_udid Show source in vios_file.py:147 Signature @property def tdev_udid(self): ... File().vios_uuid Show source in vios_file.py:140 Signature @property def vios_uuid(self): ... FileType Show source in vios_file.py:38 Attributes DISK_IMAGE_COORDINATED - Obsolete. Behaves the same as DISK_IMAGE.: 'BROKERED_DISK_IMAGE' Supported file types. Signature class FileType(object): ...","title":"Vios File"},{"location":"pypowervm/wrappers/vios_file/#vios-file","text":"Pypowervm Index / Pypowervm / Wrappers / Vios File Auto-generated documentation for pypowervm.wrappers.vios_file module. Vios File File File().asset_file File.bld File().current_file_size File().date_modified File().enum_type File().expected_file_size File().file_name File().file_uuid File().internet_media_type File().tdev_udid File().vios_uuid FileType","title":"Vios File"},{"location":"pypowervm/wrappers/vios_file/#file","text":"Show source in vios_file.py:47 Wraps the File Metadata for files on the VIOS. The API supports passing a File up to devices on the Virtual I/O Server. This object wraps the metadata for the Files.","title":"File"},{"location":"pypowervm/wrappers/vios_file/#signature","text":"class File(ewrap.EntryWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#fileasset_file","text":"Show source in vios_file.py:154 Used to identify the asset file on upload. Only used in conjunction with DISK_IMAGE_COORDINATED. Provides the path to a file on the local system where data can be sent during an upload operation. This is used for significant speed improvements as the REST API server does not need to be involved with the upload.","title":"File().asset_file"},{"location":"pypowervm/wrappers/vios_file/#signature_1","text":"@property def asset_file(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#filebld","text":"Show source in vios_file.py:54 Creates a fresh File wrapper that can be used for a create action.","title":"File.bld"},{"location":"pypowervm/wrappers/vios_file/#arguments","text":"adapter - A pypowervm.adapter.Adapter (for traits, etc.) f_name - The name for the file. f_type - The type of the file. One of the FileType values. v_uuid - The UUID for the Virtual I/O Server that the file will reside on. sha_chksum - (OPTIONAL) The SHA256 checksum for the file. Useful for integrity checks. f_size - (OPTIONAL) The size in bytes of the file to upload. Can be an int or a String (that represents an integer number). Useful for integrity checks. File().tdev_udid - The device UDID that the file will back into.","title":"Arguments"},{"location":"pypowervm/wrappers/vios_file/#returns","text":"The newly created File wrapper.","title":"Returns"},{"location":"pypowervm/wrappers/vios_file/#signature_2","text":"@classmethod def bld( cls, adapter, f_name, f_type, v_uuid, sha_chksum=None, f_size=None, tdev_udid=None ): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#filecurrent_file_size","text":"Show source in vios_file.py:125","title":"File().current_file_size"},{"location":"pypowervm/wrappers/vios_file/#signature_3","text":"@property def current_file_size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#filedate_modified","text":"Show source in vios_file.py:101","title":"File().date_modified"},{"location":"pypowervm/wrappers/vios_file/#signature_4","text":"@property def date_modified(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#fileenum_type","text":"Show source in vios_file.py:129 The type of the file. One of the FileType values.","title":"File().enum_type"},{"location":"pypowervm/wrappers/vios_file/#signature_5","text":"@property def enum_type(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#fileexpected_file_size","text":"Show source in vios_file.py:118","title":"File().expected_file_size"},{"location":"pypowervm/wrappers/vios_file/#signature_6","text":"@property def expected_file_size(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#filefile_name","text":"Show source in vios_file.py:94","title":"File().file_name"},{"location":"pypowervm/wrappers/vios_file/#signature_7","text":"@property def file_name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#filefile_uuid","text":"Show source in vios_file.py:113 The file's UUID (different from the entries).","title":"File().file_uuid"},{"location":"pypowervm/wrappers/vios_file/#signature_8","text":"@property def file_uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#fileinternet_media_type","text":"Show source in vios_file.py:105 Typically 'application/octet-stream'.","title":"File().internet_media_type"},{"location":"pypowervm/wrappers/vios_file/#signature_9","text":"@property def internet_media_type(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#filetdev_udid","text":"Show source in vios_file.py:147","title":"File().tdev_udid"},{"location":"pypowervm/wrappers/vios_file/#signature_10","text":"@property def tdev_udid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#filevios_uuid","text":"Show source in vios_file.py:140","title":"File().vios_uuid"},{"location":"pypowervm/wrappers/vios_file/#signature_11","text":"@property def vios_uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/vios_file/#filetype","text":"Show source in vios_file.py:38","title":"FileType"},{"location":"pypowervm/wrappers/vios_file/#attributes","text":"DISK_IMAGE_COORDINATED - Obsolete. Behaves the same as DISK_IMAGE.: 'BROKERED_DISK_IMAGE' Supported file types.","title":"Attributes"},{"location":"pypowervm/wrappers/vios_file/#signature_12","text":"class FileType(object): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/","text":"Virtual Io Server Pypowervm Index / Pypowervm / Wrappers / Virtual Io Server Auto-generated documentation for pypowervm.wrappers.virtual_io_server module. Virtual Io Server STDev STDev.bld VFCMapping VFCMapping().backing_port VFCMapping().backing_port VFCMapping.bld VIOS VIOS.bld VIOS().can_lpm VIOS().derive_orphan_trunk_adapters VIOS().get_active_pfc_wwpns VIOS().get_pfc_wwpns VIOS().get_vfc_wwpns VIOS().hdisk_from_uuid VIOS().hdisk_reserve_policy VIOS().io_adpts_for_link_agg VIOS().ip_addresses VIOS().is_license_accepted VIOS().is_mover_service_partition VIOS().is_mover_service_partition VIOS().media_repository VIOS().pfc_ports VIOS().phys_vols VIOS().scsi_mappings VIOS().scsi_mappings VIOS().seas VIOS().trunk_adapters VIOS().vfc_mappings VIOS().vfc_mappings VIOS().vnic_capable VIOS().vnic_failover_capable VSCSIBus VSCSIBus.bld VSCSIBus.bld_from_existing VSCSIBus().mappings VSCSIBus().mappings VSCSIMapping VSCSIMapping.bld VSCSIMapping.bld_from_existing VStorageMapping VStorageMapping().client_adapter VStorageMapping().client_lpar_href VStorageMapping.crt_related_href VStorageMapping().server_adapter STDev Show source in virtual_io_server.py:554 Mapping backing storage and target device. Used as a mixin for VSCSIMapping, and first-class internal Element for VSCSIBus. Signature class STDev(_STDevMethods): ... STDev.bld Show source in virtual_io_server.py:560 Build a new STDev - only to be used with VSCSIBus. Arguments adapter - The pypowervm Adapter that will be used to create the mapping. stg_ref - The backing storage element (PV, LU, VDisk, or VOptMedia) to use in the new mapping. lua - (Optional. Default: None) Logical Unit Address to set on the TargetDevice. If None, the LUA will be assigned by the server. Should be specified for all of the VSCSIMappings for a particular bus, or none of them. Returns The newly-created STDev. Signature @classmethod def bld(cls, adapter, stg_ref, lua=None): ... VFCMapping Show source in virtual_io_server.py:749 The mapping of a VIOS FC adapter to the Client LPAR FC adapter. PowerVM provides a mechanism for Server/Client adapters to provide storage connectivity (for LPARs that do not have dedicated hardware). This mapping describes the Virtual I/O Server's Server Fibre Channel (FC) Adapter and the Client LPAR's Client FC Adapter. To create a new Client FC Adapter, create a new mapping and update the Virtual I/O Server. This will be an atomic operation that creates the adapters on the Virtual I/O Server and Client LPAR, and then maps them properly. There is no need to pre-create the adapters before creating a new mapping. Signature class VFCMapping(VStorageMapping): ... See also VStorageMapping VFCMapping().backing_port Show source in virtual_io_server.py:810 The Virtual I/O Server backing PhysicalFCPort. If None - then the vfcmap isn't done and no physical port is backing it. Signature @property def backing_port(self): ... VFCMapping().backing_port Show source in virtual_io_server.py:822 Sets the backing port. Signature @backing_port.setter def backing_port(self, value): ... VFCMapping.bld Show source in virtual_io_server.py:767 Creates the VFCMapping object to connect to a Physical FC Port. This is used when creating a new mapping between a Client LPAR and the VirtualIOServer. This creates a Fibre Channel connection between an LPAR and a physical Fibre Port. The response object should be used for creating the mapping via an adapter.update() to the Virtual I/O Server. The response object will not have the UUIDs (as those are not assigned until the update is done). This holds true for certain other elements as well. Arguments adapter - The pypowervm Adapter that will be used to create the mapping. host_uuid - The host system's UUID. client_lpar_uuid - The client LPAR's UUID that the disk should be connected to. backing_phy_port - The name of the physical FC port that backs the virtual adapter. client_wwpns - An optional set of two WWPNs that can be set upon the mapping. These represent the client VM's WWPNs on the client FC adapter. If not set, the system will dynamically generate them. lpar_slot_num - An optional integer to be used as the Virtual slot number on the client adapter Returns The new VFCMapping Wrapper. Signature @classmethod def bld( cls, adapter, host_uuid, client_lpar_uuid, backing_phy_port, client_wwpns=None, lpar_slot_num=None, ): ... VIOS Show source in virtual_io_server.py:171 Attributes xags - DEPRECATED. Use pypowervm.const.XAG and pypowervm.util.xag_attrs().: _VIOSXAGs() Signature class VIOS(bp.BasePartition): ... VIOS.bld Show source in virtual_io_server.py:176 Creates a new VIOS wrapper. Signature @classmethod def bld(cls, adapter, name, mem_cfg, proc_cfg, io_cfg=None): ... VIOS().can_lpm Show source in virtual_io_server.py:393 Determines if a partition is ready for Live Partition Migration. Returns Type: capable False, VIOS types are not LPM capable Type: reason A message that will indicate why it was not capable of LPM. Signature def can_lpm(self, host_w, migr_data=None): ... VIOS().derive_orphan_trunk_adapters Show source in virtual_io_server.py:352 Builds a list of trunk adapters not attached to a SEA. Signature def derive_orphan_trunk_adapters(self): ... VIOS().get_active_pfc_wwpns Show source in virtual_io_server.py:207 Returns a set of Physical FC Adapter WWPNs of 'active' ports. Signature def get_active_pfc_wwpns(self): ... VIOS().get_pfc_wwpns Show source in virtual_io_server.py:198 Returns a set of the Physical FC Adapter WWPNs on this VIOS. Signature def get_pfc_wwpns(self): ... VIOS().get_vfc_wwpns Show source in virtual_io_server.py:186 Returns a list of the virtual FC WWPN pairs for the vios. The response is a List of Lists. Ex. (('c05076065a8b005a', 'c05076065a8b005b'), ('c05076065a8b0060', 'c05076065a8b0061')) Note: ViosFCMapping extended attribute is required. Signature def get_vfc_wwpns(self): ... VIOS().hdisk_from_uuid Show source in virtual_io_server.py:253 Get the hdisk name from the volume uuid. Arguments disk_uuid - The uuid of the hdisk. Returns The associated hdisk name. Signature def hdisk_from_uuid(self, disk_uuid): ... VIOS().hdisk_reserve_policy Show source in virtual_io_server.py:233 Get the reserve policy for an hdisk. Arguments disk_uuid - The uuid of the hdisk. Returns The reserve policy or None if the disk isn't found. Signature def hdisk_reserve_policy(self, disk_uuid): ... VIOS().io_adpts_for_link_agg Show source in virtual_io_server.py:385 Signature @ewrap.Wrapper.xag_property(c.XAG.VIO_NET) def io_adpts_for_link_agg(self): ... VIOS().ip_addresses Show source in virtual_io_server.py:288 Returns a list of IP addresses assigned to the VIOS. Will only return the IP Addresses that can be made known to the system. This only includes online Shared Ethernet Adapters and Ethernet Backing Devices. It will not include, for example, a VLAN adapter. This is a READ-ONLY list. Signature @ewrap.Wrapper.xag_property(c.XAG.VIO_NET) def ip_addresses(self): ... VIOS().is_license_accepted Show source in virtual_io_server.py:229 Signature @property def is_license_accepted(self): ... VIOS().is_mover_service_partition Show source in virtual_io_server.py:274 Signature @property def is_mover_service_partition(self): ... VIOS().is_mover_service_partition Show source in virtual_io_server.py:278 Set the Mover Service Partition designation. Arguments value - Boolean indicating whether the VIOS should be designated as a Mover Service Partition. Signature @is_mover_service_partition.setter def is_mover_service_partition(self, value): ... VIOS().media_repository Show source in virtual_io_server.py:182 Signature @ewrap.Wrapper.xag_property(c.XAG.VIO_STOR) def media_repository(self): ... VIOS().pfc_ports Show source in virtual_io_server.py:216 The physical Fibre Channel ports assigned to the VIOS. Signature @property def pfc_ports(self): ... VIOS().phys_vols Show source in virtual_io_server.py:372 Will return a list of physical volumes attached to this VIOS. This list is READ-ONLY. Signature @ewrap.Wrapper.xag_property(c.XAG.VIO_STOR) def phys_vols(self): ... VIOS().scsi_mappings Show source in virtual_io_server.py:323 Returns a WrapperElemList of the VSCSIMapping objects. Signature @ewrap.Wrapper.xag_property(c.XAG.VIO_SMAP) def scsi_mappings(self): ... VIOS().scsi_mappings Show source in virtual_io_server.py:333 Signature @scsi_mappings.setter def scsi_mappings(self, new_mappings): ... VIOS().seas Show source in virtual_io_server.py:338 Signature @ewrap.Wrapper.xag_property(c.XAG.VIO_NET) def seas(self): ... VIOS().trunk_adapters Show source in virtual_io_server.py:344 Signature @ewrap.Wrapper.xag_property(c.XAG.VIO_NET) def trunk_adapters(self): ... VIOS().vfc_mappings Show source in virtual_io_server.py:311 Returns a WrapperElemList of the VFCMapping objects. Signature @ewrap.Wrapper.xag_property(c.XAG.VIO_FMAP) def vfc_mappings(self): ... VIOS().vfc_mappings Show source in virtual_io_server.py:318 Signature @vfc_mappings.setter def vfc_mappings(self, new_mappings): ... VIOS().vnic_capable Show source in virtual_io_server.py:402 Signature @property def vnic_capable(self): ... VIOS().vnic_failover_capable Show source in virtual_io_server.py:406 Signature @property def vnic_failover_capable(self): ... VSCSIBus Show source in virtual_io_server.py:679 Virtual SCSI Bus, first-class CHILD of VirtualIOServer. PowerVM provides a mechanism for Server/Client adapters to provide storage connectivity (for LPARs that do not have dedicated hardware). This mapping describes the Virtual I/O Server's Server SCSI Adapter and the Client LPAR's Client SCSI Adapter. To create a new Client SCSI Adapter, create a new mapping and update the Virtual I/O Server. This will be an atomic operation that creates the adapters on the Virtual I/O Server and Client LPAR, and then maps them properly. There is no need to pre-create the adapters before creating a new mapping. Signature class VSCSIBus(ewrap.EntryWrapper, VStorageMapping): ... See also VStorageMapping VSCSIBus.bld Show source in virtual_io_server.py:696 Creates a new VSCSIBus with no storage. Storage should be added afterwards by modifying stg_targets. Arguments adapter - The pypowervm Adapter that will be used to create the bus. client_lpar_uuid - The client LPAR's UUID. lpar_slot_num - (Optional, Default: None) The client slot number to use in the new mapping. If None then we let REST choose the slot number. Returns The newly-created VSCSIBus. Signature @classmethod def bld(cls, adapter, client_lpar_uuid, lpar_slot_num=None): ... VSCSIBus.bld_from_existing Show source in virtual_io_server.py:719 Clones a bus's LPAR and client/server adapters, but not storage. Arguments existing_bus - The existing VSCSIBus to clone. Returns The newly-created VSCSIBus. Signature @classmethod def bld_from_existing(cls, existing_bus): ... VSCSIBus().mappings Show source in virtual_io_server.py:737 Signature @property def mappings(self): ... VSCSIBus().mappings Show source in virtual_io_server.py:742 Signature @mappings.setter def mappings(self, stdevs): ... VSCSIMapping Show source in virtual_io_server.py:581 The mapping of a VIOS SCSI adapter to the Client LPAR SCSI adapter. PowerVM provides a mechanism for Server/Client adapters to provide storage connectivity (for LPARs that do not have dedicated hardware). This mapping describes the Virtual I/O Server's Server SCSI Adapter and the Client LPAR's Client SCSI Adapter. To create a new Client SCSI Adapter, create a new mapping and update the Virtual I/O Server. This will be an atomic operation that creates the adapters on the Virtual I/O Server and Client LPAR, and then maps them properly. There is no need to pre-create the adapters before creating a new mapping. Signature class VSCSIMapping(VStorageMapping, _STDevMethods): ... See also VStorageMapping VSCSIMapping.bld Show source in virtual_io_server.py:598 Creates a new VSCSIMapping Arguments adapter - The pypowervm Adapter that will be used to create the mapping. host_uuid - Not used. client_lpar_uuid - The client LPAR's UUID. stg_ref - The backing storage element (PV, LU, VDisk, or VOptMedia) to use in the new mapping. lpar_slot_num - (Optional, Default: None) The client slot number to use in the new mapping. If None then we let REST choose the slot number. lua - (Optional. Default: None) Logical Unit Address to set on the TargetDevice. If None, the LUA will be assigned by the server. Should be specified for all of the VSCSIMappings for a particular bus, or none of them. target_name - (Optional, Default: None) Name of the TargetDevice If None, the target_name will be assigned by the server. Returns The newly-created VSCSIMapping. Signature @classmethod def bld( cls, adapter, host_uuid, client_lpar_uuid, stg_ref, lpar_slot_num=None, lua=None, target_name=None, ): ... VSCSIMapping.bld_from_existing Show source in virtual_io_server.py:632 Clones the existing mapping, but swaps in the new storage elem. Arguments existing_map - The existing VSCSIMapping to clone. stg_ref - The backing storage element (PV, LU, VDisk, or VOptMedia) to use in the new mapping. If explicitly None, the new mapping is created with no storage. lpar_slot_num - (Optional, Default: None) The client slot number to use in the mapping. If None then the existing slot number is used. lua - (Optional. Default: None) Logical Unit Address to set on the TargetDevice. If None, the LUA will be assigned by the server. Should be specified for all of the VSCSIMappings for a particular bus, or none of them. target_name - (Optional, Default: None) Name of the TargetDevice If None, the target_name will be assigned by the server. Returns The newly-created VSCSIMapping. Signature @classmethod def bld_from_existing( cls, existing_map, stg_ref, lpar_slot_num=None, lua=None, target_name=None ): ... VStorageMapping Show source in virtual_io_server.py:413 Base class for VSCSIMapping and VFCMapping. Signature class VStorageMapping(ewrap.ElementWrapper): ... VStorageMapping().client_adapter Show source in virtual_io_server.py:448 Returns the Client side V*ClientAdapterElement. If None - then no client is connected. Signature @property def client_adapter(self): ... VStorageMapping().client_lpar_href Show source in virtual_io_server.py:437 Returns the Client LPAR (if any) URI. If None - then no client is connected. Signature @property def client_lpar_href(self): ... VStorageMapping.crt_related_href Show source in virtual_io_server.py:416 Creates the Element for the 'AssociatedLogicalPartition'. Arguments adapter - A pypowervm.adapter.Adapter. host_uuid - The UUID of the ManagedSystem. Specify None to get a ROOT link. client_lpar_uuid - The UUID of the LPAR to which the mapping is to be attached. Signature @staticmethod def crt_related_href(adapter, host_uuid, client_lpar_uuid): ... VStorageMapping().server_adapter Show source in virtual_io_server.py:463 Returns the Virtual I/O Server side V*ServerAdapterElement. Signature @property def server_adapter(self): ...","title":"Virtual Io Server"},{"location":"pypowervm/wrappers/virtual_io_server/#virtual-io-server","text":"Pypowervm Index / Pypowervm / Wrappers / Virtual Io Server Auto-generated documentation for pypowervm.wrappers.virtual_io_server module. Virtual Io Server STDev STDev.bld VFCMapping VFCMapping().backing_port VFCMapping().backing_port VFCMapping.bld VIOS VIOS.bld VIOS().can_lpm VIOS().derive_orphan_trunk_adapters VIOS().get_active_pfc_wwpns VIOS().get_pfc_wwpns VIOS().get_vfc_wwpns VIOS().hdisk_from_uuid VIOS().hdisk_reserve_policy VIOS().io_adpts_for_link_agg VIOS().ip_addresses VIOS().is_license_accepted VIOS().is_mover_service_partition VIOS().is_mover_service_partition VIOS().media_repository VIOS().pfc_ports VIOS().phys_vols VIOS().scsi_mappings VIOS().scsi_mappings VIOS().seas VIOS().trunk_adapters VIOS().vfc_mappings VIOS().vfc_mappings VIOS().vnic_capable VIOS().vnic_failover_capable VSCSIBus VSCSIBus.bld VSCSIBus.bld_from_existing VSCSIBus().mappings VSCSIBus().mappings VSCSIMapping VSCSIMapping.bld VSCSIMapping.bld_from_existing VStorageMapping VStorageMapping().client_adapter VStorageMapping().client_lpar_href VStorageMapping.crt_related_href VStorageMapping().server_adapter","title":"Virtual Io Server"},{"location":"pypowervm/wrappers/virtual_io_server/#stdev","text":"Show source in virtual_io_server.py:554 Mapping backing storage and target device. Used as a mixin for VSCSIMapping, and first-class internal Element for VSCSIBus.","title":"STDev"},{"location":"pypowervm/wrappers/virtual_io_server/#signature","text":"class STDev(_STDevMethods): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#stdevbld","text":"Show source in virtual_io_server.py:560 Build a new STDev - only to be used with VSCSIBus.","title":"STDev.bld"},{"location":"pypowervm/wrappers/virtual_io_server/#arguments","text":"adapter - The pypowervm Adapter that will be used to create the mapping. stg_ref - The backing storage element (PV, LU, VDisk, or VOptMedia) to use in the new mapping. lua - (Optional. Default: None) Logical Unit Address to set on the TargetDevice. If None, the LUA will be assigned by the server. Should be specified for all of the VSCSIMappings for a particular bus, or none of them.","title":"Arguments"},{"location":"pypowervm/wrappers/virtual_io_server/#returns","text":"The newly-created STDev.","title":"Returns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_1","text":"@classmethod def bld(cls, adapter, stg_ref, lua=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vfcmapping","text":"Show source in virtual_io_server.py:749 The mapping of a VIOS FC adapter to the Client LPAR FC adapter. PowerVM provides a mechanism for Server/Client adapters to provide storage connectivity (for LPARs that do not have dedicated hardware). This mapping describes the Virtual I/O Server's Server Fibre Channel (FC) Adapter and the Client LPAR's Client FC Adapter. To create a new Client FC Adapter, create a new mapping and update the Virtual I/O Server. This will be an atomic operation that creates the adapters on the Virtual I/O Server and Client LPAR, and then maps them properly. There is no need to pre-create the adapters before creating a new mapping.","title":"VFCMapping"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_2","text":"class VFCMapping(VStorageMapping): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#see-also","text":"VStorageMapping","title":"See also"},{"location":"pypowervm/wrappers/virtual_io_server/#vfcmappingbacking_port","text":"Show source in virtual_io_server.py:810 The Virtual I/O Server backing PhysicalFCPort. If None - then the vfcmap isn't done and no physical port is backing it.","title":"VFCMapping().backing_port"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_3","text":"@property def backing_port(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vfcmappingbacking_port_1","text":"Show source in virtual_io_server.py:822 Sets the backing port.","title":"VFCMapping().backing_port"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_4","text":"@backing_port.setter def backing_port(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vfcmappingbld","text":"Show source in virtual_io_server.py:767 Creates the VFCMapping object to connect to a Physical FC Port. This is used when creating a new mapping between a Client LPAR and the VirtualIOServer. This creates a Fibre Channel connection between an LPAR and a physical Fibre Port. The response object should be used for creating the mapping via an adapter.update() to the Virtual I/O Server. The response object will not have the UUIDs (as those are not assigned until the update is done). This holds true for certain other elements as well.","title":"VFCMapping.bld"},{"location":"pypowervm/wrappers/virtual_io_server/#arguments_1","text":"adapter - The pypowervm Adapter that will be used to create the mapping. host_uuid - The host system's UUID. client_lpar_uuid - The client LPAR's UUID that the disk should be connected to. backing_phy_port - The name of the physical FC port that backs the virtual adapter. client_wwpns - An optional set of two WWPNs that can be set upon the mapping. These represent the client VM's WWPNs on the client FC adapter. If not set, the system will dynamically generate them. lpar_slot_num - An optional integer to be used as the Virtual slot number on the client adapter","title":"Arguments"},{"location":"pypowervm/wrappers/virtual_io_server/#returns_1","text":"The new VFCMapping Wrapper.","title":"Returns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_5","text":"@classmethod def bld( cls, adapter, host_uuid, client_lpar_uuid, backing_phy_port, client_wwpns=None, lpar_slot_num=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vios","text":"Show source in virtual_io_server.py:171","title":"VIOS"},{"location":"pypowervm/wrappers/virtual_io_server/#attributes","text":"xags - DEPRECATED. Use pypowervm.const.XAG and pypowervm.util.xag_attrs().: _VIOSXAGs()","title":"Attributes"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_6","text":"class VIOS(bp.BasePartition): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosbld","text":"Show source in virtual_io_server.py:176 Creates a new VIOS wrapper.","title":"VIOS.bld"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_7","text":"@classmethod def bld(cls, adapter, name, mem_cfg, proc_cfg, io_cfg=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vioscan_lpm","text":"Show source in virtual_io_server.py:393 Determines if a partition is ready for Live Partition Migration.","title":"VIOS().can_lpm"},{"location":"pypowervm/wrappers/virtual_io_server/#returns_2","text":"Type: capable False, VIOS types are not LPM capable Type: reason A message that will indicate why it was not capable of LPM.","title":"Returns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_8","text":"def can_lpm(self, host_w, migr_data=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosderive_orphan_trunk_adapters","text":"Show source in virtual_io_server.py:352 Builds a list of trunk adapters not attached to a SEA.","title":"VIOS().derive_orphan_trunk_adapters"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_9","text":"def derive_orphan_trunk_adapters(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosget_active_pfc_wwpns","text":"Show source in virtual_io_server.py:207 Returns a set of Physical FC Adapter WWPNs of 'active' ports.","title":"VIOS().get_active_pfc_wwpns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_10","text":"def get_active_pfc_wwpns(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosget_pfc_wwpns","text":"Show source in virtual_io_server.py:198 Returns a set of the Physical FC Adapter WWPNs on this VIOS.","title":"VIOS().get_pfc_wwpns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_11","text":"def get_pfc_wwpns(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosget_vfc_wwpns","text":"Show source in virtual_io_server.py:186 Returns a list of the virtual FC WWPN pairs for the vios. The response is a List of Lists. Ex. (('c05076065a8b005a', 'c05076065a8b005b'), ('c05076065a8b0060', 'c05076065a8b0061')) Note: ViosFCMapping extended attribute is required.","title":"VIOS().get_vfc_wwpns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_12","text":"def get_vfc_wwpns(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vioshdisk_from_uuid","text":"Show source in virtual_io_server.py:253 Get the hdisk name from the volume uuid.","title":"VIOS().hdisk_from_uuid"},{"location":"pypowervm/wrappers/virtual_io_server/#arguments_2","text":"disk_uuid - The uuid of the hdisk.","title":"Arguments"},{"location":"pypowervm/wrappers/virtual_io_server/#returns_3","text":"The associated hdisk name.","title":"Returns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_13","text":"def hdisk_from_uuid(self, disk_uuid): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vioshdisk_reserve_policy","text":"Show source in virtual_io_server.py:233 Get the reserve policy for an hdisk.","title":"VIOS().hdisk_reserve_policy"},{"location":"pypowervm/wrappers/virtual_io_server/#arguments_3","text":"disk_uuid - The uuid of the hdisk.","title":"Arguments"},{"location":"pypowervm/wrappers/virtual_io_server/#returns_4","text":"The reserve policy or None if the disk isn't found.","title":"Returns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_14","text":"def hdisk_reserve_policy(self, disk_uuid): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosio_adpts_for_link_agg","text":"Show source in virtual_io_server.py:385","title":"VIOS().io_adpts_for_link_agg"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_15","text":"@ewrap.Wrapper.xag_property(c.XAG.VIO_NET) def io_adpts_for_link_agg(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosip_addresses","text":"Show source in virtual_io_server.py:288 Returns a list of IP addresses assigned to the VIOS. Will only return the IP Addresses that can be made known to the system. This only includes online Shared Ethernet Adapters and Ethernet Backing Devices. It will not include, for example, a VLAN adapter. This is a READ-ONLY list.","title":"VIOS().ip_addresses"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_16","text":"@ewrap.Wrapper.xag_property(c.XAG.VIO_NET) def ip_addresses(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosis_license_accepted","text":"Show source in virtual_io_server.py:229","title":"VIOS().is_license_accepted"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_17","text":"@property def is_license_accepted(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosis_mover_service_partition","text":"Show source in virtual_io_server.py:274","title":"VIOS().is_mover_service_partition"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_18","text":"@property def is_mover_service_partition(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosis_mover_service_partition_1","text":"Show source in virtual_io_server.py:278 Set the Mover Service Partition designation.","title":"VIOS().is_mover_service_partition"},{"location":"pypowervm/wrappers/virtual_io_server/#arguments_4","text":"value - Boolean indicating whether the VIOS should be designated as a Mover Service Partition.","title":"Arguments"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_19","text":"@is_mover_service_partition.setter def is_mover_service_partition(self, value): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosmedia_repository","text":"Show source in virtual_io_server.py:182","title":"VIOS().media_repository"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_20","text":"@ewrap.Wrapper.xag_property(c.XAG.VIO_STOR) def media_repository(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viospfc_ports","text":"Show source in virtual_io_server.py:216 The physical Fibre Channel ports assigned to the VIOS.","title":"VIOS().pfc_ports"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_21","text":"@property def pfc_ports(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosphys_vols","text":"Show source in virtual_io_server.py:372 Will return a list of physical volumes attached to this VIOS. This list is READ-ONLY.","title":"VIOS().phys_vols"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_22","text":"@ewrap.Wrapper.xag_property(c.XAG.VIO_STOR) def phys_vols(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosscsi_mappings","text":"Show source in virtual_io_server.py:323 Returns a WrapperElemList of the VSCSIMapping objects.","title":"VIOS().scsi_mappings"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_23","text":"@ewrap.Wrapper.xag_property(c.XAG.VIO_SMAP) def scsi_mappings(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosscsi_mappings_1","text":"Show source in virtual_io_server.py:333","title":"VIOS().scsi_mappings"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_24","text":"@scsi_mappings.setter def scsi_mappings(self, new_mappings): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosseas","text":"Show source in virtual_io_server.py:338","title":"VIOS().seas"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_25","text":"@ewrap.Wrapper.xag_property(c.XAG.VIO_NET) def seas(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viostrunk_adapters","text":"Show source in virtual_io_server.py:344","title":"VIOS().trunk_adapters"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_26","text":"@ewrap.Wrapper.xag_property(c.XAG.VIO_NET) def trunk_adapters(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosvfc_mappings","text":"Show source in virtual_io_server.py:311 Returns a WrapperElemList of the VFCMapping objects.","title":"VIOS().vfc_mappings"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_27","text":"@ewrap.Wrapper.xag_property(c.XAG.VIO_FMAP) def vfc_mappings(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosvfc_mappings_1","text":"Show source in virtual_io_server.py:318","title":"VIOS().vfc_mappings"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_28","text":"@vfc_mappings.setter def vfc_mappings(self, new_mappings): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosvnic_capable","text":"Show source in virtual_io_server.py:402","title":"VIOS().vnic_capable"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_29","text":"@property def vnic_capable(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#viosvnic_failover_capable","text":"Show source in virtual_io_server.py:406","title":"VIOS().vnic_failover_capable"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_30","text":"@property def vnic_failover_capable(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vscsibus","text":"Show source in virtual_io_server.py:679 Virtual SCSI Bus, first-class CHILD of VirtualIOServer. PowerVM provides a mechanism for Server/Client adapters to provide storage connectivity (for LPARs that do not have dedicated hardware). This mapping describes the Virtual I/O Server's Server SCSI Adapter and the Client LPAR's Client SCSI Adapter. To create a new Client SCSI Adapter, create a new mapping and update the Virtual I/O Server. This will be an atomic operation that creates the adapters on the Virtual I/O Server and Client LPAR, and then maps them properly. There is no need to pre-create the adapters before creating a new mapping.","title":"VSCSIBus"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_31","text":"class VSCSIBus(ewrap.EntryWrapper, VStorageMapping): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#see-also_1","text":"VStorageMapping","title":"See also"},{"location":"pypowervm/wrappers/virtual_io_server/#vscsibusbld","text":"Show source in virtual_io_server.py:696 Creates a new VSCSIBus with no storage. Storage should be added afterwards by modifying stg_targets.","title":"VSCSIBus.bld"},{"location":"pypowervm/wrappers/virtual_io_server/#arguments_5","text":"adapter - The pypowervm Adapter that will be used to create the bus. client_lpar_uuid - The client LPAR's UUID. lpar_slot_num - (Optional, Default: None) The client slot number to use in the new mapping. If None then we let REST choose the slot number.","title":"Arguments"},{"location":"pypowervm/wrappers/virtual_io_server/#returns_5","text":"The newly-created VSCSIBus.","title":"Returns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_32","text":"@classmethod def bld(cls, adapter, client_lpar_uuid, lpar_slot_num=None): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vscsibusbld_from_existing","text":"Show source in virtual_io_server.py:719 Clones a bus's LPAR and client/server adapters, but not storage.","title":"VSCSIBus.bld_from_existing"},{"location":"pypowervm/wrappers/virtual_io_server/#arguments_6","text":"existing_bus - The existing VSCSIBus to clone.","title":"Arguments"},{"location":"pypowervm/wrappers/virtual_io_server/#returns_6","text":"The newly-created VSCSIBus.","title":"Returns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_33","text":"@classmethod def bld_from_existing(cls, existing_bus): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vscsibusmappings","text":"Show source in virtual_io_server.py:737","title":"VSCSIBus().mappings"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_34","text":"@property def mappings(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vscsibusmappings_1","text":"Show source in virtual_io_server.py:742","title":"VSCSIBus().mappings"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_35","text":"@mappings.setter def mappings(self, stdevs): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vscsimapping","text":"Show source in virtual_io_server.py:581 The mapping of a VIOS SCSI adapter to the Client LPAR SCSI adapter. PowerVM provides a mechanism for Server/Client adapters to provide storage connectivity (for LPARs that do not have dedicated hardware). This mapping describes the Virtual I/O Server's Server SCSI Adapter and the Client LPAR's Client SCSI Adapter. To create a new Client SCSI Adapter, create a new mapping and update the Virtual I/O Server. This will be an atomic operation that creates the adapters on the Virtual I/O Server and Client LPAR, and then maps them properly. There is no need to pre-create the adapters before creating a new mapping.","title":"VSCSIMapping"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_36","text":"class VSCSIMapping(VStorageMapping, _STDevMethods): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#see-also_2","text":"VStorageMapping","title":"See also"},{"location":"pypowervm/wrappers/virtual_io_server/#vscsimappingbld","text":"Show source in virtual_io_server.py:598 Creates a new VSCSIMapping","title":"VSCSIMapping.bld"},{"location":"pypowervm/wrappers/virtual_io_server/#arguments_7","text":"adapter - The pypowervm Adapter that will be used to create the mapping. host_uuid - Not used. client_lpar_uuid - The client LPAR's UUID. stg_ref - The backing storage element (PV, LU, VDisk, or VOptMedia) to use in the new mapping. lpar_slot_num - (Optional, Default: None) The client slot number to use in the new mapping. If None then we let REST choose the slot number. lua - (Optional. Default: None) Logical Unit Address to set on the TargetDevice. If None, the LUA will be assigned by the server. Should be specified for all of the VSCSIMappings for a particular bus, or none of them. target_name - (Optional, Default: None) Name of the TargetDevice If None, the target_name will be assigned by the server.","title":"Arguments"},{"location":"pypowervm/wrappers/virtual_io_server/#returns_7","text":"The newly-created VSCSIMapping.","title":"Returns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_37","text":"@classmethod def bld( cls, adapter, host_uuid, client_lpar_uuid, stg_ref, lpar_slot_num=None, lua=None, target_name=None, ): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vscsimappingbld_from_existing","text":"Show source in virtual_io_server.py:632 Clones the existing mapping, but swaps in the new storage elem.","title":"VSCSIMapping.bld_from_existing"},{"location":"pypowervm/wrappers/virtual_io_server/#arguments_8","text":"existing_map - The existing VSCSIMapping to clone. stg_ref - The backing storage element (PV, LU, VDisk, or VOptMedia) to use in the new mapping. If explicitly None, the new mapping is created with no storage. lpar_slot_num - (Optional, Default: None) The client slot number to use in the mapping. If None then the existing slot number is used. lua - (Optional. Default: None) Logical Unit Address to set on the TargetDevice. If None, the LUA will be assigned by the server. Should be specified for all of the VSCSIMappings for a particular bus, or none of them. target_name - (Optional, Default: None) Name of the TargetDevice If None, the target_name will be assigned by the server.","title":"Arguments"},{"location":"pypowervm/wrappers/virtual_io_server/#returns_8","text":"The newly-created VSCSIMapping.","title":"Returns"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_38","text":"@classmethod def bld_from_existing( cls, existing_map, stg_ref, lpar_slot_num=None, lua=None, target_name=None ): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vstoragemapping","text":"Show source in virtual_io_server.py:413 Base class for VSCSIMapping and VFCMapping.","title":"VStorageMapping"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_39","text":"class VStorageMapping(ewrap.ElementWrapper): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vstoragemappingclient_adapter","text":"Show source in virtual_io_server.py:448 Returns the Client side V*ClientAdapterElement. If None - then no client is connected.","title":"VStorageMapping().client_adapter"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_40","text":"@property def client_adapter(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vstoragemappingclient_lpar_href","text":"Show source in virtual_io_server.py:437 Returns the Client LPAR (if any) URI. If None - then no client is connected.","title":"VStorageMapping().client_lpar_href"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_41","text":"@property def client_lpar_href(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vstoragemappingcrt_related_href","text":"Show source in virtual_io_server.py:416 Creates the Element for the 'AssociatedLogicalPartition'.","title":"VStorageMapping.crt_related_href"},{"location":"pypowervm/wrappers/virtual_io_server/#arguments_9","text":"adapter - A pypowervm.adapter.Adapter. host_uuid - The UUID of the ManagedSystem. Specify None to get a ROOT link. client_lpar_uuid - The UUID of the LPAR to which the mapping is to be attached.","title":"Arguments"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_42","text":"@staticmethod def crt_related_href(adapter, host_uuid, client_lpar_uuid): ...","title":"Signature"},{"location":"pypowervm/wrappers/virtual_io_server/#vstoragemappingserver_adapter","text":"Show source in virtual_io_server.py:463 Returns the Virtual I/O Server side V*ServerAdapterElement.","title":"VStorageMapping().server_adapter"},{"location":"pypowervm/wrappers/virtual_io_server/#signature_43","text":"@property def server_adapter(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/","text":"Pcm Pypowervm Index / Pypowervm / Wrappers / Pcm Auto-generated documentation for pypowervm.wrappers.pcm module. Pcm Info Modules Info Show source in init .py:20 Signature class Info(object): def __init__(self, utilInfo): ... Modules Lpar Phyp Vios","title":"Pcm"},{"location":"pypowervm/wrappers/pcm/#pcm","text":"Pypowervm Index / Pypowervm / Wrappers / Pcm Auto-generated documentation for pypowervm.wrappers.pcm module. Pcm Info Modules","title":"Pcm"},{"location":"pypowervm/wrappers/pcm/#info","text":"Show source in init .py:20","title":"Info"},{"location":"pypowervm/wrappers/pcm/#signature","text":"class Info(object): def __init__(self, utilInfo): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/#modules","text":"Lpar Phyp Vios","title":"Modules"},{"location":"pypowervm/wrappers/pcm/lpar/","text":"Lpar Pypowervm Index / Pypowervm / Wrappers / Pcm / Lpar Auto-generated documentation for pypowervm.wrappers.pcm.lpar module. Lpar LparInfo LparInfo().find LparInfo().lpars_util LparMemory LparMemory().active_pg_count LparMemory().free_pg_count LparMemory().pct_real_mem_avbl LparMemory().pct_real_mem_free LparMemory().real_mem_size_bytes LparMemory().total_pg_count LparMemory().vm_pg_in_rate LparMemory().vm_pg_out_rate LparMemory().vm_pg_swap_in_rate LparMemory().vm_pg_swap_out_rate LparUtil LparUtil().lpar_id LparUtil().memory LparUtil().name LparUtil().timestamp LparUtil().uuid LparInfo Show source in lpar.py:22 Represents a monitor sample from the IBM.Host Resource Manager. The Lpar JSON utilization data has the following structure: - LparUtil - LparMemory lpar_metrics are generally collected once every two minutes, as opposed to the other data which is collected every 30 seconds. Signature class LparInfo(object): def __init__(self, raw_json): ... LparInfo().find Show source in lpar.py:51 Signature def find(self, lpar_uuid): ... LparInfo().lpars_util Show source in lpar.py:68 Signature @property def lpars_util(self): ... LparMemory Show source in lpar.py:103 Represents information on Lpar memory utilization Signature class LparMemory(object): def __init__(self, memory): ... LparMemory().active_pg_count Show source in lpar.py:129 Signature @property def active_pg_count(self): ... LparMemory().free_pg_count Show source in lpar.py:125 Signature @property def free_pg_count(self): ... LparMemory().pct_real_mem_avbl Show source in lpar.py:117 Signature @property def pct_real_mem_avbl(self): ... LparMemory().pct_real_mem_free Show source in lpar.py:137 Signature @property def pct_real_mem_free(self): ... LparMemory().real_mem_size_bytes Show source in lpar.py:133 Signature @property def real_mem_size_bytes(self): ... LparMemory().total_pg_count Show source in lpar.py:121 Signature @property def total_pg_count(self): ... LparMemory().vm_pg_in_rate Show source in lpar.py:141 Signature @property def vm_pg_in_rate(self): ... LparMemory().vm_pg_out_rate Show source in lpar.py:145 Signature @property def vm_pg_out_rate(self): ... LparMemory().vm_pg_swap_in_rate Show source in lpar.py:149 Signature @property def vm_pg_swap_in_rate(self): ... LparMemory().vm_pg_swap_out_rate Show source in lpar.py:153 Signature @property def vm_pg_swap_out_rate(self): ... LparUtil Show source in lpar.py:73 Represents individual Lpar metric information. Signature class LparUtil(object): def __init__(self, lpar_util): ... LparUtil().lpar_id Show source in lpar.py:82 Signature @property def lpar_id(self): ... LparUtil().memory Show source in lpar.py:98 Signature @property def memory(self): ... LparUtil().name Show source in lpar.py:90 Signature @property def name(self): ... LparUtil().timestamp Show source in lpar.py:94 Signature @property def timestamp(self): ... LparUtil().uuid Show source in lpar.py:86 Signature @property def uuid(self): ...","title":"Lpar"},{"location":"pypowervm/wrappers/pcm/lpar/#lpar","text":"Pypowervm Index / Pypowervm / Wrappers / Pcm / Lpar Auto-generated documentation for pypowervm.wrappers.pcm.lpar module. Lpar LparInfo LparInfo().find LparInfo().lpars_util LparMemory LparMemory().active_pg_count LparMemory().free_pg_count LparMemory().pct_real_mem_avbl LparMemory().pct_real_mem_free LparMemory().real_mem_size_bytes LparMemory().total_pg_count LparMemory().vm_pg_in_rate LparMemory().vm_pg_out_rate LparMemory().vm_pg_swap_in_rate LparMemory().vm_pg_swap_out_rate LparUtil LparUtil().lpar_id LparUtil().memory LparUtil().name LparUtil().timestamp LparUtil().uuid","title":"Lpar"},{"location":"pypowervm/wrappers/pcm/lpar/#lparinfo","text":"Show source in lpar.py:22 Represents a monitor sample from the IBM.Host Resource Manager. The Lpar JSON utilization data has the following structure: - LparUtil - LparMemory lpar_metrics are generally collected once every two minutes, as opposed to the other data which is collected every 30 seconds.","title":"LparInfo"},{"location":"pypowervm/wrappers/pcm/lpar/#signature","text":"class LparInfo(object): def __init__(self, raw_json): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparinfofind","text":"Show source in lpar.py:51","title":"LparInfo().find"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_1","text":"def find(self, lpar_uuid): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparinfolpars_util","text":"Show source in lpar.py:68","title":"LparInfo().lpars_util"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_2","text":"@property def lpars_util(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemory","text":"Show source in lpar.py:103 Represents information on Lpar memory utilization","title":"LparMemory"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_3","text":"class LparMemory(object): def __init__(self, memory): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemoryactive_pg_count","text":"Show source in lpar.py:129","title":"LparMemory().active_pg_count"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_4","text":"@property def active_pg_count(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemoryfree_pg_count","text":"Show source in lpar.py:125","title":"LparMemory().free_pg_count"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_5","text":"@property def free_pg_count(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemorypct_real_mem_avbl","text":"Show source in lpar.py:117","title":"LparMemory().pct_real_mem_avbl"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_6","text":"@property def pct_real_mem_avbl(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemorypct_real_mem_free","text":"Show source in lpar.py:137","title":"LparMemory().pct_real_mem_free"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_7","text":"@property def pct_real_mem_free(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemoryreal_mem_size_bytes","text":"Show source in lpar.py:133","title":"LparMemory().real_mem_size_bytes"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_8","text":"@property def real_mem_size_bytes(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemorytotal_pg_count","text":"Show source in lpar.py:121","title":"LparMemory().total_pg_count"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_9","text":"@property def total_pg_count(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemoryvm_pg_in_rate","text":"Show source in lpar.py:141","title":"LparMemory().vm_pg_in_rate"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_10","text":"@property def vm_pg_in_rate(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemoryvm_pg_out_rate","text":"Show source in lpar.py:145","title":"LparMemory().vm_pg_out_rate"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_11","text":"@property def vm_pg_out_rate(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemoryvm_pg_swap_in_rate","text":"Show source in lpar.py:149","title":"LparMemory().vm_pg_swap_in_rate"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_12","text":"@property def vm_pg_swap_in_rate(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparmemoryvm_pg_swap_out_rate","text":"Show source in lpar.py:153","title":"LparMemory().vm_pg_swap_out_rate"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_13","text":"@property def vm_pg_swap_out_rate(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparutil","text":"Show source in lpar.py:73 Represents individual Lpar metric information.","title":"LparUtil"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_14","text":"class LparUtil(object): def __init__(self, lpar_util): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparutillpar_id","text":"Show source in lpar.py:82","title":"LparUtil().lpar_id"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_15","text":"@property def lpar_id(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparutilmemory","text":"Show source in lpar.py:98","title":"LparUtil().memory"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_16","text":"@property def memory(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparutilname","text":"Show source in lpar.py:90","title":"LparUtil().name"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_17","text":"@property def name(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparutiltimestamp","text":"Show source in lpar.py:94","title":"LparUtil().timestamp"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_18","text":"@property def timestamp(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/lpar/#lparutiluuid","text":"Show source in lpar.py:86","title":"LparUtil().uuid"},{"location":"pypowervm/wrappers/pcm/lpar/#signature_19","text":"@property def uuid(self): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/","text":"Phyp Pypowervm Index / Pypowervm / Wrappers / Pcm / Phyp Auto-generated documentation for pypowervm.wrappers.pcm.phyp module. Phyp PhypInfo PhypLparMemory PhypLparProc PhypLparSample PhypNetwork PhypSample PhypSharedProcPool PhypSriovLparPort PhypStorage PhypStorageVAdpt PhypSystemFirmware PhypSystemMemory PhypSystemProcessor PhypVEA PhypVMSample PhypViosSample PhypVirtualFCAdpt PhypInfo Show source in phyp.py:27 Represents a monitor sample from the PHYP monitor. The PHYP PCM monitor JSON data can be parsed by this. The base structure is: - PhypInfo - Info - PhypSample - PhypSystemFirmware - PhypSystemProcessor - PhypSystemMemory - PhypSharedProcPool - PhypVMSample (list - client virtual machines) - PhypLparProc - PhypLparMemory - PhypNetwork - PhypVEA - PhypSriovLparPort - PhypStorage - PhypStorageVAdpt - PhypVirtualFCAdpt - PhypViosSample (list - Virtual I/O Servers) - PhypLparProc Signature class PhypInfo(object): def __init__(self, raw_json): ... PhypLparMemory Show source in phyp.py:170 A sample of a Client Virtual Machines's memory presented by PHYP. Part of the PhypLparSample. Signature class PhypLparMemory(object): def __init__(self, mem): ... PhypLparProc Show source in phyp.py:181 A sample of the LPARs processor presented by PHYP. Part of the PhypLparSample Signature class PhypLparProc(object): def __init__(self, proc): ... PhypLparSample Show source in phyp.py:130 A LPAR sample presented by PHYP. Generic for VIOS & VM. Signature class PhypLparSample(object): def __init__(self, lpar): ... PhypNetwork Show source in phyp.py:203 A sample of the LPARs network information. Part of the PhypLparSample Signature class PhypNetwork(object): def __init__(self, network): ... PhypSample Show source in phyp.py:59 A Power Hypervisor Sample. Signature class PhypSample(object): def __init__(self, util_sample): ... PhypSharedProcPool Show source in phyp.py:98 Information of the Shared Processor Pool. Signature class PhypSharedProcPool(object): def __init__(self, spp): ... PhypSriovLparPort Show source in phyp.py:238 A metric for the SR-IOV Logical Ports. Signature class PhypSriovLparPort(object): def __init__(self, sriov_p): ... PhypStorage Show source in phyp.py:256 A sample of the LPARs storage information. Part of the PhypLparSample Signature class PhypStorage(object): def __init__(self, stor): ... PhypStorageVAdpt Show source in phyp.py:272 An indicator to the Client VM Storage to the VIOS storage elem. Signature class PhypStorageVAdpt(object): def __init__(self, stor): ... PhypSystemFirmware Show source in phyp.py:90 Firmware information from PHYP. Signature class PhypSystemFirmware(object): def __init__(self, system_firmware): ... PhypSystemMemory Show source in phyp.py:120 System wide Memory information from PHYP. Signature class PhypSystemMemory(object): def __init__(self, mem): ... PhypSystemProcessor Show source in phyp.py:110 Processor information about the entire system from PHYP. Signature class PhypSystemProcessor(object): def __init__(self, processor): ... PhypVEA Show source in phyp.py:218 The Virtual Ethernet Adapters (aka. CNA's) data. Signature class PhypVEA(object): def __init__(self, vea): ... PhypVMSample Show source in phyp.py:152 A Virtual Machine (non VIOS) presented by the PHYP metrics. Signature class PhypVMSample(PhypLparSample): def __init__(self, lpar): ... See also PhypLparSample PhypViosSample Show source in phyp.py:145 A VIOS sample presented by the PHYP metrics. Signature class PhypViosSample(PhypLparSample): def __init__(self, lpar): ... See also PhypLparSample PhypVirtualFCAdpt Show source in phyp.py:281 An indicator to identify the Client VFC Adpt with the VIOS storage. Signature class PhypVirtualFCAdpt(object): def __init__(self, vfc): ...","title":"Phyp"},{"location":"pypowervm/wrappers/pcm/phyp/#phyp","text":"Pypowervm Index / Pypowervm / Wrappers / Pcm / Phyp Auto-generated documentation for pypowervm.wrappers.pcm.phyp module. Phyp PhypInfo PhypLparMemory PhypLparProc PhypLparSample PhypNetwork PhypSample PhypSharedProcPool PhypSriovLparPort PhypStorage PhypStorageVAdpt PhypSystemFirmware PhypSystemMemory PhypSystemProcessor PhypVEA PhypVMSample PhypViosSample PhypVirtualFCAdpt","title":"Phyp"},{"location":"pypowervm/wrappers/pcm/phyp/#phypinfo","text":"Show source in phyp.py:27 Represents a monitor sample from the PHYP monitor. The PHYP PCM monitor JSON data can be parsed by this. The base structure is: - PhypInfo - Info - PhypSample - PhypSystemFirmware - PhypSystemProcessor - PhypSystemMemory - PhypSharedProcPool - PhypVMSample (list - client virtual machines) - PhypLparProc - PhypLparMemory - PhypNetwork - PhypVEA - PhypSriovLparPort - PhypStorage - PhypStorageVAdpt - PhypVirtualFCAdpt - PhypViosSample (list - Virtual I/O Servers) - PhypLparProc","title":"PhypInfo"},{"location":"pypowervm/wrappers/pcm/phyp/#signature","text":"class PhypInfo(object): def __init__(self, raw_json): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phyplparmemory","text":"Show source in phyp.py:170 A sample of a Client Virtual Machines's memory presented by PHYP. Part of the PhypLparSample.","title":"PhypLparMemory"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_1","text":"class PhypLparMemory(object): def __init__(self, mem): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phyplparproc","text":"Show source in phyp.py:181 A sample of the LPARs processor presented by PHYP. Part of the PhypLparSample","title":"PhypLparProc"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_2","text":"class PhypLparProc(object): def __init__(self, proc): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phyplparsample","text":"Show source in phyp.py:130 A LPAR sample presented by PHYP. Generic for VIOS & VM.","title":"PhypLparSample"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_3","text":"class PhypLparSample(object): def __init__(self, lpar): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypnetwork","text":"Show source in phyp.py:203 A sample of the LPARs network information. Part of the PhypLparSample","title":"PhypNetwork"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_4","text":"class PhypNetwork(object): def __init__(self, network): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypsample","text":"Show source in phyp.py:59 A Power Hypervisor Sample.","title":"PhypSample"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_5","text":"class PhypSample(object): def __init__(self, util_sample): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypsharedprocpool","text":"Show source in phyp.py:98 Information of the Shared Processor Pool.","title":"PhypSharedProcPool"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_6","text":"class PhypSharedProcPool(object): def __init__(self, spp): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypsriovlparport","text":"Show source in phyp.py:238 A metric for the SR-IOV Logical Ports.","title":"PhypSriovLparPort"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_7","text":"class PhypSriovLparPort(object): def __init__(self, sriov_p): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypstorage","text":"Show source in phyp.py:256 A sample of the LPARs storage information. Part of the PhypLparSample","title":"PhypStorage"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_8","text":"class PhypStorage(object): def __init__(self, stor): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypstoragevadpt","text":"Show source in phyp.py:272 An indicator to the Client VM Storage to the VIOS storage elem.","title":"PhypStorageVAdpt"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_9","text":"class PhypStorageVAdpt(object): def __init__(self, stor): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypsystemfirmware","text":"Show source in phyp.py:90 Firmware information from PHYP.","title":"PhypSystemFirmware"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_10","text":"class PhypSystemFirmware(object): def __init__(self, system_firmware): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypsystemmemory","text":"Show source in phyp.py:120 System wide Memory information from PHYP.","title":"PhypSystemMemory"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_11","text":"class PhypSystemMemory(object): def __init__(self, mem): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypsystemprocessor","text":"Show source in phyp.py:110 Processor information about the entire system from PHYP.","title":"PhypSystemProcessor"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_12","text":"class PhypSystemProcessor(object): def __init__(self, processor): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypvea","text":"Show source in phyp.py:218 The Virtual Ethernet Adapters (aka. CNA's) data.","title":"PhypVEA"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_13","text":"class PhypVEA(object): def __init__(self, vea): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#phypvmsample","text":"Show source in phyp.py:152 A Virtual Machine (non VIOS) presented by the PHYP metrics.","title":"PhypVMSample"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_14","text":"class PhypVMSample(PhypLparSample): def __init__(self, lpar): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#see-also","text":"PhypLparSample","title":"See also"},{"location":"pypowervm/wrappers/pcm/phyp/#phypviossample","text":"Show source in phyp.py:145 A VIOS sample presented by the PHYP metrics.","title":"PhypViosSample"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_15","text":"class PhypViosSample(PhypLparSample): def __init__(self, lpar): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/phyp/#see-also_1","text":"PhypLparSample","title":"See also"},{"location":"pypowervm/wrappers/pcm/phyp/#phypvirtualfcadpt","text":"Show source in phyp.py:281 An indicator to identify the Client VFC Adpt with the VIOS storage.","title":"PhypVirtualFCAdpt"},{"location":"pypowervm/wrappers/pcm/phyp/#signature_16","text":"class PhypVirtualFCAdpt(object): def __init__(self, vfc): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/","text":"Vios Pypowervm Index / Pypowervm / Wrappers / Pcm / Vios Auto-generated documentation for pypowervm.wrappers.pcm.vios module. Vios ViosFCPhysAdpt ViosFCVirtAdpt ViosInfo ViosMemory ViosNetwork ViosNetworkAdpt ViosSSP ViosSample ViosSharedEthernetAdapter ViosStorage ViosStorageAdpt ViosStoragePAdpt ViosStorageVAdpt ViosFCPhysAdpt Show source in vios.py:145 Represents a physical fiber channel adapter on the VIOS. Signature class ViosFCPhysAdpt(ViosStorageAdpt): def __init__(self, adpt): ... See also ViosStorageAdpt ViosFCVirtAdpt Show source in vios.py:160 Represents a Virtual FC Port (NPIV). Signature class ViosFCVirtAdpt(ViosStorageAdpt): def __init__(self, vadpt): ... See also ViosStorageAdpt ViosInfo Show source in vios.py:27 Represents a monitor sample from the Virtual I/O Server monitor. The VIOS PCM monitor JSON data can be parsed by this. The base structure is: - ViosInfo - Info - ViosSample - ViosMemory - ViosNetwork - ViosNetworkAdpt (List) - ViosSharedEthernetAdapter (List) - ViosStorage - ViosFCPhysAdpt (List) - ViosFCVirtAdpt (List) - ViosStoragePAdpt (List) - ViosStorageVAdpt (List) - ViosSSP (List) Signature class ViosInfo(object): def __init__(self, raw_json): ... ViosMemory Show source in vios.py:76 Signature class ViosMemory(object): def __init__(self, mem): ... ViosNetwork Show source in vios.py:82 The Network elements within the VIOS. Signature class ViosNetwork(object): def __init__(self, net): ... ViosNetworkAdpt Show source in vios.py:92 Represents a Network Adapter on the system. Signature class ViosNetworkAdpt(object): def __init__(self, adpt): ... ViosSSP Show source in vios.py:187 Represents a Shared Storage Pool (entire element). Signature class ViosSSP(object): def __init__(self, ssp): ... ViosSample Show source in vios.py:54 Signature class ViosSample(object): def __init__(self, util_sample): ... ViosSharedEthernetAdapter Show source in vios.py:107 Represents a Shared Ethernet Adapter on the VIOS. Signature class ViosSharedEthernetAdapter(ViosNetworkAdpt): def __init__(self, bridge): ... See also ViosNetworkAdpt ViosStorage Show source in vios.py:115 Represents the storage elements on the VIOS. Signature class ViosStorage(object): def __init__(self, storage): ... ViosStorageAdpt Show source in vios.py:133 Base class for storage adapters. Signature class ViosStorageAdpt(object): def __init__(self, adpt): ... ViosStoragePAdpt Show source in vios.py:171 Represents a physical storage adapter (typically a SAS drive). Signature class ViosStoragePAdpt(ViosStorageAdpt): def __init__(self, adpt): ... See also ViosStorageAdpt ViosStorageVAdpt Show source in vios.py:179 Represents a virtual storage adapter (vscsi). Signature class ViosStorageVAdpt(ViosStorageAdpt): def __init__(self, adpt): ... See also ViosStorageAdpt","title":"Vios"},{"location":"pypowervm/wrappers/pcm/vios/#vios","text":"Pypowervm Index / Pypowervm / Wrappers / Pcm / Vios Auto-generated documentation for pypowervm.wrappers.pcm.vios module. Vios ViosFCPhysAdpt ViosFCVirtAdpt ViosInfo ViosMemory ViosNetwork ViosNetworkAdpt ViosSSP ViosSample ViosSharedEthernetAdapter ViosStorage ViosStorageAdpt ViosStoragePAdpt ViosStorageVAdpt","title":"Vios"},{"location":"pypowervm/wrappers/pcm/vios/#viosfcphysadpt","text":"Show source in vios.py:145 Represents a physical fiber channel adapter on the VIOS.","title":"ViosFCPhysAdpt"},{"location":"pypowervm/wrappers/pcm/vios/#signature","text":"class ViosFCPhysAdpt(ViosStorageAdpt): def __init__(self, adpt): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#see-also","text":"ViosStorageAdpt","title":"See also"},{"location":"pypowervm/wrappers/pcm/vios/#viosfcvirtadpt","text":"Show source in vios.py:160 Represents a Virtual FC Port (NPIV).","title":"ViosFCVirtAdpt"},{"location":"pypowervm/wrappers/pcm/vios/#signature_1","text":"class ViosFCVirtAdpt(ViosStorageAdpt): def __init__(self, vadpt): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#see-also_1","text":"ViosStorageAdpt","title":"See also"},{"location":"pypowervm/wrappers/pcm/vios/#viosinfo","text":"Show source in vios.py:27 Represents a monitor sample from the Virtual I/O Server monitor. The VIOS PCM monitor JSON data can be parsed by this. The base structure is: - ViosInfo - Info - ViosSample - ViosMemory - ViosNetwork - ViosNetworkAdpt (List) - ViosSharedEthernetAdapter (List) - ViosStorage - ViosFCPhysAdpt (List) - ViosFCVirtAdpt (List) - ViosStoragePAdpt (List) - ViosStorageVAdpt (List) - ViosSSP (List)","title":"ViosInfo"},{"location":"pypowervm/wrappers/pcm/vios/#signature_2","text":"class ViosInfo(object): def __init__(self, raw_json): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#viosmemory","text":"Show source in vios.py:76","title":"ViosMemory"},{"location":"pypowervm/wrappers/pcm/vios/#signature_3","text":"class ViosMemory(object): def __init__(self, mem): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#viosnetwork","text":"Show source in vios.py:82 The Network elements within the VIOS.","title":"ViosNetwork"},{"location":"pypowervm/wrappers/pcm/vios/#signature_4","text":"class ViosNetwork(object): def __init__(self, net): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#viosnetworkadpt","text":"Show source in vios.py:92 Represents a Network Adapter on the system.","title":"ViosNetworkAdpt"},{"location":"pypowervm/wrappers/pcm/vios/#signature_5","text":"class ViosNetworkAdpt(object): def __init__(self, adpt): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#viosssp","text":"Show source in vios.py:187 Represents a Shared Storage Pool (entire element).","title":"ViosSSP"},{"location":"pypowervm/wrappers/pcm/vios/#signature_6","text":"class ViosSSP(object): def __init__(self, ssp): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#viossample","text":"Show source in vios.py:54","title":"ViosSample"},{"location":"pypowervm/wrappers/pcm/vios/#signature_7","text":"class ViosSample(object): def __init__(self, util_sample): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#viossharedethernetadapter","text":"Show source in vios.py:107 Represents a Shared Ethernet Adapter on the VIOS.","title":"ViosSharedEthernetAdapter"},{"location":"pypowervm/wrappers/pcm/vios/#signature_8","text":"class ViosSharedEthernetAdapter(ViosNetworkAdpt): def __init__(self, bridge): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#see-also_2","text":"ViosNetworkAdpt","title":"See also"},{"location":"pypowervm/wrappers/pcm/vios/#viosstorage","text":"Show source in vios.py:115 Represents the storage elements on the VIOS.","title":"ViosStorage"},{"location":"pypowervm/wrappers/pcm/vios/#signature_9","text":"class ViosStorage(object): def __init__(self, storage): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#viosstorageadpt","text":"Show source in vios.py:133 Base class for storage adapters.","title":"ViosStorageAdpt"},{"location":"pypowervm/wrappers/pcm/vios/#signature_10","text":"class ViosStorageAdpt(object): def __init__(self, adpt): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#viosstoragepadpt","text":"Show source in vios.py:171 Represents a physical storage adapter (typically a SAS drive).","title":"ViosStoragePAdpt"},{"location":"pypowervm/wrappers/pcm/vios/#signature_11","text":"class ViosStoragePAdpt(ViosStorageAdpt): def __init__(self, adpt): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#see-also_3","text":"ViosStorageAdpt","title":"See also"},{"location":"pypowervm/wrappers/pcm/vios/#viosstoragevadpt","text":"Show source in vios.py:179 Represents a virtual storage adapter (vscsi).","title":"ViosStorageVAdpt"},{"location":"pypowervm/wrappers/pcm/vios/#signature_12","text":"class ViosStorageVAdpt(ViosStorageAdpt): def __init__(self, adpt): ...","title":"Signature"},{"location":"pypowervm/wrappers/pcm/vios/#see-also_4","text":"ViosStorageAdpt","title":"See also"}]}